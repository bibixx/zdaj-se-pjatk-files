<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.ceti.pl/~gralinski/lik320/lik-prolog1.htm -->
<HTML><HEAD><TITLE>LIK320 / Prolog</TITLE><LINK 
href="LIK320 - Prolog1_files/lik.css" type=text/css rel=stylesheet>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-2">
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY>
<DIV class=main>
<H1>Lingwistyka komputerowa 320</H1>
<H2>Programowanie w Prologu - powtórzenie</H2>
<H3>Æwiczenia 1. Fakty, regu³y, cele, operator równo¶ci, operatory 
arytmetyczne</H3>
<H4>Powtórzenie podstawowych pojêæ</H4>
<P>Prolog jest <EM class=term>jêzykiem deklaratywnym</EM>. Jego deklaratywno¶æ 
polega na tym, ¿e programista deklaruje (wymienia) jedynie obiekty konieczne do 
rozwi±zania problemu oraz zwi±zki, jakie pomiêdzy tymi obiektami zachodz±, w 
postaci tzw. <EM class=term>faktów</EM> oraz regu³. Zadanie do rozwi±zania 
przedstawiane jest w postaci <EM class=term>celu</EM>.</P>
<H5>fakty</H5>Fakty to bezwarunkowo prawdziwe stwierdzenia o istnieniu pewnych 
powi±zañ pomiêdzy obiektami. Powi±zania, jakie istniej± miêdzy obiektami, 
przedstawia siê za pomoc± <EM class=term>predykatów</EM>. Fakty przedstawiamy w 
Prologu w nastêpuj±cy sposób: <PRE><I>symbol_predykatu</I>(<I>obiekt1</I>, <I>obiekt2</I>,<I>obiekt3</I>,... <I>obiektn</I>).</PRE>gdzie 
<I>symbol_predykatu</I> oznacza nazwê predykatu, za¶ <I>obiekt1</I>, 
<I>obiekt2</I>, <I>obiekt3</I>,... <I>obiektn</I> stanowi± argumenty predykatu. 
Tak zapisany fakt oznacza istnienie zale¿no¶ci o nazwie <I>symbol_predykatu</I> 
miêdzy obiektami reprezentowanymi przez nazwy <I>obiekt1</I>, <I>obiekt2</I>, 
<I>obiekt3</I>,... <I>obiektn</I>, np. <TT>lubi(marta,piotr)</TT>. Uwaga: 
kolejno¶æ argumentów jest wa¿na, np. fakt <TT>lubi(marta,piotr)</TT> oznacza co 
innego ni¿ fakt <TT>lubi(piotr,marta)</TT>. 
<H5>regu³y</H5>
<P>Regu³y to warunkowe stwierdzenia o istnieniu pewnych zale¿no¶ci miêdzy 
obiektami. Znaczenie regu³ mo¿na przedstawiæ schematycznie w nastêpuj±cy sposób: 

<BLOCKQUOTE><I>nazwa_powi±zania</I>(<I>obiekt1</I>, <I>obiekt2</I>, 
  <I>obiekt3</I>,... <I>obiektn</I>) <STRONG>if</STRONG> 
  <I>nazwa_powi±zania1</I>(<I>obiekt<SUB>1</SUB>1</I>, 
  <I>obiekt<SUB>1</SUB>2</I>, 
  <I>obiekt<SUB>1</SUB>3</I>,...<I>obiekt<SUB>1</SUB>m<SUB>1</SUB></I>) 
  <STRONG>and</STRONG> <I>nazwa_powi±zania2</I>(<I>obiekt<SUB>2</SUB>1</I>, 
  <I>obiekt<SUB>2</SUB>2</I>, <I>obiekt<SUB>2</SUB>3</I>, ... 
  <I>obiekt<SUB>2</SUB>m<SUB>2</SUB></I>) <STRONG>and</STRONG> ... 
  <I>nazwa_powi±zaniak</I>(<I>obiekt<SUB>k</SUB>1</I>, 
  <I>obiekt<SUB>k</SUB>2</I>,<I>obiekt<SUB>k</SUB>3</I>,... 
  <I>obiekt<SUB>k</SUB>m<SUB>k</SUB></I>). </BLOCKQUOTE>
<P>Warunkowy charakter regu³ polega na tym, ¿e predykat wystêpuj±cy po lewej 
stronie s³owa <STRONG>if</STRONG> jest prawdziwy jedynie wówczas, gdy prawdziwe 
s± wszystkie warunki zapisane po prawej stronie. S³owa kluczowe 
<STRONG>if</STRONG> oraz <STRONG>and</STRONG> zastêpujemy symbolami odpowiednio 
<TT>:-</TT> oraz <TT>,</TT>. Przyk³ad regu³y: <TT>lubi(magda,X):- mezczyzna(X), 
przystojny(X).</TT>, predykat <VAR>lubi</VAR> jest tutaj <EM 
class=term>g³ow±</EM> regu³y (g³owa sk³ada siê tylko z jednego predykatu), za¶ 
dwa warunki <TT>mezczyzna(X)</TT> i <TT>przystojny(X)</TT> tworz± <EM 
class=term>cia³o</EM> regu³y. Uwaga: zakres zmiennej jest lokalny - dotyczy 
tylko jednej regu³y, np.</P><PRE>ma_powodzenie(X):- lubi(magda, X), lubi(dorota,X).
</PRE>
<P>dotyczy tego samego <VAR>X</VAR>, ale regu³y <PRE>ma_powodzenie(X) :- lubi(magda, X).
ma_powodzenie(X) :- lubi(dorota, X).
</PRE>
<P>dotyczyæ mog± ró¿nych <VAR>X</VAR>-ów.</P>
<P>Fakty i regu³y stanowi± tzw. <EM class=term>klauzule</EM>. W przypadku faktów 
mamy do czynienia z klauzulami sk³adaj±cymi siê tylko z g³owy. Fakty i regu³y 
wystêpuj±ce w programie tworz± tzw. <EM class=term>bazê danych programu</EM>. 
Zbiór klauzul o takiej samej g³owie i identycznej liczbie argumenty 
(<EM>arno¶ci</EM>) tworzy tzw. <EM class=term>procedurê</EM>. 
<H5>cel</H5>
<P>Maj±c skonstruowan± bazê danych programu, mo¿na j± wykorzystaæ poprzez 
zadawanie pytañ (celów). Celem jest: 
<UL>
  <LI>pytanie o prawdziwo¶æ podanych faktów, 
  <LI>polecenie znalezienia nazw obiektów bêd±cych w relacji z innymi obiektami. 
  </LI></UL>
<P>Cel mo¿e byæ albo pojedynczym predykatem, albo koniunkcj± predykatów (tzw. 
podcelów). Przyk³ady celów: 
<TABLE>
  <TBODY>
  <TR>
    <TD><TT>?- lubi(marta,piotr).</TT></TD>
    <TD><I>czy Marta lubi Piotra?</I></TD></TR>
  <TR>
    <TD><TT>?- lubi(piotr,marta).</TT></TD>
    <TD><I>czy Piotr lubi Martê?</I></TD></TR>
  <TR>
    <TD><TT>?- lubi(marta,X).</TT></TD>
    <TD><I>kogo lubi Marta?</I></TD></TR></TBODY></TABLE>
<H4>Transfer programów do pamiêci</H4>
<P>Jako interpretera Prologu u¿ywaæ bêdziemy programu SWI-Prolog dzia³aj±cego w 
Linuksie. Wszelkie informacje o SWI-Prologu mo¿na znale¼æ na stronie <A 
class=ext href="http://www.swi-prolog.org/">http://www.swi-prolog.org/</A>. Z 
podanej strony mo¿na tak¿e <A class=ext 
href="http://www.swi-prolog.org/download.html">¶ci±gn±æ najnowsze wersje binarne 
dla ró¿nych systemów operacyjnych</A>.</P>
<P>Na komputerach uczelnianych SWI-Prolog jest ju¿ zainstalowany - w systemie 
Linux wystarczy wydaæ polecenie <TT>pl</TT>, by uruchomiæ interpreter.</P>
<P>SWI-Prolog nie udostêpnia edytora programów. Programy prologowe mo¿na 
zapisywaæ u¿ywaj±c dowolnego edytora (np. pico, vim, emacs). Najwygodniej mieæ 
równocze¶nie otwarte dwa okna - jedno z interpreterem, drugie z edytorem. 
Programy napisane w jêzyku SWI Prolog maj± domy¶lne rozszerzenie <TT>.pl</TT> 
(przez co niestety mog± siê mieszaæ z programami w jêzyku Perl, które 
przypadkowo maj± takie same rozszerzenie).</P>
<P>Aby <EM>skonsultowaæ</EM> (wczytaæ do pamiêci) pliki <TT>plik1.pl</TT>, 
<TT>plik2.pl</TT>, ... nale¿y wydaæ interpreterowi nastêpuj±ce polecenia:</P><PRE>?- [plik1].
?- [plik2].

</PRE>
<P>Uwaga: wczytywane pliki musz± byæ w tym samym katalogu, spod którego 
uruchamiany jest program <TT>pl</TT>.</P>
<P>Inna metoda uruchamiania plików polega na utworzeniu pliku o nazwie np. 
<TT>start.pl</TT> i o nastêpuj±cej tre¶ci:</P><PRE>:- [plik1]. 
:- [plik2].
</PRE>
<P>Nastêpnie wystarczy skonsultowaæ ten plik poprzez cel:</P><PRE>?- [start].
</PRE>
<H4>Omówienie niektórych elementów jêzyka</H4>
<H5>równo¶æ i uzgadnianie</H5>
<P>Równo¶æ jest wbudowanym predykatem infiksowym. Wyra¿enie <TT>A=B</TT> oznacza 
próbê uzgodnienia (<I>matching</I>) zmiennych <VAR>A</VAR> i <VAR>B</VAR>, tj. 
sprawienia, by by³y sobie równe. W przypadku wyra¿enia <TT>A=B</TT> mo¿emy mieæ 
nastêpuj±ce mo¿liwo¶ci: 
<UL>
  <LI><VAR>A</VAR> jest <EM class=term>zmienn± ukonkretnion±</EM>, tj. zwi±zan± 
  z pewn± sta³±, <VAR>B</VAR> jest <EM class=term>zmienn± woln±</EM> - wówczas 
  <VAR>B</VAR> zostanie ukonkretniona przez warto¶æ zmiennej <VAR>A</VAR>, 
  <LI><VAR>B</VAR> jest zmienn± ukonkretnion±, <VAR>A</VAR> jest zmienn± woln± - 
  wówczas <VAR>B</VAR> zostanie ukonkretniona przez warto¶æ zmiennej 
  <VAR>B</VAR>, 
  <LI>je¶li obie zmienne s± wolne, to wtedy nastêpuje ich powi±zanie, w efekcie 
  którego je¿eli pó¼niej jedna z nich zostanie ukonkretniona, to druga 
  automatycznie przyjmie tê sam± warto¶æ, 
  <LI>je¶li obie zmienne s± ukonkretnione, nastêpuje porównanie ich warto¶ci i 
  równo¶æ zachodzi, je¶li ta sama warto¶æ wystêpuje po obu stronach predykatu 
  <TT>=</TT>. </LI></UL>(Predykatem przeciwnym do równo¶ci jest <TT>X\=Y</TT> lub 
inaczej <TT>not(A=B)</TT>.) <!--<table border="1">
<tr><th>fakt</th><th>pytanie</th><th>uzgodnienie</th><th>rodzaj</th></tr>
<tr>
<td><tt>lubi(jan,wino)</tt></td>
<td><tt>lubi(X,wino)</tt></td>
<td><tt>X=jan</tt></td>
<td>ukonkretnienie</td></tr>
<tr>
<td><tt>lubi(piotr,maria)</tt></td>
<td><tt>lubi(X,Y)</tt></td>
<td><tt>X=piotr, Y=maria</tt></td>
<td>ukonkretnienie</td></tr>
<tr>
<td><tt>lubi(jan,Z)</tt></td>
<td><tt>lubi(jan,X)</tt></td>
<td><tt>Z=X</tt></td>
<td>powi±zanie</td></tr>
</table>
-->
<H4>operator specjalny <TT>is</TT></H4>
<P>Operator <TT>is</TT> s³u¿y do ukonkretniania wystêpuj±cej po lewej stronie 
zmiennej przez warto¶æ termu znajduj±cego siê po prawej stronie. Term ten musi 
byæ wyra¿eniem arytmetycznym, poniewa¿ Prolog stara siê najpierw obliczyæ jego 
warto¶æ. Inne struktury nie s± dopuszczalne.</P>
<P>Przyk³ad zastosowania wyra¿eñ arytmetycznych:</P><PRE>d³ugo¶æ(obiekt, 10).
szeroko¶æ(obiekt, 20).
powierzchnia(X, Y):- dlugo¶æ(X, A),
	             szeroko¶æ(X, B),
		     Y is A * B.	
</PRE>
<P>(Patrz tak¿e <A 
href="http://www.ceti.pl/~gralinski/lik320/lik-prolog1.htm#dodatek">dodatek</A>.)</P>
<H3>Zadania z æwiczeñ 1</H3>
<P><B>Zadanie 1</B> (dla "niewprawionych") Utworzyæ plik z faktami i predykatami 
podanymi jako przyk³ady (<TT>lubi</TT>, <TT>przystojny</TT>, 
<TT>ma_powodzenie</TT>) i uzupe³niæ kilkoma klauzulami. Wypróbowaæ ró¿nego typu 
cele: sprawdzenie prawdziwo¶ci pewnych faktów (np. <TT>?- 
ma_powodzenie(jan)</TT>), wyszukanie pewnych informacji (np. 
<TT>ma_powodzenie(X)</TT>).</P>
<P><B>Zadanie 2</B> Dane jest drzewo genealogiczne:</P><IMG 
src="LIK320 - Prolog1_files/rodzina.png"> 
<P>Utworzyæ bazê danych: 
<UL>
  <LI>fakty: <TT>rodzic</TT>, <TT>mê¿czyzna</TT>, <TT>kobieta</TT>, 
  <LI>regu³y: <TT>matka</TT>, <TT>ojciec</TT>, <TT>dziecko</TT>, <TT>wnuk</TT>, 
  <TT>potomek</TT>, <TT>przodek</TT>, <TT>brat</TT>, <TT>siostra</TT>. </LI></UL>
<P>Zadawaæ cele: 
<OL type=a>
  <LI>sprawdzaj±ce poprawno¶æ faktów, 
  <LI>sprawdzaj±ce poprawno¶æ regu³, np. <TT>przodek(eugenia, maria)</TT>, 
  <LI>wyszukuj±ce, np. <TT>przodek(X, maria)</TT>. </LI></OL>
<P>(W celu wyszukania kilku odpowiedzi nale¿y po wy¶wietleniu odpowiedzi 
nacisn±æ '<TT>;</TT>'.)</P>
<P><B>Zadanie A</B> (dodatkowe) Na przyk³adzie rodziny zdefiniowaæ pewn± relacjê 
symetryczn±, np. <TT>rodzeñstwo</TT>, czyli napisaæ tak± regu³ê, która umo¿liwi 
wywnioskowanie, ¿e <TT>rodzeñstwo(b, a)</TT> na podstawie faktu 
<TT>rodzeñstwo(a, b)</TT>.</P>
<P><B>Zadanie B</B> (dodatkowe) Informacje o rodzinie poszerzyæ o dane dotycz±ce 
wieku oraz o pewne dodatkowe klauzule poszerzaj±ce relacjê pokrewieñstwa. 
Sprawdziæ, czy istnieje jaka¶ osoba z poprzedniego pokolenia m³odsza od osoby z 
m³odszego pokolenia (np. ciocia m³odsza od bratanka).</P>
<P><B>Zadanie 3</B> Zdefiniowaæ relacjê <TT>wiêkszy(X, Y, Z)</TT>, której dwoma 
pierwszymi elementami s± dwie liczby, a trzecim elementem jest wiêksza z 
nich.</P>
<P><B>Zadanie 4</B>. Zdefiniowaæ dwuargumentow± relacjê <TT>modu³</TT>, w której 
drugim argumentem jest warto¶æ bezwzglêdna pierwszego argumentu.</P>
<P><B>Zadanie 5</B>. Zdefiniowaæ rekurencyjnie relacjê <TT>silnia</TT>, której 
drugim argumentem jest warto¶æ silni pierwszego argumentu. Wskazówka - 
skorzystaæ z nastêpuj±cego opisu sumowania kolejnych liczb naturalnych od 0 do 
<VAR>N</VAR>. <PRE>suma(0,0).  /* suma 0 liczb wynosi 0 */

suma(N, Nwynik) :-
     N &gt; 0, 
     M is N-1, /* za M przyjmij N-1  */
     suma(M, Mwynik), /* oblicz rekurencyjnie sumê N-1 liczb */
     Nwynik is N + Mwynik. /* do uzyskanej sumy dodaj N */
</PRE>
<P><B>Zadanie C</B> (dodatkowe) Zdefiniowaæ operacjê potêgowania liczb 
naturalnych.</P>
<P><B>Zadanie D</B> (dodatkowe) Napisaæ predykat, który opisuje rozwi±zanie 
problemu wie¿y z Hanoi: N kr±¿ków pouk³adanych jeden na drugim od najwiêkszego 
(na spodzie) do najwiêkszego nale¿y przenie¶æ na inn± wie¿ê w tym samym 
uk³adzie. Nie mo¿na kr±¿ka wiêkszego po³o¿yæ na mniejszy. Mamy do dyspozycji 
trzeci± wie¿ê pomocnicz±.<BR>Wskazówki: 1. Opis rozwi±zania mo¿e wygl±daæ tak 
"przenie¶ kr±¿ek z wie¿y pierwszej na drug±, przenie¶ kr±¿ek z wie¿y trzeci± na 
pierwsz±", itp. 2. Aby przenie¶æ N kr±¿ków z wie¿y pierwszej na drug±, nale¿y 
przeniesæ N-1 kra¿ków na wie¿ê trzeci±, nastêpnie przenie¶æ pozosta³y kra¿ek na 
wie¿ê drug± i przenie¶æ N-1 kr±¿ków z wie¿y trzeciej na drug±.</P>
<P><B>Zadanie 6</B> (dodatkowe) Napisaæ predykat <TT>slownie</TT>, którego 
pierwszym argumentem jest liczba, a drugim liczebnik w jêzyku polskim 
odpowiadaj±cy tej liczbie, przyk³ad oczekiwanego dzia³ania predykatu: <PRE>?- slownie(5, L).

L = piêæ

Yes

?- slownie(214, L).

L = 'dwie¶cie czterna¶cie'

Yes
</PRE>
<P>Ograniczyæ siê do liczb naturalnych mniejszych od 10000. Wskazówka: u¿yæ 
predykatu wbudowanego <TT>concat</TT>, który skleja napisy podane jako dwa 
pierwsze argumenty; przyk³ad dzia³ania predykatu <TT>concat</TT>: <PRE>?- concat('Ala',' ma kota', S).

S = 'Ala ma kota'

Yes
</PRE><A name=dodatek></A>
<H3>Dodatek</H3>
<H4>niektóre operatory w Prologu</H4>
<TABLE cellPadding=5 border=1>
  <TBODY>
  <TR>
    <TD vAlign=top width="20%"><CODE>L = R</CODE></TD>
    <TD vAlign=top><VAR>L</VAR> i <VAR>R</VAR> pasuj± do siebie 
      (<I>matching</I>)</TD>
    <TD vAlign=top><PRE>?- X = 2+3

X = 2+3

Yes
?- [5, X] = [Y, 7].

X = 7
Y = 5

Yes
</PRE></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L == R</CODE></TD>
    <TD vAlign=top><VAR>L</VAR> i <VAR>R</VAR> s± tym samym</TD>
    <TD vAlign=top><PRE>?- X == X.

X = _G174

Yes
?- X == Y.

No

?- X == 5.

No
</PRE></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L =:= R</CODE></TD>
    <TD vAlign=top>arytmetyczna równo¶æ (L i R s± wyliczane)</TD>
    <TD vAlign=top><PRE>?- X =:= 2+3.

ERROR: Arguments are not 
sufficiently instanstiated
[Prolog próbuje wyliczyæ 
warto¶æ arytmetyczn± X, 
co nie ma sensu]

Yes
?- 22-12+2 =:= 7+5.

Yes
</PRE></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L is R</CODE></TD>
    <TD vAlign=top>dopasuj R do L, R jest wyliczane (zwykle u¿ywane do 
      wi±zania zmiennej)</TD>
    <TD vAlign=top><PRE>?- X is 2+3.

X = 5

Yes
?- 5 is 2+3.

Yes
</PRE></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L + R</CODE></TD>
    <TD vAlign=top>dodawanie</TD>
    <TD>&nbsp;</TD></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L - R</CODE></TD>
    <TD vAlign=top>odejmowanie</TD>
    <TD>&nbsp;</TD></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L * R</CODE></TD>
    <TD vAlign=top>mno¿enie</TD>
    <TD>&nbsp;</TD></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L / R</CODE></TD>
    <TD vAlign=top>dzielenie (na liczbach rzeczywistych)</TD>
    <TD vAlign=top><PRE>?- X is 5/2.

X = 2.5

Yes
</PRE></TD></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L // R</CODE></TD>
    <TD vAlign=top>dzielenie (ca³kowitoliczbowe)</TD>
    <TD vAlign=top><PRE>?- X is 5//2.

X = 2

Yes
</PRE></TD></TD></TR>
  <TR>
    <TD vAlign=top><CODE>L mod R</CODE></TD>
    <TD vAlign=top>reszta z dzielenia</TD>
    <TD vAlign=top><PRE>?- X is 14 mod 10.

X = 4

Yes
</PRE></TD></TD></TR></TBODY></TABLE>
<P>Uwaga: znaczenie operatorów <CODE>/</CODE> i <CODE>//</CODE> zale¿y od 
interpretera Prologu (mo¿e byæ na odwrót).</P></DIV></BODY></HTML>
