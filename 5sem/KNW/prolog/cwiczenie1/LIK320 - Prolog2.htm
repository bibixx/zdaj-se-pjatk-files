<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.ceti.pl/~gralinski/lik320/lik-prolog2.htm -->
<HTML><HEAD><TITLE>LIK320 / Prolog</TITLE><LINK 
href="LIK320 - Prolog2_files/lik.css" type=text/css rel=stylesheet>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-2">
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY>
<H1>Lingwistyka komputerowa 320</H1>
<H2>Programowanie w Prologu - powtórzenie</H2>
<H3>Æwiczenia 2. Tryb pracy mechanizmu wnioskowania, funktory, listy</H3>
<P>Integraln± czê¶ci± jêzyka Prolog jest tzw. mechanizm wnioskowania. Dzia³anie 
mechanizmu wnioskowania omówimy na nastêpuj±cym przyk³adzie:</P><PRE>/* dziadek(A,B) - A jest dziadkiem B	*/
/* ojciec(A,B)  - A jest ojcem B	*/
/* dziecko(A,B) - A jest dzieckiem B	*/

dziadek(X,Y) :- ojciec(X,Z), dziecko(Y,Z).     /* (k1) */
dziadek(karol,maurycy).                        /* (k2) */

ojciec(karol,elzbieta).                          /* (k3) */
ojciec(karol,august).                          /* (k4) */

dziecko(henryk,elzbieta).                        /* (k5) */
dziecko(teofil,august).                        /* (k6) */
</PRE>
<P>Cel:</P><PRE>?-dziadek(karol,W). 
</PRE>
<P>Poni¿ej podano schematyczne przedstawienie kilku pierwszych kroków mechanizmu 
wnioskowania przy realizacji celu <TT>dziadek(karol,W)</TT>.</P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>(zn1)</TD>
    <TD><TT>dziadek(karol,Y)</TT></TD>
    <TD>(k1)</TD>
    <TD><TT>X=karol,Y=W</TT></TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD><B><TT>&nbsp;ojciec(karol,Z)</TT></B></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD><TT>&nbsp;dziecko(Y,Z)</TT></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <CAPTION align=bottom>realizacja pierwszego podcelu</CAPTION></TABLE>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD>(zn1)</TD>
    <TD><TT>dziadek(karol,Y)</TT></TD>
    <TD>(k1)</TD>
    <TD><TT>X=karol,Y=W</TT></TD></TR>
  <TR>
    <TD>(zn2)</TD>
    <TD><TT>ojciec(karol,elzbieta)</TT></TD>
    <TD>(k3)</TD>
    <TD><TT>Z=elzbieta</TT></TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD><B><TT>&nbsp;dziecko(Y,elzbieta)</TT></B></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR>
  <CAPTION align=bottom>realizacja drugiego podcelu</CAPTION></TABLE>
<TABLE border=1>
  <CAPTION align=bottom>odpowied¼ pierwsza <TT>W=henryk</TT>, nawrót do 
  (zn3)</CAPTION>
  <TBODY>
  <TR>
    <TD>(zn1)</TD>
    <TD><TT>dziadek(karol,Y)</TT></TD>
    <TD>(k1)</TD>
    <TD><TT>X=karol,Y=W</TT></TD></TR>
  <TR>
    <TD>(zn2)</TD>
    <TD><TT>ojciec(karol,elzbieta)</TT></TD>
    <TD>(k3)</TD>
    <TD><TT>Z=elzbieta</TT></TD></TR>
  <TR>
    <TD>(zn3)</TD>
    <TD><TT>dziecko(henryk,elzbieta)</TT></TD>
    <TD>(k5)</TD>
    <TD><TT>Y=W=henryk</TT></TD></TR></TBODY></TABLE>
<TABLE border=1>
  <CAPTION align=bottom>pora¿ka, usuniêcie (zn3) i przej¶cie do (zn2)</CAPTION>
  <TBODY>
  <TR>
    <TD>(zn1)</TD>
    <TD><TT>dziadek(karol,Y)</TT></TD>
    <TD>(k1)</TD>
    <TD><TT>X=karol,Y=W</TT></TD></TR>
  <TR>
    <TD>(zn2)</TD>
    <TD><TT>ojciec(karol,august)</TT></TD>
    <TD>(k4)</TD>
    <TD><TT>Z=elzbieta</TT></TD></TR>
  <TR>
    <TD>&nbsp;</TD>
    <TD><B><TT>&nbsp;dziecko(Y,august)</TT></B></TD>
    <TD>&nbsp;</TD>
    <TD>&nbsp;</TD></TR></TBODY></TABLE><!--

<table border="1">
<caption align="bottom">odpowied¼ trzecia <tt>W=maurycy</tt>, koniec</captioN>
<tr><td>(zn1)</td><td><tt>dziadek(karol,maurycy)</tt></td>
<td>(k2)</td><td><tt>W=maurycy</tt></td></tr>
</table>

-->
<H4>Sterowanie mechanizmem wnioskowania</H4>
<P>Dzia³anie mechanizmu wnioskowania mo¿na modyfikowaæ u¿ywaj±c m.in. predykatów 
wbudowanych <TT>cut</TT> i <TT>fail</TT>.</P>
<H5><TT>cut</TT></H5>
<P>Standardowy bezargumentowy predykat <TT>cut</TT> (predykat odciêcia), 
alternatywnie oznaczany jako <TT>!</TT>, jest interpretowany logicznie jako 
zawsze prawdziwy i s³u¿y do ograniczania nawrotów. Realizacja tego predykatu, 
wystêpuj±cego jako jeden z podcelów w ciele klauzuli, uniemo¿liwia nawrót do 
któregokolwiek z poprzedzaj±cych go podcelów przy próbie znajdowania rozwi±zañ 
alternatywnych. Wszystkie zmienne, które zosta³y ukonkretnione podczas 
realizacji poprzedzaj±cych odciêcie podcelów w ciele klauzuli zostaj± 
"zamro¿one" (zachowuj± nadane im warto¶ci). Przyk³ad:</P><PRE>ojciec(jan, sta¶).
ojciec(jan, marek).
dziecko(kasia, sta¶).
dziecko(marysia, sta¶).
dziecko(joasia, marek).

/* I mo¿liwo¶æ */
dziadek(X, Z):- ojciec(X, Y), dziecko(Z, Y).
/* ?- dziadek (jan, X). znajduje 3 rozwi±zania */

/* II mo¿liwo¶æ */
/* dziadek(X, Z):- ojciec(X, Y), !, dziecko(Z, Y). */
/* ?- dziadek (jan, X). znajduje 2 rozwi±zania */

/* III mo¿liwo¶æ */
/* dziadek(X, Z):- ojciec(X, Y),  dziecko(Z, Y), !. */
/* ?- dziadek (jan, X). znajduje 1 rozwi±zanie */
</PRE>
<H5><TT>fail</TT></H5>
<P>Drugim predykatem modyfikuj±cym standardowy proces poszukiwania rozwi±zañ 
jest bezargumentowy predykat <TT>fail</TT>. Wykonanie tego predykatu zawsze 
zawodzi. Najczê¶ciej jest on u¿ywany w celu wymuszenia nawrotów. U¿yty w 
kombinacji z predykatem <TT>cut</TT> (w kolejno¶ci: <TT>!, fail</TT>) zapobiega 
u¿yciu innej klauzuli przy próbie znalezienia rozwi±zañ alternatywnych, co 
oznacza niepowodzenie wykonania ca³ej procedury.</P>
<P>Przyk³ad:</P><PRE>pyt :- matka(X, maria), write(X), fail. 

pyt.
</PRE>
<P>Predykat <TT>fail</TT> zawsze zawodzi - bêd±c jednym z podcelów powoduje wiêc 
pora¿kê celu g³ównego <TT>pyt</TT>. Oznacza to, ¿e zmienna <VAR>X</VAR> 
ukonkretniona w czasie realizacji celu g³ównego pozostaje ostatecznie 
niezwi±zana. Wbudowany predykat <TT>write</TT> umo¿liwia wypisywanie 
"chwilowych" warto¶ci zmiennej <VAR>X</VAR>. Predykat <TT>fail</TT> wymusza 
nawroty, umo¿liwiaj±c sukcesywne ukonkretnianie zmiennej <VAR>X</VAR> 
warto¶ciami z bazy danych (nast±pi wypisanie wszystkich matek maj±cych córkê o 
imieniu Maria). Druga klauzula <TT>pyt</TT> gwarantuje ostateczny sukces celu 
g³ównego <TT>pyt</TT> (dziêki czemu interpreter odpowiada w koñcu <TT>Yes</TT> 
zamiast <TT>No</TT>).</P>
<H4>Funktory</H4>
<P>Obiekty mog± byæ reprezentowane przez sta³e lub <EM class=term>termy 
z³o¿one</EM> (struktury). Term z³o¿ony ma postaæ 
<TT><I>f</I>(<I>arg1</I>,...,<I>argn</I>)</TT>, gdzie <I>f</I> jest <EM 
class=term>funktorem</EM> o arno¶ci <I>n</I>.</P>
<P>Myl±ce mo¿e byæ to, ¿e termy z³o¿one zapisywane s± podobnie jak relacje. 
Nale¿y jednak pamiêtaæ, ¿e obiekty reprezentowane przez funktory mog± byæ 
argumentami predykatów, natomiast niedopuszczalne jest, aby argumentem predykatu 
by³ inny predykat (z wyj±tkiem pewnych predykatów specjalnych np. 
<TT>call</TT>):</> 
<TABLE>
  <TBODY>
  <TR>
    <TD><TT>posiada(osoba(jan, kowalski), samochód(opel, astra, 1997))</TT></TD>
    <TD><I>dobrze</I></TD>
  <TR>
    <TD><TT>ojciec(jan, janek).<BR>matka(halina, ojciec(jan, janek)).</TT>
    <TD><I>¼le!</I></TD></TR></TBODY></TABLE>
<P>Je¶li zapiszemy w programie fakt <TT>samochód(opel, astra, 1997)</TT>, to 
<TT>samochód</TT> jest interpretowany jako predykat i nie mo¿e ju¿ byæ 
argumentem innego predykatu.</P>
<H4>Listy</H4>
<P>Lista jest podstawow± struktur± rekurencyjn± w jêzyku Prolog. Jest ona 
ci±giem z³o¿onym z dowolnej liczby elementów, którymi mog± byæ termy tj. sta³e, 
zmienne i struktury. Jako ¿e lista jest struktur± (termem z³o¿onym), do jej 
konstrukcji u¿yto dwuargumentowego funktora <TT>.</TT> (tzw. operator 
<I>cons</I>). Poni¿ej podano przyk³ady list zapisanych przy pomocy tego 
operatora.</P><IMG src="LIK320 - Prolog2_files/listy.png"> 
<P>(Ogólnie dla listy zawieraj±cej <I>n</I> elementów nale¿y u¿yæ operatora 
<TT>.</TT> <I>n</I> razy. Koniec listy jest zaznaczany przy u¿yciu specjalnego 
atomu <TT>[]</TT>, który oznacza te¿ listê pust±.)</P>
<P>Aby unikn±æ uci±¿liwego zapisu za pomoc± funktora <TT>.</TT>, przyjêto 
zamiast niego u¿ywaæ nawiasów kwadratowych, za¶ elementy listy odzielaæ 
przecinkami. Ka¿d± listê mo¿na podzieliæ na dwie czê¶ci: <I>g³owê</I> 
(<I>head</I>) i <I>ogon</I> (<I>tail</I>). W przypadku u¿ycia funktora 
<TT>.</TT>, g³ow± jest zawsze pierwszy argument, za¶ ogonem - drugi. W zapisie 
przy u¿yciu nawiasów kwadratowych g³ow± jest pierwszy element listy, ogonem 
natomiast pozosta³a czê¶æ listy (bez g³owy). Uwaga: Lista pusta (tj. 
<TT>[]</TT>) nie posiada ani g³owy, ani ogona. Podzia³ listy na g³owê i ogon 
jest w zasadzie jedyn± operacj±, za pomoc± której mo¿na rekurencyjnie 
przetwarzaæ listy. Istnieje symbol <TT>|</TT> reprezentuj±cy tê operacjê, wiêc 
zapis <TT>[X|Y]</TT> oznacza listê, której g³ow± jest <VAR>X</VAR>, za¶ ogonem - 
<VAR>Y</VAR>, np. zapytanie <TT>[X|Y]=[1,2,3]</TT> da nastêpuj±ce wi±zania 
zmiennych: <TT>X=1</TT>,<TT>Y=[2,3]</TT>.</P>
<P>Przyk³ad podzia³u listy na g³owê i ogon:</P>
<TABLE>
  <TBODY>
  <TR>
    <TH>lista</TH>
    <TH>g³owa</TH>
    <TH>ogon</TH></TR>
  <TR>
    <TD><TT>[a,b,c,d]</TT></TD>
    <TD><TT>a</TT></TD>
    <TD><TT>[b,c,d]</TT></TD></TR>
  <TR>
    <TD><TT>[a,b,[c,d]]</TT></TD>
    <TD><TT>a</TT></TD>
    <TD><TT>[b,[c,d]]</TT></TD></TR>
  <TR>
    <TD><TT>[]</TT></TD>
    <TD><I>brak</I></TD>
    <TD><I>brak</I></TD></TR>
  <TR>
    <TD><TT>[elemencik]</TT></TD>
    <TD><TT>elemencik</TT></TD>
    <TD><TT>[]</TT></TD></TR>
  <TR>
    <TD><TT>[[1,2],[3,4],5]</TT></TD>
    <TD><TT>[1,2]</TT></TD>
    <TD><TT>[[3,4],5]</TT></TD></TR></TBODY></TABLE>
<H4>Zmienne anonimowe</H4>
<P>Je¿eli w klauzuli zmienna jest u¿yta tylko raz, to w zasadzie oznacza to, ¿e 
jej u¿ycie jest bezsensowne. SWI-Prolog zg³asza w takim wypadku ostrze¿enie 
podczas kompilacji. Zmienn± wystêpuj±c± tylko raz lepiej jest zapisywaæ jako 
specjaln± zmienn± anonimow± o postaci <TT>_</TT> (znak podkre¶lenia). 
Przyk³ady:</P><PRE>/* Fragment definicji procedury multiply(X,Y,Z) (X pomno¿one przez Y
   daje Z) */
multiply(0, _, 0).   /* 0 pomno¿one przez dowoln± liczbê daje 0 */

/* Fragment definicji procedury member(E, L) (E jest elementem listy L) */
member(W, [X | _]) :- W = X.
</PRE>
<H3>Zadania z æwiczeñ 2</H3>
<P><B>Zadanie 1</B> Zmodyfikowaæ przy pomocy odciêcia poni¿sz± procedurê 
<TT>objêto¶æ</TT> (nie usuwaj±c ¿adnego faktu z bazy), aby przy realizacji celu 
<TT>objêto¶æ(Z)</TT> uzyskaæ (a) jedn±, (b) dwie, (c) cztery, (d) osiem 
odpowiedzi.</P><PRE>dlugo¶æ(10).
dlugo¶æ(20).
szeroko¶æ(1).
szeroko¶æ(2).
wysoko¶æ(5).
wysoko¶æ(6).
objeto¶æ(X):-
	dlugo¶æ(A),
	szeroko¶æ(B),
	wysoko¶æ(C),
	X is A*B*C.
objeto¶æ(30).
</PRE>
<P><B>Zadanie 2</B> Opisaæ powi±zania miêdzy cz³onkami rodziny (np. w³asnej) 
stosuj±c funktor <TT>osoba</TT> zamiast sta³ych. Termy z takim funktorem mog± 
mieæ nastêpuj±c± postaæ: <TT>osoba(imiê, nazwisko, wiek, 
miejsce_zamieszkania)</TT>. Przyk³ady faktu: <TT>ojciec(osoba(jan, kowalski, 50, 
poznañ), osoba(janek, kowalski, 20, warszawa))</TT>. Wykonaæ kilka celów typu: 
odszukaæ wujka osoby o imieniu jan zamieszka³ego w Poznaniu. Utworzyæ procedurê, 
który wypisuje wszystkie osoby spe³niaj±ce pewien warunek.</P>
<P><B>Zadanie A</B> Utworzyæ krótk± bazê danych wypo¿yczalni filmów sk³adaj±c± 
siê z filmów (o pewnych parametrach, m.in. ograniczenia wiekowego) i osób o 
pewnych danych (miêdzy innymi: wiek). Napisaæ predykat dwuargumentowy 
<TT>mo¿e_po¿yczyæ</TT>, który sprawdza, czy osoba reprezentowana przez pierwszy 
argumente mo¿e po¿yczyæ film bêd±cy drugim argumentem.</P>
<P><B>Zadanie 3</B> Sprawdziæ wyniki, jakie daje SWI-Prolog dla nastêpuj±cych 
zapytañ (nie trzeba wprowadzaæ do bazy danych ¿adnych faktów):</P><PRE>?- [ala,  ma, kota] = [kota, ma, ala].
?- [1,2,3] = [X,Y].
?- [1,2,3,osiem] = [1|Ogon].
?- [1|[2|[3|[osiem]]]] = [1|Ogon].
?- [[0,1,2],[3,4],[5]] = [Glowa|Ogon].
?- [ala,ma,kota,a,ola,ma,psa] = [ala,ma,kota,a|X].
?- [alfa(1,2), alfa(3,4), alfa(5,6)] = [alfa(X,2)|Ogon].
</PRE>
<P><B>Zadanie 4</B> Zdefiniowaæ predykat <TT>pisz_listê(L)</TT>, który wypisuje 
na ekranie wszystkie elementy listy <VAR>L</VAR>. Skorzystaæ z predykatu 
jednoargumentowego <TT>write</TT>. Wskazówka: napisaæ dwie regu³y dla predykatu 
<TT>pisz_listê(X)</TT> - (1) wypisanie listy pustej, (2) wypisanie listy, 
sk³adaj±cej siê z g³owy i ogona (z wywo³aniem rekurencyjnym).</P>
<P><B>Zadanie 5</B> Zdefiniowaæ predykat <TT>nale¿y(E, L)</TT> - element 
<VAR>E</VAR> nale¿y do listy <VAR>L</VAR>. Wskazówka: sformu³owaæ dwie regu³y - 
(1) <VAR>E</VAR> jest g³ow± listy, (2) <VAR>E</VAR> nale¿y do ogona listy.</P>
<P><B>Zadanie 6</B> (dodatkowe) Zdefiniowaæ predykat <TT>dopasuj(L, W, Z)</TT>, 
który dla listy <VAR>L</VAR> zwraca jej podlistê <VAR>Z</VAR> pasuj±c± do 
zadanego wzorca <VAR>W</VAR>. Wzorzec jest list±, której elementami mog± byæ 
nastêpuj±ce sta³e:</P>
<UL>
  <LI><TT>n</TT> - pasuje do liczby, 
  <LI><TT>a</TT> - pasuje do atomu, 
  <LI><TT>l</TT> - pasuje do elementu bêd±cego (dowoln±) list±, 
  <LI><TT>.</TT> - pasuje do dowolnego elementu, 
  <LI><TT>*</TT> - pasuje do podlisty o dowolnej d³ugo¶ci (tak¿e pustej). 
</LI></UL>
<P>Np. wzorzec <TT>[n,n]</TT> oznacza podlistê z³o¿on± z dwóch liczb, za¶ 
wzorzec <TT>[a,*,n]</TT> - podlistê zaczynaj±c± siê atomem i koñcz±c± siê 
liczb±.</P>
<P>Wskazówka: u¿yæ predykatów wbudowanych <TT>atom</TT>, <TT>integer</TT>.</P>
<P>Przyk³ad oczekiwanego dzia³ania predykatu:</P><PRE>?- dopasuj([x,a,15,101,ala,ma,kota,[1,2],a,b,c],[n,n,*,l,.],Z).

Z = [15, 101, ala, ma, kota, [1,2], a]

Yes
</PRE>
<P><B>Zadanie B</B> (dodatkowe) Zdefiniowaæ predykat <TT>pomiêdzy(A, B, X)</TT>, 
który daje wszystkie liczby naturalne nie mniejsze od <VAR>A</VAR> i nie wiêksze 
od <VAR>B</VAR>. Przyk³ad oczekiwanego dzia³ania predykatu:</P><PRE>?- pomiêdzy(3, 5, X).

X = 3; [naci¶niêto ¶rednik]

X = 4; 

X = 5;

No
</PRE>
<P>Nie u¿ywaæ operatora <TT>is</TT>. Wskazówka: u¿yæ predykatu wbudowanego 
<TT>succ</TT>.</P>
<P><B>Zadanie C</B> (dodatkowe) Napisaæ predykat, w którym trzeci argument 
bêdzie po³±czeniem list-dwóch pierwszych argumentów. Wskazówka: sformu³owaæ dwie 
regu³y - (1) pierwsza lista jest pusta, (2) pierwsza lista sk³ada siê z g³owy i 
ogona.</P>
<P><B>Zadanie 7</B> Znale¼æ ostatni element listy (zdefiniowaæ predykat 
<TT>ostatni(E, L)</TT>).</P>
<P><B>Zadanie D</B> (dodatkowe) Sprawdziæ, czy pierwsza lista jest pocz±tkiem 
drugiej listy (zdefiniowaæ predykat <TT>pocz±tek(Lista1,Lista2)</TT>).</P>
<P><B>Zadanie E</B> (dodatkowe) Zdefiniowaæ predykat <TT>podziel (ListaWej, 
Liczba, ListaMniejsze, ListaWiêksze)</TT> dziel±cy listê <VAR>ListaWej</VAR> na 
dwie listy: <VAR>ListaMniejsze</VAR> jest list± tych liczb z 
<VAR>ListyWej</VAR>, które s± mniejsze od <VAR>Liczby</VAR>, a 
<VAR>ListaWiêksze</VAR> jest list± tych liczb z <VAR>ListyWej</VAR>, które s± 
wiêksze od <VAR>Liczby</VAR>.</P>
<P><B>Zadanie F</B> (dodatkowe) Dla danej liczby uzyskaæ listê odwrócon±. 
Wskazówka: mo¿na np. utworzyæ predykat trójargumentowy <TT>odwróæ_liste(Lista, 
ListaOdwrocona, ListaPomoc)</TT>.</P>
<P><B>Zadanie G</B> (dodatkowe) Zdefiniowaæ parê predykatów, które wyznaczaj± 
sk³adniki listy na odpowiednio parzystych i nieparzystych pozycjach.</P>
<P><B>Zadanie H</B> (dodatkowe) Zdefiniowaæ predykat (trójargumentowy), który 
usuwa dany element z listy.</P>
<P><B>Zadanie I</B> (dodatkowe) Zdefiniowaæ predykat (czteroargumentowy), który 
w danej li¶cie zamienia wszystkie wyst±pienia danego elementu na inny dany 
element.</P>
<P><B>Zadanie J</B> (dodatkowe) Zdefiniowaæ predykat (dwuargumentowy), który 
sprawdza czy lista podana jako drugi argument jest permutacj± listy podanej jako 
pierwszy argument. Na podstawie tego predykatu zdefiniowaæ predykat, który 
wypisuje wszystkie permutacje danej listy.</P>
<P><B>Zadanie K</B> (dodatkowe) Rozwi±zaæ (przy u¿yciu Prologu) nastêpuj±cy 
kryptarytm:</P>
<TABLE>
  <TBODY>
  <TR>
    <TD></TD>
    <TD></TD>
    <TD>E</TD>
    <TD>A</TD>
    <TD>R</TD>
    <TD>T</TD>
    <TD>H</TD></TR>
  <TR>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>A</TD>
    <TD>I</TD>
    <TD>R</TD></TR>
  <TR>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>F</TD>
    <TD>I</TD>
    <TD>R</TD>
    <TD>E</TD></TR>
  <TR>
    <TD>+</TD>
    <TD></TD>
    <TD>W</TD>
    <TD>A</TD>
    <TD>T</TD>
    <TD>E</TD>
    <TD>R</TD></TR>
  <TR>
    <TD colSpan=7>
      <HR width="100%">
    </TD></TR>
  <TR>
    <TD></TD>
    <TD>N</TD>
    <TD>A</TD>
    <TD>T</TD>
    <TD>U</TD>
    <TD>R</TD>
    <TD>E</TD></TR></TBODY></TABLE>
<P>Ró¿nym literom odpowiadaj± ró¿ne cyfry. ¯adna liczba nie mo¿e zaczynaæ siê 
zerem.</P>
<P><B>Zadanie L</B> (dodatkowe) Dla danej listy znale¼æ listê bez powtórzeñ 
elementów.</P>
<P><B>Zadanie M</B> (dodatkowe) Listê bez powtórzeñ bêdziemy interpretowaæ jako 
zbiór. Skonstruowaæ predykaty sprawdzaj±ce inkluzjê, równo¶æ i ró¿nicê 
zbiorów.</P>
<P><B>Zadanie N</B> (dodatkowe) Dla danego zbioru wypisaæ jego zbiór potêgowy 
(wszystkie podzbiory).</P>
<P><B>Zadanie P</B> (dodatkowe) Zdefiniowaæ predykat <TT>sortuj(L, P)</TT>, 
który dla listy liczb L daje posortowan± niemalej±co listê <TT>P</TT>.</P>
<P><B>Zadanie Q</B> (dodatkowe, zadanie jest pracoch³onne i wymaga dobrego 
zaznajomienia siê z predykatami standardowymi Prologu) Dany ci±g wej¶ciowy 
znaków zamieniæ na listê s³ów.</P></BODY></HTML>
