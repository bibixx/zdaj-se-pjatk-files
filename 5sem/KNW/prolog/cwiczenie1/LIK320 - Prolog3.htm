<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.ceti.pl/~gralinski/lik320/lik-prolog3.htm -->
<HTML><HEAD><TITLE>LIK320 / Prolog</TITLE><LINK 
href="LIK320 - Prolog3_files/lik.css" type=text/css rel=stylesheet>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-2">
<META content="MSHTML 6.00.2800.1400" name=GENERATOR></HEAD>
<BODY>
<H1>Lingwistyka komputerowa 320</H1>
<H2>Programowanie w Prologu - powtórzenie</H2>
<H3>Æwiczenia 3</H3>
<H4>K³opoty z rekurencj±</H4>
<H5>rekurencja lewostronna</H5>
<P>Mechanizm prologowy napotyka k³opoty z realizacj± regu³ z rekurencj± 
lewostronn±. Z <EM class=term>rekurencj± lewostronn±</EM> mamy do czynienia 
wtedy, kiedy ten sam predykat wystêpuje w g³owie regu³y i w pierwszym podcelu 
cia³a. Przyk³ad (patrz te¿ zadanie 1): <PRE>rodzeñstwo(piotr, pawe³).
rodzeñstwo(A, B):- rodzeñstwo(B, A).
</PRE>
<P>Podanie celu niezgodnego z baz±, np. <TT>rodzeñstwo(marek, X)</TT>, spowoduje 
zapêtlenie programu.</P>
<P>Przyk³adowe rozwi±zanie:</P><PRE>rodzeñstwo1(piotr, pawe³).
rodzeñstwo(A, B):- rodzeñstwo1(A, B).
rodzeñstwo(A, B):- rodzeñstwo1(B, A).
</PRE>
<H5>stosowanie akumulatora</H5>
<P>Efektywniejsz± metod± stosowania rekurencji w programach arytmetycznych jest 
u¿ycie konstrukcji z akumulatorem. Odpowiada to zast±pieniu rekurencji iteracj±, 
np. zamiast nastêpuj±cego programu:</P><PRE>silnia(1, 1) :- !. 
silnia(N, Wynik) :- 
       N1 is N - 1,
       silnia(N1, Wynik1),
       Wynik is N * Wynik1.
</PRE>
<P>mo¿na u¿yæ programu:</P><PRE>silnia(N, Wynik) :-
          silnia_z_akumulatorem_i_licznikiem(N, 1, 1, Wynik).

silnia_z_akumulatorem_i_licznikiem(N, N, Wynik, Wynik) :- !.

silnia_z_akumulatorem_i_licznikiem(N, L, A, Wynik) :-
       L1 is L+1,
       A1 is A*L1,
       silnia_z_akumulatorem_i_licznikiem(N, L1, A1, Wynik).
</PRE>
<P>Drugi argument predykatu <TT>silnia_z_akumulatorem_i_licznikiem</TT> pe³ni 
funkcjê <EM class=term>licznika</EM> zliczaj±cego liczbê wykonanych pêtli (od 1 
do <I>N</I>), trzeci argument to <EM class=term>akumulator</EM> przechowuj±cy 
cz±stkowy wynik, za¶ czwarty argument s³u¿y do przekazania wyniku.</P>
<P>Najczê¶ciej mo¿liwe jest, by funkcjê licznika pe³ni³ jednocze¶nie argument 
wej¶ciowy - wtedy liczba argumentów zmniejsza siê o jeden, np. dla silni:</P><PRE>silnia(N, Wynik) :- 
          silnia_z_akumulatorem(N, 1, Wynik).    /* (1) */

silnia_z_akumulatorem(1, A, A) :- !.   /* (2) */

silnia_z_akumulatorem(N, A, Wynik) :-       /* (3) */
          N1 is N - 1,
	  A1 is A * N,
	  silnia_z_akumulatorem(N1, A1, Wynik).
</PRE>
<P>Tym razem drugi argument pe³ni rolê <EM class=term>akumulatora</EM>, trzeci 
argument s³u¿y do przekazywania wyniku. Procedura <TT>silnia_z_akumulatorem</TT> 
dzia³a w ten sposób, ¿e dla wywo³ania <TT>silnia_z_akumulatorem(N, A, W)</TT> 
pod <VAR>W</VAR> zostanie podstawiona warto¶æ wyra¿enia <TT>N! * A</TT>. Przy 
stosowaniu tej techniki musimy podaæ:</P>
<OL type=a>
  <LI>regu³ê wprowadzaj±c± akumulator i ustalaj±c± jego pocz±tkow± warto¶æ 
  (tutaj klauzula (1)), 
  <LI>regu³ê koñcz±c± iteracjê (tutaj: (2)) 
  <LI>regu³ê dokonuj±c± obliczenia kolejnej warto¶ci akumulatora (tutaj: (3)). 
  </LI></OL>
<H4>Predykaty wej¶cia-wyj¶cia</H4>
<UL>
  <LI><TT>nl</TT> - wypisanie znaku koñca wiersza, 
  <LI><TT>get0(-Char)</TT> - wczytanie znaku z klawiatury, zmienna 
  <VAR>Char</VAR> przyjmuje warto¶æ kodu znaku (w ASCII), 
  <LI><TT>get_single_char(-Char)</TT> - wczytanie znaku z klawiatury bez echa i 
  czekania na naci¶niêcie klawisza Enter, 
  <LI><TT>write(+Term)</TT> - wypisanie termu prologowego na standardowym 
  wyj¶ciu, 
  <LI><TT>read(-Term)</TT> - wczytanie termu prologowego ze standardowego 
  wej¶cia, <STRONG>uwaga:</STRONG> podawany term nale¿y zakoñczyæ kropk±, a 
  nastêpnie nacisn±æ klawisz Enter. </LI></UL>
<P>Szczegó³owe informacje na temat wszystkich predykatów wbudowanych dostêpnych 
w SWI-Prologu mo¿na znale¼æ w <A class=ext 
href="http://www.swi.psy.uva.nl/projects/SWI-Prolog/Manual/Contents.html">podrêczniku 
do tego programu</A>.</P>
<H4>Stosowanie alternatywy</H4>
<P>W Prologu dopuszczalne jest stosowanie alternatywy w celu uproszczenia zapisu 
(jak równie¿ poprawienia dzia³ania mechanizmu wnioskowania). Do wyra¿ania 
alternatywy s³u¿y operator <TT>;</TT> (¶rednik). Nastêpuj±ce zapisy s± 
równowa¿ne: <PRE>A :- B.
A :- C.
</PRE>
<P>oraz</P><PRE>A :- (B; C).
</PRE>
<H4>Predykat <TT>call</TT></H4>
<P>Predykat <TT>call</TT> s³u¿y do wywo³ania predykatu, który jest argumentem 
innego predykatu. Przyk³ad:</P><PRE>poka¿_rozwi±zanie(Cel) :- call(Cel).

?- poka¿_rozwi±zanie(syn(X, henryk)).
</PRE>
<P>Podanie powy¿szego celu spowoduje wykonanie celu <TT>syn(X, henryk)</TT>.</P>
<H4>Predykat <TT>repeat</TT></H4>
<P>Predykat <TT>repeat</TT> s³u¿y do wymuszenia poszukiwania kolejnych 
rozwi±zañ. Jest to predykat, który zawsze siê powodzi i wymusza "zmianê 
kierunku" podczas nawracania. Przyk³ad:</P><PRE>/* czeka na naci¶niêcie klawisza N lub T, 
   inne klawisze s± pomijane */
potwierdzenie(X):-
    repeat,
    get_single_char(Odp),
    ((Odp = 78; Odp = 110), X = no;
     (Odp = 84; Odp = 116), X = yes).
</PRE>
<P>Przyk³ad zastosowania predykatów <TT>call</TT> i <TT>repeat</TT>:</P><PRE>sesja :-   
          repeat,
          write('Podaj cel'), nl,
          read(Cel), nl,
          szukaj_wszystkie_rozw(Cel).

szukaj_wszystkie_rozw(Cel):- 
          	call(Cel),
          	write('Znalezione rozwi±zanie'), nl,
                write(Cel),  nl,
	        write('Czy podaæ nastêpne?'), nl,
                get(Odp), nl,
                (Odp = 78; Odp = 110). 

szukaj_wszystkie_rozw(_) :- write('Brak innych rozwiazan'), nl, fail.
</PRE>
<H4>¦ledzenie dzia³ania mechanizmu wnioskowania</H4>
<P>Poszukiwanie rozwi±zañ mo¿na ¶ledziæ poprzez podanie celu <TT>trace</TT>, a 
nastêpnie podanie celu, którego osi±gniêcie chcemy ¶ledziæ. Kolejne kroki 
obserwuje siê naciskaj±c klawisz Enter. Debugowanie mo¿na przerwaæ poprzez 
naci¶niêcie <TT>n</TT> (koniec ¶ledzenia) lub <TT>a</TT> (przerwanie dzia³ania). 
Cel <TT>notrace</TT> uniewa¿nia cel <TT>trace</TT>. Mo¿na ¶ledziæ wybrane kroki 
poprzez podanie celu <TT>spy(<I>predykat</I>)</TT>. Wówczas program zatrzymuje 
siê przy napotkaniu podanego predykatu. Naci¶niêcie <TT>l</TT> powoduje skok do 
nastêpnej realizacji predykatu.</P>
<H4>Modyfikowanie bazy danych w trakcie dzia³ania programu</H4>
<P>Do bazy danych mo¿na do³±czyæ nowe klauzule podczas wykonywania programu przy 
pomocy polecenia <TT>asserta(+<I>Klauzula</I>)</TT> lub 
<TT>assertz(+<I>Klauzula</I>)</TT>. Ró¿nica miêdzy nimi polega na tym, ¿e 
polecenie <TT>asserta</TT> umieszcza klauzule przed wszystkimi klauzulami 
znajduj±cymi siê ju¿ w bazie danych, natomiast <TT>assertz</TT> - za klauzulami. 
Przyk³ady:</P><PRE>asserta(ojciec(bronek, broncio)).
asserta(syn(X, Y):- ojciec(Y,X)).
</PRE>
<P>Predykat <TT>retract(+<I>Klauzula</I>)</TT> powoduje usuniêcie klauzuli z 
bazy danych. Predykat <TT>abolish(+<I>Predykat</I>, +<I>Arg</I>)</TT> powoduje 
usuniêcie z bazy danych wszystkich klauzul opisuj±cych <VAR>Predykat</VAR> o 
arno¶ci (liczbie argumentów) <VAR>Arg</VAR>.</P>
<H3>Zadania z æwiczeñ 3</H3>
<P><B>Zadanie 1</B> Podaæ przyk³ad opisu relacji przechodniej (np. 
dwuargumentowej relacji <TT>przodek</TT>) z lewostronn± rekurencj± i bez 
niej.</P>
<P><B>Zadanie 2</B> Zdefiniowaæ rekurencyjnie predykat <TT>potêga(A, B, C)</TT>, 
gdzie <VAR>C</VAR> jest wynikiem potêgowania 
<VAR>A</VAR><SUP><VAR>B</VAR></SUP>. Zdefiniowaæ ten sam predykat przy u¿yciu 
konstrukcji z akumulatorem (z licznikiem lub bez).</P>
<P><B>Zadanie 3</B> Podane przyk³ady zastosowania instrukcji <TT>repeat</TT> 
wykonaæ z zas³oniêciem i bez zas³oniêcia instrukcji <TT>repeat</TT>.</P>
<P><B>Zadanie 4</B> Sprawdziæ na wybranej przez siebie bazie, czy zapisy a) 
<TT>A :- B, C. A:- B, D.</TT> b) <TT>A:- B, (C; D)</TT> s± równowa¿ne (tzn., ¿e 
przy obu zapisach cel A jest spe³niony dla tych samych warunków). Który z 
zapisów jest efektywniejszy (tzn. wymaga mniej pracy od mechanizmu 
wnioskowania)? Odpowied¼ znale¼æ, wykorzystuj±c mechanizm ¶ledzenia 
wnioskowania.</P>
<P><B>Zadanie 5</B> Plik <A 
href="http://www.ceti.pl/~gralinski/lik320/odmiana.pl">odmiana.pl</A> zawiera 
program-bazê danych form fleksyjnych rzeczowników mêsko¿ywotnych (rzeczowników 
mêskich oznaczaj±cych zwierzêta, uwaga: program nie zawsze generuje poprawne 
formy). 
<OL type=a>
  <LI>sprawdziæ dzia³anie programu, ustawiæ formê celownika liczby pojedynczej 
  rzeczownika 'kot' na 'kotu' (zamiast 'kotowi'), ustawiæ poprawny temat dla 
  rzeczowników 'lew' i 'paw', 
  <LI>zmodyfikowaæ program, tak aby poprawnie by³y generowane formy narzêdnika 
  liczby pojedynczej dla 'rak' i innych rzeczowników zakoñczonych na 'k' 
  ('rakiem' zamiast 'rakem'), 
  <LI>rozszerzyæ program o opcje 'a - dodaj wyj±tek-formê alternatywn±', np. dla 
  rzeczownika 'osio³' oprócz regularnej formy 'os³owi' celownikiem liczby 
  pojedynczej mo¿e byæ 'os³u', zmodyfikowaæ procedurê <TT>wykonaj(102)</TT>, tak 
  aby wypisywa³a ona wszystkie formy fleksyjne (je¶li jest ich wiêcej ni¿ 
  jedna). </LI></OL>
<P><B>Zadanie A</B> Na podstawie pliku <A 
href="http://www.ceti.pl/~gralinski/lik320/baza_dan.pl">baza_dan.pl</A> napisaæ 
swoj± bazê danych, np. bazê danych samochodów lub rozbudowaæ bazê danych z 
przyk³adu o dodatkowe operacje.</P>
<P><B>Zadanie 6</B> Na podstawie pliku <A 
href="http://www.ceti.pl/~gralinski/lik320/alkohol.pl">alkohol.pl</A> napisaæ 
podobny program typu "zgadywanka", np. "Twoja ulubiona ksi±¿ka".</P>
<P><B>Zadanie B</B> (dodatkowe) Podaæ a) predykat dwuargumentowy obliczaj±cy 
n-t± liczbê ci±gu Fibbonacciego, b) predykat wykonuj±cy to samo zadanie z 
licznikiem i akumulatorem.</P></BODY></HTML>
