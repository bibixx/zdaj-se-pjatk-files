<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <meta name="Author" content="Krzysztof Barteczko">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; U) [Netscape]">
   <title>Krzysztof Barteczko - Java, wyjatki</title>
</head>
<body>

<center><b><font size=+1>WYJ¡TKI</font></b></center>

<p><br>
<br>
<p><b>Tradycyjna obs³uga b³êdów</b>
<ul>
<li>
return true | false | int</li>

<li>
ustawianie flag (argumenty, obiekty globalne)</li>
</ul>
Problemy
<ul>
<li>
pamiêtaæ, ¿eby sprawdziæ</li>

<li>
nie ma standardowych, zunifikowanych ¶rodków</li>

<li>
mo¿na pomin±æ sprawdzanie</li>
</ul>

<center>
<p><br><b>PROSTY SCHEMAT OBS£UGI WYJ¡TKÓW W JAVIE</b></center>

<p>Wyj±tek powstaje na skutek jakiego¶ nieoczekiwanego b³êdu.
<br>Wyj±tek jest <b>zg³aszany</b>.
<br>Wyj±tek jest <b>obs³ugiwany</b>.
<p>int a, b, c;
<br>String s;
<br>try {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// w bloku <b>try</b> ujmujemy instrukcje, które mog± spowodowaæ wyj±tek
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b/c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// je¿eli np. c = 0, zostanie zg³oszony wyj±tek ArithmeticException
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = Integer.toString(a);
<br>} catch(ArithmeticException ex) {&nbsp; // wyj±tek jest obs³ugiwany
w bloku <b>catch</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp; s = "*" ;
<br>&nbsp;&nbsp;&nbsp;&nbsp; }
<p>Uwaga: w przypadku operacji na liczbach rzeczywistych przy dzieleniu
przez 0 wyj±tek nie zostanie zg³oszony, a warto¶æ wyniku bêdzie POSITIVE_INFINITY
(lub NEGATIVE_INFINITY), co po przeskzta³ceniu w String da napis "Infinity"
("-Infinity").
<center>
<p><b>KLASY WYJ¡TKÓW</b></center>

<p><b>Wyj±tki s± obiektami klas wyj±tków</b>.
<p><img SRC="../images/jexcept.gif" height=428 width=553>
<br><b><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(¯ród³o: Peter Haggar, Java Exception Handling, IBM 1999)</font></b>
<br>&nbsp;
<br>&nbsp;
<br>
<br>
<center>
<p><b>WYJ¡TKI KONTROLOWANE I NIEKONTROLOWANE</b></center>

<ul>
<li>
S± dwa rodzaje wyj±tków: <b>kontrolowane</b> i <b>niekontrolowane</b></li>

<li>
Wyj±tki pochodne od klas RuntimeException i Error s± niekontrolowane</li>

<ul>
<li>
oznaczaj± one b³êdy fazy wykonania (mniej powa¿ne i powa¿ne)</li>

<li>
mog± wyst±piæ w dowolnym miejscu kodu</li>
</ul>

<li>
Pozosta³e wyj±tki s± kontrolowane, co oznacza, ¿e:</li>

<ul>
<li>
metody zg³aszaj±ce te wyj±tki wymieniaj± je jawnie w swojej deklaracji
w klauzuli <b>throws</b></li>

<li>
metody te mog± zg³aszaæ tylko wymienione w klauzuli <b>throws</b>&nbsp;
wyj±tki lub wyj±tki ich podklas</li>

<li>
odwo³ania do tych metod wymagaj± jawnej obs³ugi ew. zg³aszanych wyj±tków:</li>

<ul>
<li>
poprzez konstrukcje try - catch</li>

<li>
poprzez wymienienie wyj±tku w klauzuli throws naszej metody (tej która
odwo³uje siê do metody, która mo¿e zg³osiæ wyj±tek) i "przesun±æ" obs³ugê
wyj±tku do miesca wywo³ania naszej metody.</li>
</ul>
</ul>
</ul>

<p><br>Przyk³ad:
<p>&nbsp;FileInputStream in&nbsp; = null;
<br>&nbsp;FileOutputStream out = null;
<p>&nbsp;try {
<br>&nbsp;&nbsp; in&nbsp; = new FileInputStream(args[0]);
<br>&nbsp;&nbsp; out = new FileOutputStream(args[1]);
<br>&nbsp;&nbsp; int c = 0;
<br>&nbsp;&nbsp; while ((c = in.read()) != -1) out.write(c);
<p>&nbsp;} catch(FileNotFoundException exc) {
<br>&nbsp;&nbsp; System.out.println("Plik " + args[0] + " nie istnieje.");
<br>&nbsp;&nbsp; System.exit(1);
<p>&nbsp;} catch(IOException exc) {
<br>&nbsp;&nbsp; System.out.println(exc.getMessage());
<br>&nbsp;&nbsp; System.exit(1);
<p>Gdyby¶my napisali metodê kopiuj±c± strumienie:
<p>public static void copyStream(InputStream in, OutputStream out)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throws IOException {
<p>&nbsp; int c = 0;
<br>&nbsp; while ((c = in.read()) != -1) out.write(c);
<br>}
<p>to obs³uga wyj±tku IOException, który mo¿e powstaæ przy read() musia³aby
byæ prowadzona w miejscu wywo³ania metody:
<p>try {
<br>&nbsp;&nbsp; .....
<br>&nbsp;&nbsp; copyStream(in, out);
<br>} catch(IOException exc) { ...&nbsp; }
<br>&nbsp;
<br>&nbsp;
<br>
<br>
<br>
<center>
<p><b>SEKWENCJA DZIA£ANIA</b></center>

<ul>
<li>
Wykonywane s± kolejne instrukcje bloku try.</li>

<li>
Je¶li powstanie wyj±tek, wykonanie bloku try jest przerywane</li>

<li>
Sterowanie przekazywane jest do <b>pierwszej w kolejno¶ci</b> klauzuli
catch, której argument (typ wyj±tku) pasuje do typu powstalego wyj±tku:</li>

<ul>
<li>
St±d wa¿ny wniosek: <b>najpierw podawaæ BARDZIEJ SZCZEGÓ£OWE TYPY WYJ¡TKÓW</b></li>
</ul>

<li>
Inne klauzule catch nie s± "uruchamiane"</li>

<li>
Obs³uguj±ca wyj±tek klauzula catch mo¿e zrobiæ wiele rzeczy: m.in. zmieniæ
sekwencjê sterowania (np. poprzez return lub zg³oszenie nowego wyj±tku
za pomoc± instrukcji <b>throw</b>). Je¶li nie zmienia sekwencji sterowania
to wykonanie programu jest kontynuowane w klauzuli finally lub je¶li jej
nie ma - od nastêpnej instrukcji po instrukcji try (czyli po ostatniej
klauzuli-bloku catch).</li>
</ul>

<center>
<p><br><b>KLAUZULA FINALLY</b></center>

<p>Klauzula finally s³u¿y do wykonania kodu niezale¿nie od tego czy wyst±pi³
wyj±tek czy nie.
<p>boolean metoda(...) {
<br>try {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instrukcje, które mog± spowodowaæ
wyj±tek
<br>}
<br>catch(Exception e) {&nbsp; return false; }
<br>finally {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // uporz±dkowanie, np. zamkniêcie
pliku
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>return true;
<br>}
<p>Je¶li powsta³ wyj±tek - uruchamiana jest klauzula catch.
<br>Mimo, i¿ zmienia ona sekwencjê sterowania (zwraca false na znak, i¿
nast±pi³o niepowodzenie), sterowanie przekazywane jest do klauzuli finally.
I dopiero potem zwracany jest wynik - false.
<br>Je¶li nie by³o wyj±tku, po zakoñczeniu instrukcji w bloku try sterowanie
od razu wchodzi do klauzuli finally, a po jej zakoñczeniu zwracany jest
wynik true (wykonywana jest ostatnia instrukcja metody).
<br>&nbsp;
<p><br>
<center>
<p><b>W£ASNE WYJ¡TKI</b></center>

<p>Wyj±tki s± obiektami klas pochodnych od Throwable.
<br>¯eby stworzyæ w³asny wyj±tek nale¿y zdefiniowaæ odpowiedni± klasê.
<br>Zgodnie z konwencj± dziedziczymy podklasê Throwable - klasê Exception.
<p>class NaszWyj extends Exception {
<br>...
<br>}
<p>Zwykle w naszej klasie wystarczy umie¶ciæ dwa konstruktory: bezparametrowy
oraz z jednym argumentem = komunikat o przyczynie powstania wyj±tku.
<p>U¿ycie wyj±tku:
<ul>
<li>
jaka¶ nasza metoda ma sygnalizowaæ wyj±tek NaszWyj -- musi podaæ w deklaracji,
¿e mo¿e to zrobiæ:</li>

<ul>
<li>
void naszaMetoda() <b>throws </b>NaszWyj</li>
</ul>

<li>
nasza metoda sprawdza warunki powstania b³êdu</li>

<li>
je¶li jest b³±d - tworzy wyj±tek (new NaszWyj(...)) i sygnalizuje go za
pomoc± instrukcji <b>throw</b> :</li>

<ul>
<li>
throw new NaszWyj(ew_param_konstruktora_z_info_o_b³êdzie)</li>
</ul>
</ul>

<br>&nbsp;
</body>
</html>
