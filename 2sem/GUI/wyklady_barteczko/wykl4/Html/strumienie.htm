<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <meta name="Author" content="Krzysztof Barteczko">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; U) [Netscape]">
   <title>Krzysztof Barteczko - Java, strumienie</title>
</head>
<body>

<center><b><font size=+1>STRUMIENIE</font></b>
<p><b>AGENDA</b></center>

<p><br>
<blockquote>
<blockquote>
<blockquote>&nbsp;</blockquote>
</blockquote>
</blockquote>

<ol>
<ol>
<ol>
<ol>
<li>
<a href="#KONCEPCJA STRUMIENIA">Koncepcja strumienia</a></li>

<li>
<a href="#KLASY STRUMIENIOWE">Klasy strumieniowe w Javie</a></li>

<li>
<a href="#KLASY PRZEDMIOTOWE">Klasy przedmiotowe</a></li>

<li>
<a href="except.htm">Wyj±tki (na marginesie)</a></li>

<li>
<a href="#KLASY PRZETWARZAJACE">Klasy przetwarzaj±ce</a></li>

<li>
<a href="#KODOWANIE">Kodowanie</a></li>

<li>
<a href="#STRUMIENIE Z INTERNETU">Strumienie z Internetu</a></li>

<li>
<a href="#SERIALIZACJA">Serializacja</a></li>

<li>
<a href="#INNE">Inne klasy we-wy</a></li>
</ol>
</ol>
</ol>
</ol>

<p>
<hr SIZE=4 WIDTH="100%">
<center>
<p><a NAME="KONCEPCJA STRUMIENIA"></a><b><font size=+1>KONCEPCJA STRUMIENIA</font></b></center>

<p><br>
<ul>
<li>
Koncepcja strumienia</li>

<ul>
<li>
zwi±zany ze ¼ród³em lub odbiornikiem danych</li>

<li>
¼ród³o-odbiornik: plik, pamiêæ, URL, socket, potok ...</li>

<li>
strumieñ s³u¿y do przesy³ania=odczytywania informacji - dowolnych danych</li>

<li>
program:</li>

<ul>
<li>
kojarzy strumieñ z zewnêtrznym ¼ród³em/odbiornikiem</li>

<li>
otwiera strumieñ</li>

<li>
dodaje lub pobiera dane ze strumienia</li>

<li>
zamyka strumieñ</li>
</ul>
</ul>
</ul>

<hr WIDTH="100%">
<center>
<p><a NAME="KLASY STRUMIENIOWE"></a><b><font size=+1>KLASY STRUMIENIOWE</font></b></center>

<p><b>W Javie do obs³ugi strumieni s³u¿± klasy z pakietu java.io</b>
<p><b>Klasy te mo¿na podzieliæ na grupy wg nastêpuj±cych kryteriów:</b>
<ul>
<li>
<b>klasy dla strumieni bajtowych -&nbsp; klasy dla strumienie znakowych</b></li>

<ul>
<li>
strumienie znakowe realizuj± przesy³anie znaków, które w Javie s± znakami
unikodu (2 bajty)</li>
</ul>

<li>
<b>klasy przetwarzaj±ce - klasy przedmiotowe</b></li>

<ul>
<li>
klasy przetwarzaj±ce implementuj± okre¶lone rodzaje przetwarzania strumieni,
niezale¿nie od ¼ród³a/odbiornika</li>

<li>
klasy przedmiotowe s± zwi±zane z konkretnymi rodzajami ¼ród³a/odbiornika</li>
</ul>

<li>
<b>klasy wej¶ciowe - klasy wyj¶ciowe</b></li>
</ul>
Na poni¿szych rysunkach pokazano hierarchiê klas znakowych i strumieniowych.
<br>Zaciemnione elementy oznaczaj± klasy przedmiotowe (zwi±zane z konkretnym
¼ród³em/odbiornikiem), jasne - klasy przetwrazaj±ce (realizuj±ce okre¶lone
rodzaje orzetwarzania).
<p>Klasy dla strumieni bajtowych
<p><img SRC="../images/bsclass.gif" height=199 width=458>
<p><img SRC="../images/bsclass2.gif" height=142 width=459>
<p>¯ród³o: Java Tutorial, JavaSoft
<br>&nbsp;
<p>Klasy dla strumieni znakowych
<p><img SRC="../images/csclass.gif" height=170 width=462>
<br><img SRC="../images/csclass2.gif" height=198 width=462>
<p>¯ród³o: Java Tutorial, JavaSoft
<br>&nbsp;
<p><b>UWAGA: Przy przetwarzaniu tekstowym nale¿y korzystaæ ze strumieni
znakowych, bowiem tylko one zapewniaj± poprawne przetwarzanie unikodu.</b>
<p>Nadklasy, z których wywodz± siê wszystkie inne klasy strumieniowe (czyli
nadklasy InputStream, OutputStream, Reader, Writer) s± abstrakcyjne i zawieraj±
deklaracje podstawowych metod przetwarzania strumieni, które podklasy winny
implementowaæ.
<ul>
<li>
Przy tworzeniu obiektu-strumienia strumieñ jest automatycznie otwierany.
Poza tym istnieje metoda <b>open.</b></li>

<li>
Do czytania ze strumienia s³u¿± metody <b>read</b>() (jest ich kilka)</li>

<li>
Do pisania s³u¿± metody <b>write()</b> -te¿ kilka</li>

<li>
Strumieñ mo¿na zamkn±æ za pomoc± metody <b>close().</b> Nie zamkniêty strumieñ
jest zamykany przy niszczeniu obiektu przez od¶miecacz. Nale¿y jednak zawsze
jawnie zamykaæ strumienie.</li>
</ul>

<hr WIDTH="100%">
<center>
<p><a NAME="KLASY PRZEDMIOTOWE"></a><b><font size=+1>KLASY PRZEDMIOTOWE</font></b>
<br><b>(zwi±zane z konkretnym ¼ród³em/odbiornikiem)</b></center>

<p><br>
<br>&nbsp;
<br>&nbsp;
<center><table BORDER CELLPADDING=5 >
<tr>
<th>¬ród³o/odbiornik</th>

<th>Strumienie znakowe</th>

<th>Strumienie bajtowe</th>
</tr>

<tr>
<td ROWSPAN="2"><b>Pamiêæ</b></td>

<td><b>CharArrayReader,</b>
<br><b>CharArrayWriter</b></td>

<td><b>ByteArrayInputStream,</b>
<br><b>ByteArrayOutputStream</b></td>
</tr>

<tr>
<td><b>StringReader,</b>
<br><b>StringWriter</b></td>

<td><b>StringBufferInputStream</b></td>
</tr>

<tr>
<td><b>Potok</b></td>

<td><b>PipedReader,</b>
<br><b>PipedWriter</b></td>

<td><b>PipedInputStream,</b>
<br><b>PipedOutputStream</b></td>
</tr>

<tr>
<td><b>Plik</b></td>

<td><b>FileReader,</b>
<br><b>FileWriter</b></td>

<td><b>FileInputStream,</b>
<br><b>FileOutputStream</b></td>
</tr>
</table></center>

<center>¬ród³o: Java Tutorial</center>

<p>Przyk³ad:
<br>kopiowanie plików bajt po bajcie.
<p>import java.io.*;
<p>public class Copy1 {
<p>public static void main(String[] args) {
<br>&nbsp;
<p>&nbsp;if (args.length != 2) {
<br>&nbsp;&nbsp;&nbsp; System.out.println("Syntax: in out");
<br>&nbsp;&nbsp;&nbsp; System.exit(1);
<br>&nbsp;&nbsp;&nbsp; }
<p>&nbsp;FileInputStream in&nbsp; = null;
<br>&nbsp;FileOutputStream out = null;
<p>&nbsp;try {
<br>&nbsp;&nbsp; in&nbsp; = new FileInputStream(args[0]);
<br>&nbsp;&nbsp; out = new FileOutputStream(args[1]);
<br>&nbsp;&nbsp; int c = 0;
<br>&nbsp;&nbsp; while ((c = in.read()) != -1) out.write(c);
<p>&nbsp;} catch(FileNotFoundException exc) {
<br>&nbsp;&nbsp; System.out.println("Plik " + args[0] + " nie istnieje.");
<br>&nbsp;&nbsp; System.exit(1);
<p>&nbsp;} catch(IOException exc) {
<br>&nbsp;&nbsp; System.out.println(exc.getMessage());
<br>&nbsp;&nbsp; System.exit(1);
<p>&nbsp;} finally {
<br>&nbsp;&nbsp; try {
<br>&nbsp;&nbsp;&nbsp;&nbsp; if (in != null) in.close();
<br>&nbsp;&nbsp;&nbsp;&nbsp; if (out != null) out.close();
<br>&nbsp;&nbsp; } catch (IOException exc) { System.out.println(""+exc);
}
<p>&nbsp;}
<p>}
<blockquote><b>Przy tej okazji omówimy <a href="except.htm">wyj±tki</a>.</b></blockquote>

<p><br>
<hr WIDTH="100%">
<center>
<p><a NAME="KLASY PRZETWARZAJACE"></a><b><font size=+1>KLASY PRZETWARZAJ¡CE</font></b>
<br><b>(implementuj±ce "abstrakcyjne" przetwarzanie)</b></center>

<p><br>
<center><table BORDER CELLPADDING=5 >
<tr>
<th>Rodzaj przetwarzania&nbsp;</th>

<th>Strumienie znakowe</th>

<th>Strumienie bajtowe</th>
</tr>

<tr>
<td>Buforowanie</td>

<td><tt>BufferedReader</tt>,
<br><tt>BufferedWriter</tt></td>

<td><tt>BufferedInputStream</tt>,
<br><tt>BufferedOutputStream</tt></td>
</tr>

<tr>
<td>Filtrowanie</td>

<td><tt>FilterReader</tt>,
<br><tt>FilterWriter</tt></td>

<td><tt>FilterInputStream</tt>,
<br><tt>FilterOutputStream</tt></td>
</tr>

<tr>
<td>Konwersja: bajty-znaki</td>

<td><tt>InputStreamReader</tt>,
<br><tt>OutputStreamWriter</tt></td>

<td>&nbsp;</td>
</tr>

<tr>
<td>Konkatenacja</td>

<td>&nbsp;</td>

<td><tt>SequenceInputStream</tt></td>
</tr>

<tr>
<td>Serializacja obiektów</td>

<td>&nbsp;</td>

<td><tt>ObjectInputStream</tt>,
<br><tt>ObjectOutputStream</tt></td>
</tr>

<tr>
<td>Konwersje danych</td>

<td>&nbsp;</td>

<td><tt>DataInputStream</tt>,
<br><tt>DataOutputStream</tt></td>
</tr>

<tr>
<td>Zliczanie wierszy</td>

<td><tt>LineNumberReader</tt></td>

<td><tt>LineNumberInputStream</tt></td>
</tr>

<tr>
<td>Podgl±danie</td>

<td><tt>PushbackReader</tt></td>

<td><tt>PushbackInputStream</tt></td>
</tr>

<tr>
<td>Drukowanie</td>

<td><tt>PrintWriter</tt></td>

<td><tt>PrintStream</tt></td>
</tr>
</table></center>

<center>¯ród³o: Java Tutorial</center>

<p><b>Komentarze:</b>
<ul>
<li>
buforowanie ogranicza liczbê fizycznych odwo³añ do urz±dzeñ zewnêtrznych</li>

<li>
klasy Filter... s± klasami abstrakcyjnymi, definiuj±cymi interfejs dla
rzeczywistych filtrów. Filtrami s±:</li>

<ul>
<li>
DataInputStream i DataOutputStream</li>

<li>
BufferedInputStream i BufferedOutputStream</li>

<li>
LineNumberInputStream</li>

<li>
PushbackInputStream</li>

<li>
PrintStream</li>

<li>
mo¿na tworzyæ w³asne filtry</li>
</ul>

<li>
konwersje bajty-znaki</li>

<ul>
<li>
InputStreamReader czyta bajty ze strumienia definiowanego przez InputStream
(strumieñ bajtowy) i zamienia je na znaki (16 bitowe), u¿ywaj±c domy¶lnej
lub podanej strony kodowej</li>

<li>
OutputStreamWriter wykonuje przy zapisie konwersjê odwrotn±</li>
</ul>

<li>
konkatenacja strumieni wej¶ciowych pozwala po³±czyæ strumienie i traktowaæ
je jak jeden strumieñ</li>

<li>
serializacja s³u¿y do "utrwalania" obiektów po to, by odtworzyæ je w innym
kontek¶cie (przy ponownym uruchomieniu programu lub w innym miejscu (np.
programie dzia³aj±cym w innym miejscu sieci po przekazaniu "utrwalonego"
obiektu</li>

<li>
DataInputStream i DataOutputStream pozwalaj± czytaæ/pisaæ dane prostych
javowych typów (np. liczby rzeczywiste). Niekiedy nazywa siê to we/wy z
formatowaniem. Strumienie s± tutaj strumieniami binarnymi, w zwi±zku z
tym koniec strumienia rozpoznaje siê jako wyj±tek EOFException.</li>

<li>
LineNumber... zlicza wiersze strumienia przy czytaniu (i pozwala w ka¿dym
momencie uzyskaæ informacjê o numerze wiersza)</li>

<li>
PushBack.. pozwala pdogl±dn±æ nastêpny znak w strumieniu</li>

<li>
Klasy Print...&nbsp; zawieraj± wygodne metody wyj¶cia (np. println). Nie
koniecznie oznacza to drukowanie fizyczne, czêsto wykorzystywane jest w
powi±zaniu z innymi strumieniami po to by ³atwo wyprowadzaæ informacje.</li>
</ul>
Przyk³ad:
<br>przy czytaniu du¿ych plików tekstowych nale¿y unikaæ bezpo¶redniego
czytania za pomoc± klasy FileReader, bowiem ka¿de odczytanie znaku powoduje
fizyczne odwo³anie do pliku (to samo dotyczy zapisu i klasy FileWriter).
<br>Mo¿na zastosowaæ klasê BufferedReader (buforowanie)
<br>Ale klasa ta jest klas± przetwarzaj±c±, wobec tego nie pozwala bezpo¶rednio
podaæ fizycznego ¼ród³a danych.
<br>¯ród³o to podajemy przy konstrukcji obiektu typu FileReader, a po to,
¿eby uzyskaæ buforowanie, "opakowujemy" FileReadera BufferedReaderem.
<br>Wygl±da to tak:
<p>FileReader fr = new FileReader("plik.txt");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// tu powstaje zwi±zek z fizycznym ¼ród³em
<br>BufferedReader br = new BufferedReader(fr); // tu dodajemy "opakowanie",
umo¿liwiaj±ce buforowanie
<br>//...&nbsp; teraz wszelkie odwo³ania czytania itp. kierujemy do obiektu
br
<p>Przyk³adowy program: stworzyæ metodê umo¿liwiaj±c± okre¶lenie czy w
pliku podanym jako argument wystêpuje którekolwiek z podanych s³ów.
<p>Zarys czytania:
<p>&nbsp; try {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String line;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileReader fr = new FileReader(fname);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// fname jest nazw± pliku
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader br = new BufferedReader(fr);
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp; ((line = br.readLine()) !=
null) {&nbsp;&nbsp; // kolejny wiersz pliku: metoda <b>readLine</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tu stwierdzenie,
czy w wierszu wystêpuje które¶ ze s³ów
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.close();&nbsp; // zamkniêcie strumienia
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; catch (IOException e) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(e);
<br>&nbsp;&nbsp;&nbsp; }
<p>Przy okazji tego programu u¿yjemy&nbsp; trzech&nbsp; wa¿nych klas Javy:
<ul>
<li>
Hashtable</li>

<ul>
<li>
tablica asocjacyjna, zawieraj±ca pary klucz-warto¶æ (obie typu Object).
Dodanie do tablicy ht pary: metoda ht.put(key,&nbsp; value). Pobranie warto¶ci
odpowiadaj±cej podanemu kluczowi (dostaniemy Object):&nbsp; ht.get( key).
Uzyskanie zbioru wszystkich kluczy:&nbsp; ht.keys() - dostaniemy obiekt
typu Enumeration.</li>
</ul>

<li>
Enumeration</li>

<ul>
<li>
"wyliczenie" - zbiór elementów. Mo¿emy go przegl±daæ korzystaj±c z metod
hasMoreElements()&nbsp; (czy co¶ jeszcze jest) i nextElement() - podaj±cy
nastêpny element (jako Object)</li>
</ul>

<li>
StringTokenizer</li>

<ul>
<li>
klasa, umo¿liwiaj±ca uproszczone rozbijanie podanego Stringu na symbole.
Co jest traktowane jako "wy³uskiwany" symbol zale¿y od podanych przez nas
ograniczników (symbolem jest ci±g znaków, nie zawieraj±cy ¿adnego z ograniczników).
<b>UWAGA:
w pakiecie java.io znajduje siê klasa StreamTokenizer urzeczywistniaj±ca
parsowanie strumieni, przy czym mo¿liwo¶ci parsowania s± du¿o wiêksze ni¿
w klasie StringTokenizer.</b></li>
</ul>
</ul>
Klasa pozwalaj±ca na przeszukiwanie pliku ma nastêpuj±c± postaæ
<p>public class Search {
<p>&nbsp;public boolean hasAnyWord(String fname, Hashtable wordtab) {
<p>&nbsp; boolean result = false;
<br>&nbsp; try {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String line;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileReader fr = new FileReader(fname);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BufferedReader br = new BufferedReader(fr);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; search:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp; ((line = br.readLine())
!= null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringTokenizer st = new
StringTokenizer(line, " ,.:;()\t\r\n");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (st.hasMoreTokens())
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String
word = st.nextToken();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wordtab.get(word)
!= null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
result = true;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break search;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; br.close();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp; catch (IOException e) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(e);
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp;return result;
<br>&nbsp;}
<br>}
<p>Jest tu jedna metoda - hasAnyWord - stwierdzaj±ca, czy plik podany jako
jej pierwszy argument zawiera którekolwiek ze s³ów, zapisanych w tablicy
asocjacyjnej wordtab. U¿ycie tej tablicy przyspiesza wyszukiwanie, bowiem
s³ów mo¿e byæ du¿o, a gdy s± one zapisane jako klucze (jakich¶) warto¶ci
w tablicy asocjacyjnej, to stwierdzenie czy jakie¶ s³owo w niej wystêpuje
jest b³yskawiczne: odwo³anie wordtab.get(word) (wynik jest null je¶li nie
ma, je¶li jest dostajemy Object skojarzony z danym kluczem; tu niewa¿ny).
<br>A co to s± s³owa? Tu traktujemy je jako ci±gi znaków nie zawieraj±ce
" ,.:;()\t\r\n" i u¿ywamy StringTokenizera do ich wyodrêbnienia (konstruktor
StringTokenizer ma za argumentu String na którym ma dzialaæ oraz ograniczniki
definiuj±ce jakie symbole bêd± wyodrêbniane).
<p>Testuj±ca klasa ma nastêpuj±c± postaæ:
<p>public class Test {
<p>&nbsp;&nbsp; public static void main(String[] args) {&nbsp; // argumenty:
nazwa_pliku slowo1 slowo2 ... slowoN
<br>&nbsp;&nbsp;&nbsp;&nbsp; if (args.length &lt; 2) System.exit(1);
<br>&nbsp;&nbsp;&nbsp;&nbsp; Object dummy = new Object();
<br>&nbsp;&nbsp;&nbsp;&nbsp; Hashtable words = new Hashtable();
<p>&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1; i&lt;args.length; i++) words.put(args[i],
dummy);&nbsp; // warto¶æ nas nie obchodzi, tylko klucz
<p>&nbsp;&nbsp;&nbsp;&nbsp; Search srch = new Search();
<br>&nbsp;&nbsp;&nbsp;&nbsp; boolean result = srch.hasAnyWord(args[0],
words);
<p>&nbsp;&nbsp;&nbsp;&nbsp; String msg = " nie zawiera ¿adnego ze s³ów:";
<br>&nbsp;&nbsp;&nbsp;&nbsp; if (result) msg = " zawiera które¶ ze s³ów:";
<p>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Plik "+args[0]+msg);
<br>&nbsp;&nbsp;&nbsp;&nbsp; Enumeration en = words.keys();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// uzyskujemy wszystkie klucze tablicy
<br>&nbsp;&nbsp;&nbsp;&nbsp; while (en.hasMoreElements()) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// ... i przebiegamy je po kolei
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String word = (String) en.nextElement();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(word);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp; }
<br>}
<br>&nbsp;
<p>
<hr WIDTH="100%">
<center>
<p><a NAME="KODOWANIE"></a><b><font size=+1>KODOWANIE</font></b></center>

<p>Java pos³uguje siê znakami w formacie Unicode (UTF8). S± to - ogólnie
- wielko¶ci 16-bitowe.
<br>¦rodowiska natywne (np. Windows) najczê¶ciej zapisuj± teksty jako sekwencje
bajtów (z przyjêt± stron± kodow±).
<br>Jak pogodziæ najczê¶ciej bajtowy charakter plików natywnych ze znakowymi
strumieniami?
<br>Otó¿ strumienie znakowe potrafi± - niewidocznie dla nas -&nbsp; przekszta³caæ
bajtowe ¼ród³a w znakowe strumienie i odwrotnie. "Pod pokrywk±" tego procesu
znajduj± siê dwie klasy: <b>InputStreamReader</b> i <b>OutputStreamWriter</b>,
które dokonuj± w³a¶ciwych konwersji w trakcie czytania/pisania.
<br>Klasy te mo¿emy wykorzystaæ równie¿ samodzielnie.
<br>Je¶li w konstruktorach tych klas nie podamy enkodowania przy konwersjach
zostanie przyjête domy¶lne.
<br>Aby siê dowiedzieæ, jakie jest domy¶lne enkodowanie mo¿na u¿yæ nastêpuj±cego
programiku:
<p>public class DefaultEncoding {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void main(String args[])
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String p = System.getProperty("file.encoding");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(p);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>}
<p>W zale¿no¶ci od ustawieñ na danej platformie otrzymamy ró¿ne wyniki.
Np. ibm-852 lub Cp852 (Latin 2) albo Cp1252 (Windows Western Europe / Latin-1).
<p>Inna wersja konstruktorów pozwala na podanie enkodowania.
<br>Napiszmy program wykonuj±cy konwersje plików z-do dowolnych (dopuszczalnych
przez Javê) formatów kodowania.
<br>Dopuszczalne symbole enkodowania mo¿na znale¼æ na stronie:
<br><b>http://java.sun.com/products/jdk/1.1/docs/guide/intl/encoding.doc.html</b>
<p>import java.io.*;
<br>&nbsp;
<p>public class Convert {
<p>public static void main(String[] args) {
<p>if (args.length != 4) {
<br>&nbsp;&nbsp; System.out.println("Syntax: in in_enc out out_enc");
<br>&nbsp;&nbsp; System.exit(1);
<br>&nbsp;&nbsp; }
<p>String infile&nbsp; = args[0],&nbsp;&nbsp;&nbsp;&nbsp; // plik wej¶ciowy
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in_enc&nbsp; = args[1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// wej¶ciowa strona kodowa
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outfile = args[2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// plik wyj¶ciowy
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out_enc = args[3];&nbsp;&nbsp;&nbsp;
// wyj¶ciowa strona kodowa
<p>try {
<br>&nbsp;FileInputStream fis = new FileInputStream(infile);
<br>&nbsp;BufferedReader in = new BufferedReader(new InputStreamReader(fis,
in_enc));
<br>&nbsp;FileOutputStream fos = new FileOutputStream(outfile);
<br>&nbsp;BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos,
out_enc));
<br>&nbsp;String line;
<br>&nbsp;while ((line = in.readLine()) != null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.write(line);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.newLine();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// zapis znaku koñca wiersza
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;in.close();
<br>&nbsp;out.close();
<br>&nbsp;}
<br>&nbsp;catch (IOException e) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(e);
<br>&nbsp;}
<p>}
<p>Przyk³adowe wykorzystanie do konwersji pliku zle.htm (zapisanego w Windows
1250) na plik dobrze.htm ( ISO-8859-2):
<blockquote>&nbsp;java Convert zle.htm Cp1250 dobrze.htm ISO8859_2
<br>&nbsp;
<br>&nbsp;</blockquote>

<p><br>
<hr WIDTH="100%">
<center><a NAME="STRUMIENIE Z INTERNETU"></a><b><font size=+1>STRUMIENIE
Z INTERNETU</font></b></center>

<p>Abstrakcyjny strumieñ (np. InputStream) mo¿e byæ zwi±zany z zasobem
sieci, oznaczanym przez URL.
<br>To co dostaniemy w rezultacie czytania takiego strumienia zale¿y od
tego w jaki sposób serwer definiuje przesy³anie informacji dotycz±cych
tego zasobu.
<p>Dwa sposoby dzia³ania:
<br>&nbsp;
<ul>
<li>
stworzyæ URL i uzyskaæ zwi±zany z nim strumieñ wej¶ciowy (umo¿liwia tylko
czytanie),</li>

<li>
stworzyæ URL, uzyskaæ po³±czenie, a nastêpnie odpowiednie strumienie (umo¿liwa
czytanie i pisanie np. automatyczne wype³nianie formularzy)</li>
</ul>

<p><br>Przyk³ad - czytanie&nbsp; z Internetu dokumentów html, których adresy
(np. w postaci: http://....) zapisane s± w pliku podanym jako argument
programu.
<p>import java.net.*;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // konieczne
do pos³ugiwania siê klas± URL
<br>import java.io.*;
<br>import java.util.*;
<p>public class URLReader {
<p>&nbsp;public static void main(String[] args) throws Exception {
<br>&nbsp;&nbsp; BufferedReader list = new BufferedReader(
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new FileReader(args[0]));
<br>&nbsp;&nbsp; String urlString;
<br>&nbsp;&nbsp; while ((urlString = list.readLine()) != null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("Trying to read "+
urlString);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; readAndSave(new URL(urlString));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// tworzony nowy obiekt klasy URL
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp; list.close();
<br>&nbsp;&nbsp; System.exit(0);
<p>&nbsp;}
<br>&nbsp;
<p>&nbsp;static void readAndSave(URL url) throws Exception {
<p>&nbsp;&nbsp; BufferedReader in = new BufferedReader(
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new InputStreamReader(url.openStream()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// url.openStream() zwraca InputStream
<p>&nbsp;&nbsp; String fname = null;
<br>&nbsp;&nbsp; StringTokenizer st = new StringTokenizer(url.getFile(),
"/");
<br>&nbsp;&nbsp; while (st.hasMoreTokens()) fname = st.nextToken();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// pobieramy nazwê pliku pod któr± ma byæ zachowany
<p>&nbsp;&nbsp; BufferedWriter out = new BufferedWriter(new FileWriter(fname));
<p>&nbsp;&nbsp; String s;
<br>&nbsp;&nbsp; while ((s = in.readLine()) != null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.write(s);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.newLine();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp; in.close();
<br>&nbsp;&nbsp; out.close();
<br>&nbsp;&nbsp; }
<p>}
<br>&nbsp;
<p>
<hr WIDTH="100%">
<center>
<p><a NAME="SERIALIZACJA"></a><b><font size=+1>SERIALIZACJA (SZEREGOWANIE)</font></b></center>

<p>Serializacja polega na zapisywaniu <b>obiektów</b> do strumienia.
<br>Zapisywany jest pe³ny stan obiektu (w tym - rekursywnie - obiektów
sk³adowych).
<br><b>Nie</b> s± zapisywane <b>pola statyczne</b> oraz pola deklarowane
z identyfikatorem
<b>transient</b>.
<p>Wykorzystanie:
<ul>
<li>
komunikacja pomiêdzy obiektami/aplikacjami poprzez gniazdka (sockets)</li>

<li>
zachowanie obiektu (jego stanu i w³a¶ciwo¶ci) do pó¼niejszego wykorzystania
przez tê sam± lub inn± aplikacjê.</li>
</ul>

<p><br>Do zapisywania/odczytywania obiektów s³u¿± klasy ObjectOutputStream
oraz ObjectInputStream.
<p>Przyk³ad: tablica asocjacyjna kolorów, umo¿liwiaj±ca odwo³ywanie siê
do kolorów przez nazwy.
<p>import java.io.*;
<br>import java.awt.*;
<br>import java.util.*;
<p>public class Kolory {
<p>&nbsp;&nbsp; public static void main(String[] args) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hashtable c = new Hashtable();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.put("black", Color.black);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.put("blue", Color.blue);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.put("red", Color.red);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.put("yellow", Color.yellow);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.put("white", Color.white);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStream out = new FileOutputStream("KOLORY.SER");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectOutputStream s = new ObjectOutputStream(out);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.<b>writeObject</b>(c);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.flush();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(IOException exc) { System.out.println(exc);
}
<p>&nbsp;&nbsp; }
<br>&nbsp;
<p>W jakiejkolwiek innej aplikacji mo¿emy teraz wybraæ kolor z zapisanej
tablicy, u¿ywaj±c jego nazwy np.:
<p>FileInputStream in = new FileInputStream("KOLORY.SER");
<br>ObjectInputStream ois = new ObjectInputStream(in);
<br>Hashtable ht = (Hashtable) ois.<b>readObject()</b>;&nbsp; // zapamiêtany
obiekt Hashtable - odtworzony
<br>&nbsp;Color c = (Color) ht.get(nazwa_koloru);
<br>&nbsp;
<p>Aby obiekt jakiej¶ klasy móg³ byæ zapisany do strumienia, klasa ta <b>musi
implementowaæ interfejs Serializable</b>.
<br>Standardowe klasy Javy implementuj± ten interfejs.
<br>W naszych klasach musimy zapewniæ tê implementacjê (co nie jest trudne,
bowiem interfejs <b>jest pusty</b>).
<p>Przyk³ad:
<br>Serializowalna klasa Slist stanowi okno z list± i przyciskiem "Save",
który pozwala zapamiêtaæ bie¿±cy stan obiektu (zawarto¶æ listy, kolory,
pismo etc.) w pliku SLIST.SER.
<p>import java.io.*;
<br>import java.awt.*;
<br>import java.util.*;
<p>class Slist extends Frame implements <b>Serializable</b>, ActionListener
{
<p>&nbsp; List list = new List();
<br>&nbsp; Button b = new Button("Save");
<p>&nbsp; Slist() {
<br>&nbsp;&nbsp;&nbsp; b.addActionListener(this);
<br>&nbsp;&nbsp;&nbsp; add(list, "Center");
<br>&nbsp;&nbsp;&nbsp; add(b, "South");
<br>&nbsp; }
<p>&nbsp; public List getList() { return list; }
<p>&nbsp; public void actionPerformed(ActionEvent e)&nbsp; {
<br>&nbsp;&nbsp; try {
<br>&nbsp;&nbsp;&nbsp; FileOutputStream out = new FileOutputStream("SLIST.SER");
<br>&nbsp;&nbsp;&nbsp; ObjectOutputStream s = new ObjectOutputStream(out);
<br>&nbsp;&nbsp;&nbsp; s.writeObject(this);
<br>&nbsp;&nbsp;&nbsp; s.flush();
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp; catch(IOException exc) { System.out.println(exc);
}
<br>&nbsp; }
<p>}
<br>&nbsp;
<p>Nastêpuj±ca aplikacja:
<blockquote>
<ul>
<li>
uruchomiona z argumentami nazwa_koloru elt1 elt2 .. elt3 tworzy i pokazuje
listê o tym kolorze i elementach</li>

<li>
uruchomiona bez ¿adnych argumentów wczytuje i pokazuje zapamiêtany obiekt
(lista, elementy, kolory)</li>
</ul>
</blockquote>
import java.io.*;
<br>import java.awt.*;
<br>import java.util.*;
<br>&nbsp;
<p>public class Serial {
<p>&nbsp;&nbsp; public static void main(String[] args)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throws IOException, ClassNotFoundException {
<br>&nbsp;&nbsp;&nbsp; Slist sl = null;
<br>&nbsp;&nbsp;&nbsp; if (args.length == 0) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream in = new
FileInputStream("SLIST.SER");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectInputStream s = new
ObjectInputStream(in);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl = (Slist) s.readObject();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp; else {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream in = new
FileInputStream("KOLORY.SER");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectInputStream ois =
new ObjectInputStream(in);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hashtable ht = (Hashtable)
ois.readObject();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color c = (Color) ht.get(args[0]);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl = new Slist();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl.getList().setBackground(c);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; args.length
- 1; i++) sl.getList().add(args[i+1]);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<p>&nbsp;&nbsp;&nbsp; if (sl != null) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl.pack();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl.setVisible(true);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp; }
<p>}
<br>&nbsp;
<p>
<hr WIDTH="100%">
<center><a NAME="INNE"></a><b><font size=+1>INNE KLASY WE-WY</font></b></center>

<ul>
<li>
<b>File - </b>pozwala uzyskiwaæ ró¿norodne informacje o plikach i katalogach,
jak równie¿ wykonywaæ dzia³ania na systemie plikowym</li>

<ul>
<li>
&nbsp;klasê File wykorzystujemy np. do uzyskiwania informacji czy plik
istnieje, jakie s± jego charakterystyki (wielko¶æ, data modyfikacji), do
listowania katalogów; istniejê konstruktory plikowych klas strumieniowych
z argumentem typu File.</li>
</ul>

<li>
<b>FileNameFilter i FileFilter</b> - interfejsy umo¿liwiaj±ce wybiórcze,
wg dowolnie konstruowanych kryteriów, listowanie plików</li>

<li>
<b>RandomAccessFile</b> - pliki o dostêpie swobodnym</li>

<li>
<b>DeflaterOutputStream</b> i <b>InflaterInputStream</b>&nbsp; - kompresja/dekompresja
strumieni</li>

<li>
<b>GZIPInputStream</b> i <b>GZIPOutputStream</b>&nbsp; - czytanie/zapisywanie
w formacie GZIP</li>

<li>
<b>ZipInputStream</b> i <b>ZipOutputStream</b>&nbsp; - czytanie/zapisywanie
w formacie ZIP</li>

<li>
W pakiecie AWT znajdziemy klasê <b>FileDialog</b> - dialog wyboru plików
(równie¿ mo¿e korzystaæ z FileNameFilter)</li>

<li>
W Swingu mamy lepszy&nbsp; <b>JFileChooser</b></li>
</ul>

<br>&nbsp;
</body>
</html>
