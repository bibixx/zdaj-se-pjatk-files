--    This SQL DDL script was generated by Microsoft Visual Studio (Release Date: LOCAL BUILD).

--    Driver Used : Microsoft Visual Studio - Oracle Server Driver.
--    Document    : Z:\RBD\Firma2016Oracle.vsd.
--    Time Created: 5 July 2016 11:32.
--    Operation   : From Visio Generate Wizard.
--    Connected data source : No connection.
--    Connected server      : No connection.
--    Connected database    : Not applicable.



-- Create f database.
connect internal ;
startup nomount pfile=   ;
spool create_db_f ;

create database F; 

create rollback segment f_r0 tablespace system ; 

alter rollback segment  f_r0 online ; 

-- Create Oracle exception file.
create table exceptions ( row_id rowid, owner varchar2(30), table_name varchar2(30), constraint varchar2(30)) ; 


-- Create new table PRACUJE_DLA.
-- PRACUJE_DLA : Table of Pracuje_dla
-- 	ID : id identifies Pracuje_dla
-- 	PESEL : Pesel partly identifies Pracuje_dla  
create table PRACUJE_DLA (
	ID NUMBER(3,0) not null,
	PESEL CHAR(11) not null, constraint PRACUJE_DLA_PK primary key (ID, PESEL) ); 

-- Create new table PROJEKT.
-- PROJEKT : Table of Projekt
-- 	ID : id identifies Projekt
-- 	TEMAT : Temat partly identifies Projekt
-- 	DATA_START : data_start is of Projekt
-- 	DATA_KON : data_kon is of Projekt
-- 	BUDZET : Budzet is of Projekt  
create table PROJEKT (
	ID NUMBER(3,0) not null,
	TEMAT VARCHAR2(40) not null,
	DATA_START DATE not null,
	DATA_KON DATE null,
	BUDZET NUMBER(9,2) not null, constraint PROJEKT_PK primary key (ID) ); 

-- Create new table DZIAL.
-- DZIAL : Table of Dzial
-- 	NR : Nr identifies Dzial
-- 	DZIAL : Dzial is of Dzial
-- 	LOKALIZACJA : Lokalizacja is of Dzial
-- 	PESEL_KIERDZ : Pesel_kierDz is of Dzial  
create table DZIAL (
	NR NUMBER(5,0) not null,
	DZIAL VARCHAR2(20) null,
	LOKALIZACJA VARCHAR2(20) null,
	PESEL_KIERDZ CHAR(11) null, constraint DZIAL_PK primary key (NR) ); 

-- Create new table PRACOWNIK.
-- PRACOWNIK : Table of Pracownik
-- 	PESEL : Pesel identifies Pracownik
-- 	IMIE : Imie is of Pracownik
-- 	NAZWISKO : Nazwisko is of Pracownik
-- 	PENSJA : Pensja is of Pracownik
-- 	DATA_UR : Data_ur is of Pracownik
-- 	DATA_ZATR : Data_zatr is of Pracownik
-- 	NR : Nr partly identifies Pracownik
-- 	PESEL_KIER : pesel_kier is of Pracownik  
create table PRACOWNIK (
	PESEL CHAR(11) not null,
	IMIE VARCHAR2(20) not null,
	NAZWISKO VARCHAR2(20) not null,
	PENSJA NUMBER(7,2) null,
	DATA_UR DATE null,
	DATA_ZATR DATE null,
	NR NUMBER(5,0) null,
	PESEL_KIER CHAR(11) null, constraint PRACOWNIK_PK primary key (PESEL) ); 

-- Add the remaining keys, constraints and indexes for the table PRACUJE_DLA.
create index PROJEKT_PRACUJE_DLA_FK1 on PRACUJE_DLA (
	ID ASC); 


create index PRACOWNIK_PRACUJE_DLA_FK1 on PRACUJE_DLA (
	PESEL ASC); 


-- Add the remaining keys, constraints and indexes for the table DZIAL.
create index PRACOWNIK_DZIAL_FK1 on DZIAL (
	PESEL_KIERDZ ASC); 


-- Add the remaining keys, constraints and indexes for the table PRACOWNIK.
create index DZIAL_PRACOWNIK_FK1 on PRACOWNIK (
	NR ASC); 


create index PRACOWNIK_PRACOWNIK_FK1 on PRACOWNIK (
	PESEL_KIER ASC); 


-- Add foreign key constraints to table PRACUJE_DLA.
alter table PRACUJE_DLA
	add constraint PROJEKT_PRACUJE_DLA_FK1 foreign key (
		ID)
	 references PROJEKT (
		ID) DISABLE; 

alter table PRACUJE_DLA
	add constraint PRACOWNIK_PRACUJE_DLA_FK1 foreign key (
		PESEL)
	 references PRACOWNIK (
		PESEL) DISABLE; 

-- Add foreign key constraints to table DZIAL.
alter table DZIAL
	add constraint PRACOWNIK_DZIAL_FK1 foreign key (
		PESEL_KIERDZ)
	 references PRACOWNIK (
		PESEL) DISABLE; 

-- Add foreign key constraints to table PRACOWNIK.
alter table PRACOWNIK
	add constraint DZIAL_PRACOWNIK_FK1 foreign key (
		NR)
	 references DZIAL (
		NR) DISABLE; 

alter table PRACOWNIK
	add constraint PRACOWNIK_PRACOWNIK_FK1 foreign key (
		PESEL_KIER)
	 references PRACOWNIK (
		PESEL); 

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_306792B6
before insert or update on PRACUJE_DLA
referencing OLD as old NEW as new
for each row when (
	new.ID IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row PROJEKT%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM PROJEKT WHERE
			ID = fkVal1
		for update of
			ID;
begin
	open c1(:new.ID);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_E7679349
after update of ID on PROJEKT
referencing OLD as old NEW as new
for each row
begin
	UPDATE PRACUJE_DLA
	SET
		PRACUJE_DLA.ID = :new.ID
	WHERE
		PRACUJE_DLA.ID = :old.ID;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_E7679349
after delete on PROJEKT
for each row
begin
	DELETE FROM PRACUJE_DLA WHERE
		PRACUJE_DLA.ID = :OLD.ID;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_C35894D3
before insert or update on PRACUJE_DLA
referencing OLD as old NEW as new
for each row when (
	new.PESEL IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row PRACOWNIK%ROWTYPE;
	cursor c1 (fkVal1 CHAR) is
		SELECT *
		FROM PRACOWNIK WHERE
			PESEL = fkVal1
		for update of
			PESEL;
begin
	open c1(:new.PESEL);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_635892B2
after update of PESEL on PRACOWNIK
referencing OLD as old NEW as new
for each row
begin
	UPDATE PRACUJE_DLA
	SET
		PRACUJE_DLA.PESEL = :new.PESEL
	WHERE
		PRACUJE_DLA.PESEL = :old.PESEL;
end;

-- Trigger: Cascade deletes to child table.
create trigger ONDELETECASCADE_635892B2
after delete on PRACOWNIK
for each row
begin
	DELETE FROM PRACUJE_DLA WHERE
		PRACUJE_DLA.PESEL = :OLD.PESEL;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_6ABD70E7
before insert or update on DZIAL
referencing OLD as old NEW as new
for each row when (
	new.PESEL_KIERDZ IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row PRACOWNIK%ROWTYPE;
	cursor c1 (fkVal1 CHAR) is
		SELECT *
		FROM PRACOWNIK WHERE
			PESEL = fkVal1
		for update of
			PESEL;
begin
	open c1(:new.PESEL_KIERDZ);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Restrict updates of referenced key.
create trigger RESTRICT_958D70E0
before update of PESEL on PRACOWNIK
referencing OLD as old NEW as new
for each row
declare
	dependent_rows_exist EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	childRow DZIAL%ROWTYPE;
	cursor c1 is
		SELECT *
		FROM DZIAL WHERE
			PESEL_KIERDZ = :old.PESEL;
begin
	open c1;
	fetch c1 into childRow;
	if c1%FOUND then
		raise dependent_rows_exist;
	end if;
	close c1;
exception
	when dependent_rows_exist then
		close c1;
		raise_application_error(-20001, 'Dependent rows exist in table DZIAL');
	when mutating_table then
		close c1;
		NULL;
end;

-- Trigger: Null-out child table's referencing FK's when parent record is deleted.
create trigger ONDELETESETNULL_958D70E0
after delete  on PRACOWNIK
for each row
begin
		UPDATE DZIAL
	SET
		DZIAL.PESEL_KIERDZ = NULL
	WHERE
		DZIAL.PESEL_KIERDZ = :old.PESEL;
end;

--Before Update/Insert Validate Foreign Key.
create trigger VALIDATEFK_95C2F5D0
before insert or update on PRACOWNIK
referencing OLD as old NEW as new
for each row when (
	new.NR IS NOT NULL )
declare
	pk_not_found EXCEPTION;
	mutating_table EXCEPTION;
	PRAGMA EXCEPTION_INIT (mutating_table,-4091);
	parent_row DZIAL%ROWTYPE;
	cursor c1 (fkVal1 NUMBERPS) is
		SELECT *
		FROM DZIAL WHERE
			NR = fkVal1
		for update of
			NR;
begin
	open c1(:new.NR);
	fetch c1 into parent_row;
	if c1%NOTFOUND then
		raise pk_not_found;
	end if;
	close c1;
exception
	when pk_not_found then
		close c1;
		raise_application_error(-20000,'Invalid FK value');
	when mutating_table then
		NULL;
	when others then
		close c1;
		raise;
end;

-- Trigger: Cascade updates to child table.
create trigger ONUPDATECASCADE_6AF2F5D7
after update of NR on DZIAL
referencing OLD as old NEW as new
for each row
begin
	UPDATE PRACOWNIK
	SET
		PRACOWNIK.NR = :new.NR
	WHERE
		PRACOWNIK.NR = :old.NR;
end;

-- Trigger: Null-out child table's referencing FK's when parent record is deleted.
create trigger ONDELETESETNULL_6AF2F5D7
after delete  on DZIAL
for each row
begin
		UPDATE PRACOWNIK
	SET
		PRACOWNIK.NR = NULL
	WHERE
		PRACOWNIK.NR = :old.NR;
end;


-- This is the end of the Microsoft Visual Studio generated SQL DDL script.
