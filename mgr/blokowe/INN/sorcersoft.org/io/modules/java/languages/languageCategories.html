<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Programming Language Categories</title>
</head>

<body>

<center>
<h2>Programming Language Categories</h2>
</center>
<p align="center"><img border="0" src="languages.gif" width="500" height="255"></p>
<p>There are literally hundreds of programming languages in the world and each 
has its own strengths and weakness. Many are simply for teaching or language 
research. They are frequently limited and almost useless. There is a certain set 
of programming fields/categories that I believe are currently distinct enough to 
have an independent programming language to represent them. Each is however, 
narrow enough that there is no need for more than one language.</p>
<table class="standard" cellSpacing="0" align="center" id="table1" width="402">
	<tr>
		<th align="left" width="215">Language Role</th>
		<th align="left" width="183">Best Candidate</th>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Scripting</td>
		<td width="183">
        <p align="left">&nbsp;Groovy</td>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Application Development</td>
		<td width="183">
        <p align="left">&nbsp;Java</td>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Systems Programming</td>
		<td width="183">
        <p align="left">C/C++</td>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Functional</td>
		<td width="183">
        <p align="left">&nbsp;</td>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Logic Programming</td>
		<td width="183">
        <p align="left">&nbsp;</td>
	</tr>
	<tr>
		<td width="215">
        <p align="left">Functional Logic<b> </b>Programming</td>
		<td width="183">
        <p align="left">&nbsp;</td>
	</tr>
</table>
<h3 align="left">Programmer's scripting</h3>
<p>Programmers often have a need for scripting capabilities. However, they need 
a language which is simple and complete. It must never stand in there way as is 
all to often the case with standard scripting languages. It must be able to 
easily integrate into other languages. Examples of languages that might fall 
into this category are Perl, Tcl, Perl, PHP, JavaScript,
<a href="http://www.mozilla.org/rhino/">Rhino</a>,
<a href="https://www.python.org/">Python</a>, <a href="http://www.jython.org/">
Jython</a>, <a href="http://www.ruby-lang.org/en/">Ruby</a>,
<a href="http://jruby.sourceforge.net/">JRuby</a>,
<a href="http://groovy.codehaus.org/">Groovy</a>, and
<a href="http://cs.oberlin.edu/~jwalker/bscheme/">Better Scheme</a> are 
languages for use Scripting. </p>
<p>Groovy is an agile dynamic language for the Java 2 Platform that has many of 
the features that people like so much in languages like Python, Ruby and 
Smalltalk, making them available to Java developers using a Java-like syntax.</p>
<h3>Application Development</h3>
<p>To develop applications a language is needed which is complete and powerful 
but very safe. The complexity of large application mandates a compile time safe 
language. It should also be fairly high level and object oriented. The only 
languages which I believe comes close to this today is Java.</p>
<h3>Systems Programming</h3>
<p>For the purpose of operating systems, compilers and other low level code we 
need a language that operates fast and just above the machine level. Of course 
there will always be occasion to slip into assembly but that is by its nature 
machine specific and so not considered here.</p>
<p>Both C and C++ can be used for this. They provide the low level power needed 
while giving a reasonable level of safety and abstraction.</p>
<h3>Functional</h3>
<p>Certain tasks can best be done working in a purely function environment. And 
these languages while not as widely used today are in many ways so distinct from 
others that it is important to keep there legacy alive in the hopes that they 
may positively influence more common languages. The only real example of this 
today is Haskell since languages like ML are not purely functional.</p>
<p>There is currently no outstanding candidate language for this category.</p>
<h3>Logic Programming</h3>
<p><a href="http://archive.comlab.ox.ac.uk/logic-prog.html">Logic programming</a>
				(sometimes called logical programming) is a
				<a title="Programming paradigm" href="https://en.wikipedia.org/wiki/Programming_paradigm">
				programming paradigm</a> that is claimed to be declarative 
				(i.e., based on
				<a title="Mathematical logic" href="https://en.wikipedia.org/wiki/Mathematical_logic">
				mathematical logic</a>) but this claim is controversial (see
				<a title="Logic programming" href="https://en.wikipedia.org/wiki/Logic_programming#Limitations_of_Prolog_as_logic_programming">
				Limitations of Prolog as logic programming</a> below).<p>There 
				are two families of
				<a title="Category:Logic programming languages" href="https://en.wikipedia.org/wiki/Category:Logic_programming_languages">
				logic programming languages</a>: an original sequential form
				<a title="Prolog" href="https://en.wikipedia.org/wiki/Prolog">
				Prolog</a> and a later concurrent form.Other, more modern examples of the paradigm include
				<a title="Mercury programming language" href="https://en.wikipedia.org/wiki/Mercury_programming_language">
				Mercury</a>,
				<a title="Visual Prolog" href="https://en.wikipedia.org/wiki/Visual_Prolog">
				Visual Prolog</a>,
				<a title="Oz programming language" href="https://en.wikipedia.org/wiki/Oz_programming_language">
				Oz</a>,
<a title="Scientific Community Metaphor" href="https://en.wikipedia.org/wiki/Scientific_Community_Metaphor">
				Scientific Community Metaphor</a>, and A-Prolog.</p>
<p>The is currently no complete practically applied logic programming language 
today.<h3><b>Functional Logic </b>Programming</h3>
<p><a href="http://www.informatik.uni-kiel.de/~mh/FLP/">Functional logic 
programming</a> aims to amalgamate the most important declarative programming 
paradigms, namely
<a href="http://www.cs.nott.ac.uk/Department/Staff/gmh/faq.html">functional 
programming</a> and <a href="http://www.comlab.ox.ac.uk/archive/logic-prog.html">
logic programming</a>. In comparison with pure functional languages, functional 
logic languages have more expressive power due to the availability of features 
like function inversion, partial data structures, existential variables, and 
non-deterministic search. In comparison with pure logic languages, functional 
logic languages have a more efficient operational behavior since functions 
provide for more efficient evaluation strategies (lazy evaluation, deterministic 
reductions) than predicates. Early research in this area has been concentrated 
on the definition and improvement of appropriate execution principles for 
functional logic languages. In recent years efficient
<a href="http://www.informatik.uni-kiel.de/~mh/FLP/implementations.html">
implementations</a> of these execution principles have been developed. You can 
look into a
<a href="http://www.informatik.uni-kiel.de/~mh/publications/papers/JLP94.html">
survey</a> of this area. </p>

<h3><b>Pattern </b>Programming (The Future?)</h3>
<p>In pattern languages everything is a “pattern”. Patterns make up classes and 
methods, however there is no direct representation of an object. Concepts 
similar similar to OO programming and functional languages like Scheme<br>
<br>
<a href="http://www.daimi.au.dk/~beta/Manuals/latest/beta-intro/">BETA</a> 
supports the object-oriented perspective on programming and contains 
comprehensive facilities for procedural and functional programming. BETA has 
powerful abstraction mechanisms for supporting identification of objects, 
classification and composition. BETA is a <a name="INX_2">
<span class="INDEXED" title="Indexed">strongly typed</span></a> language like 
Simula, Eiffel and C++ with most type checking being carried out at 
compile-time. The abstraction mechanisms include: class, procedure, function, 
coroutine, process, exception, and many more, all unified to the ultimate 
abstraction mechanism: the pattern. In addition to the pattern, BETA has 
subpattern, virtual pattern and pattern variable. </p>

<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'90fd71afbfa2ecba',t:'MTczOTIwNDYxMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>

</html>