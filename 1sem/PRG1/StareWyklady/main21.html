<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index20.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><div class="tytulpunktu">4. Funkcje</div>

<a name="W3.4"></a>

<p>Idea podzia³u programu na fragmenty, które mog± byæ opracowywane odrêbnie
od siebie, do kodu w³±czone jednokrotnie a wywo³ywane wielokrotnie jest zrealizowana
(w taki czy inny sposób) chyba we wszystkich jêzykach programowania.<br>
 Takie wyodrêbnione fragmenty nazywa siê<A NAME="EDU.skorowidz.termin podprogram 21_173"></A> <b>podprogramami</b>,<A NAME="EDU.skorowidz.termin procedura 21_174"></A> <b>procedurami</b>
  lub<A NAME="EDU.skorowidz.termin funkcja 21_175"></A> <b>funkcjami</b>. <br>
 Ró¿nice pojêciowe s± tu raczej rozmyte. Niekiedy mówi siê ogólnie o procedurach
lub podprogramach (<b><i>procedure, subroutine</i></b>), funkcjami (<b><i>
function</i></b>) nazywaj±c specjalne ich przypadki, które zwracaj± warto¶ci.<br>
 Jêzyki C i C++ operuj± wy³±cznie pojêciem funkcji, nazywaj±c tak oba rodzaje
procedur.<br>
Teraz zastosujemy w³asnie tê terminologiê.<br>Nale¿y dodaæ, ¿e w innych ni¿ C++ jêzykach obiektowych (w tym w Javie) odpowiednikiem pojêcia funkcji jest pojêcie <b>metody</b>. O ró¿nicy miêdzy funkcjami i metodami dowiemy siê przy okazji omawiania podstaw programowania obiektowego.<br>
 <br><A NAME="EDU.skorowidz.termin funkcja 21_176"></A> 
 <div class="def"> <b>Funkcja</b> - to wyodrêbniony opis czynno¶ci (zestaw instrukcji)
zapisany we fragmencie kodu, który mo¿e byæ jednokrotnie po³±czony (przez
wstawienie albo w fazie kompilacji lub wykonania) z programem ¼ród³owym i
wielokrotnie u¿yty za pomoc± odwo³añ z innych fragmentów programu</div>
<br>
<p>Funkcje definiujemy w programie za pomoc± dostarczenia:<br>
<ul>
<li><A NAME="EDU.skorowidz.termin funkcja nag³ówek 21_177"></A> <b>nag³ówka funkcji</b> (opisuj±cego m.in. nazwê funkcji oraz informacje, które mog± byæ funkcji przekazane),</li>

<li><<A NAME="EDU.skorowidz.termin funkcja cia³o 21_178"></A> b>cia³a funkcji</b> (samego kodu, opisuj±cego czynno¶ci wykonywane przez funkcjê).</li>
</ul>

<br>

<div class="notel">Uwaga. W klasycznym REXXie wystêpuje pojêcie procedury, a sk³adnia jest
zupe³nie inna.</div>

<div class="ddd">
<br>
W ró¿nych jêzykach w ró¿ny sposób definiuje siê nag³ówki i ogranicza cia³o funkcji.
</div>

<br clear="all">

<p>Umówmy siê, ¿e w naszym uproszczonym, zmodyfikowanym REXXie
nag³ówki funkcji bêdziemy oznaczaæ s³owem <b>function</b>, wystêpuj±cym jako
pierwsze s³owo w wierszu, po którym nastêpuje nazwa funkcji i w nawiasach
okr±g³ych lista parametrów (opis informacji, przekazywanej do funkcji) a
kod funkcji bêdzie siê zawsze koñczy³<A NAME="EDU.skorowidz.termin instrukcja_return 21_179"></A> instrukcj± <b>return</b>, która zwróci
sterowanie do miejsca wywo³ania funkcji, ew. zwracaj±c te¿ wynik funkcji
jako warto¶æ wyra¿enia podanego w instrukcji return.<br>
<br>

<div class="syntax"><br>
        <b>function</b> <i><b>nazwa_funkcji </b></i><b>(</b> <i><b>lista_parametrów</b></i> <b>)</b><br>
                <i>ins1</i><br>
                <i>ins2</i><br>
                ...<br>
                <i>insN</i><br>
                <b>return [</b> <b><i>wyra¿enie</i></b> ]<br>
<br>
Uwagi: <br>
<ul>
  <li>nawiasy kwadratowe oznaczaj±, ¿e wyra¿enie w instrukcji return (zwrot wymiku) jest opcjonalne,</li>
  <li><A NAME="EDU.skorowidz.termin lista_parametrów 21_180"></A> lista parametrów stanowi listê zmiennych, rozdzielonych przecinkami; lista mo¿e byæ pusta.</li>
</ul>
</div>

<br>
<p>Có¿ to jest lista parametrów? <br>
<br><A NAME="EDU.skorowidz.termin parametr 21_181"></A> <div class="def">Parametry s± zmiennymi za pomoc± których w ciele funkcji uzyskujemy
dostêp do informacji przekazanych przy wywo³aniu funkcji.</div>
<br>
<p>Zatem, ¿eby zrozumieæ budowê funkcji musimy te¿ wiedzieæ w jaki sposób funkcjê siê wywo³uje.<br>
<br><A NAME="EDU.skorowidz.termin funkcja wywo³anie 21_182"></A> 
<div class="syntax"> Wywo³anie funkcji jest <b>wyra¿eniem</b> o nastêpuj±cej postaci:<br>
    <br>
            <i><b>nazwa_funkcji(lista_argumentów)</b></i><br>
<br>
Przy czym:<br>
<ul>
  <li>wyra¿enie to ma warto¶æ wyniku funkcji (wyra¿enia w instrukcji return),
je¶li funkcja zwraca wynik (je¶li jakie¶ wyra¿enie w return jest podane);</li>

  <li><A NAME="EDU.skorowidz.termin lista_argumentów 21_183"></A> lista argumentów jest list± wyra¿eñ, rozdzielonych przecinkami. Wyra¿enia
s± opracowywane, a   ich warto¶ci przekazywane funkcji i dostêpne wewnêtrz
funkcji jako warto¶ci parametrów znajduj±cych siê na pozycjach odpowiadaj±cych
pozycjom argumentów;</li>

  <li><font color="#cc0000">nawias otwieraj±cy listê argumentów musi nastêpowaæ zaraz po nazwie funkcji</font> (bez rozdzielaj±cej spacji). <i>Uwaga. Konieczno¶æ spe³nienia tego wymagania zale¿y od jêzyka programowania</i>. <br>
  </li>
</ul>
</div>

<br>
<p>Np. mo¿emy zdefiniowaæ funkcjê, której zadaniem bêdzie porównanie dwóch warto¶ci.
Ka¿de wywo³anie tej funkcji bêdzie jej przekazywaæ dwa argumenty - warto¶ci
do porównania. Bêd± one dostêpne w funkcji poprzez nazwy odpowiednich parametrów.
Po porównaniu funkcja zwróci wynik do miejsca wywo³ania (0 - warto¶ci rózne,
1, - pierwszy argument wiêkszy od drugiego, -1 - pierwszy mniejszy od drugiego).<br><br>

<img src="images/Funkcja.jpg" alt="Funkcja" width="516" height="398" border="1" align="Right" hspace="15">
Zobaczmy.<br>
Nazwa funkcji: compare<br>
Parametry: val1, val2<br>
Wywo³ana najpierw z argumentami a i b (ich warto¶ci s± przekazywane funkcji i wchodz± "na miejsce" parametrów val1 i val2).<br>
Kod funkcji stwierdza, ¿e val1 (czyli warto¶æ a) jest mniejsze od val2 (czyli
warto¶ci b) i stosownie do tego ustala warto¶æ zmiennej r. Warto¶æ ta jest
zwracana do miejsca wywo³ania przez instrukcjê return, a instrukcja przypisania
podstawia j± na zmienn± wynik.<br>
Zauwa¿my dalej, ¿e  funkcje tê:

<ul>
  <li>mo¿emy z kodu programu wywo³ywaæ wielokrotnie (ostatnia instrukcja na rysunku - drugie wywo³anie)</li>
  <li>jako argumenty mo¿emy podawaæ dowolne wyra¿enia (np. y+1 lub warto¶æ zwrócon± przez inn± funkcjê)</li>
</ul>
<br clear="all">

<br>

<div class="notel">
W innych jêzykach bêdzie inaczej: np. w C  program sk³ada siê wy³±cznie
z definicji funkcji (oraz ew. z deklaracji tzw zmiennych globalnych), w¶ród
których jedna - o nazwie main - jest wyró¿niona i stanowi odpowiednik naszego
"g³ównego programu". Java stanowi nieco inny przypadek, bowiem jest jêzykiem
obiektowym i operuje wy³±cznie klasami.
</div>

<div class="ddd">
<br>
Definiuj±c funkcje musimy wiedzieæ
nie tylko jak sformu³owaæ jej definicjê, ale równie¿ w jaki sposób umie¶ciæ
j± w strukturze ca³ego programu. I znowu, ró¿ne jêzyki stosuj± tutaj ró¿ne
regu³y.<br>
<br>
W naszym uproszczonym REXXie bêdziemy rozró¿niaæ g³ówny program i funkcje. <br>
G³ówny program zaczynaæ siê bêdzie w pierwszym wierszu pliku ¼ród³owego i
musi koñczyæ siê instrukcj± exit (koniec wykonania programu). Dopiero potem
mog± nastêpowaæ definicje funkcji.
</div>

<br clear="all">

<p>Zobaczmy przyk³ad. Program korzystaj±cy ze zdefiniowanej funkcji compare
i porównuj±cy warto¶ci wprowadzane przez u¿ytkownika z konsoli. Przy okazji
na tym przyk³adzie warto zaobserwowaæ, ¿e funkcja mo¿e byæ wywo³ywana
z innej funkcji.<br>

<pre>
/* Test funkcji  */

do forever
  v1 = linein();
  if (v1 = '') then exit;
  v2 = linein();
  if (v2 = '') then exit;
  showComparison( v1, v2);
end
exit


function compare ( val1, val2 )

   if ( val1 &gt; val2 ) then return 1;
   else if (val1 &lt; val2) then return -1;
   else return 0;


function showComparison ( val1, val2)

   msg[1] = "wiêksza od";
   msg[0] = "rowna";
   i = -1;
   msg[i] = "mniejsza od";

   r = compare( val1, val2 );
   say "Warto¶æ " val1 " jest " msg[r] "warto¶ci " val2
   return

</pre>

<p>Pêtla <b><i>do forever</i></b> (s³owo kluczowe jêzyka) wykonywana jest w
nieskoñczono¶æ. W petli tej u¿ytkownik wprowadza z konsoli po kolei dwie
warto¶ci (liczby lub napisy!). Wci¶niêcie "pustego" ENTER przerywa dzia³anie
pêtli (bowiem koñczy program - instrukcja exit). Po wprowadzeniu warto¶ci
wo³ana jest funkcja showComparison, która sama z kolei wo³a funkcjê compare
i wyprowadza wyniki porównania. Wyprowadzane napisy ("mniejsze od", "równe",
"wiêksze od") umie¶cili¶my w tablicy, której indeksy odpowiadaj± wynikom
porównania zwracanym przez funkcjê compare (w ten sposób unikamy instrukcji
if, które - je¶li s± rozbudowane - stanowi± czêste ¼ród³o b³êdów logicznych
w programie). Na marginesie: REXX dopuszcza dowolne warto¶ci jako indeksy
tablicy, ale warto¶ci, które nie s± nieujemnymi liczbami ca³kowitymi powinny
byæ podawane jako zmienne, dlatego u¿yli¶my zmiennej <b><i>i</i></b> z nadan± warto¶ci±
-1 do indeksowania elementu-napisu "mniejsze od". <br>
<br>
Zwróæmy te¿ uwagê na to, ¿e funkcja <i><b>showComparison</b></i> nie zwraca ¿adnych warto¶ci. Koñczy jej dzia³anie instrukcja <i><b>return</b></i> bez podanego wyra¿enia "do zwrotu".<br>
<br>
<font color="#ff6600"><b>Proszê zapisaæ i uruchomiæ omawiany wy¿ej program na w³asnym komputerze. </b></font><br>
<br>
Funkcje nie musz± mieæ parametrów.<br>
<br>

<div class="important"> Je¿eli funkcja nie ma ¿adnych parametrów to w jej definicji  i tak trzeba podaæ po nazwie nawiasy okr±g³e ().<br>
Przy wywo³aniu funkcji bez podawania jakichkolwiek argumentów - po nazwie funkcji równie¿ podajemy nawiasy okr±g³e ()</div>

<br>
<p>Mo¿emy teraz stwierdziæ, ¿e w wykorzystywanych przez nas wcze¶niej funkcjach
linein(), time(), right() nie ma nic tajemniczego. Po prostu, niektóre u¿yteczne
funkcje ju¿ zosta³y napisane i s± udostêpnione jako tzw.<A NAME="EDU.skorowidz.termin funkcja_wbudowana 21_184"></A> funkcje wbudowane
(wbudowane w REXX). W innych jêzykach mamy tzw.<A NAME="EDU.skorowidz.termin biblioteka_funkcji_standardowych 21_185"></A> biblioteki funkcji standardowych,
które te¿ ju¿ s± gotowe do wykorzystania. Pakiety Javy (choæ maj± nieco inne
znaczenie) mo¿emy kojarzyæ pod wzglêdem funkcjonalno¶ci z bibliotekami funkcji
standardowych.<br>

<br>

<div class="def"><A NAME="EDU.skorowidz.termin funkcja_wbudowana 21_186"></A> Funkcje wbudowane lub<A NAME="EDU.skorowidz.termin funkcja_standardowa 21_187"></A> standardowe - to skompilowane, gotowe do wykorzystania
w programach funkcje, spe³niaj±ce wiele u¿ytecznych zadañ np. przetwarzanie
³añcuchów znakowych, wej¶cie-wyj¶cie, funkcje matematyczne
</div>

<br clear="all">

<div class="notel">Przez <b>definicjê zmiennej</b> w REXXie bêdziemy rozumieli pierwsze jej
u¿ycie (np. przypisanie) jej warto¶ci). W innych jêzykach rozró¿nia siê deklaracjê
i definicjê zmiennej; o deklaracjach bêdziemy mówiæ ucz±c siê Javy</div>

<div class="ddd">
<br>
Tworz±c
i u¿ywaj±c funkcji musimy zdawaæ sobie sprawê z dwóch wa¿nych problemów:<br>
<ul>
  <li>po pierwsze, jakie s± relacje pomiêdzy zmiennymi <b>definiowanymi</b> w danej funkcji, a zmiennymi wystêpuj±cymi w programie poza t± funkcj± (w "programie glównym", w innych funkcjach),</li>
  <li>po drugie, <b>w jaki sposób przekazywane</b> s± funkcji argumenty.<br>
  </li>
</ul>
</div>

<br clear="all">
<br>

<p>W wiêkszo¶ci jêzyków programowania zmienne definiowane w kodzie funkcji s± tak zwanymi <b>zmiennymi lokalnymi</b>. <br><br>

<div class="notel33">
W naszym uproszczonym REXXie mamy do czynienia tylko z lokalnymi blokami
wprowadzanymi przez definicjê funkcji. W innych jêzykach mo¿emy mieæ zagnie¿d¿one
bloki lokalne wprowadzane przez instrukcjê grupuj±c±, np. w C czy Javie -
nawiasy klamrowe</div>

<div class="ddd">
<br>
<br>
<br>
Cia³o funkcji  jest szczególnym przypadkiem tzw.<A NAME="EDU.skorowidz.termin blok_lokalny 21_188"></A> bloku
lokalnego. Istotnie, definicja funkcji grupuje kod (w REXXie miêdzy nag³owkiem
funkcji  a s³owem return w³±cznie)  - st±d nazwa "blok", natomiast s³owo
"lokalny" wi±¿e siê z w³a¶ciwo¶ciami tego bloku, m.in. z tym, ¿e ka¿da zmienna
zdefiniowana w tym bloku ma charakter lokalny) czyli:
</div>

<br clear="all">

<br><A NAME="EDU.skorowidz.termin zmienna_lokalna 21_189"></A> 
<div class="def"> <b>Zmienna lokalna</b> jest zmienn± zdefiniowan± w bloku lokalnym, widzian±
(przez kompilator czy interpreter) i istniej±c± tylko w tym bloku, od pocz±tku
definicji zmiennej do koñca bloku</div>

<br>
<p>Zobaczmy przyk³ad:<br>
<pre>
a = 3;
b = 5;
func1();
func2();
say "main a =" a "b =" b;
exit;

function func1()
  a = 7;
  b = 10;
  c = 12;
  func2();
  say "func1 a =" a "b = " b "c = " c;
  return;

function func2()
  a = 100;
  b = 101;
  c = 101;
  say "func2 a =" a "b = " b "c = " c;
  return;
</pre>

<br>

<div class="listing33r">
<i>Wydruk z programu</i><br>
func2 a = 100 b =  101 c =  101<br>
func1 a = 7 b =  10 c =  12<br>
func2 a = 100 b =  101 c =  101<br>
main a = 3 b = 5<br><br>
</div>

<div class="ddd">
<br>
Wa¿ne obserwacje:<br>
<ul>
  <li>mimo tych samych nazw zmienne a i b w funkcji func1 s± innymi zmiennymi ni¿ a i b w funkcji func2 oraz a i b w programie g³ównym</li>
  <li>zmienna c jest znana w func1 i jest znana w func2 (ale tu mimo tej
samej nazwy jest to inna zmienna), natomiast nie mo¿emy odwo³aæ siê do c
w programie g³ównym, bo tu ta zmienna jest nieznana (¶ci¶lej - jej warto¶æ
bêdzie nieokre¶lona) </li>
</ul>
</div>

<br clear="all">

<p>Widaæ tu wyra¼nie,  ¿e zmienne a, b, c s± lokalne w funkcjach func1 i func2
(a zatem za ka¿dym razem istniej± tylko w ramach bloku danej funkcji). I
co potwierdza  wydruk programu ka¿da funkcja operuje na swoich lokalnych
zmiennych a, b, c. Dlatego - mimo wywo³ania func2 z func1 - warto¶ci zmiennych
a, b, c na koñcu func1 równe s± 7, 10, 12 (a nie 100, 101,101). Tak samo
a i b na koñcu dzia³ania programu (ju¿ po wywo³aniu func1) maj± warto¶ci
nadane w dwóch pierwszych instrukcjach programu g³ównego.<br>
<br>
Czasami jednak - oprócz dostêpu do informacji przekazanej jako argumenty
wywo³ania - funkcja winna mieæ dostêp do zmiennych zdefiniowanych poza jej
kodem. <br><br>

<div class="notel33">
W jêzyku C podobny efekt uzyskuje siê za pomoc± tzw. zmiennych globalnych,
deklarowanych poza cia³em jakiejkolwiek funkcji. W Javie pewnym odpowiednikiem
zmiennych globalnych s± pola klasy.
</div>

<div class="ddd">
<br>
W REXXie mechanizm "dzielenia" zmiennych
przez g³ówny program i funkcje jest bardzo elastyczny. Dla ka¿dej funkcji
- indywidualnie - mo¿emy w jej nag³ówku podaæ jakie zmienne (w tym tablice)
definiowane poza funkcj± bêd± dostêpne w jej ciele. S³u¿y temu klauzula <b>expose</b>.
</div>

 <br clear="all">
<br>

<div class="syntax">
            <b>function</b> (<i><b>lista_parametrów</b></i>) <b>expose</b> <i><b>lista_zmiennych</b></i> <br>
<br>
    gdzie:<br>
<ul>
  <li>lista_zmiennych  - lista nazw zmiennych (rozdzielonych spacjami)  zdefiniowanych poza funkcj±, a do których
funkcja bêdzie mia³a dostêp,</li>

  <li>Uwaga. Zmienne oznaczaj±ce tablice zapisujemy podaj±c bezpo¶rednio po nazwie zmiennej nawiasy klamrowe [ ]
  </li>
</ul>
</div>

<p>Drugi, istotny, wspomniany wcze¶niej, problem dotyczy<A NAME="EDU.skorowidz.termin funkcja przekazywanie_argumentów 21_190"></A> <b>sposobu przekazywania argumentów</b> przy wywo³aniu funkcji.<br>
<br>
Generalnie mo¿emy mieæ dwa sposoby przekazywania argumentów: przez warto¶æ i przez adres.<br>
<br><A NAME="EDU.skorowidz.termin funkcja przekazywanie_argumentów_przez_warto¶æ 21_191"></A> 
<div class="def"> Mówimy, ¿e argument przekazywany jest <b>przez warto¶æ</b>, je¶li przy
wywo³aniu funkcji warto¶æ argumentu kopiowana jest do zmiennej-parametru wystêpuj±cej w definicji funkcji na li¶cie parametrów</div>

<br>
<p>Ma to powa¿ne konsekwencje. Otó¿ parametry funkcji s± zmiennymi lokalnymi.
Zatem - przy przekazywaniu argumentów przez warto¶æ - w funkcji mamy dostêp
do warto¶ci przekazanego argumentu (poprzez zmienn±-parametr), ale zmiany
tej warto¶ci bêd± dotyczyæ tylko zmiennej-parametru, a nie zmiennej - przekazanego
argumentu.<br>
<br>
Zobaczmy:<br>

<pre>
a = 3;
tryChange(a);
say a;
exit;

function tryChange(a)
   a = a + 1;
   return;
</pre>

<p>Funkcja otrzymuje - jako parametr <i><b>a</b></i> - warto¶æ zmiennej <i><b>a</b></i> zdefiniowanej w pierwszym wierszu.<br>
Ale mamy tu przekazanie przez warto¶æ, zatem warto¶æ zmiennej <b><i>a</i></b> (3) jest kopiowana do zmiennej lokalnej - parametru <i><b>a</b></i> (przypadkowo nazywa siê tak samo, ale jak ju¿ wiemy jest ca³kiem inn± zmienn±). Zatem wszystko co robimy w funkcji ze zmienn± <i><b>a</b></i> ma lokalny charakter i nie dotyczy zmiennej <i><b>a</b></i> z programu g³ównego.<br>
<br>

<center>
<div class="important"> Modyfikacje argumentów przekazanych przez warto¶æ s± nieskuteczne</div><br>
</center>

<br>

<div class="notel">
Ze wzglêdu na implementacjê tablic w C, C++ i Javie elementy przekazanych
funkcji tablic mog± byæ modyfikowane (ale nie oznacza to, ¿e argumenty s±
przekazywane przez adres). W naszym uproszczonym REXXie nie mo¿emy przekazywac
tablic jako argumentów, zamiast tego - dla udostêpniania tablic funkcjom
-  bêdziemy stosowaæ klauzulê expose
</div>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin funkcja przekazywanie_argumentów_przez_adres 21_192"></A> W niektórych jêzykach programowania
mo¿liwe jest przekazywania argumentów przez adres (wtedy funkcja otrzymuje
nie warto¶æ, ale adres argumentu). Maj±c adres mo¿emy oczywi¶cie nie tylko
pobraæ dane spod tego adresu, ale i zapisaæ tam jak±¶ now± warto¶æ. Ten sposób
przekazywania argumentów nie jest jednak mo¿liwy w Javie ani te¿ w naszym
uproszczonym REXXie, zatem pozostawimy go na boku.
</div>

<br clear="all">
<br>

<p>Po tej dawce do¶æ skomplikowanych rozwa¿añ warto spojrzeæ na omawiane zagadnienie bardziej ogólnie.  <br>
£atwo mo¿emy sobie wyobraziæ, ¿e wprowadzenie funkcji do programu oszczêdza
nam pisaniny. Oto jaki¶ wielokrotnie powtarzany kod wyodrêbniamy w funkcjê
i zapisujemy tylko raz, a wszêdzie tam, gdzie poprzednio ten kod wystêpowa³
umieszczamy wywo³anie tej funkcji.<br>
Daje to nie tylko wiêksz± efektywno¶æ programowania, ale i zwiêksza jego
elastyczno¶æ. Przy modyfikacjach kodu odpowiedzialnego za jakie¶ zadanie
trzeba zrobiæ to tylko raz - w funkcji, która go zawiera. <br>
Ale nie tylko to sprawia, ¿e stosowanie funkcji w programowaniu jest korzystne.<br>
Przecie¿ istot± tworzenia i u¿ycia funkcji jest wyodrêbnienie w ramach du¿ego
problemu, który jest rozwi±zywany przez nasz program - mniejszych podproblemów
i zajêcie siê ka¿dym z nich niejako osobno, skupiaj±c siê wy³±cznie na konkretnej
specyfice danego zadania.<br>
 <br>
Wróæmy do problemu wyliczenia ceny procesora wg podanych przez u¿ytkownika informacji.<br>
Jak pamiêtamy, zarysowuj±c w pierwszym wykladzie ró¿ne mo¿liwe algorytmy
rozwi±zania tego problemu, zwracali¶my uwagê na potrzebê sprawdzania poprawno¶ci
danych (czy wprowadzona cena jest liczb±). Uwzglêdnimy teraz ten warunek.
W programie bêdziemy równie¿ chcieli daæ u¿ytkownikowi mo¿liwo¶æ policzenia
udzia³u w sumarycznej cenie ceny wybranego komponentu oraz zmiany ceny wybranego
komponentu.<br>
Nasz problem rozbijemy na nastêpuj±ce podproblemy:<br>
<ul>
  <li>wprowadzenie ceny i-tego komponentu komputera wraz ze sprawdzeniem jej poprawno¶ci</li>
  <li>wyliczenie sumarycznej ceny komputera</li>
  <li>wybór numeru komponentu z listy</li>
  <li>policzenie udzia³u ceny komponentu</li>
  <li>zmiany ceny komponentu.<br>
  </li>
</ul>

<p>Trzy pierwsze zadania zrealizujemy jako funkcje (wprowadzenie ceny komponentu
- inputData(..), obliczenie ceny komputera - sumPrices(), wybór numeru komponentu
z listy - choose()). Pozosta³e dwa, wraz z organizacj± danych i kolejno¶ci
wywo³añ funkcji bêd± stanowiæ tre¶æ programu g³ównego.<br>
<br>
Program g³ówny bêdzie mia³ nastêpuj±c± postaæ:<br>
<br>

<pre>
/* Tablica nazw sk³adników */

elt[0] = 6;  /* liczba skladnikow - w elemencie z indeksem 0 */
elt[] = { "Procesor", "P³yta", "Pamiêæ", "Dysk", "Monitor", "Inne" };

cena[0] = elt[0]  /* tyle samo cen ile skladnikow */

do i = 1 to cena[0]             /* pobieranie cen i umieszczanie w tablicy cena */
   cena[i] = <b>inputData</b>(elt[i]);
end

more = 1;                             /* czy powtarzaæ obliczenia i zmiany ? */
do while (more = 1)
   cenaOg = <b>sumPrices</b>();              /* obliczenie ceny komputera */
   say "Cena komputera wynosi :" cenaOg;

   nrSkl = <b>choose</b>("Wybierz sk³adnik, którego udzia³ w cenie chcesz policzyæ");
   if (nrSkl \= '') then do      /* je¿eli wybrano sk³adnik  - licz udzia³ */
     udzial = cena[nrSkl]/cenaOg;
     say "Udzial ceny skladnika" elt[nrSkl] "wynosi: " udzial;
   end

   nrSkl = choose("Wybierz skladnik, ktorego cene chcesz zmienic");
   if (nrSkl = "") then more = 0; /* je¿eli zrezygnowano z wyboru - koniec dzia³ania*/
   else cena[nrSkl] = <b>inputData</b>( elt[nrSkl] );

end
exit;

</pre>

<p>A funkcje:<br>

<pre>
function inputData(nazwaSkl)
   say "Wprowadz cene dla: " nazwaSkl;
   trzebaPobracDane = 1;
   do while (trzebaPobracDane)
      cena = linein()
      if datatype(cena) = "NUM" then trzebaPobracDane = 0;
   end
   return cena;

function sumPrices() expose cena[]
  sum = 0;
  do i = 1 to cena[0]      /* umowa: cena[0] zawiera liczbê elementów tablicy cena */
    sum = sum + cena[i];
  end
  return sum;

function choose(msg) expose elt[]
  say msg;
  do i = 1 to elt[0]         /* umowa: elt[0] zawiera liczbê elementów tablicy elt */
    say i '-' elt[i];
  end
  do forever
    say "Podaj wybrany numer lub samo ENTER by zrezygnowac:"
    nr = linein();
    if nr = "" then leave;
    if (nr &lt; 1 | nr &gt; elt[0]) then say "Z³y wybór.";
    else leave;
  end
  return nr;

</pre>

<p>Uwagi: <br>
<ol>
  <li>w funkcji inputData sprawdzamy czy wprowadzona cena jest liczb±, je¶li
nie - ponawiamy wprowadzania danych. Wykorzystujemy przy tym wbudowan± funkcjê
datatype(), która ma ró¿ne formy, a w zastosowanej tutaj (datatype(arg))
zwraca napis "NUM", je¶li argument jest liczb±,</li>
  <li>w funkcji choose zwracamy pusty ³añcuch znakowy ("") gdy u¿ytkownik zrezygnowa³ z wyboru wciskaj±c tylko ENTER.</li></ol>

<p><font color="#ff6600"><b> Proszê zapisaæ i uruchomiæ omawiany wy¿ej program na w³asnym komputerze. </b></font></p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index20.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
