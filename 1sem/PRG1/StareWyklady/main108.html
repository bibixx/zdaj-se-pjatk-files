<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index107.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index109.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 3"></A><div class="tytulpunktu">3. Kilka s³ów o rekurencji</div>

<a name="W14.3"></a>

<p><A NAME="EDU.skorowidz.termin rekurencja 108_749"></A> 
Z cia³a (kodu) metody  mo¿emy wywo³aæ j± sam±. Takie wywo³anie nazywa siê wywo³aniem rekurencyjnym.<br>
<br>

<div class="def">Rekurencyjne wywo³anie metody polega na wywo³aniu tej metody z jej w³asnego cia³a</div>

<br>
<p>
Pojêcie rekurencji bêdzie bardziej obszernie, szczegó³owo i w ciekawszych zastosowaniach omawiane w trakcie zajêæ z przedmiotu
"Algorytmy i struktury danych". Tutaj ograniczymy siê tylko kilkoma uwagami,
tak by mo¿na by³o czasem, na intuicyjnym poziomie, zastosowac odwo³ania rekurencyjne.<br>
<br>
Rozpatrzmy najprostsze przyk³ady.<br>
<br>

<pre>
public class Recurs {

  public static void show1(int i) {
    System.out.println("show1 " + i);
    if (i &gt; 10) return;
    show1(i+1);
  }

  public static void main(String[] args) {
    show1(1);
 }

}
</pre>

<br>

<div class="listing33r">show1 1<br>
show1 2<br>
show1 3<br>
show1 4<br>
show1 5<br>
show1 6<br>
show1 7<br>
show1 8<br>
show1 9<br>
show1 10<br>
show1 11</div>

<div class="ddd"><br>
Tutaj sprawa jest do¶æ prosta i do przewidzenia. Wywo³anie show1(1)
z metody main uruchamia ³añcuch wywo³añ rekurencyjnych. Ka¿de wywo³anie wyprowadza
przekazany argument, po czym sprawdzany jest warunek (i&gt;10), i dopóki 
jest on nieprawdziwy ponownie wywo³ywana jest metoda show1 z powiêkszon±
o 1 warto¶ci± argumentu. Np. po wypisaniu 1 (pierwsze wywo³anie) wywo³ywana
jest metoda show1 z argumentem 2 = 1+1, ten argument jest wypisywany, wywo³ywana
jest metoda show1 z argumenten 3 (= 2+1),  ten jest wypisywany itd. a¿ w
"wewnêtrznym wywo³aniu" show1 argument nie osi±gnie warto¶ci 11. Wtedy -
po jej wypisaniu - warunek oka¿e siê prawdziwy i dopiero teraz sterowanie
zwrócone zostanie do metody main.
</div>
<br clear="all">

<br><A NAME="EDU.skorowidz.termin rekurencja wywo³ania 108_750"></A> 
<div class="important">Przy wywo³aniach rekurencyjnych nale¿y zapewniæ warunek, którego spe³nienie
zakoñczy<A NAME="EDU.skorowidz.termin rekurencja ³añcuch 108_751"></A> ³añcuch rekurencji i spowoduje zwrócenie sterowania do miejsca,
w którym po raz pierwszy wywo³ano metodê rekurencyjn±</div>

<br>
<p>
Zobaczmy drugi fragment kodu. Tym razem wywo³amy z metody main - za pomoc± odwo³ania show2(1) - nastêpuj±c± metodê.<br>
<br>

<pre>
  public static void show2(int i) {
    if (i &gt; 10) return;
    show2(i+1);
    System.out.println("show2 " + i);
  }

</pre>

<div class="listing33r">
show2 10<br>
show2 9<br>
show2 8<br>
show2 7<br>
show2 6<br>
show2 5<br>
show2 4<br>
show2 3<br>
show2 2<br>
show2 1<br>
</div>

<div class="ddd"><br>Wynik dzia³ania tej metody mo¿e wydaæ siê nieco zaskakuj±cy.
</div>
<br clear="all">

<p>
Co siê dzieje? Wywo³anie show2(1) przekazuje jako argument 1, i z wnêtrza
show2 nastêpuje wywo³anie show2 z argumentem 2 (1+1). W tym momecie wykonanie
dalszego kodu metody zostaje wstrzymane. Wykonanie zaczyna siê od pocz±tku!
Zaczyna dzia³aæ jakby "nowy egzemplatrza" metody show2. Tym razem z nowym
argumentem (2). I tak dalej. Gdy parametr <i><b>i</b></i> osi±gnie warto¶æ
11 powinna zadzia³aæ instrukcja return. Ale najpierw musz± byæ "dokoñczone"
wszystkie poprzednie, "wstrzymane",  wykonania metody show2. Ostatnie by³o
z argumentem 10. Zatem wyprowadzona zostanie liczba 10 i wykonanie "tego
egzemplarza" metody zostanie zakoñczone. Poprzedza³o go wywo³anie show2 z
argumentem 9 - zostanie wiêc dokoñczone itd., a¿ dojdziemy do pierwszego
wywo³ania show2 (z argumentem 1). Po zakoñczeniu wykonania metody z tym argumentem
zostanie wykonana instrukcja return i sterowanie wróci do main.<br>
<br>
Zauwa¿my, ¿e w pierwszym przypadku mieli¶my tak naprawdê do czynienia z takim
samym wstrzymywaniem wykonania kodu metody show1 inicjowanego przez kolejne
wywo³ania rekurencyjne, tyle, ¿e nie mogli¶my tego dostrzec, poniewa¿ wstrzymywanie
nastêpowa³o na ostatniej instrukcji metody, ju¿ po wyprowadzeniu liczby.<br>
<br>
Oczywi¶cie metody rekurencyjne mog± zwracaæ warto¶ci.<br>
Zobaczmy, jak np. mo¿na rekurencyjnie zapisaæ zadanie sumowania dodatnich liczb ca³kowitych.<br>
W istocie rekurencja oznacza "zdefiniowanie czego¶ przez to samo co¶".<br>
We¼my sumê 1 + 2 + 3 + 4 + 5.<br>
Mo¿emy powiedzieæ tak: <br>
suma(1..5) = 5 + suma(1..4) <br>
suma(1..4) = 4 + suma(1..3)<br>
<br>
Definiujemy sumê przez sumê!<br>
<br>
Ogólnie, suma liczb od 1 do n  równa jest n + suma(1..n-1)<br>
Zatem je¶li nasza metoda sumowania otrzymuje argument n (oznaczaj±cy, ¿e
mamy zsumowaæ liczby od 1 do n), to mogliby¶my spróbowaæ zapisaæ:<br>
<br>
int sum(int n) {<br>
 return n + sum(n-1);<br>
}<br>
<br><A NAME="EDU.skorowidz.termin rekurencja nieskoñczona 108_752"></A> £atwo jednak zauwa¿yæ, ¿e wpadamy tu w "nieskoñczon±" rekurencjê. Metoda <i><b>sum</b></i>
  bêdzie wywo³ywana teoretycznie bez koñca ze swojego wnêtrza (praktycznym
ograniczeniem bêdzie pamiêæ komputera - program skoñczy dzia³anie z komunkatem
"Stack overflow").<br>
<br>
Musimy zatem zapewniæ jaki¶<A NAME="EDU.skorowidz.termin warunek_zakoñczenia_wywo³añ_rekurencyjnych 108_753"></A> warunek zakoñczenia wywo³añ rekurencyjnych,<br>
Uwzglêdniæ jaki¶ szczególny przypadek warto¶ci przekazanego argumentu, który przerwie nieskoñczone rekurencyjne wywo³ania.<br>
W przypadku sumowania liczb od 1 do n, takim szczególnym przypadkiem jest warto¶æ n = 1 (zwracamy wtedy 1).<br>
<br>

<pre>
public class Recurs {

  public static int sum(int n) {
    if (n == 1) return 1;
    else return n + sum(n-1);
  }

  public static void main(String[] args) {
    System.out.println(sum(100));
  }

}
</pre>

<p>
Wyprowadzi: 5050 (Gauss policzy³ to szybciej!) <br>
<br>
<b><font color="#ff6600">Proszê dok³adnie przeanalizowaæ dzia³anie tej metody dla n = 5</font></b>
, pamiêtaj±c, ¿e kolejne zwroty wyników rekurencyjnego wywo³ania sum(...)
s± wstrzymywane dopóki n nie osi±gnie warto¶ci 1 i zauwa¿aj±c, ¿e odtwarzanie
tych wyników nastêpuje w else, po kolei: 1, 2 + 1, 3 + (2 + 1), 4 + (3 +
2 + 1), 5 + (4 + 3 + 2 +1) i ta ostatnia warto¶æ jest w³a¶nie zwracana do
punktu wywo³ania sum(..) w metodzie main.<br>
<br>
Mo¿na siê domy¶liæ (choæby z przyk³adu sumowania), ¿e rekurencyjne wywo³ania funkcji mo¿na zast±piæ pêtlami iteracyjnymi.<br><br><A NAME="EDU.skorowidz.termin rekurencja istota 108_754"></A> 
<div class="notec">Bardzo czêsto rekurencja bêdzie jednak prostsza do oprogramowania, bowiem
odzwierciedla ona bezpo¶rednio pewien sposób rozumowania: nie wiemy jak rozwi±zaæ
ca³y problem, na którego rozwi±zanie  sk³ada siê powiedzmy n kroków, ale
wiemy jak wykonaæ jeden krok, gdy ju¿ n-1 poprzednich zosta³o wykonane. I
to w³a¶nie mo¿emy (do¶æ prosto) zapisaæ w postaci rekurencyjnej.</div>

<br>
<p><A NAME="EDU.skorowidz.termin rekurencja efektywno¶æ 108_755"></A> Trzeba jednak  te¿ wiedzieæ o tym, ¿e nie zawsze podej¶cie rekurencyjne prowadzi
do efektywnych algorytmów; czasami iteracyjne wersje rozwi±zania jakich¶
problemów s± wielokrotnie szybsze od rekurencyjnych, a nawet - przy ograniczeniach
na pamiêæ operacyjn± i moc procesora - jedynie mo¿liwe. Sztandarowym przyk³adem
jest tu rekursywne oprogramowanie wyliczenia liczb ci±gu Fibonacciego.<br><br><A NAME="EDU.skorowidz.termin ci±g_Fibonacciego 108_756"></A> Ci±g Fibonacciego dany jest za pomoc± nastêpuj±cego równania, okreslaj±cego warto¶ci F<sub>n</sub> kolejnych liczb ciagu (dla n = 0, 1, 2, ...):<br>
<br>F<sub>0</sub>   =  0,<br>
F<sub>1</sub>   =  1,<br>
F<sub>n</sub>  =   F<sub>n-2</sub>  + F<sub>n-1</sub>, dla n &gt; 1.<br>
<br>
Czyli jest to ci±g liczb zaczynaj±cy siê od liczb 0 i 1, przy czym ka¿da
nastêpna liczba ci±gu (poczynaj±c od trzeciej) jest sum± dwóch poprzednich
liczb ci±gu:

<pre>
0  1  1  2  3  5  8 13 21 34 55 89 144 233 377 610 987 ...
</pre>

<p>Liczby Fibonacciego maj± niezwykle ciekawe w³a¶ciwo¶ci. Nader czêsto ci±gi
takich liczb obserwowane s± w zjawiskach naturalnych, maj± te¿ intryguj±ce
w³a¶ciwo¶ci matematyczne. Wiêcej na ten temat zobacz na <a href="http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fib.html">stronie Rona Knotta z Uniwersytetu w Surrey</a>. <br>
<br>
Jak widaæ. ci±g Fibonanciego jest ciagiem rekurencyjnym, zatem wyliczenie
jego kolejnych wyrazów w naturalny sposob mo¿na zapisaæ w postaci rekurencyjnej.<br>
<br>

<pre>
  int fib(int n) {
    if (n &lt; 2) return n;
    else return fib(n-1) + fib(n-2);
  }
</pre>

<p>
Jednak wraz ze zwiêkszaniem warto¶ci <i><b>n</b></i> czas obliczeñ za pomoc± tej metody ro¶nie katastrofalnie.<br>
Dzieje siê tak dlatego, ¿e katastrofalnie ro¶nie liczba rekurencyjnych wywo³añ metody fib.<br>
Wiêksz± czê¶æ czasu zajmuje obliczanie ju¿ policzonych warto¶ci!<br>
Zobaczmy.<br>
U¿ywaj±c zmodyfikowanej postaci metody fib:<br>

<pre>
  int fib(int n) {
    System.out.println("Wywo³anie fib z argumentem " + n);
    int wynik = 0;
    if (n &lt; 2) wynik = n;
    else wynik = fib(n-1) + fib(n-2);
    System.out.println("Zwrot wyniku: " + wynik);
    return wynik;
  }
</pre>

<p>
i analizuj±c wydruk po wywo³aniu tej metody z jakim¶ argumentem (np. 8) -
zobaczymy, ¿e wielokrotnie powtarzaj± siê rekurencyjne wywo³ania metody fib
z tymi samymi argumentami i wielokrotnie powtarzaj± siê zwroty tych samych wyników.<br>
<font color="#ff0000"><b><br>
Proszê samodzielnie zbudowaæ pe³ny program, który pozwala na tak± analizê
(wykorzystaæ podan± wy¿ej metodê oraz  przekierowanie standardowego wyj¶cia
do pliku).</b><br>
</font><br>
Mo¿emy te¿ automatycznie policzyæ liczbê wywo³añ z ró¿nymi argumentami za pomoc± np. takiego programu:<br>

<pre>
public class ShowFibRec {

  int[] calls;

  ShowFibRec(int n) {
    calls = new int[n+1];
    fib(n);
    for(int i=0; i &lt;= n; i++)
      System.out.println("Liczba wywo³añ fib z argumentem " + i
                          + " " + calls[i]);
  }

  int fib(int n) {
    calls[n]++;
    if (n &lt; 2) return n;
    else return fib(n-1) + fib(n-2);
  }

  public static void main(String[] args) {
    int n = Integer.parseInt(args[0]);
    new ShowFibRec(n);
  }

}
</pre>

<p>
Po kompilacji, mo¿emy porównaæ liczbê "powtórnych" wywo³añ dla ró¿nych n podawanych jako argument wywo³ania, np. 8 i 20.<br>
Uzyskamy nastêpuj±ce wyniki:<br><br>

<table cellpadding="6" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">Dla n = 8<br>
      </td>
      <td valign="Top">Dla n = 20<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Liczba wywo³añ fib z argumentem 0 13<br>
Liczba wywo³añ fib z argumentem 1 21<br>
Liczba wywo³añ fib z argumentem 2 13<br>
Liczba wywo³añ fib z argumentem 3 8<br>
Liczba wywo³añ fib z argumentem 4 5<br>
Liczba wywo³añ fib z argumentem 5 3<br>
Liczba wywo³añ fib z argumentem 6 2<br>
Liczba wywo³añ fib z argumentem 7 1<br>
Liczba wywo³añ fib z argumentem 8 1<br>
      <br>
      </td>
      <td valign="Top">Liczba wywo³añ fib z argumentem 0 4181<br>
Liczba wywo³añ fib z argumentem 1 6765<br>
Liczba wywo³añ fib z argumentem 2 4181<br>
Liczba wywo³añ fib z argumentem 3 2584<br>
Liczba wywo³añ fib z argumentem 4 1597<br>
Liczba wywo³añ fib z argumentem 5 987<br>
Liczba wywo³añ fib z argumentem 6 610<br>
Liczba wywo³añ fib z argumentem 7 377<br>
Liczba wywo³añ fib z argumentem 8 233<br>
Liczba wywo³añ fib z argumentem 9 144<br>
Liczba wywo³añ fib z argumentem 10 89<br>
Liczba wywo³añ fib z argumentem 11 55<br>
Liczba wywo³añ fib z argumentem 12 34<br>
Liczba wywo³añ fib z argumentem 13 21<br>
Liczba wywo³añ fib z argumentem 14 13<br>
Liczba wywo³añ fib z argumentem 15 8<br>
Liczba wywo³añ fib z argumentem 16 5<br>
Liczba wywo³añ fib z argumentem 17 3<br>
Liczba wywo³añ fib z argumentem 18 2<br>
Liczba wywo³añ fib z argumentem 19 1<br>
Liczba wywo³añ fib z argumentem 20 1<br>
      </td>
    </tr>
  </tbody>
</table>

<br><p>
Ze wzglêdu na konstrukcjê metody rekurencyjnej, liczba wielokrotnych wywo³añ metody z tym samym argumentem <i><b>i</b></i> , dla i =1,2...n, jest liczb± Fibonacciego: <b>F(n-i+1)</b> ! Zatem przy du¿ych n bardzo du¿o czasu tracone jest na powtarzanie tych samych wywo³añ i zwracanie tych samych wyników.<br>
<br>
<b><font color="#ff0000">Zadanie do samodzielnego wykonania</font></b><br><br>

Napisaæ iteracyjn± wersjê metody obliczaj±cej wyrazy ci±gu Fibonacciego.
Za pomoc± znanej nam ju¿ klasy QTimer porównaæ czas obliczeñ wersji rekursywnej
i iteracyjnej.<br>
Po napisaniu programu porównaæ go z programem FibonTest.java znajduj±cym siê w katalogu samples\Fibonacci14.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index107.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index109.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
