<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index28.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><div class="tytulpunktu">4. Instalacja Javy,  pierwszy program i kilka elementów sk³adni</div>

<a name="W4.16"></a>

<p>Instrukcje instalacyjne Javy dla ró¿nych systemów mo¿na znale¼æ tu:<br><br>

<a href="javascript:popUp('dodatki/W3LinInst.htm',30,30)">dla Linuxa</a><br>
<a href="javascript:popUp('dodatki/W3WinInst.htm',40,40)">dla Windows</a> <br>
<a href="javascript:popUp('dodatki/W3OS2Inst.htm',50,30)">dlaOS/2</a><br>
<br>
Pisz±c programy mo¿emy korzystaæ ze<A NAME="EDU.skorowidz.termin zintegrowane_¶rodowisko_programowania 29_282"></A> zintegrowanych ¶rodowisk programowania<A NAME="EDU.skorowidz.termin IDE 29_283"></A> (IDE) zob.<a href="http://www.javaworld.com/javaworld/tools/jw-tools-index.html"> listê miesiêcznika JavaWorld</a>
, a tak¿e <a href="javascript:popUp('dodatki/W3IDE.htm',50,50)">IDE polecane na I semestr dla Windows</a>  lub
po prostu u¿ywaæ wybranego edytora i w sesjach znakowych (terminalach, oknach
DOS) uruchamiaæ kompilator i maszynê wirtualn± Javy.<br>
<br>

<div class="notec">Je¶li nie korzystamy z IDE to:<br>
<ul>
  <li>powinni¶my zapewniæ, by katalog, w którym program instalacyjny umie¶ci³ 
kompilator Javy (javac.exe) oraz interpreter - maszynê wirtualn± Javy (java.exe)
znajdowa³ siê na ¶cie¿ce dostêpu (PATH),</li>
  <li><A NAME="EDU.skorowidz.termin Java program_¼ród³owy 29_284"></A> program ¼ród³owy Javy zapisujemy w pliku ¼ród³owym za pomoc± dowolnego edytora (np. w pliku Test.java),</li>
  <li>plik ¼ród³owy np. Test.java<A NAME="EDU.skorowidz.termin Java kompilacja 29_285"></A> kompilujemy za pomoc± polecenia <b>javac (np. javac Test.java)</b></li>
  <li>w rezultacie kompilacji otrzymamy plik(i) klasowe (z rozszerzeniem .class) (np. Test.class)</li>
  <li><A NAME="EDU.skorowidz.termin Java wykonanie_programu 29_286"></A> wykonanie programu uruchamiamy za pomoc± polecenia <b>java (np. java Test)</b></li>
</ul>
</div>


<br>
<p>Uwagi:<br>
<ol>
  <li>Program ¼ród³owy mo¿e byæ zapisany w wielu plikach z rozszerzeniem
.java; w ka¿dym pliku musi wystêpowaæ pe³na definicja jednej lub kilku klas.</li>

  <li>Nazwa pliku powinna byæ dok³adnie (a wiêc uwzglêdniaj±c wielkie i ma³e
litery) taka sama jak nazwa publicznej  klasy zdefiniowanej w tym pliku (czyli klasy z kwalifikatorem <b>public</b>; co
to jest klasa publiczna - dowiemy siê pó¼niej). W  pliku ¼ród³owym mo¿e wyst±piæ tylko jedna klasa publiczna.</li>

  <li>Uruchamiaj±c maszynê wirtualn± (polecenie <b>java</b>) podajemy jako argument nazwê klasy, w której jest
zdefiniowana metoda main. Nie podajemy rozszerzenia pliku (".class") czyli:
java Test a nie java Test.class.</li>

</ol>

<p>Nasz pierwszy program mo¿e wygl±daæ tak:<br>
<br>

<pre>
<font color="#3333ff"><b>public class</b></font> Test <font color="#ff0000"><b>{</b></font><font color="#3333ff"><b>

   public static void</b></font> main( String[] args ) <b><font color="#33cc00">{
      </font></b>System.out.println( "Dzieñ dobry!")<b>;</b>
   <b><font color="#33cc00">}</font></b> 
<b><font color="#ff0000">
}</font></b>
</pre>

<p>Komentarze:<br>
<ol>

  <li>S³owa kluczowe jêzyka zaznaczono na niebiesko.<br>
</li><li>Na razie nie przejmujemy siê dziwnymi s³owami (public, void itp.). Dowiemy siê o nich z nastêpnych wyk³adów.<br>
  </li>
  <li>Program w Javie zawsze sk³ada siê  z definicji klas. Tu mamy zdefiniowan±
jedn± klasê o nazwie Test. Do definiowania klas s³u¿y s³owo kluczowe <b>class</b>. Sam± definicjê klasy podajemy w nastêpuj±cych potem nawiasach klamrowych. Nawiasy te zaznaczono na czerwono.</li>

  <li>W klasie Test zosta³a zdefiniowana metoda o nazwie  main (czyli co¶ bardzo podobnego do funkcji)</li>

<li>Cia³o metody zapisujemy w nawiasach klamrowych (zaznaczone na zielono).<br>
  </li>

  <li>Wykonanie programu zacznie siê w³a¶nie od metody main, ale musi ona
mieæ dok³adnie taki nag³ówek jak podano (public static void main(String[ ]
args)), z tym wyjatkiem, ¿e s³owo args mo¿emy zast±piæ innym (jest to nazwa
zmiennej).</li>

<li>Jak widaæ, metoda main ma parametr o nazwie args. Oznacza
on tablicê ³añcuchów znakowych (obiektów typu String) - która zawiera argumenty
przekazane przy uruchomieniu programu (np. podane w wierszu poleceñ sesji
znakowej). W naszym programie nie korzystamy z tych argumentów.<br>
  </li>

  <li>W metodzie main wywo³ujemy metodê <i><b>println</b></i> (ju¿ dla nas
przygotowan± i znajduj±c± siê w "bibliotece" standardowych klas jêzyka),
która wyprowadza przekazany jej argument na konsolê. Wywo³anie metody stanowi
wyra¿enie. Koñcz±c je ¶rednikiem przekszta³cili¶my je w <b>instrukcjê</b> programu
"do wykonania".</li>
  <li>Na razie nie przejmujemy siê tym po co i dlaczego trzeba pisaæ System.out.println. Dowiemy siê tego pó¼niej.</li>
  <li>Argument podany w wywo³aniu metody println - to litera³ ³añcuchowy
(napis podany literalnie). Pojêcie litera³u ³ancuchowego znamy ju¿ z poprzedniego wyk³adu.</li>
  <li>Zapisany program musimy skompilowaæ: javac Test.java (lub ¶rodkami IDE)</li>
  <li>W rezultacie otrzymamy plik Test.class</li>
  <li>Uruchamiamy program ( w IDE lub  pisz±c: java Test). Program wyprowadzi na konsolê napis "Dzieñ dobry!" <br>
  </li>
</ol>
<br>

<div class="notel">Trzeba jednak pamiêtaæ, ¿e obowi±zuje nas przejrzysty <b>styl programowania</b>. Elementy stylu bêdziemy poznawaæ sukcesywnie przy omawianiu jêzyka. W omawianym
przyk³adzie zastosowali¶my wciêcia i odpowiednie rozmieszczenie nawiasów
klamrowych
</div>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin Java styl_programowania 29_287"></A> Przy kompilacji programu znaki spacji, tabulacji, koñca wiersza
(tzw. whitespaces) wystêpuj±ce <b>pomiêdzy</b> konstrukcjami sk³adniowymi
jêzyka (takimi jak nazwy zmiennych, metod, s³owa kluczowe, litera³y itp.)
s± pomijane. Zatem mo¿emy dowolnie "formatowaæ" kod programu (dzieliæ na
wiersze, umieszczaæ dodatkowe spacje np. po nawiasie otwieraj±cym listê argumentów
wywo³ania metody).
</div>

<br clear="all">

<p>Przy kompilacji pomijane s± równie¿ komentarze.<br><A NAME="EDU.skorowidz.termin Java komentarz 29_288"></A> W Javie mamy trzy rodzaje komentarzy:<br>
<ul>
  <li>teksty umieszczone w jednym wierszu programu po znakach <b>//</b> (komentarze jednowierszowe; ca³y tekst po znakach // do koñca wiersza traktowany jest jako komentarz),</li>
  <li>teksty umieszczone pomiêdzy znakami /* i */ (teksty te mog± obejmowaæ kilka wierszy),</li>
  <li>teksty umieszczone pomiêdzy znakami /** i */ (komentarze dokumentacyjne,
które sa przetwarzane przez oprogramowanie tworz±ce dokumentacjê, np. javadoc;
mog± obejmowaæ kilka wierszy).</li>
</ul>

<p>Przyk³ad:<br>
<br>

<pre>
/**
 Klasa TestComm pokazuje
 u¿ycie komentarzy
 (to jest komentarz dokumentacyjny)
*/

public class TestComm {

  /*
     to jest komentarz
     wielowierszowy
  */

  /* to te¿ jest
     komentarz */

  // a to komentarz jednowierszowy

   public static void main( String[] args ) {
      // i tu te¿ komentarz
      System.out.println( "Zob. komentarze" );   // i tu te¿
   }

}
</pre>

<p>Oczywi¶cie, komentarze nie mog± rozdzielaæ jednolitych konstrukcji sk³adniowych
(np. znajdowaæ siê "w ¶rodku" nazwy zmiennej czy metody).<br>
<br><A NAME="EDU.skorowidz.termin Java b³êdy_w_kompilacji 29_289"></A> W trakcie kompilacji programu sprawdzana jest jego sk³adniowa poprawno¶æ.
Kompilacja mo¿e wiêc zakoñczyæ siê niepowodzeniem (wtedy nie dostaniemy pliku
.class), a kompilator powiadomi nas o tym gdzie i jakie b³êdy wyst±pi³y.<br>
Np. gdyby¶my w naszym programie testowym zapomnieli zamkn±æ nawias okr±g³y w wywo³aniu metody println: <br>

<pre>
System.out.println( "Dzieñ dobry!"<b>;</b>
</pre>

<p>to kompilator wyprowadzi³by nastêpuj±cy komunikat:<br><br>

<div class="listing100">
Test.java:4: ')' expected<br>
      System.out.println( "Dzieñ dobry!";<br>                                        ^<br>
1 error
</div>

<br>
<p>Mamy tu wyra¼nie powiedziane, ¿e b³±d wyst±pi³ w 4 wierszu pliku Test.java,
¿e oczekiwany by³ okr±g³y nawias zamykaj±cy (a zabrak³o go), przy czym miejsce
w którym wyst±pi³ problem wskazane jest znakiem ^.<br>
<br>
Nie zawsze komunikaty z kompilacji bêd± tak klarowne. Czasami b³±d  nie bêdzie
dok³adnie zlokalizowany (informacja bêdzie wskazywaæ na inny wiersz ni¿ ten,
w którym wyst±pi³ b³±d). Musimy wtedy g³êbiej zastanowiæ siê nad przyczyn±
b³êdu i przeanalizowaæ poprawno¶æ poprzedzaj±cych wierszy programu.<br>
<br>
Program, który przeszed³ etap kompilacji jest poprawny sk³adniowo, ale jego
wykonanie niekoniecznie musi byæ poprawne. Mog± w nim bowiem wyst±piæ tzw.<A NAME="EDU.skorowidz.termin Java b³êdy_fazy_wykonania 29_290"></A> b³êdy fazy wykonania.<br>
Na przyk³ad, poni¿szy program kompiluje siê bezb³êdnie,<br>
<br>

<pre>
public class TestRTE {

   static String napis;

   public static void main( String[] args ) {
      System.out.println( napis.length()  );
   }
</pre>

<p>
ale przy jego wykonaniu wyst±pi b³±d:<br>
<br>

<div class="listing100">Exception in thread "main" java.lang.NullPointerException<br>
        at TestRTE.main(TestRTE.java:7)</div>

<br>
<p>bowiem próbujemy pobraæ d³ugo¶æ ³añcucha znakowego (napis), który
nie istnieje. Zreszt± przyczyna nie jest tu istotna, teraz wa¿ne jest tylko
by¶my wiedzieli, ¿e  b³±d wykonania mo¿e wyst±piæ mimo pomy¶lnej kompilacji).<br>
Zwrócmy uwagê, ¿e Java nazywa takie b³êdy<A NAME="EDU.skorowidz.termin wyj±tek 29_291"></A> <b>wyj±tkami</b> (<i><b>exception</b></i>) i ¿e JVM podaje jaki rodzaj wyj±tku wyst±pi³, w jakiej klasie i w jakiej metodzie i który wiersz w programie go spowodowa³.<br>
<br>
W koñcu warto jeszcze raz podkre¶liæ oczywist± prawdê, ¿e nawet je¶li program
nie ma b³êdów sk³adniowych (kompilacja pomy¶lna) i nie wystêpuj± b³êdy fazy
wykonania - to jeszcze nie znaczy, ¿e jest on poprawny.<br>
Na przyk³ad taki program przejdzie pomy¶lnie kompilacjê i wykona siê bez b³êdów (zg³aszanych przez JVM):<br>

<pre>
public class TestBad {

   public static void main( String[] args ) {
      System.out.println("2 + 2 = " + (2 - 2) );
   }

}
</pre>

<br>

<div class="listing25r">2 + 2 = 0</div>

<div class="ddd"><br>
ale wyprowadzi (raczej) niepoprawny wynik, bo wygl±da na to,
¿e programista pomyli³ siê i zamiast operatora + u¿y³ operatora -.</div>
<br clear="all">
<p>
Takie b³êdy s± najtrudniejsze do wykrycia, a ich unikanie (czy walka z nimi) wymaga:<br>
<ul>
  <li>tworzenia poprawnych algorytmów,</li>
  <li>starannego ich zapisu w jêzyku programowania,</li>
  <li>pieczo³owitego testowania gotowego programu, przy ró¿nych danych wej¶ciowych
i oceny czy wyniki podawane przez program s± poprawne.<br>
  </li>
</ul><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index28.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
