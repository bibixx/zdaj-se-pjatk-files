<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index36.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index38.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><div class="tytulpunktu">4. Trochê wiêcej o operatorach i wyra¿eniach</div>

<a name="W5.4"></a>

<p>Ze zmiennych, sta³ych, litera³ów oraz wywo³añ metod (funkcji), pos³uguj±c
siê operatorami jêzyka i nawiasami mo¿emy konstruowaæ<A NAME="EDU.skorowidz.termin wyra¿enie 37_351"></A> wyra¿enia. <br>
<br>


Je¶li a i b s± nazwami zmiennych typu numerycznego, to wyra¿eniami bêd± np.:<br>


a<br>


1<br>


b + 1<br>


a  * (b + 10)<br>


'a'<br>


"ala ma kota"<br>
<br><A NAME="EDU.skorowidz.termin wyra¿enie opracowywanie 37_352"></A> Wyra¿enia s± <b>opracowywane </b>(wyliczane), a ich wyniki mog± byæ w ró¿ny
sposób wykorzystane (np. w przypisaniu,  jako argumenty innych operatorów,
w instrukcjach steruj±cych wykonaniem programu, w wywo³aniach metod).  <br>


Np. je¶li zmienna a ma warto¶æ 1, zmienna b - warto¶c 2, to:<br>
<br>

<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Top">Wyra¿enie<br></td><td valign="Top">Wynik<br></td></tr><tr><td valign="Top">a<br></td><td valign="Top">warto¶æ zmiennej a ( =1 )<br></td></tr><tr><td valign="Top">1<br></td><td valign="Top">warto¶æ litera³u 1 ( = 1)<br></td></tr><tr><td valign="Top">a * (b  + 10)<br></td><td valign="Top">12<br></td></tr><tr><td valign="Top">'a'<br></td><td valign="Top">znak a (dziesiêtnie liczba 91, która jest kodem znaku a)<br></td></tr></tbody>
</table>

<br>

<p>Kolejno¶æ wyliczeñ zale¿y od <b>priorytetów i wi±zañ</b><A NAME="EDU.skorowidz.termin operator 37_353"></A> operatorów u¿ytych w wyra¿eniach. <br>
<br><A NAME="EDU.skorowidz.termin operator priorytety 37_354"></A> <b>Priorytety</b> mówi± o tym, w jakiej kolejno¶ci bêd± wykonywane ró¿ne
operacje zawarte w tym samym wyra¿eniu (np. czy w wyra¿eniu a + b * c najpierw
bêdzie wykonywane mno¿enie czy dodawanie). <br>
<br><A NAME="EDU.skorowidz.termin operator wi±zania> 37_355"></A> <b>Wi±zania</b> okre¶laj± kolejno¶æ wykonywania operacji o tym samym priorytecie
- czy s± wykonywane od lewej strony wyra¿enia czy od prawej (np. czy wyra¿enie
a + b - c bêdzie traktowane jako (a+b)-c czy jako (b-c)+a  - co nie zawsze
- chocia¿ nie w tym przypadku - jest kwesti± obojêtn± !).<br>
<br><A NAME="EDU.skorowidz.termin operator argumenty 37_356"></A> Jak pamiêtamy, operatory maj± <b>argumenty</b>, inaczej te¿ zwane operandami.<br>


W Javie s± operatory jedno- i dwu- argumentowe oraz jeden operator trzyargumentowy.  <br>


Argumentami operatorów zawsze s± wyra¿enia. Np. w wyra¿eniu <br>


 a + (b - 1)<br>


argumentami dwuargumentowego operatora + s± wyra¿enia a i (b-1), <br>


natomiast w wyra¿eniu b-1 argumentami dwuargumentowego operatora - (minus) s± wyra¿enia b i 1.<br>
<br>


W Javie zdefiniowano nastêpuj±ce operatory.<br>
<p></p>

<table border="1" bordercolor="plum" width="100%" bgcolor="#ffffff">

<tr valign="Top">
<td><div align="Center"><strong>Priorytet,Wi±zanie</strong></div></td>
<td align="Center"><b>Operator</b></td>
<td><b>Nazwa </b></td>
</tr>

<tr valign="Top">
<td bgcolor="#ccffff" rowspan="7" colspan="1">1, prawe</td>
<td align="Center" bgcolor="#ccffff">!</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator negacja_logiczna 37_357"></A> Negacja logiczna</td>
</tr>

<tr valign="Top">
<td align="Center" bgcolor="#ccffff">~</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator bitowe_uzupe³nienie_do_1 37_358"></A> Bitowe uzupe³nienie do 1 </td>
</tr>

<tr valign="Top"><td align="Center" bgcolor="#ccffff">+</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator jednoargumentowy_+_(liczba dodatnia) 37_359"></A> Jednoargumentowy + (liczba dodatnia) </td>
</tr>

<tr valign="Top"><td align="Center" bgcolor="#ccffff">-</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator jednoargumentowy_-_(liczba ujemna) 37_360"></A> Jednoargumentowy - (liczba ujemna) </td>
</tr>

<tr valign="Top"><td align="Center" bgcol
or="#ccffff">++</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator zwiêkszania 37_361"></A> Operator zwiêkszania </td>
</tr>

<tr valign="Top">
<td align="Center" bgcolor="#ccffff">--</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator zmniejszania 37_362"></A> Operator zmniejszania </td>
</tr>

<tr valign="Top">
<td align="Center" bgcolor="#ccffff">(typ)</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator konwersji_(rzutowania) 37_363"></A> konwersja (rzutowanie) </td>
</tr>

<tr valign="Top">
<td rowspan="3" colspan="1">2, lewe</td>
<td align="Center">*</td><td><A NAME="EDU.skorowidz.termin operator mno¿enia 37_364"></A> mno¿enie </td>
</tr>

<tr valign="Top"><td align="Center">/</td>
<td><A NAME="EDU.skorowidz.termin operator dzielenia 37_365"></A> dzielenie </td>
</tr>

<tr valign="Top">
<td align="Center">%</td>
<td><A NAME="EDU.skorowidz.termin operator reszty_z_dzielenia 37_366"></A> reszta z dzielenia </td>
</tr>

<tr valign="Top">
<td rowspan="2" colspan="1">3, lewe</td>
<td align="Center">+</td>
<td><A NAME="EDU.skorowidz.termin operator dodawania 37_367"></A> Dodawanie </td>
</tr>

<tr valign="Top">
<td align="Center">-</td>
<td><A NAME="EDU.skorowidz.termin operator odejmowania 37_368"></A> Odejmowanie </td>
</tr>

<tr valign="Top">
<td rowspan="3" colspan="1">4, lewe</td>
<td align="Center">&lt;&lt;</td>
<td><A NAME="EDU.skorowidz.termin operator przesuniêcie_bitowe_w_lewo 37_369"></A> Przesuniêcie bitowe w lewo </td>
</tr>

<tr valign="Top">
<td align="Center">&gt;&gt;</td>
<td><A NAME="EDU.skorowidz.termin operator przesuniêcie_bitowe_w_prawo 37_370"></A> Przesunêcie bitowe w prawo </td>
</tr>

<tr valign="Top">
<td align="Center">&gt;&gt;&gt;</td>
<td><A NAME="EDU.skorowidz.termin operator przesuniêcie_bitowe_bez_znaku 37_371"></A> Przesunêcie bitowe w prawo bez znaku </td>
</tr>

<tr valign="Top">
<td rowspan="5" colspan="1">5, lewe</td>
<td align="Center">&lt;</td>
<td rowspan="4" colspan="1"><A NAME="EDU.skorowidz.termin operator relacyjny 37_372"></A> <br><br><p>operatory relacyjne</p></td>
</tr>

<tr valign="Top">
<td align="Center">&lt;=</td>
</tr>

<tr valign="Top">
<td align="Center">&gt;=</td>
</tr>

<tr valign="Top">
<td align="Center">&gt;</td>
</tr>

<tr valign="Top">
<td align="Center" bgcolor="#ccffff">instanceof</td>
<td bgcolor="#ccffff"><A NAME="EDU.skorowidz.termin operator stwierdzenia_typu 37_373"></A> stwierdzenie typu </td>
</tr>

<tr valign="Top">
<td rowspan="2" colspan="1">6, lewe</td>
<td align="Center">==</td>
<td rowspan="2" colspan="1"><A NAME="EDU.skorowidz.termin operator równo¶ci-nierówno¶ci 37_374"></A> Operatory równo¶ci - nierówno¶ci</td>
</tr>

<tr valign="Top">
<td align="Center">!=</td>
</tr>

<tr valign="Top">
<td>7.</td>
<td align="Center">&amp;</td>
<td><A NAME="EDU.skorowidz.termin operator bitowa_koniunkcja 37_375"></A> Bitowa koniunkcja  </td>
</tr>

<tr valign="Top">
<td>8.</td>
<td align="Center">^</td>
<td><A NAME="EDU.skorowidz.termin operator bitowe_wy³±czaj±ce_ALBO 37_376"></A> Bitowe wy³±czaj±ce ALBO </td>
</tr>

<tr valign="Top">
<td>9.</td>
<td align="Center">|</td>
<td><A NAME="EDU.skorowidz.termin operator bitowa_alternatywa 37_377"></A> Bitowa alternatywa </td>
</tr>

<tr valign="Top">
<td>10.</td>
<td align="Center">&amp;&amp;</td>
<td><A NAME="EDU.skorowidz.termin operator logiczna_koniunkcja 37_378"></A> Logiczna koniunkcja </td>
</tr>

<tr valign="Top">
<td>11.</td>
<td align="Center">||</td>
<td><A NAME="EDU.skorowidz.termin operator logiczna_alternatywa 37_379"></A> Logiczna alternatywa </td>
</tr>

<tr valign="Top">
<td bgcolor="#ffffcc">12, prawe</td>
<td align="Center" bgcolor="#ffffcc">?:</td>
<td bgcolor="#ffffcc"><A NAME="EDU.skorowidz.termin operator warunku_(trójargumentowy) 37_380"></A> Operator warunku (trójargumentowy) </td>
</tr>

<tr valign="Top">
<td rowspan="1" colspan="1">13, prawe</td>
<td align="Center" rowspan="1" colspan="1">=<br>
*=<br>
/=<br>
%=<br>
+=<br>
-=<br>
&amp;=<br>
^=<br>
|=<br>
&lt;&lt;=<br>
&gt;&gt;=</td>
<td rowspan="1" colspan="1"><A NAME="EDU.skorowidz.termin operator przypisania 37_381"></A> <p>Operatory przypisania</p></td>
</tr>

</table>




<p><i>Uwagi:  <br>
mniejsza liczba w kolumnie priorytetu oznacza wy¿szy priorytet<br>
niebieski kolor t³a - operatory jednoargumentowe, bia³y - dwu<br>
</i><br>
Nie bêdziemy teraz omawiaæ wszystkich tych operatorów, po czê¶ci uwagi na
temat niektórych z nich by³y ju¿ wypowiedziane, o innych bêdziemy siê dowiadywaæ
sukcesywnie. <br>
<br>
Kilka uwag na tle przedstawionej tablicy warto jednak sformu³owaæ.<br>
<br>
Zauwa¿my najpierw, ¿e<A NAME="EDU.skorowidz.termin operator przypisania 37_382"></A> <b>operatory przypisania</b> jako jedyne w¶ród operatorów dwuargumentowych maj± wi±zanie prawostronne. Oznacza to, ¿e wyra¿enie:<br>
<br>
x = a + b<br>
<br>
opracowywane jest od prawej do lewej. W takim wyra¿eniu nie ma to istotnego
znaczenia, ale je¶li uwzglêdnimy to, ¿e samo przypisanie jest wyra¿eniem
o warto¶ci równej jego lewej stronie (ktora zawsze musi byæ zmienn±) po wykonaniu przypisania, to np. w takiej sekwencji:<br>
<br>
int x, a = 3, b = 4;<br>
int c = 1;<br>
x = a = b = c + 7<br>
<br>
po pierwsze, priorytet operatora + jest wy¿szy od priorytetu operatora =, wobec tego<br>
najpierw zostanie wyliczone wyra¿enie c + 7, jego warto¶æ zostanie podstawiona
na zmienn± b, warto¶ci± wyra¿enia b = c + 7 bêdzie teraz ta w³a¶nie warto¶æ
(8) i kolejno - przesuwaj±c siê do lewej strony ca³ego wyra¿enia bêdzie ona
podstawiona na zmienne a i x. W rezultacie zmienne x, a, b bêd± mialy tak±
sam± warto¶æ 8.<br>
<br>
Jak widzimy w tablicy operatorów, wystêpuje ca³a grupa tzw.<A NAME="EDU.skorowidz.termin z³o¿ony_operator_przypisania 37_383"></A> <b>z³o¿onych operatorów przypisania</b> w postaci:<br>
<br>
                <b>op= </b><br>
<br>
gdzie op - to jeden z operatorów<br>
<br>
<b> *        /        %        +        -        &lt;&lt;    &gt;&gt;    &gt;&gt;&gt;        &amp;        ^        |</b><br>
<br>

<div class="syntax">Z³o¿one operatory przypisania, stosowane w nastêpuj±cy sposób:<br><br>

            <b>x op= wyra¿enie</b><br>
<br>
s± wygodn± form± skrócenia zapisu:<br>
<br>
<b>            x = x op ( wyra¿enie )</b><br>
<br>
gdzie:<br>
x - dowolna zmienna<br>
wyra¿enie - dowolne wyra¿enie<br>
op - symbol operatora
</div>

<br>
<p>
Na przyk³ad, zamiast:<br>
<br>
numOfChildren = numOfChildren + 1<br>
<br>
mo¿emy napisac:<br>
<br>
numOfChildren += 1<br>
<br>
W¶ród operatorów arytmetycznych szczególn± rolê odgrywaj± <b>jednoargumentowe</b> <A NAME="EDU.skorowidz.termin operator zwiêkszania 37_384"></A> <b>operatory zwiêkszania</b> <b>(++) </b>i<A NAME="EDU.skorowidz.termin operator zmniejszania 37_385"></A> <b>zmniejszania (--)</b>. Oba wystêpuj± w dwóch postaciach:<br>
<ul>
  <li>przyrostkowej (operator po argumencie - zmiennej)</li>
  <li>przedrostkowej (operator przed argumentem - zmienn±)<br>
  </li>
</ul>
<p>Przy czym :<br>
<ul>
  <li>++ zwiêksza, a -- zmniejsza <b>o jeden</b> warto¶æ argumentu (zmiennej),</li>
  <li>przyrostkowa forma operatorów (znak operatora po argumencie) modyfikuje
warto¶æ argumentu po jej wykorzystaniu w wyra¿eniu, przedrostkowa (znak operatora
przed argumentem) - przed wykorzystaniem tej warto¶ci.</li>
</ul>

<p>Na przyk³ad zapis:<br>
<br>
int n, i = 1;<br>
n = i++;      // przyrostkowa forma operatora ++<br>
<br>
interpretowany jest w nastêpuj±cy sposób: zmienna i zostanie zwiêkszona o
1, ale zmiennej n zostanie nadana warto¶æ zmiennej i sprzed zwiêkszenia,
czyli po wykonaniu obu instrukcji: n bêdzie równe 1 , a  i  bêdzie równe
2.<br>
<br>
Natomiast:<br>
int n, i = 1;<br>

n = ++i;      // przedrostkowa forma operatora ++<br>
<br>
interpretowany jest w nastêpuj±cy sposób: zmienna i zostanie zwiêksozna o
1i ta nowa jej warto¶æ zostanie przypisana zmiennej n,  czyli po wykonaniu
obu instrukcji: n = 2 , i = 2.<br>
<br>
Oczywi¶cie, je¶li jedynym wyra¿eniem w instrukcji jest wyra¿enie zwiêkszania
(lub zmniejszania), to rozró¿nienie przyrostkowej i przedrostkowej form tych
operatorów nie ma znaczenia:<br>
<br>
i++;<br>
znaczy to samo, co<br>
++i;<br>
oraz <br>
i = i + 1<br>
<br>

<div class="important">Gdy nie jeste¶my absolutnie pewni kolejno¶ci opracowania wyra¿eñ, nale¿y
unikaæ stosowania operatorów ++ oraz -- w wyra¿eniach, w których wystêpuj±
inne wyra¿enia. </div>

<br>
<p>
Zamiast pisaæ: <br>
<br>
if (n++ &gt; 2) ...;<br>
<br>
lepiej jest zawsze napisaæ:<br>
<br>
n++;<br>
if (n &gt; 2) ...<br>
<br>
Na pewno za¶ nigdy nie nale¿y pisaæ (choæ jest to dopuszczalne), czego¶ w rodzaju:<br>
<br>
x = i++*++j;<br>
<br>
Pe³niejszemu zrozumieniu przedstawionych uwag mo¿e pos³u¿yæ analiza dzia³ania poni¿szego programu.<br>

<pre>
public class Express1 {

  public static void main(String[] args) {

    int a = 1, b = 2, c = 3;
    a = b = c * 1 + 2;
    System.out.println("a=" + a + " b=" + b + " c=" + c);
    a = b = c * (1 + 2);
    System.out.println("a=" + a + " b=" + b + " c=" + c);
    a = b++;
    System.out.println("a=" + a + " b=" + b + " c=" + c);
    c = --b;
    System.out.println("a=" + a + " b=" + b + " c=" + c);
    a++;
    b++;
    c++;
    System.out.println("a=" + a + " b=" + b + " c=" + c);

    a = b++*++c;
    System.out.println("a=" + a + " b=" + b + " c=" + c);

    int DlugaNazwaZmiennej = 20;
    DlugaNazwaZmiennej = DlugaNazwaZmiennej * 10;
    DlugaNazwaZmiennej *= 10;
    System.out.println( DlugaNazwaZmiennej );

  }
}
</pre>

<br>

<div class="listing33r">Wydruk<br>
a=5 b=5 c=3<br>
a=9 b=9 c=3<br>
a=9 b=10 c=3<br>
a=9 b=9 c=9<br>
a=10 b=10 c=10<br>
a=110 b=11 c=11<br>
2000</div>

<div class="ddd">
<br>
W programie tym stosujemy operator +  nie tylko do dodawania liczb.
S³u¿y on tak¿e konkatenacji (³±czeniu ³añcuchów znakowych). O szczegó³ach
dowiemy siê w nastêpnym wyk³adzie.<br>
<br>
Inne operatory arytmetyczne by³y ju¿ po czê¶ci omówione. Jeszcze raz warto
jednak podkre¶liæ, ¿e dzielenie dla liczb ca³kowitych odrzuca u³amkow± czê¶æ
wyniku.
</div>

<br clear="all">

<p>Np.<br>
int a,b,c;<br>
b = 1; c = 10; a = b/c;   // a = 0, bo "prawdziwy" wynik dzielenia jest 0 i 1/10<br>
a = 19/10;                    // a = 1, bo "prawdziwy" wynik dzielenia jest 1 i 9/10<br>
<br>
Ogólnie wiêc, gdy b i c s± zmiennymi typu int nie spelniona jest intuicyjna zale¿no¶æ matematyczna:<br>
<br><b>
b</b>  równa siê <b>c</b> razy <b>b</b> dzielone przez <b>c</b> <br>
<br>
Bêdzie ona zachodziæ na pewno wtedy, gdy b dzieli siê bez reszty przez c<br>
Je¶li b nie dzieli siê bez reszty przez c, to mo¿emy otrzymaæ "prawdziwy" wynik gdy iloczyn c*b dzieli siê bez reszty przez c.<br>
<br>
Np.<br>
<br>
b = 30; c = 20; b = c*b/c;    //  b = 30  <br>
<br>
ale:<br>
<br>
b = 30; c = 20; b = c*(b/c);  // b = 20 !<br>
<br>
Tutaj widzimy jak nawiasy zmieniaj± kolejno¶æ obliczania warto¶ci wyra¿enia.<br>
Wi±zanie operatorów * i / jest lewostronne i w pierwszym przypadku ca³a operacja<br>
wykonuje siê w nastêpuj±cy sposób:<br>
c*b daje 600 co dzielone przez c = 20 daje równo 30.<br>
<br>
W drugim przypadku najpierw wykonane zostanie dzielenie w nawiasach (30/20 da 1), a wynik pomno¿ony przez warto¶æ c (20) da 20.<br>
<br>
Wbrew pozorom "dziwne"<A NAME="EDU.skorowidz.termin dzielenie_ca³kowitoliczbowe 37_386"></A> dzielenie ca³kowitoliczbowe mo¿e byæ u¿yteczne, szczególnie
wraz z zastosowaniem operatora reszty z dzielenia.<br>
Rozwa¿my przyk³ad.<br> Wyobra¼my sobie, ¿e musimy wydrukowaæ szablon jakiej¶
numerowanej listy zawieraj±cej posNum pozycji. Na ka¿dej stronie wydruku
ma byæ umieszczone maksymalnie posPP pozycji, a nasz program ma umie¶ciæ
na niej kolejne numery pozycji, zwiêkszaj±ce siê w sposób ci±g³y od 1 do
numPos. Ka¿da nowa strona wydruku (oprócz pierwszej) winna zawieraæ nag³ówek
w postaci "Strona i z n", gdzie i - numer bie¿±cej strony, a n - liczba wszystkich
stron.<br>
<br>
Zadanie to mo¿na ³atwo oprogramowaæ stosuj±c operatory dzielenia ca³kowitoliczbowego oraz reszty z dzielenia.<br>
Liczba pe³nych (czyli zawieraj±cych okre¶lon± maksymaln± liczbê pozycji na
stronie - posPP) stron wydruku bêdzie równa  posNum/posPP. Je¿eli reszta
z dzielenia posNum przez posPP nie jest równa 0, znaczy to, ¿e sumaryczna
liczba stron bêdzie o 1 wiêksza od liczby pe³nych stron (na tej dodatkowej
stronie wyprowadzone zostan± ostatnie numery listy, ich liczba bêdzie oczywi¶cie
mniejsza o posPP). W ten sposób okre¶limy informacjê o liczbie wszystkich
stron niezbêdn± w nag³ówku ka¿dej (oprócz pierwszej) strony.<br>
Wypisuj±c kolejne pozycje bêdziemy je numerowaæ od 1 i przy ka¿dym wyprowadzeniu
zwiêkszaæ numer bie¿±cej wyprowadzanej pozycji o 1. £atwo mo¿na okre¶liæ
moment rozpoczêcia kolejnej strony. Bêdzie on nastêpowa³ zawsze wtedy, gdy
wyprowadzono kolejn± porcjê posPP pozycji, a zatem zawsze wtedy, gdy numer
wyprowadzonej pozycji dzieli siê bez reszty przez posPP. <br>

<pre>
public class Pages {

  public static void main(String[] args) {

    int posNum = 17;                       // liczba pozycji do wyprowadzenia
    int posPP = 5;                         // liczba pozycji na stronie

    int pageNum = posNum/posPP;            // liczba pelnych stron
    if (posNum % posPP != 0) pageNum++;    // i ew. dodatkowa

    int pageNr = 1;                        // bie¿±cy numer strony
    int pos = 1;                           // bie¿±cy numer pozycji

    while (pos &lt;= posNum) {

      System.out.println(pos);

      if (pos % posPP == 0) {              // zaczyna siê nowa strona
         pageNr++;
         System.out.println('\f' + "Strona " + pageNr + " z " + pageNum);
      }
      pos++;
    }

  }

}
</pre>

<br>
<div class="notel">Przypomnienie: znak '\f' jest znakiem steruj±cym "nowa strona". Dziêki
jego wyprowadzeniu w nag³ówku stron - po przekierowaniu standardowego strumienia
wyj¶ciowego na drukarkê - otrzymamy rzeczywi¶cie podzia³ listy na fizyczne
strony.</div>

<div class="ddd">
<br>
W programie pojawia siê kilka nowych elementów jêzyka. Bêd± one
szczegó³owo omawiane dalej, teraz dla zrozumienia dzia³anie programu wystarczy
odnie¶æ siê do znanych nam instrukcji uproszczonego REXXa z wyk³adu 3:<br>
<ul>
  <li>operator "czy nie równe" zapisujemy w Javie jako !=</li>
  <li>operator "czy równe" zapisujemy jako ==</li>
  <li>zuwa¿my, ¿e priorytet operatora % jest wy¿szy ni¿ operatoró == i !=, dlatego w if nie musieli¶my stosowaæ dodatkowych nawiasów</li>
  <li>instrukcja while { ... } dzia³a tak samo jak znana nam instrukcja
do while ... end, w instrukcji if pomijamy s³ówko then, a instrukcja grupuj±ca
do ... end zapisywana jest jako { }</li>
</ul>
</div>
<br clear="all">

<br>

<div class="notel55">Zwróæmy uwagê na styl programowania. Stosujemy wciêcia dla wyró¿nienia
bloków instrukcji grupuj±cych. Otwieraj±cy nawias klamrowy instrukcji grupuj±cej
w if i while umieszczamy w tym samym wierszu co instrukcja steruj±ca (if
lub while). Jest to tzw.wierszooszczêdny ("linesaver") styl programowania,
alternatyw± dla niego jest umieszczenie otwieraj±cego nawiasu klamrowego
dok³adnie pod if lub while. Zamykaj±ce nawiasy klamrowe umieszczamy zawsze
w nowym wierszu dok³adnie pod if lub while.</div>

<div class="ddd">
Zatem zamiast:<br>
<br>
        do while (...) {<br>
            ...<br>
        end<br>
<br>
piszemy:<br>
<br>
        while (..) {<br>
            ...<br>
        }<br>
<br>
a zamiast:<br>
<br>
         if (...) then do<br>
            ....<br>
         end<br>
<br>
piszemy<br>
           <br>
         if (...) {<br>
            ....<br>
        }<br>
</div>
<br clear="all"></p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index36.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index38.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
