<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index81.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 1"></A><div class="tytulpunktu">1. Pojêcie pêtli iteracyjnej</div>

<a name="W10.1"></a>

<p><A NAME="EDU.skorowidz.termin pêtla_iteracyjna 80_601"></A> Czêsto instrukcjê lub grupê instrukcji trzeba wykonaæ wielokrotnie, powtarzaj±c
je znowu i znowu, a¿ do chwili, gdy zostanie spe³niony jaki¶ warunek (w szczególno¶ci
np. dotycz±cy liczby powtórzeñ). Ka¿de powtórzenie instrukcji lub ich grupy
nazywa siê<A NAME="EDU.skorowidz.termin iteracja 80_602"></A> <b>iteracj±</b>, a jêzykowa konstrukcja pozwalaj±ca na ich powtarzanie - <b>pêtl± iteracyjn±</b>.<br>
<br>
Wyobra¼my sobie np., ¿e trzeba policzyæ sumê i iloczyn kolejnych dodatnich 
liczb ca³kowitych. Nie znaj±c pojêcia pêtli iteracyjnej musieliby¶my zapisaæ
to w nastêpuj±cy sposob:<br>
<br>
int suma = 0;<br>
int iloczyn = 1;<br>
int i = 1;<br>
suma += i;<br>
iloczyn *= i;<br>
i++;<br>
suma += i;<br>

iloczyn *= i;<br>

i++;<br>
suma += i;<br>

iloczyn *=i;<br>
...<br>
<br>
Widzimy tu wielokrotnie powtarzaj±ce siê fragmenty kodu. Oczywi¶cie powinni¶my je umie¶ciæ w pêtli.<br><br>

Przy tym jednak istotne jest, aby dobrze sformu³owaæ<A NAME="EDU.skorowidz.termin pêtla warunek_zakoñczenia 80_603"></A> <b>warunki zakoñczenia</b>
 dzia³ania pêtli. Przecie¿ nie mo¿emy próbowaæ sumowaæ i mno¿yæ wszystkich
liczb ca³kowitych, bo nasz program nie zakoñczy³by nigdy dzia³ania.<br>
Ogólnie, warunki zakoñczenia dzia³ania pêtli mo¿na podaæ w dwojaki sposób:<br>

<ul>
  <li>jako liczbê iteracji do wykonania (liczbê powtórzeñ instrukcji umieszczonych
w pêtli) - np. zsumowac i pomno¿yæ 20 pierwszych dodatnich liczb ca³kowitych</li>
  <li>jako jaki¶ inny warunek - np. sumowaæ i mno¿yæ kolejne liczby a¿ do
chwili, gdy ich iloczyn stanie siê równy lub wiêkszy od 100000.</li>
</ul>

<p>W instrukcjach steruj±cych, które wprowadzaj± pêtle, ze wzglêdu na lepsz± czytelno¶æ programu  podaje siê<A NAME="EDU.skorowidz.termin pêtla warunek_kontynuacji 80_604"></A> <b>warunki kontynuacji</b>
, a nie zakoñczenia pêtli. Wykonanie pêtli mo¿na jednak przerwaæ w jej ¶rodku
- i wtedy warunek, który sprawdzimy, by przerwaæ pêtlê - bêdzie<A NAME="EDU.skorowidz.termin pêtla warunek_zakoñczenia 80_605"></A> <b>warunkiem zakoñczenia</b> dzia³ania pêtli. Na to rozró¿nienie warto pocz±tkowo zwracaæ baczn± uwagê,<br>
<br>
Na samym pocz±tku lepszemu zrozumieniu dzia³ania pêtli sprzyja obrazowanie
ich za pomoc± schematów blokowych. Dzia³anie bardziej skomplikowanych pêtli
dodatkowo nale¿y prze¶ledziæ - iteracja po iteracji (oczywi¶cie nie wszystkie,
np. kilka poczatkowych iteracji i kilka koñcowych).<br>
<br>
Zobaczmy to na przyk³adzie  podnoszena do potêgi podanej liczby ca³kowitej. <br>
Naszym pierwszym zadaniem jest policzenie n-tej potêgi (n&gt;=0) podanej liczby ca³kowitej <i><b>a</b></i>.<br><br>

<div class="notel">Pêtle o znanej liczbie iteracji zapisujemy zwykle za pomoca instrukcji <b>for (...)</b></div>

<div class="ddd"><br><A NAME="EDU.skorowidz.termin pêtla instrukcja_for 80_606"></A> W naturalny sposób mo¿emy zapisaæ to jako n-krotne mno¿enie tej liczby przez
sam± siebie: a*a*a...<A NAME="EDU.skorowidz.termin pêtla o_znanej_liczbie_iteracji 80_607"></A> Bêdziemy mieli n - iteracji. W ka¿dej i-ej iteracji
(1&lt;= i &lt;=n) zmienna <b><i>wynik</i></b> bêdzie mia³a warto¶æ <i><b>a</b></i> w potêdze <i><b>i</b></i>.
</div>
<br clear="all">

<p>
Sposób dzia³ania takiej pêtli iteracyjnej ilustruje poni¿szy schemat blokowy.<br>
<br>

<div>
<img src="images/petla1.jpg" alt="Rys" width="352" height="477" border="1">
</div>

<br><p>
Mo¿emy sprawdziæ dzia³anie pêtli "z kartk± i o³ówkiem" dla jakiego¶ zestawu danych wej¶ciowych, np. a = 2 i n = 5.<br>
<br>

<table border="1" width="100%" cellpadding="2" cellspacing="2">
<tbody><tr><td valign="Top">Iteracja<br>
      </td>
<td>Warto¶æ<br>
zmiennej i</td><td>Warto¶æ warunku<br>
kontynuacji pêtli </td><td>Warto¶æ zmiennej wynik</td></tr><tr><td valign="Top">1<br>
      </td>
<td>1</td><td>true</td><td>2</td></tr><tr><td valign="Top">2<br>
      </td>
<td>2</td><td>true</td><td>4</td></tr><tr><td valign="Top">3<br>
      </td>
<td>3</td><td>true</td><td>8</td></tr><tr><td valign="Top">4<br>
      </td>
<td>4</td><td>true</td><td>16</td></tr><tr><td valign="Top">5<br>
      </td>
<td>5</td><td>true</td><td>32</td></tr><tr><td valign="Top">-<br>
      </td>
<td>6</td><td><b><font color="#ff0000">false (pêtla koñczy dzia³anie)</font></b></td><td>32</td></tr></tbody>
</table>

<br>
<p>
Zwróæmy uwagê, ¿e w tym algorytmie - po zakoñczeniu pêtli - zmienna <i><b>i</b></i>
 bêdzie mia³a warto¶æ o jeden wiêksz± od liczby wykonanych iteracji (chocia¿
traktowali¶my j± jako<A NAME="EDU.skorowidz.termin licznik_iteracji 80_608"></A> licznik iteracji, to nie mo¿emy powiedzieæ, ¿e pêtla
wykona³a siê i-razy).<br>
Czy jeste¶my pewni poprawno¶ci tego algorytmu? Czy dobrze dobrali¶my warto¶æ pocz±tkow±<i><b> i </b></i>oraz rodzaj warunku kontynuacji? <br>
Nie wystarczy rozpatrzeæ tylko jednego, wybranego przebiegu obliczeñ. Warto przyjrzeæ siê tak¿e  <b>warunkom brzegowym</b>
 zadania. Mamy podnosiæ dowoln± liczbê ca³kowit± do potêgi ca³kowitej n &gt;=
0. Co siê zatem stanie, gdy n = 0? Pêtla nie wykona siê ani razu (bo i =
1 jest mniejsze od n = 0), ale wynik bêdzie poprawny (bo zmienn± <i><b>wynik</b></i> zainicjowali¶my warto¶ci± 1).<br>
Ten sam efekt (poprawnego dzia³ania) mo¿na uzyskaæ gdyby zamiast<i><b> i = 1</b></i> napisaæ <i><b>i = 0</b></i>, a zamiast <b><i>i &lt;= n</i></b> napisaæ <i><b>i &lt; n</b></i>. (oczywi¶cie zwróæmy uwagê, ¿e algorytm jest poprawny tylko dla n &gt;= 0).<br><br>

<div class="notel"><br>Czêstym b³êdem przy konstrukcji pêtli iteracyjnych jest wykonywanie iteracji
o jeden raz za du¿o lub jeden raz za ma³o<br><br></div>

<div class="ddd"><br>
Ale nie mo¿emy oczywi¶cie ca³kiem
dowolnie, na wyczucie stosowaæ znaku &lt; zamiast &lt;= lub inicjowac zmiennej
<i><b>i</b></i> zerem lub jedynk±. Nie ma tu z³otych regu³ - dobór zale¿y
od starannej analizy poprawno¶ci algorytmu. W przypadku tak prostego zadania
o jakim by³a mowa przed chwil± nie ma tu wiêkszych problemów, ale w bardziej
z³o¿onych przypadkach w³a¶ciwy dobór liczby iteracji mo¿e sprawiaæ k³opoty.
</div>
<br clear="all">

<br><p>
Rozwa¿my teraz inne zadanie. Mamy oto okre¶liæ do jakiej <b>parzystej</b> potêgi <i><b>n</b></i> (<i><b>n&gt;=0</b></i>) nale¿y podnie¶æ podan± liczbê ca³kowit± <i><b>a (a &gt; 1)</b></i>, aby osi±gn±æ wynik <b>co najmniej</b> równy  zadanej wielko¶ci (któr± okre¶limy jako warto¶æ ca³kowit± <i><b>cel</b></i>).<br>
<br>
<div class="important"><br>

<b>Przed lektur± dalszego tekstu proszê spróbowaæ samodzielnie zbudowaæ schemat blokowy rozwi±zania tego zadania.</b><br>
<br>

</div>

<br><p>
Rozpatrujemy parzyste potêgi <i><b>n</b></i> liczby <i><b>a</b></i>. Niech <i><b>w</b></i> oznacza wynik potêgowania.<br>
Dla n = 2 w = a*a.<br>
Dla n = 4 w = a*a*a*a.<br>
Dla n = 6 w = a*a*a*a*a*a<br>
Itd.<br>
A zatem je¶li  na pocz±tku w = 1, to nastêpnie w pêtli mo¿emy uzyskiwaæ kolejne potêgi za pomoc± wyra¿enia:<br>
w = w *a * a<br>
<br>
Nie wiemy jednak z góry ile razy powinna wykonaæ siê pêtla. Naszym celem jest przecie¿ okre¶lenie liczby <i><b>n</b></i>, a nie podniesienie <i><b>a</b></i> do znanej potêgi <i><b>n</b></i>.<br>
Warunkiem kontynuacji pêtli powinno byæ porównanie uzyskiwanych warto¶ci <i><b>w</b></i> z zadan± liczb± <i><b>cel</b></i>.<br>
Powiedziano: "osi±gn±æ wynik <b>co najmniej</b> równy  zadanej wielko¶ci <i><b>cel</b></i>". A to oznacza, ¿e pêtla ma byæ kontynuowana dopóki <b><i>w</i> jest mniejsze od <i>cel</i></b>. Proszê zwróciæ uwagê: nie równe lub mniejsze, ale <b>mniejsze</b>!<br>
W samej pêtli musimy nie tylko wyliczaæ bie¿±cy wynik potêgowania, ale równie¿
zwiêkszaæ n (i to zawsze o 2, bo potêgi maj± byæ parzyste).<br>
A jak± pocz±tkow± warto¶æ powinno mieæ n? <br>
Oczywi¶cie 0, bowiem takie s± warunki zadania (<b><i>cel</i></b> - jest dowoln±
liczb± ca³kowit±,  n za¶ mo¿e byæ &gt;=0). Zatem np. dla cel &lt;= 1, w³a¶ciw±
odpowiedzi± jest n = 0 (bo zmienna <i><b>w</b></i> pocz±tkowo rowna jest 1, co jest wiêksze lub równe warto¶ci zmiennej <i><b>cel</b></i>,  pêtla nie wykona siê ani razu, ale dowolne <i><b>a</b></i> podniesione do potêgi 0 jest równe 1).<br>
<br>
Pokazuje to nastêpuj±cy schemat blokowy.<br><br>

<div>
<img src="images/petla2.jpg" alt="Rys" width="352" height="511" border="1">
</div>

<br>

<div class="notel">Warunkowe pêtle iteracyjne zapisujemy zwykle za pomoc± instrukcji <b>while</b>
</div>

<div class="ddd"><br><A NAME="EDU.skorowidz.termin instrukcja_while 80_609"></A> Mamy tu zatem pêtlê, która koñczy dzia³anie nie na skutek wyczerpania
limitu iteracji, ale ze wzglêdu na niespe³nienie warunku, który z liczb±
iteracji nie ma nic wspólnego. Takie pêtle mo¿emy nazwaæ<A NAME="EDU.skorowidz.termin pêtla_iteracyjna warunkowa 80_610"></A> warunkowymi pêtlami
iteracyjnymi.
</div>
<br clear="all">

<p>
Bardzo wa¿n± spraw± przy programowaniu pêtli jest zagwarantowanie zakoñczenia
ich dzia³ania. Czêsto - przy niezbyt starannej analizie warunków zadania,
przy jakich¶ konkretnych warto¶ciach danych, mo¿emy uzyskaæ pêtle dzia³aj±ce
w nieskoñczono¶æ.<br>
<br>
Np. prawid³owe dzia³anie obu omówionych wy¿ej algorytmów zale¿y od konkretnej
reprezentacji liczb w jêzyku. Je¿eli wyniki potêgowania bêdziemy przedstawiaæ
jako liczby typu int, to pierwszy algorytm (przy du¿ych <i><b>a</b></i> i <i><b>n</b></i>
) nie da prawid³owych wyników, a drugi mo¿e siê zapêtliæ (tzn, petla bêdzie
wykonywana w nieskoñczono¶æ). Wynika to z tego, ¿e w którym¶ momecie (przy
du¿ych a i n) wynik potêgowania nie bêdzie mie¶ci³ siê w obszarze pamiêci
przeznaczonym do przechowywania liczb typu int.<br>
<br>

<p>
<a href="javascript:popUp('dodatki/W10Prb1.htm', 50, 50)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a><br>Zauwa¿my te¿, ¿e formu³uj±c drugie zadanie (znale¼æ parzyste nieujemne <i><b>n</b></i>, takie, ¿e <i><b>a</b></i> podniesione do potêgi<i><b> n </b></i>jest co najmniej równe <i><b>cel</b></i> ) podano warunek <i><b>a&gt;1</b></i>.</p>

<br clear="all">
<br>
<p>
Co siê stanie, gdy uchylimy ten warunek i powiemy, ¿e <i><b>a</b></i> mo¿e byæ dowoln± liczb± ca³kowit±? Czy dla ka¿dego <i><b>a</b></i>  (przy dowolnym ca³kowitym <i><b>cel</b></i>) pêtla bêdzie mia³a zagwarantowane zakoñczenia?<br>
Proszê sprobowaæ samodzielnie rozwi±zaæ tê zagadkê, a pó¼niej spojrzeæ na rozwi±zanie.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index81.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
