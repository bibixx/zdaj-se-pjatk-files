<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index44.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 1"></A><div class="tytulpunktu">1. Obiekty i referencje</div>

<a name="W6.1"></a>

<p><A NAME="EDU.skorowidz.termin obiekt 43_397"></A> Za wyj±tkiem operacji na liczbach, programowanie w Javie - tak naprawdê -
polega na pos³ugiwaniu siê obiektami. Jak pamiêtamy z wyk³adu 4 obiekty s±
egzemplarzami klas. <br><A NAME="EDU.skorowidz.termin ³añcuch_znakowy 43_398"></A> Np. ³añcuchy znakowe (napisy) s± egzemplarzami klasy<A NAME="EDU.skorowidz.termin String 43_399"></A> String, a klasa ta definiuje
wspólne w³a¶ciwo¶ci tego rodzaju obiektów (napisów). Klasa String jest jedn±
z wielu klas "standardowych", dostarczonych wraz ze ¶rodowiskiem Java 2 SDK,
ju¿ gotow± do wykorzystania przez programistê. Klasy mo¿emy definiowaæ sami
(za chwilê zobaczymy jak), mo¿emy tak¿e korzystaæ z klas, które przygotowali
jacy¶ inni programi¶ci (i które nie wchodz± w sk³ad klas "standardowych").<br>


Przypomnijmy sobie równie¿, ¿e na obiektach operujemy wydaj±c im polecenia
(komunikaty do obiektów), a wydawanie poleceñ nazywane jest wywo³ywaniem
metod (odpowiednika pojêcia funkcji) na rzecz obiektów.<br>
<br>


Wyobra¼my sobie teraz, ¿e kto¶ przygotowa³ dla nas klasê o nazwie Para  i
¿e jej obiekty s± parami liczb ca³kowitych tzn. ka¿dy obiekt sk³ada siê z
dwóch elementów -  liczb ca³kowitych (pierwszego sk³adnika pary i drugiego
sk³adnika pary). <br>


To co mo¿emy robiæ z obiektami klasy Para okre¶lone jest przez zestaw metod
tej klasy (poleceñ, które mo¿na wydawaæ obiektom-parom liczb ca³kowitych).
Wyobra¼my sobie dalej, ¿e w klasie Para s± zdefiniowane nastêpuj±ce polecenia
(metody):<br>
<ul>
<li>o nazwie set  - ustalaj±ca warto¶æ pary (obu sk³adników pary)</li><li>i o nazwie show - pokazuj±ca parê (wyprowadzaj±ca na konsolê oba sk³adniki pary) <br></li>
</ul>

<p>Ta informacja wystarczy nam teraz by pos³ugiwaæ siê obiektami klasy Para (jej budowê poznamy w nastêpnych wyk³adach).<br>
<br>
Co trzeba zrobiæ, ¿eby ustaliæ warto¶æ pary i wyprowadziæ j± na konsolê?<br>
<br>


Po pierwsze, musimy mieæ zmienn±, która bêdzie oznaczaæ obiekt- parê.<br>


Po drugie, musimy utworzyæ obiekt-parê.<br>


Po trzecie, temu obiektowi trzeba wydaæ polecenia set i show.<br>
<br>


Mo¿e to wygl±daæ w nastêpuj±cy sposób:<br>

<pre>
public class ParaSetAndShow {

  public static void main(String[] args) {

    Para para1 = new Para(); // 1
    para1.set( 1, 2 );       // 2
    para1.show();            // 3

  }
}
</pre>

<br>

<div class="listing33r">Wydruk dzia³ania programu:<br>
( 1 , 2 )</div>

<div class="ddd">Po kolei:</DIV><br clear="all"><br>

<ul>
<li>w wierszu oznaczonym 1 deklarujemy zmienn± o nazwie para1 i <b>tworzymy obiekt</b> parê za pomoc± <b>wyra¿enia new</b> (jak widaæ <b><i>wyra¿enie new</i></b> sk³ada siê ze s³owa kluczowego <b>new</b>
  i nastêpuj±cej po nim nazwie klasy obiektu oraz nawiasów okr±g³ych, w których
- jak siê mo¿na domysliæ - podawane mog± byæ - jako argumenty - informacje
niezbêdne do tworzenia obiektu. Tu nie podajemy takich informacji. Po nastêpnym
wyk³adzie bêdziemy dobrze rozumieæ dlaczego wyra¿enie new ma tak± formê);</li>

<li>teraz mamy ju¿ (jeden) obiekt-parê i zmienn± (o nazwie para1) za pomoc± której bêdziemy na tym obiekcie operowaæ;</li>

<li>w wierszu // 2 do obiektu oznaczanego przez zmienn± para1 posy³amy
polecenie set. Aby pos³aæ polecenie musimy wybraæ jakiego konkretnie obiektu
ma ono dotyczyæ. Temu wyborowi s³u¿y kropka (.), nazywana <b>selektorem</b>
. Gdy piszemy para1. - znaczy to, ¿e nastêpuj±ce po kropce polecenie ma byæ
wys³ane do obiektu oznaczanego przez zmienn± para1.  Poleceniem tym jest
set. W nawiasach okr±g³ych podajemy jego argumenty (dodatkow± informacjê,
która ma byæ uwzglêdniona przy wykonaniu polecenia). W tym przypadku pierwszy
argument jest warto¶ci±, która ma byæ nadana pierwszemu sk³adnikowi pary,
a drugi - drugiemu. W sumie para1.set( 1, 2); znaczy:  ustaliæ warto¶æ pierwszego
elementu obiektu (sk³adnika pary) oznaczanego przez zmienn± para1 na 1, a
drugiego elementu (sk³adnika pary) - na 2;</li><li>w wierszu // 3 do obiektu, oznaczanego przez para1 posylamy komunikat
show ("poka¿ siê") i w rezultacie na konsolê wyprowadzana jest "warto¶æ pary",
w tym przypadku podana jako ( warto¶æ_pierwszego_skladnika , warto¶æ_drugiego_skladnika
) czyli ( 1 , 2 );<br></li>
</ul>

<p>
Nieco niepokoj±ce jest w tym opisie ciag³e u¿ywanie sformu³owania "obiektu
oznaczanego przez  (zmienn±) para1". Czy¿ nie ³atwiej by³oby mowiæ: obiektu para1, tak
jak mówimy np liczby calkowitej x? I w ogóle czym jest, tak naprawdê, zmienna
para1?<br>


Widzimy wyra¼nie, ¿e zosta³a ona zadeklarowana, ale jednocze¶nie pojawi³ siê nieco dziwny punkt o tworzeniu obiektu.<br>


Co by siê sta³o gdyby¶my po prostu napisali:<br>
<br>


Para para1;<br>


para1.set( 1, 2 );<br>


para1.show();<br>
<br>   Jak ju¿ by³o powiedziane, deklaracje zmiennych, które oznaczaj± obiekty
zapisujemy w analogiczny sposób jak deklaracje zmiennych typów pierwotnych.<br>
<br>


int x;      // deklaracja zmiennej typu int<br>


Para p; // deklaracja zmiennej p, za pomoc± której mo¿emy operowaæ na obiektach klasy Para<br>


Pomiêdzy tymi deklaracjami wystêpuje jednak subtelna ró¿nica znaczeniowa.<br>
<br><A NAME="EDU.skorowidz.termin deklaracja_zmiennej 43_400"></A> Otó¿, deklaracja zmiennej x wydziela pamiêæ dla przechowywania liczby ca³kowitej
(cztery bajty). W tym momencie x jest synonimem jednostki danych - liczby
ca³kowitej.<br>


Piszemy np.  x = 4; i do miejsca pamiêci oznaczanego przez zmienn± x wpisywana jest liczba 4. Wygl±da to mniej wiêcej tak:<br><br>

<div>
<img src="images/IntDcl.jpg" alt="Rys" width="500" height="143" border="1">
</div>
<br>


<div class="notel">W innych jêzykach programowania (np. C++) mówi siê, ¿e jest to deklaracja wraz z definicj±
</div>

<div class="ddd">
<br>
Zatem sama deklaracja zmiennej calkowitoliczbowej x tworzy "obiekt" - liczbê
ca³kowit± (przed ustaleniem warto¶ci zmiennej liczba ta ma jak±¶ domy¶ln±
warto¶æ, byæ mo¿e 0).
</div>

<br clear="all">


<p><A NAME="EDU.skorowidz.termin deklaracja_zmiennej 43_401"></A> W przypadku deklaracji zmiennej, która mo¿e oznaczaæ obiekt jakiej¶ klasy
sytuacja jest zupe³nie inna. Deklaracja nie tworzy obiektu (nie wydziela
pamiêci do przechowywania obiektu klasy).<br><A NAME="EDU.skorowidz.termin obiekt tworzenie 43_402"></A> <b>Sam obiekt musi byæ dopiero utworzony - za pomoc± wyra¿enia <big>new</big>.</b><br>


Jego zastosowanie powoduje przydzielenie pamiêci dla obiektu w dynamicznej
(zmieniaj±cej siê w trakcie dzia³ania programu) czê¶ci pamiêci, zwanej <b>stert±</b>.<br>


Wynikiem wyra¿enia new jest adres (lokalizacja) miejsca w pamiêci, przydzielonego
obiektowi. Ten adres mo¿emy przypisaæ zmiennej, za pomoc± której chcemy na
danym obiekcie operowaæ.<br>
<br>


Np. deklaracja: <br>
<br>


            Para p;<br>
<br>
<b>nie tworzy</b> obiektu klasy Para.<br>
<br>

 A je¶li nie ma obiektu, to nie mo¿emy pos³aæ do niego ¿adnego komunikatu
(wydaæ polecenia, wywo³aæ na jego rzecz metody). Zatem, w tym kontek¶cie,
p.set(...) i p.show() bêd± niepoprawnymi odwo³aniami.<br>
<br>


Zatem zmienna p nie zawiera obiektu Para.<br>


Mo¿e natomiast zawieraæ jego lokalizacjê (adres w pamiêci) - inaczej nazywan± <b>referencj±</b> do obiektu.<br>
<br><A NAME="EDU.skorowidz.termin referencja 43_403"></A> 

<div class="def"><b>Referencja</b> to warto¶æ, która oznacza lokalizacjê (adres) obiektu w pamiêci </div>
<br>
<p>

Obiekt klasy Para mo¿emy utworzyæ u¿ywaj±c wyra¿enia new Para(), a przypisuj±c
warto¶æ tego wyra¿enia zmiennej p, uzyskujemy mo¿liwo¶æ operowania na tym obiekcie:<br>
<br>



Para p;<br>


p = new Para();<br>
<br>


co wcze¶niej, w skrócie, zapisywali¶my stosuj±c inicjacjê przy deklaracji:<br>
<br>


Para p = new Para(); <br>
<br>
<br>


Dok³adnego wyja¶nienia dostarcza poni¿szy ideowy schemat <br><br>
<div>
<img src="images/Reference.jpg" alt="Rys" width="484" height="266" border="1">
</div>

<br>

<div class="notel33">W literaturze polskiej rozró¿nia siê czasem dwa pojêcia:<br>
<ul>
<li>odniesienie - to co tutaj nazywamy referencj± do obiektu, lokalizacj±, adresem obiektu.</li>
<li>odno¶nik - zmienn±, której warto¶ci± jest odniesienie</li>
</ul>

Nota bene, w niniejszych wykladach bêdziemy pos³ugiwaæ siê czasem terminem "referencja" na
oznaczenie obu tych pojêæ.. Ró¿nice bêd± zawsze jasne z kontekstu.  <br>

</div>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin odniesienie 43_404"></A> gdzie:<br>
<ol>
<li>Przydzielenie pamiêci zmiennej p do przechowania referencji do obiektu.
Referencja jest nieustalona, ma warto¶æ null, co oznacza, ¿e nie odnosi siê
do ¿adnego obiektu.</li>

<li><A NAME="EDU.skorowidz.termin odno¶nik 43_405"></A> Opracowanie wyra¿enia new powoduje przydzielenie pamiêci dla obiektu
klasy Para na stercie pod jakim¶ wolnym adresem (tu symbolicznie 1304). Wielko¶æ
przydzielonego obszaru jest wystarczaj±ca, by zmie¶ciæ dwie liczby ca³kowite
(sk³adniki pary). W tym momencie oba skladniki pary równe s± 0.</li><li>Warto¶ci± wyra¿enia new jest referencja (adres 1304). Jest ona umieszczana w uprzednio przydzielonym zmiennej p obszarze pamiêci</li><li>Zmienna p ma teraz warto¶æ = referencji do obiektu klasy Para, któremu w kroku 2 przydzialono pamiêæ na stercie (adres 1304). <br></li>
</ol>
</div>
<br clear="all">


<p>Zatem zmienna p w naszym przyk³adzie zawiera (w koñcu) referencjê do obiektu klasy Para. Powiemy te¿ "<b>wskazuje na obiekt</b>". Powiemy te¿ czasem w skrócie: <b>jest referencj±</b>. <br>


I: "referencja wskazuje na obiekt".  <br>


Mówili¶my wcze¶niej: "zmienna p <b>mo¿e oznaczaæ</b>
 obiekt klasy Para" w tym w³a¶nie sensie, i¿ mo¿e zawieraæ referencjê do obiektu
klasy Para (zatem jako¶ go "oznaczaæ", ale na pewno nie zawieraæ). A dlaczego
<i><b>mo¿e</b></i>? Bo nie zawsze zawiera referencjê do obiektu, czasami
(np. zaraz po deklaracji bez inicjacji) nie zawiera referencji do ¿adnego
obiektu (bo ¿aden nie zosta³ jeszcze utworzony).   <br>
<br>


 Powstaje pytanie - jakiego typu jest zmienna p i wszystkie podobne zmienne, te o których mówili¶my, ¿e mog± oznaczaæ obiekty?<br>
<br><A NAME="EDU.skorowidz.termin typ_referencyjny 43_406"></A> Otó¿ w Javie oprócz typów numerycznych i typu boolowskiego istnieje jeszcze tylko jeden typ - <b>typ referencyjny</b>.<br>
<br>


<div class="important">
Wszystkie zmienne deklarowane z nazw± klasy w miejscu nazwy typu s± zmiennymi
typu referencyjnego. Zmienne te mog± zawieraæ referencje do obiektów lub
nie zawieraæ ¿adnej referencji (nie wskazywaæ na ¿aden obiekt).</div>
<br>
<p>


Warto¶æ zmiennej typu referencyjnego, która nie zawiera referencji do obiektu równa jest <b>null</b>. S³owo null jest s³owem kluczowym jêzyka<br>
<br>


Zatem dopuszczalne warto¶ci zmiennych typu referencyjnego - to referencje
do obiektów lub warto¶æ<A NAME="EDU.skorowidz.termin null 43_407"></A> <i><b>null</b></i>. Tak samo jak <i><b>1</b></i> jest litera³em typu int - <i><b>null</b></i>
jest litera³em typu referencyjnego.<br>
<br>

<div class="notel33">Referencje s± bardzo podobne do wska¼ników w C, z t± istotn±
ró¿nic±, ¿e nie ma w Javie arytmetyki "na referencjach". Dziêki temu programowanie
w Javie jest bardziej odporne na b³êdy.  Arytmetyka wska¼nikowa w C  jest
czêst± przyczyn± b³êdów, gdy¿ pozwala siêgaæ do dowolnego miejsca w pamiêci
(np. poprzez zwiêkszanie wska¼nika, który wskazuje na obszar przydzielony
jakiej¶ zmiennej). </div>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin referencja porównywanie 43_408"></A> Dla warto¶ci typów referencyjnych (które to warto¶ci
w istocie s± liczbami, bo adresy obiektów s± liczbami) nie s± dopuszczalne
operacje arytmetyczne.<A NAME="EDU.skorowidz.termin referencja przypisanie 43_409"></A> Mo¿emy natomiast:<br>
<ul>
<li>porównywaæ referencje na równo¶æ (==) lub nierówno¶æ (!=),</li><li>przypisywaæ im warto¶ci innych referencji oraz warto¶æ <i><b>null</b></i><br></li>
</ul>
</div>

<br clear="all">

<p>Musimy zawsze pamiêtaæ, ¿e operacje te (wykonywane na zmiennych, oznaczaj±cych
obiekty) dotycz± referencji, a nie obiektów (na obiektach, ich wnêtrzu operujemy
za pomoc± metod, poleceñ posy³anych do obiektów za po¶rednictwem referencji
i  za pomoc± "operatora" kropka).<br>
<br>


Wyobra¼my sobie, ¿e na dwóch "danych" - liczbach ca³kowitych i na dwóch "danych"
- obiektach klasy Para wykonujemy podobne operacje:<br>
<ol>
<li>Nadanie warto¶ci pierwszej danej, nadanie warto¶ci drugiej danej,</li>

<li>Przypisanie <b>zmiennej</b> oznaczaj±cej drug± dan± <b>warto¶ci zmienej</b> oznaczaj±cej pierwsz± dan±,</li>

<li>Zmianê warto¶ci drugiej danej,</li>

<li>Porównanie <b>zmiennych</b>, oznaczaj±cych obie dane.</li>
</ol>


<p>A dodatkowo (w obu przypadkach) wprowadzimy trzeci± dan±, której warto¶æ ustalimy na warto¶æ drugiej i porównamy <b>zmienne</b> oznaczaj±ce te dane (drug± i trzeci±). <br>


Program móg³by wygl±daæ tak:<br>
<br>

<pre>
public class Roznica {

  public static void main(String[] args) {

    // Operacje na zmiennych typów pierwotnych
    int x, y, z;
    x = 3;
    y = 4;
    x = y;
    y = 5;
    z = 5;
    System.out.println("x = " + x);
    System.out.println("y = " + y);
    System.out.println("z = " + z);
    if (x == y) System.out.println ("x i y równe.");
    else  System.out.println ("x i y nierówne.");
    if (y == z) System.out.println ("y i z równe.");
    else  System.out.println ("y i z nierówne.");


    // Podobne operacje na zmiennych typu referencyjnego
    Para px = new Para(), py = new Para(), pz = new Para();
    px.set( 3, 3 );
    py.set( 4, 4 );
    pz.set( 5, 5 );
    px = py;
    py.set( 5, 5 );
    System.out.print("Para px: "); px.show();
    System.out.print("Para py: "); py.show();
    System.out.print("Para pz: "); pz.show();
    if (px == py) System.out.println ("px i py równe.");
    else  System.out.println ("px i py nierówne.");
    if (py == pz) System.out.println ("py i pz równe.");
    else  System.out.println ("py i pz nierówne.");

  }
}
</pre>

<br>

<div class="listing33r">x = 4<br>


y = 5<br>


z = 5<br>


x i y nierówne.<br>


y i z równe.<br>


Para px: ( 5 , 5 )<br>


Para py: ( 5 , 5 )<br>


Para pz: ( 5 , 5 )<br>


px i py równe.<br>


py i pz nierówne.<br>


</div>

<div class="ddd">
<br>
Wynik dzia³ania programu (obok) mo¿e wygl±daæ zaskakuj±co dla kogo¶, kto nie u¶wiadomi sobie <b>braku</b>
 ró¿nicy pomiêdzy operacjami na zmiennych typów pierwotnych i referencyjnych
(my¶l±c ¿e zmienne typów referencyjnych zawieraj± obiekty).  Otrzymany rezultat
wynika z nastêpuj±cych faktów:<br>
<ul>
<li>wyra¿enie new Para() zwraca referencjê do nowoutworzonego obiektu klasy
Para; uzyskiwane referencje przypisywane s± zmiennym typu Para (który jest
typem referencyjnym)<br></li>

<li>u¿ycie metody (polecenia) set  ustala warto¶ci danych w obiekcie klasy
Para; do obiektu odwo³ujemy siê przez referencjê, która na niego wskazuje
(np. px.set(...)</li>

<li>przypisanie px = py powoduje skopiowanie referencji (wskazuj±cej na obiekt-parê o sk³adnikach (4, 4)) do zmiennej
 px (dot±d wskazuj±cej na obiekt-parê o warto¶ciach (3,3). Od tej chwili
px i py oznaczaj± ten sam obiekt (który jest par± o warto¶ciach (4,4)). Do
obiektu-pary (3,3) nie mamy ju¿ w tej chwili ¿adnego dostêpu. </li>

<li>poniewa¿
za pomoc± referencji py ustalamy nowe warto¶ci sk³adników pary (py.set(5,5)),
na któr± wskazuje zarówna zmnenna py jak i px, to odwolania show wobec tych
zmiennych poka¿± identyczne warto¶ci (skladniki pary o warto¶ciach 5, 5)<br></li>

<li>
dalej porównanie referencji px i py da warto¶æ true (bo referencje wskazuj±
na ten sam obiekt, a nie dlatego, ¿e wskazuj± na dwa obiekty o tych samych
warto¶ciach elementów - sk³adników pary)</li>

<li>o czym dobitnie siê przekonujemy porównuj±c zmienne py i pz. Zmienne te
 wskazuj± na dwa ró¿ne obiekty (zatem warto¶ci tych zmiennych s± ró¿ne) i
dlatego wynik porównania jest false, mimo, ¿e warto¶ci elementów obu tych obiektów (sk³adniki pary) s± takie same (5, 5).</li>
</ul>
</div>

<p>
Przy okazji warto zastanowiæ siê, co dzieje siê obiektem-par± o warto¶ciach
(3,3) na któr± wskazywa³a najpierw referencja px. Obiekt  ten zosta³ utworzony
na stercie (px = new Para()), a wiêc zajmuje jaki¶ obszar pamiêci. Nastêpnie
ustalono warto¶ci jego elementów (sk³adników pary) - px.set(3,3) - a wiêc
te warto¶ci zosta³y wpisane do tego obszaru. Po czym zmiennej px przypisano
warto¶æ zmiennej py i w ten sposób w programie nie mamy ju¿ ¿adnej referencji
do tego obiektu. A poniewa¿ na obiektach mo¿emy dzialaæ tylko za pomoc± referencji,
to jest on ju¿ dla nas bezu¿yteczny i wy³±cznie "za¶mieca pamiêæ". Czy musimy
siê tym martwiæ? Gdyby np. takich za¶miecaj±cych pamiêæ obiektów pojawi³o
siê w naszym programie tysi±ce, to czy nie spowodowo³oby to przepe³nienia
pamiêci?<br>
<br>


 <div class="notel33">Jest to istotne u³atwienie w porównaniu z takimi jêzykami jak C czy
C++, gdzie dynamicznie alokowane przez programistê (za pomoc± operatorów
lub funkcji) obszary pamiêci musz± byæ przez programistê ¶wiadomie zwalniane</div>

<div class="ddd">
<br>
Na szczê¶cie - nie. Bezu¿yteczne obiekty s± automatycznie usuwane z pamiêci
(bez konieczno¶ci ¿adnej ingerencji programisty), mimo, ¿e powsta³y one na
skutek wykonania odpowiednich instrukcji zapisanych przez programistê w programie
(np. Para py = new Para();).
</div>
<br clear="all">

<br>

<div class="notec"><A NAME="EDU.skorowidz.termin od¶miecianie 43_410"></A> Obiekty, na które w programie nie wskazuje ju¿ ¿adna referencja s± automatycznie usuwane z pamiêci. Nazywa siê to <b>automatycznym od¶miecaniem</b> (garbage collecting)</div>
<br>
<p>


Podsumujmy najwa¿niejsze fakty.<br>
<br>


<div class="important"> <br>
<ul>
<li><A NAME="EDU.skorowidz.termin obiekt 43_411"></A> obiekty musimy tworzyæ za pomoc± wyra¿enia new ...</li>
</ul>

<ul>
<li>na obiektach operujemy za pomoc± referencji (które na nie wskazuj±) i poleceñ (metod) zdefiniowanych w klasie obiektów</li>
</ul>

<ul>
<li><A NAME="EDU.skorowidz.termin referencja 43_412"></A> referencje nie s± obiektami - s± adresami obiektów</li>
</ul>

<ul>
<li>zmienne typów referencyjnych musimy (tak samo jak zmienne innych typów) deklarowaæ przed ich u¿yciem w programie</li>
</ul>

<ul>
<li>deklaracja zmiennej-referencji nie tworzy obiektu</li>
</ul>


</div>

<br>
<p>

Programuj±c w Javie, w wielu przypadkach, mo¿na nawet nie zdawaæ sobie z
tego wszystkiego sprawy. Mo¿na pokazaæ wiele programów obiektowych w Javie,
które dzia³aj± poprawnie i wykonuj± przewidziane dla nich zadania, a zosta³y
napisane bez u¶wiadomienia sobie ró¿nicy pomiêdzy referencjami i obiektami.
Dobrym przyk³adem s± aplikacje powitalne z poprzedniego wyk³adu: mo¿na je
napisaæ nic nie wiedz±c o referencjach i my¶l±c (b³êdnie), ¿e zmienne zadeklarowane
tam jako Frame czy Label zawieraj± obiekty.<br>


Jednak w wielu nawet prostych przypadkach (np. poprzedni program porównuj±cy
dzia³ania na liczbach i na obiektach-parach) brak wiedzy o referencjach mo¿e
doprowadziæ do powa¿nych b³êdów w programie. Na pewno za¶ do napisania nieco
bardziej skomplikowanych programów u¶wiadomienie sobie ró¿nicy pomiêdzy obiektami
i referencjami jest bardzo istotne. Dlatego po¶wiêcili¶my tej kluczowej sprawie
sporo miejsca ju¿ na pocz±tku: by³oby chyba niedobrze zaczynaæ od  prostszej,
mo¿e bardziej zrozumia³ej (nie wspominaj±cej o referencjach), ale z gruntu
fa³szywej interpretacji jêzyka, aby potem - ze zdziwieniem - musieæ przestawiaæ
swoje my¶lenie na ca³kiem inne tory. <br>


Dlatego - mimo, ¿e podany tu materia³ mo¿e wydaæ siê nieco skomplikowany
- warto mu po¶wiêciæ i czas i wysi³ek. Nie odk³adaj±c tego na po¼niej.<br>
<br>


Powiedzmy te¿ szczerze, ¿e model przyjêty przez twórców Javy, jest trudny
w opisie. Precyzyjne opisy dzia³ania programu (¶ci¶le zgodne z modelem) musz±
roiæ siê od s³abo czytelnych zbitek.<br>


Na przyk³ad, opis jednej prostej instrukcji:<br>
<br>


  Color x = y.getBackground();<br>
<br>


powinien wygl±dac tak:<br>
<br>


 "zmiennej x przypisujemy referencjê do obiektu klasy Color zwrócon± przez
metodê getBackground(), wywo³an± na rzecz obiektu, do którego referencjê
zawiera zmienna y". <br>
<br>


Sytuacji w niczym nie poprawia u¿ycie terminologii odno¶nik i odniesienie: <br>
<br>


"odno¶nikowi x przypisujemy odniesienie do obiektu klasy Color, zwrócone
przez metodê getBackground(), wywo³an± na rzecz obiektu, do którego odniesienie
zawiera odno¶nik y".<br>
<br>


Dlatego w dalszej czê¶ci wyk³adów bêdziemy siê starali u¿ywaæ uproszczonego jêzyka, stosuj±c swoiste skróty my¶lowe.<br>
<br>


<div class="important">
Zawsze pamiêtaj±c o ró¿nicy miêdzy referencj±, zmienn± zawieraj±c± referencjê
oraz obiektem bêdziemy czasem (dla uproszczenia opisów) mówiæ:<br>
<ul>
<li>referencja - nazywaj±c  tak zarówno  adres obiektu, jak i zmienn± go zawieraj±c±</li>

<li>obiekt -  maj±c na my¶li referencjê do obiektu</li>
</ul>


</div>

<br>
<p>


Na przyk³ad <u>w kontek¶cie</u>:<br>
<br>


JakasKlasa x; <br>


...<br>


powiemy czasem "referencja x" (gdy bêdziemy chcieli uwypukliæ "wska¼nikowy" charakter zmiennej x)<br>
<br>


a czasem: "obiekt x" (gdy bêdziemy chcieli podkre¶liæ operowanie na obiekcie, wskazywanym przez referencjê zawart± w x)<br>
<br>
<u>W kontek¶cie</u> :<br>
<br>


String txt;<br>


...<br>


powiemy czasem: "³añcuch znakowy txt". <br>
<br>


a w kontek¶cie:<br>
<br>


Frame v;<br>


...<br>


powiemy czasem "okno v ..." .<br>
<br>
<u>Albo w kontek¶cie:</u><br>
<br>


 Color x = y.getBackground();<br>
<br>


powiemy czasem: "uzyskanie koloru t³a obiektu y"<br>
<br>
<br>


Nale¿y pamiêtaæ, ¿e bêd± to wszystko skróty my¶lowe, s³u¿±ce do bardziej
klarownego przedstawienia tre¶ci, istoty, wysokopoziomowej semantyki programów.<br>
<br>
<font color="#ff0000"><b>I - mimo tych skrótów - zawsze nale¿y pamiêtaæ o ró¿nicy pomiêdzy referencjami i obiektami.</b></font></p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index44.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
