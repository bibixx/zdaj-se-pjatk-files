<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index106.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index108.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Kilka s³ów o niezmiennikach pêtli iteracyjnych</div>

<a name="W14.2"></a>

<p>W tym podpunkcie zajmiemy siê krótko zagadnieniem,
które jest istotne m.in. w dowodzeniu poprawno¶ci algorytmów. Ta problematyka
bêdzie szczegó³owo i znacznie bardziej formalnie przedstawiona w ramach przedmiotu
"Algorytmy i struktury danych". Tutaj w sposób mo¿liwie najmniej formalny
zwrócona zostanie uwaga na pojêcie niezmienników pêtli iteracyjnych i to
raczej pod k±tem lepszego rozumienia dzia³ania (czy nawet sprawniejszego
formu³owania) pêtli iteracyjnych ni¿ dowodzenia ich poprawno¶ci.<br><br>

Rozpatrzymy najpierw pêtlê while (jak ju¿ wiemy - pêtle for ³atwo sprowadziæ
do pêtli while), po czym zobaczymy w jaki sposób, mo¿na bezpo¶rednio formu³owaæ
niezmienniki dla pêtli for.<br>
<br>
Ogóln± postaæ pêtli while mo¿na zapisaæ jako:<br>
<br>
<b><i>inicjacja_zmiennych_u¿ywanych_w_pêtli</i><br>
while (<i>warunek_kontynuacji_pêtli</i>) {<br>
    <i>cia³o_pêtli</i><br>
}<br>
</b><br>
gdzie przez <i><b>cia³o_pêtli</b></i> rozumiemy instrukcje wykonywane w pêtli<br>
<br><A NAME="EDU.skorowidz.termin niezmiennik_pêtli 107_747"></A> 

<div class="def">Niezmiennikiem pêtli <i><b>while</b></i> nazywamy relacjê pomiêdzy
warto¶ciami zmiennych programu, która jest prawdziwa tu¿ przed rozpoczêciem
pêtli, przed ka¿dym wykonaniem i po ka¿dym wykonaniu cia³a pêtli w kolejnych
iteracjach  <b>oraz</b> zaraz po zakoñczeniu pêtli iteracyjnej;
przy czym przynajmniej niektóre z warto¶ci zmiennych, uczestnicz±cych w tej
relacji, zmieniaj± siê w trakcie wykonywania iteracji pêtli. <br>
(Uwaga: jest to definicja nieformalna; formalne definicje bêd± przedstawione w ramach przedmiotu ASD). <br>
</div>

<br>
<p>
Je¶li przez K oznaczymy wyra¿enia-warunek kontynuacji pêtli, a przez N -
wyra¿enie-niezmiennik pêtli, to prawid³owa konstrukcja pêtli powinna wygl±daæ nastêpuj±co:<br>
<br>

<div class="notec">
    // N jest prawdziwe<br>
    while (K) {<br>
        // N i K jest prawdziwe<br>
        cia³o pêtli<br>
        // N jest prawdziwe<br>
     }<br>
    // N jest prawdziwe i jednocze¶nie K nie jest prawdziwe<br>
<br>
przy czym instrukcje cia³a pêtli powinny zapewniaæ (w którym¶ momencie) zanegowanie
wyra¿enia K (po to, by pêtla mog³a zakoñczyæ dzia³anie).<br>
</div>

<br>
<p>
Uwaga: w pêtli takiej mo¿e zdarzyæ siê, ¿e od pocz±tku K nie jest prawdziwe
(wtedy pêtla nie wykona siê ani razu, ale powinny zachodziæ pierwszy i ostatni
warunki podane w komentarzach).<br>
<br>

Spójrzmy na przyk³ad znajdowania minimalnego elementu tablicy <i><b>n</b></i> liczb ca³kowitych. <br>
<br>

<pre>
 static int getMin(int[] a) {
   int n = a.length;
   int vmin = a[0];
   int i = 1;
   while (i &lt; n) {
     if (a[i] &lt; vmin) vmin = a[i];
     i++;
   }
   return vmin;
 }
</pre>

<p>
Zauwa¿my, ¿e po zakoñczeniu pêtli chcemy, by spe³niony by³ warunek:<br>
warto¶æ zmiennej <i><b>vmin</b></i> jest warto¶ci± minimalnego elementu tablicy <i><b>a</b></i> czyli minimaln± warto¶ci± spo¶ród warto¶ci zmiennych a[0], a[1], ... a[n-1].<br><br>
Inaczej mówi±c warto¶ci± wyra¿enia (zapisanego w pseudokodzie):<br>
<br>
<b>vmin == minimum (a[0], ... ,a[n-1])</b><br>
<br>
winno byæ <b>true</b>.<br>
<br> Na tej podstawie mo¿emy ³atwo wydedukowaæ niezmiennik (który - w tym
przypadku - bezpo¶rednio pomaga nam zbudowaæ algorytm dzia³ania pêtli).
<br>
<br>

<div class="notec">
<b>Niezmiennik</b>: dla  ka¿dego <i><b>i</b></i> = 1, ... n :  <b>vmin == minimum ( a[0], .., a[i-1] )</b>.<br>
</div>

<br><p>Miejsca w którym warunek ten powinien byæ spe³niony pokazano poni¿ej
za pomoc± komentarza  N z dodatkow± liczb± 0, 1, 2, 3 - rozró¿niaj±c± umiejscowienie
warunku:<br>
<br>

<pre>
 static int getMin(int[] a) {
   int n = a.length;
   int vmin = a[0];
   int i = 1;
   <b><font color="#ff6600">// N0</font></b>
   while (i &lt; n) {
     <b><font color="#ff6600">// N1</font></b>
     if (a[i] &lt; vmin) vmin = a[i];
     i++;
     <font color="#ff6600"><b>// N2</b></font>
   }
   <font color="#ff6600"><b>// N3</b></font>
   return vmin;
 }
</pre>

<p>
Niezmiennik ten wyra¿a okre¶lon± relacjê pomiêdzy zmiennymi <i><b>vmin</b></i>, <i><b>a</b></i> oraz <i><b>i</b></i>. Zwróæmy uwagê, ¿e niektóre z tych zmiennych (vmin oraz i) zmieniaj± swoje
warto¶ci  w trakcie iteracji, a jednak warto¶æ wyra¿enia stanowi±cego niezmiennik
powinna byæ w ka¿dej iteracji taka sama (st±d nazwa niezmiennik!). <br> Je¿eli
mo¿emy teraz wykazaæ, ¿e wybrany jako niezmiennik warunek jest prawdziwy
we wszystkich pokazanych miejscach, pêtla koñczy dzia³anie, a po jej zakoñczeniu 
z niezmiennika mo¿emy wyprowadziæ zamierzony wynik dzia³ania pêtli, to -
nasza pêtla jest poprawna (gwoli ¶cis³o¶ci: trzeba jeszcze zapewniæ spe³nienie
jakich¶ warunków pocz±tkowych, w naszym przyk³adzie bêdzie to <i><b>n &gt; 0</b></i>).<br>
<br> Faktycznie, przed wej¶ciem w pêtlê, i=1, vmin = a[0], zatem <i><b>vmin</b></i> jest minimum
z (a[0]...a[i-1]), bo zbiór ten zawiera tylko jedn± liczbê a[0]. Wobec tego
w miejscu N0 niezmiennik jest prawdziwy. Je¿eli w miejscu N0 niezmiennik
jest prawdziwy, to w pierwszej iteracji - w miejscu N1 równie¿ bêdzie prawdziwy
(bo wyra¿enie stanowi±ce warunek kontynuacji nie zmienia warto¶ci <i><b>i</b></i>, <i><b>vmin</b></i>, oraz elementów tablicy <i><b>a</b></i>).<br>
Dalej mo¿emy ³atwo wykazaæ ¿e, je¿eli w jakiejkolwiek iteracji niezmiennik
jest prawdziwy w miejscu N1, to bêdzie równie¿ prawdziwy w miejscu N2. We¼my
i-t± iteracjê. W miejscu N1 zachodzi  <i><b>vmin ==
minimum (a[0], ... a[i-1])</b></i>. Nastêpnie warto¶æ <i><b>a[i]</b></i> porównywana jest z warto¶ci± <i><b>vmin</b></i>, je¶li jest mniejsza, to <i><b>vmin = a[i]</b></i>, w przeciwnym
razie minimum siê nie zmienia i w obu przypadkach w miejscu N2 (po zwiêkszeniu <i><b>i</b></i> o 1) znowu zachodzi  <i><b>vmin == minimum(a[0],
 ... . a[i-1])</b></i>.<br>Je¶li niezmiennik jest prawdziwy w miejscu N2,
to - przy kontynuacji pêtli - jest równie¿ prawdziwy w miejscu N1. Natomiast
gdy warunek kontynuacji nie jest spe³niony - prawdziwo¶æ w N2 implikuje prawdziwo¶æ
niezmiennika w N3.<br>
Pêtla na pewno skoñczy dzia³anie, bowiem w ka¿dej iteracji <i><b>i</b></i> jest zwiêkszane, a¿ osi±gnie warto¶æ <i><b>n</b></i>.<br>
W miejscu N3 wyra¿enie stanowi±cc niezmiennik bezpo¶rednio okre¶la poprawno¶æ
zamierzonego wyniku dzia³ania pêtli: otrzymali¶my minimum ze wszystkich elementów
tablicy. <br>
<br>
Zobaczmy wiêc: niezmiennik dobrali¶my tak by "prowadzi³ nas" do koñcowego wyniku.
By³oby raczej bez sensu u¿yæ tu jakiego¶ innego niezmiennika.<br>Nie zawsze
uda siê osi±gn±æ tak bezpo¶redni efekt, ale na podstawie dobrze dobranego
niezmiennika pêtli mo¿na znacznie sobie u³atwiæ  stworzenie poprawnego algorytmu
rozwi±zania jakiego¶ problemu.<br>
<br>
No, dobrze, ale czy zawsze musimy przekszta³caæ pêtle for do pêtli while - by poprowadziæ rozumowanie za pomoc± niezmienników?<br>
Niekoniecznie. Bardzo czêsto w pêtlach for, w których mamy do czynienia z
prost± zmian± licznika iteracji  mo¿emy tego nie robiæ.<br>
Ze wzglêdu na konstrukcjê takich pêtli  (przypomnijmy: inicjacja licznika
wykonywana jest raz, warunek kontynuacji sprawdzany jest przed ka¿dym wykonaniem
iteracji, a wyra¿enie zmieniaj±ce licznik wykonywane jest po wykonaniu instrukcji
pêtli) niezmiennik mo¿na "umie¶ciæ" na pocz±tku ka¿dej iteracji oraz po pêtli:<br>
<br>
for (.....) {<br>
    // Niezmiennik<br>
    instrukcje pêtli<br>
}<br>
// Niezmiennik<br>
      
<br>W naszym przypadku poszukiwania minimum z elementów tablicy mogliby¶my zapisaæ:<br>
<br>

<pre>
  static int getMin(int[] a) {
    int vmin = a[0];
    for (int i=1; i &lt; a.length; i++) {
      <b><font color="#ff6600">// NIEZMIENNIK: vmin == minimum (a[0],.. a[i-1])</font></b>
      if (a[i] &lt; vmin) vmin = a[i];
    }
    <b><font color="#ff6600">// NIEZMIENNIK: vmin == minimum (a[0],.. a[i-1])</font></b>
   return vmin;
     
  }
</pre>

<p>
£atwo zobaczyæ, ¿e niezmiennik jest prawdziwy w ka¿dej iteracji oraz po zakoñczeniu pêtli.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index106.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index108.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
