<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index98.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index100.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 3"></A><div class="tytulpunktu">3. Opakowanie typów pierwotnych</div>

<a name="W12.3"></a><A NAME="EDU.skorowidz.termin opakowanie_typów_pierwotnych 99_682"></A> 
<p>Widzieli¶my ju¿ w praktyce, ¿e znakowa reprezentacja liczb  (napisy  reprezentuj±ce
liczby) - to zupelnie co innego ni¿ ich wewnêtrzna, binarna postaæ.<br>
W³a¶nie dlatego uporczywie musieli¶my u¿ywaæ metody parseInt z klasy Integer
do przekszta³cania znakowej (napisowej) postaci liczb ca³kowitych na ich
binarn± wewnêtrzn± postaæ.<br>
Powstaje pytanie: co to za klasa Integer? I co robiæ z innymi typami liczb: np. rzeczywistymi ?<br>
Otó¿ bardzo czêsto wystêpuje potrzeba traktowania liczb jako obiektów. Tymczasem
liczby s± reprezentowane przez typy pierwotne (i nie s± obiektami). Dlatego
w standardowym pakiecie java.lang umieszczono specjalne klasy, opakowuj±ce
liczby (w ogóle wszystkie typy pierwotne) i czyni±ce z nich obiekty.<br>
Nale¿± do nich nastêpuj±ce klasy:<br>
<ul>
  <li><A NAME="EDU.skorowidz.termin Integer 99_683"></A> Integer</li>
  <li><A NAME="EDU.skorowidz.termin Short 99_684"></A> Short</li>
  <li><A NAME="EDU.skorowidz.termin Byte 99_685"></A> Byte</li>
  <li><A NAME="EDU.skorowidz.termin Long 99_686"></A> Long</li>
  <li><A NAME="EDU.skorowidz.termin Float 99_687"></A> Float</li>
  <li><A NAME="EDU.skorowidz.termin Double 99_688"></A> Double</li>
</ul>

<p>
Obiekty tych klas reprezentuj± (w sposób obiektowy) liczby odpowiednich typów.<br>
Np. obiektowy odpowiednik liczby 5 typu int mo¿emy uzyskaæ tworz±c obiekt klasy Integer:<br>
<br>
Integer a = new Integer(5);<br>
<br>
Mówimy o opakowaniu liczby 5, bowiem liczba ta jest umieszczana "w ¶rodku" obiektu klasy Integer, jako jego element.<br>
<br>
Klasy opakowuj±ce nie dostarczaj± ¿adnych metod do wykonywania operacji na
liczbach. Z obiektu takiej klasy musimy liczbê "wyci±gn±æ" za pomoc± odpowiednich
metod, np.<br>
<br>
int i = a.intValue(); // zwraca warto¶æ typu int, "zawart±" w obiekcie a<br>
<br>
Podobnie:<br>
<br>
Double dd = new Double(7.1);<br>
double d = dd.doubleValue(); // d == 7.1 <br>
<br>
Po co to wszystko? Po co takie opakowanie mo¿e byæ potrzebne? Pamiêtamy z wykladów o klasach i tablicach, ¿e:<br>
<ol>
  <li>ka¿da klasa w Javie dziedziczy po¶rednio (lub bezpo¶rednio) klasê Object</li>
  <li>zatem referencji do obiektu klasy Object mo¿emy przypisac referencjê do obiektu dowolnej innej klasy</li>
  <li>tablice mog± zawieraæ referencje do dowolnych obiektów<br>
  </li>
</ol>

<p>
Wyobra¼my sobie teraz, ¿e mamy jak±¶ tablicê, w kolejnych elementach której
chcemy zapisywaæ dowolne informacje. Czy to mo¿liwe? Ale¿ tak - w³a¶nie dziêki
wymienionym wy¿ej trzem w³a¶ciwo¶ciom - pod warunkiem jednak, ¿e informacja
ta bêdzie przedstawiana w sposób obiektowy (jako obiekty).<br>
Mo¿emy zatem stworzyæ tablicê, za pomoc± której jednocze¶nie bêdziemy rejestrowaæ
np. i napisy (³añcuchy znakowe) i liczby. Te ostatnie jednak musimy "opakowaæ"
odpowiednimi klasami: Integer, Double itd.<br>
<br>
Na przyk³ad:<br>
<br>
Object[] tab = new Object[4];<br>
tab[0] = "Kowalski";<br>
tab[1]  = new Integer(28);<br>
tab[2] = "Kowalska";<br>
tab[3] = new Integer(30);<br>
<br>
W ³atwy sposób mo¿emy pokazaæ wszystkie elementy tablicy.<br>
<br><A NAME="EDU.skorowidz.termin toString 99_689"></A> 

<div class="syntax">
Metoda <b>toString()</b> zastosowana wobec obiektu dowolnej klasy zwraca
napis, bêd±cy znakow± reprezentacj± tego obiektu. Definicje tej metody w
klasach okreslaj± jak obiekty tych klas s± przedstawiane w postaci napisów<br>
</div>

<br>
<p>
W przypadku powy¿szego przyk³adu wypisanie wszystkich elementów tablicy wygl±da tak:<br>
<br>
for (int i=0; i&lt;tab.length; i++) <br>
    System.out.println(tab[i].toString());<br>
<br>
co da napisy:<br>
Kowalski<br>
28<br>
Kowalska<br>
30<br>
<br>
Jednak, gdyby¶my wobec obiektów zarejestrowanych w tablicy chcieli u¿yæ metod
ich klas (albo - wobec obiektów klasy String - operatora konkatenacji ³añcuchów
znakowych), to natkniemy siê na dwa problemy.<br>
<br>
Po pierwsze, po to by zastosowaæ metody jakiej¶ klasy musimy rozpoznaæ w³a¶ciwe obiekty, stwierdziæ do jakiej klasy nale¿±. <br>
Operujemy przecie¿ elementami typu Object. W naszym przyk³adzie ka¿dy z nich
mo¿e wskazywaæ na obiekt klasy Integer albo obiekt klasy String.<br>
<br><A NAME="EDU.skorowidz.termin instanceof operator 99_690"></A> 
<div class="syntax">
    Stwierdzeniu do jakiej klasy nale¿y obiekt s³u¿y operator <b>instanceof</b>.<br>
<br>
Wyra¿enie:<br>
<br>
        <b><i>nazwa_zmiennej</i>  instanceof  <i>nazwa_klasy</i></b><br>
<br>
ma warto¶æ true, je¶li zmienna <b><i>nazwa_zmiennej</i></b>   jest referencj± do obiektu klasy <b><i>nazwa_klasy</i></b><br>
</div>

<br>
<p>
Np. je¶li:<br>
<br>
Object[] tab = { "Kowalski", new Integer(28) };<br>
<br>
to<br>
        tab[0] instanceof String   - ma warto¶æ true<br>
        tab[0] instanceof Integer  - ma warto¶æ false<br>
        tab[1] instanceof String    -  ma warto¶æ false<br>
        tab[1] instanceof Integer  - ma warto¶æ true<br>
<br>
Drugi problem polega na tym, ¿e dla kompilatora wszystkie elementy tablicy
tab w omawianym przyk³adzie s± typu Object. Jak pamiêtamy, kompilator sprawdza
zgodno¶æ typów. Zatem w kontek¶cie:<br>
<br>
Object[] tab = { "Kowalski", new Integer(28) };<br>
<br>
takie zapisy:<br>
<br>
String s = "";<br>
if (tab[0] instanceof String) s += tab[0];<br>
<br>
int i;<br>
if (tab[1] instanceof Integer) i += tab[1].intValue();<br>
<br>
spowoduj± b³êdy w kompilacji, bowiem:<br>
<ol>
  <li>tab[1] jest typu Object, a wobec Object nie mo¿emy stosowaæ operatora +</li>
  <li>tab[2] jest typu Object, a w klasie Object nie ma  metody intValue</li>
</ol>

<p>
Ale przecie¿ wewn±trz obiektów oznaczanych przez tab[1] i tab[2]  "siedz±"
naprawdê (odpowiednio) - obiekt klasy String i obiekt klasy Integer. Mówi
nam o tym wynik zastosowania operatora instanceof, który w obu przypadkach
jest true. Mo¿emy o tym powiedzieæ kompilatorowi za pomoc±<A NAME="EDU.skorowidz.termin zawê¿aj±ca_konwersja_referencyjna 99_691"></A> zawê¿aj±cej konwersji
referencyjnej (lub - inaczej mówi±c - obiektowej).<br>
<br>

<div class="syntax">
Je¶li klasa B dziedziczy klasê A, to po:<br>
<br>
<b>    B b = new B();<br>
    A a = b;<br>
</b><br>
mo¿emy poinformowaæ kompilator, ¿e <i><b>a</b></i> wskazuje na obiekt klasy B za pomoc± jawnej konwersji zawê¿aj±cej:<br>
<br>
    <b>B c = (B) a;</b><br>
<br>
po czym wobec zmiennej <i><b>c</b></i> bêdziemy mogli u¿ywaæ metod klasy B<br>
</div>

<br>
<p>
W naszym przypadku powinni¶my wiêc zapisaæ:<br>
<br>
Object[] tab = { "Kowalski", new Integer(28) };<br>
<br>
String s = "Jan";<br>

if (tab[0] instanceof String) s +=  (String) tab[0];<br>
<br>

int i = 200;<br>
if (tab[1] instanceof Integer)  {<br>
    Integer liczba = (Integer) tab[1];<br>
    i += liczba.intValue();<br>
}<br>
 <br>
i w tym momencie zarówno kompilacja jak i wykonaie programu bêd± pomy¶lne, daj±c: <br>
s == "JanKowalski"<br>
i == 228;<br>
<br>
Zadanie: w dwóch tablicach zapisane s± imiona graczy (w jak±¶ grê) oraz punkty przez nich uzyskane:<br>
    String[] name = { "Ala", "Ela", "Jan"};<br>
    int[]  points = { 10, 12, 11 };<br>
<br>
Stworzyæ <b>jedn±</b> tablicê <i><b>tab</b></i>, w której bêdzie zapisana sekwencja wyników: imiê, punkty, imiê, punkty...<br>
po czym, korzystaj±c tylko z tablicy <i><b>tab</b></i>, w kolejnych wierszach
wypisaæ zestawy imiê - punkty, podaæ (w jednym wierszu) imiona wszystkich
graczy, a nastêpnie sumê punktów, któr± uzyskali.<br>
Przyk³adowy wydruk:<br><br>

<div class="listing100">
W grze punkty uzyskali: <br>
Ala 10<br>
Ela 12<br>
Jan 11<br>
Grali:  Ala Ela Jan<br>
Zdobyli ³±cznie: 33 pkt.<br>
</div>

<br>

<div class="important">
<br>
Przed lektur± dalszego tekstu proszê to zadanie rozwi±zaæ samodzielnie
<br>
<br>





</div>

<br>

<p>
Mo¿liwe rozwi±zanie:<br>

<pre>
public class Wrap {

  public static void main(String[] args) {


    String[] name = { "Ala", "Ela", "Jan"};
    int[]  points = { 10, 12, 11 };
    Object[] tab = new Object[name.length*2];

    int k = 0;
    for (int i=0; i&lt;name.length; i++) {
      tab[k++] = name[i];
      tab[k++] = new Integer(points[i]);
    }

   System.out.println("W grze punkty uzyskali: ");
   for (int i=0; i &lt;tab.length; i+=2)
     System.out.println(tab[i].toString() + " " + tab[i+1].toString());

   String players = "";
   int pointSum = 0;

   for (int i=0; i &lt; tab.length; i++) {
     if (tab[i] instanceof String)
       players += " " + (String) tab[i];
     else if ( tab[i] instanceof Integer)
       pointSum += ((Integer) tab[i]).intValue();
   }

   System.out.println("Grali: " + players);
   System.out.println("Zdobyli ³±cznie: " + pointSum + " pkt.");

  }

}
</pre>

<p>
Niejako przy okazji, w klasach opakowuj±cych typy pierwotne zdefiniowano statyczne metody:<br>
<br>

<div class="syntax">
<b>            public static <i>ttt</i>  parse<i>Ttt</i>(String </b><i>s</i><b>)</b><br>
<br>

zwracaj±ce warto¶ci typu <i><b>ttt</b></i> reprezentowane przez napis <i><b>s</b></i><br>
<br>

gdzie: <i><b>ttt</b></i> nazwa typu pierwotnego (np. int, double), Ttt - ta sama nazwa z kapitalizowan± pierwsz± liter± (np. Int, Double)<br>

</div>

<br>
<p>
A wiêc, po to by przeksta³ciæ napis <i><b>s</b></i> reprezentuj±cy liczbê rzeczywist± do typu double nale¿y napisaæ:<br>
<br><A NAME="EDU.skorowidz.termin Double.parseDouble 99_692"></A> double d = Double.parseDouble(s); <br>
<br>
np.<br>
<br>
String s = "12.4";<br>
double d = Double.parseDouble(s);  // d == 12.4<br>
<br>
U¿ytecznych dodatkowych metod dostarcza<A NAME="EDU.skorowidz.termin Character klasa 99_693"></A> klasa Character (opakowujaca typ char).<br>
Nale¿± do nich metody stwierdzania rodzaju znaku np.:<br>
<br><A NAME="EDU.skorowidz.termin isDigit 99_694"></A> isDigit()             // czy znak jest znakiem cyfry<br><A NAME="EDU.skorowidz.termin isLetter 99_695"></A> isLetter()           // czy znak jest znakiem litery<br><A NAME="EDU.skorowidz.termin isLetterOrDigit 99_696"></A> isLetterOrDigit() // litera klub cyfra<br><A NAME="EDU.skorowidz.termin isWhiteSpace 99_697"></A> isWhiteSpace()   // czy to "bia³y" znak (spacja, tabulacja etc.)<br><A NAME="EDU.skorowidz.termin isUpperCase 99_698"></A> isUpperCase();  // czy to du¿a litera   <br><A NAME="EDU.skorowidz.termin isLowerCase 99_699"></A> isLowerCase();  // czy to ma³a litera<br>

<br>
Metody te zwracaj± warto¶ci true lub false.<br>
<br>
<b><font color="#ff6600">Proszê zapoznaæ siê z dokumentacj± klasy Character</font></b>.<br>

<br>
W klasach opakowuj±cych typy numeryczne zdefiniowano tak¿e wiele u¿ytecznych
statycznych sta³ych. Nale¿± do nich sta³e zawieraj±ce<A NAME="EDU.skorowidz.termin maksymalne_i_minimalne_warto¶ci_danego_typu 99_700"></A> maksymalne i minimalne
warto¶ci danego typu.<br>
Maj± one nazwy<A NAME="EDU.skorowidz.termin MAX_VALUE 99_701"></A> MAX_VALUE i<A NAME="EDU.skorowidz.termin MIN_VALUE 99_702"></A> MIN_VALUE.<br>
Dziêki temu nie musimy pamiêtaæ zakresów warto¶ci danego typu.<br>
Mo¿emy np. zsumowaæ wszystkie dodatnie liczby typu short:<br>
<br>

<pre>
public class MaxVal {

  public static void main(String[] args) {

    long sum = 0;
    for (int i=1; i &lt;= Short.MAX_VALUE; i++) sum +=i;
    System.out.println(sum);

  }

}
</pre>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index98.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index100.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
