<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index18.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index20.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Iteracje</div>

<a name="W3.2"></a>

<p>Bardzo czêsto pewne instrukcje lub grupy instrukcji bêdziemy
chcieli    wykonywaæ   wielokrotnie.<br>
            Na przyk³ad okre¶lon± liczbê razy. Lub dopóki spe³niony jest
jaki¶    warunek.<br>
         <br><A NAME="EDU.skorowidz.termin pêtla_iteracyjna 19_156"></A> Zapewniaj± to instrukcje steruj±ce nazywane <b>instrukcjami pêtli
  iteracyjnych</b>. <br>
            Rozwa¿ymy dwie formy takich instrukcji.<br>
         <br>
            Pierwsza s³u¿y do wykonywania instrukcji okre¶lon± liczbê razy,
 jednocze¶nie     zmieniaj±c warto¶æ zmiennej, nazywanej licznikiem. Ma ona postaæ:<br>
         <br>

<div class="syntax">         <br>
        <b>do</b><i> licznik</i> = <i>wart_pocz</i><b> to</b><i> wart_konc</i>
     [ <b>by</b><i> krok</i>  ]<br>
     <i>        ins1;</i><br>
     <i>        ins2;</i><br>
     <i>        ...</i><br>
     <i>        insN;</i> <b><br>
        end</b><br>
    <br>
    gdzie:<br>

<ul>
               <li><A NAME="EDU.skorowidz.termin licznik 19_157"></A> licznik - nazwa zmiennej bêd±cej licznikiem</li>
               <li>    wart_pocz - pocz±tkowa warto¶æ licznika</li>
               <li>    wart_konc - koñcowa warto¶æ licznika</li>
               <li>    krok - o ile zwiêksza siê w ka¿dej iteracji warto¶æ
 licznika;  gdy nie podano klauzuli by, przyjmuje siê krok = 1</li>
               <li>    instrukcja1,... instrukcjaN - instrukcje wykonywane
 w  pêtli</li>

</ul>

</div>

<br>
<p>Pêtla ta wykonywana jest w nastêpuj±cy sposób: 

<div class="notel"> Zmienne oznaczaj±ce
   liczniki pêtli nazywamy zwykle krótko: i, j, k, l
</div>

<div class="ddd">

<ol>
               <li>Zmiennej <i>licznik</i> przypisywana jest warto¶æ wyra¿enia<i>
         wart_pocz</i></li>
               <li>Sprawdzany jest warunek: <i>licznik</i> &lt;=  <i>wart_konc</i>. Je¿eli warunek jest prawdziwy to wykonywane s± instrukcje zawarte
   w  pêtli  (do napotkania s³owa end - a wiêc <i>ins1, ins2.. insN</i>).
W  przeciwnym   razie (je¿eli <i>licznik &gt; wart_konc</i>) sterowanie opuszcza
  pêtle i  jest przekazywane do instrukcji po s³owie end.</li>
               <li>Zmienna <i>licznik</i> zostaje zwiêkszona o warto¶æ wyra¿enia
             <i>    krok</i>. Wracamy do punktu 2</li>

</ol>
</div>
<br clear="all">

<p>Rozpatrzmy przyk³ady. Poni¿szy program wypisuje na konsoli kwadraty
   liczb   ca³kowitych od 1 do 100.<br>

<pre>
/* Kwadraty liczb ca³kowitych od 1 do 100 */

do i = 1 to 100
   say i i*i;
end
</pre>

<p>Zmiennej <i><b>i</b></i> nadawana jest warto¶æ 1. Warto¶æ ta
mniejsza    jest od 100, zatem wykonywana jest instrukcja w pêtli (say ...),
wyprowadzaj±ca    na konsolê warto¶æ zmiennej <i><b>i</b></i> oraz - po spacji
- jej kwadrat.    Przy napotkaniu s³owa end sprawdzany jest warunek kontynuacji
pêtli (czy        <i><b>i</b></i> &lt;= 100). Warunek jest prawdziwy, zatem
<i><b>i</b></i>        zwiêksza siê o 1  a instrukcje pêtli wykonywane s± znowu
(wypisywana  jest  warto¶æ <i><b>i</b></i> oraz jej kwadrat:  2  4. </p>

<div class="notel">Terminem <b>sterowanie</b> okre¶lamy kolejno¶æ wykonania instrukcji
   programu. Sformu³owanie "sterowanie przekazywane jest do instrukcji <i>
  ins</i>    " oznacza, ¿e kolejn± wykonywan± instrukcj± w programie bêdzie
 <i>ins</i>    .</div>
 
 <div class="ddd">
 <br><A NAME="EDU.skorowidz.termin sterowanie 19_158"></A> I tak dalej: dopóki warto¶æ <i><b>i</b></i> nie osi±gnie
 101. W tym  momencie warunek kontynuacji pêtli (i &lt;= 100) nie jest spe³niony
 i sterowanie  przekazywane jest do instrukcji po s³owie end. Poniewa¿ nie
 ma ju¿ ¿adnych  instrukcji - program koñczy dzia³anie.
 </div>

<br clear="all">
<br>
<p>Inny przyk³adowy program symuluje sp³aty kredytu. Podajemy na
wej¶ciu: wielko¶æ kredytu, liczbê lat kredytu oraz jego oprocentowanie
(w %). Oprocentowanie pobierane jest wraz z miesiêczn± rat± i obliczane
 jako miesiêczne oprocentowanie      niesp³aconej czê¶ci kredytu. Program
wyprowadza dla kolejnych miesiêcy   okresu   kredytowania nale¿ne sp³aty,
a w podsumowaniu sumê sp³at i  informacjê   o  ile (na skutek oprocentowania)
przekroczy ona wielko¶æ kredytu.

<pre>
/* Symulacja splaty kredytu */

/*---------------------- Wprowadzanie danych */
say "Kredyt?";
kredyt = linein();
say "Liczba lat kredytu?";
lata = linein();
say "Oprocentowanie w skali rocznej?"
proc = linein();

/*---------------------- Obliczenia i wyniki */

proc = (proc/100)/12;   /* odsetki miesiêczne */
lrat = lata * 12;       /* liczba rat */
rata = kredyt / lrat;   /* wielko¶æ raty */

doSplaty = kredyt;      /* ile pozosta³o do sp³aty */

sumaSplat = 0;          /* ile splacono: raty + oprocentowanie */

do i = 1 to lrat
   splata = rata + proc*doSplaty; /* splata = rata + nalezne odsetki */
   doSplaty = doSplaty - rata;
   sumaSplat = sumaSplat + splata;
   say i ':' splata;                 /* informacja o splacie dla i-go miesi±ca */
end

say "Suma sp³at   =" sumaSplat;
say "Ponad kredyt =" sumaSplat - kredyt;

</pre>

<p>W  tym programie pêtla <b><i>do...</i></b>
   wykonywana jest tyle razy ile wynosi  liczba rat do sp³acenia. Zmienna
<i><b>  i</b></i> oznacza numer raty (miesi±ca  sp³aty). Za ka¿dym razem wyliczana
jest sp³ata (która wynosi wielko¶æ raty  + miesiêczna wielko¶æ odsetek od
niesp³acanej jeszcze czê¶ci kredytu). Na  konsolê wyprowadzany jest numer
miesi±ca oraz przypadaj±ca na ten miesi±c   sp³ata. Gdy <b><i> i = lrat</i></b>
  (oststni miesi±c sp³aty) po raz ostatni   obliczana i wyprowadzana jest
informacja o sp³acie. Nastêpnie<b><i>  i </i></b>    zwiêksza siê o 1 i wynosi
<i><b>lrat +1</b></i>. Warunek kontynuacji pêtli   nie jest spe³niony, zatem
sterowanie opuszcza pêtlê (przekazywane jest do   instrukcji po s³owie kluczowym
end - czyli say "Suma splat..."). Na konsolê   wyprowadzane s± informacje
wyj¶ciowe i program koñczy dzia³anie.<br>
<br>


<div class="listing33r"><i>Wydruk dzia³ania programu:</i><br><br>
             Kredyt?<br>
             10000<br>
             Liczba lat kredytu?<br>
             1<br>
             Oprocentowanie w skali rocznej?<br>
             20<br>
             1 : 1000.00000<br>
             2 : 986.111111<br>
             3 : 972.222222<br>
             4 : 958.333333<br>
             5 : 944.444445<br>
             6 : 930.555556<br>
             7 : 916.666667<br>
             8 : 902.777778<br>
             9 : 888.888889<br>
             10 : 875.000000<br>
             11 : 861.111111<br>
             12 : 847.222223<br>
             Suma sp³at   = 11083.3333<br>
             Ponad kredyt = 1083.3333
</div>
			 


<div class="ddd">
<br>Zwróæmy uwagê na zastosowany w tym programie sposób sumowania sp³at.
  Sumê  sp³at uzyskamy w zmiennej sumaSplat. Na pocz±tku jej warto¶æ równa
 jest 0.  W pierwszej iteracji do sumaSplat dodawana jest warto¶c pierwszej
 sp³aty  (w tej chwili sumaSplat równa jest pierwszej sp³acie). W ka¿dej
nastêpnej    iteracji poprzednia suma sp³at jest zwiêkszana o bie¿±c± sp³atê,
a wynik   znowu zapisywany w zmiennej sumaSplat. <br>
        Jest to powszechny sposób sumowania (akumulowania) ró¿nych warto¶ci.
  Mo¿e  on byæ zastosowany nie tylko do warto¶ci numerycznych, ale równie¿
 w innych  przypadkach, np. do kumulatywnego ³±czenia ³añcuchów znakowych.<br>
 </div>
 <br clear="all">
 
<p>Np. w poni¿szym programiku wypisujemy napis sk³adaj±cy siê z n-razy
kolejno   ³±czonych s³ów "Ala" i "kot".<br>

<pre>
/* £±czenie napisów w pêtli */

word1 = "Ala";
word2 = "kot";

n = 8;
string = "";

do i = 1 to n
  if ( i // 2 = 0 ) then string = string||word2;
  else string = string||word1;
end

say string;
</pre>

<br>

<div class="listing33r"><i>Wydruk dzia³ania programu</i><br>
       AlakotAlakotAlakotAlakot</div>
	   
<div class="ddd">
<br>
Na pocz±tku zapisujemy  do zmiennej string
  pusty  ³añcuch znakowy (""). Nastêpnie w pêtli na przemian  dodajemy do
bie¿±cej zawarto¶ci zmiennej string albo s³owo word1, albo s³owo  word2.
</div>
<br clear="all">
<p>Sposób naprzemiennego dodawania jest nastêpuj±cy: je¶li numer iteracji
  (warto¶æ  zmiennej i) jest parzysty, dodajemy zmienn± word2, a je¶li jest
  nieparzysty  - zmienn± word1. <br>

<div class="notel"><b>Uwaga!</b> W Javie operatorem reszty z dzielenia jest <b>%</b><br><br>
</div>

<br>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin operator_reszty_z_dzielenia 19_159"></A> Parzysto¶æ   sprawdzamy za pomoc± u¿ycia operatora reszty z dzielenia
(który w  REXXie oznaczany jest //). Reszta z dzielenia przez 2 dla liczb
parzystych równa jest 0,  a dla nieparzystych ma inn± warto¶æ ni¿ 0. Zwróæmy
te¿ uwagê, ¿e wykorzystali¶my   priorytety operatorów: priorytety operatorów
arytmetycznych (w tym: reszty   z dzielania) s± wy¿sze ni¿ priorytet operatora
równo¶ci =, dlatego w wyra¿enie   i // 2 = 0  najpierw jest stosowany operator
//, a pó¼niej dopiero operator   =,  porównuj±cy wynik wyra¿enia i // 2 z
zerem.
</div>
<br clear="all">

<font color="#ff6600"><b>Proszê zapisaæ i uruchomiæ omawiane wy¿ej programy na w³asnym komputerze. </b></font><br>

<p>Drug±, przedstawian± tu, formê pêtli iteracyjnej realizuje instrukcja
         <b>   do while</b><br>
             <br>
           Ma ona postaæ:<br>
             <br>

<div class="syntax">
        <b>    do while</b> ( warunek )<br>
                ins1;<br>
                ins2;<br>
                ...<br>
                insN;<br>
           <b>        end</b><br>
    <br>
    Instrukcje w pêtli (ins1, ins2, ... insN) wykonywane s± <b>o ile i dopóki
  </b>warunek jest prawdziwy.
</div>

<br>
<p>Poni¿szy program s³u¿y do testowania dzia³ania pêtli <b>do while</b>.<br>

<pre>
say "Podaj a: ";
a = linein();
say "Podaj b: ";
b = linein();
say "a = " a  "b = " b;

n = 0
do while ( a &gt; b)
   a = a - 1;
   n = n + 1
end

say "Pêtla zosta³a wykonana: " n "razy."
say "a = " a  "b = " b;
</pre>

<br>

<div class="listing33r"> <i>Przyk³adowy wydruk dzia³ania programu</i><br>
                 Podaj a:<br>
                 1078.1<br>
                 Podaj b:<br>
                 23.5<br>
                 a =  1078.1 b =  23.5<br>
                 Pêtla zostala wykonana:  1055 razy.<br>
                 a =  23.1 b =  23.5
</div>

<div class="ddd">
<br>
Podajemy w nim warto¶ci zmiennych a i b. Pêtla do while zawiera
warunek    (a &gt; b) zatem: 

<ul>
                   <li>jej wykonanie rozpocznie siê tylko wtedy, gdy warunek
  jest  spe³niony  (a &gt; b)</li>
                   <li>w pêtli a ulegnie zmniejszeniu o 1</li>
                   <li>je¶li nadal bêdzie wiêksze od b, to instrukcje petli
 zostan±    powtórzone</li>
                   <li>bêd± one powtarzane <b>dopóki</b> a bêdzie wiêksze
od  b</li>
                   <li>gdy a stanie siê równe lub mniejsze od b, pêtla zakoñczy
   dzia³anie<br>
                   </li>

</ul>
</div>

<br clear="all">

<p><font color="#ff6600"><b>Proszê zapisaæ i uruchomiæ omawiany wy¿ej program na w³asnym komputerze. </b></font><br>
<br>
Pêtle iteracyjne (do..., do while) jak równie¿ instrukcje if  mog± byæ dowolnie zagnie¿d¿one.<br>
<br>

<div class="def"><A NAME="EDU.skorowidz.termin zagnie¿d¿enie_konstrukcji_jêzykowych 19_160"></A> Zagnie¿d¿enie konstrukcji jêzykowych oznacza umieszczanie ich jedna -
w - drugiej
</div>
<br>

<p>Na przyk³ad, ca³kiem dopuszczalny jest taki schemat:<br>
<pre>
do while (a &gt; b)
  do i = 1 to N
    ....
    do j = 1 to M
       .....
       do while (s = "")
          ...
       end
    end
  end
end
</pre>

<p>Istotn± spraw± przy zagnie¿d¿aniu instrukcji steruj±cych jest "dopasowanie"
ich pocz±tków i koñców (w naszym przypadku ka¿demu otwieraj±cemu <b>do</b> musi odpowiadaæ zamykaj±ce <b>end</b>).<br>
Przy takim dopasowaniu pomaga nam odpowiednie formatowanie kodu programu (wcinanie wierszy). <br>
W powy¿szym przyk³adzie widac jeden ze sposobów wykonywania "wciêæ".<br>
<br>
<div class="important"><A NAME="EDU.skorowidz.termin wciêcie 19_161"></A> Wciêcia w kodzie programu zwiêkszaj± jego czytelno¶æ i pozwalaj± ³atwiej odnajdywaæ b³êdy.<br>
Wciêcia s± jednym z elementów tzw.<A NAME="EDU.skorowidz.termin styl_programowania 19_162"></A> <b>stylu programowania</b>, czyli sposobu formatowania kodu tak by by³ przejrzysty.
</div>
<br>
<p>Nale¿y jednak pamiêtaæ, ¿e sposób formatowania kodu programu nie ma nic wspólnego
z jego poprawno¶ci± sk³adniow± i semantyk±. ¯aden kompilator i ¿aden interpreter
nigdy nie stara siê odczytaæ intencji programisty na podstawie zastosowanych
wciêæ.<br>
Np. je¿eli napiszemy:<br>
<br>
if  (a &gt; b) then  <br>
        if ( c &gt; d) then  x = y;<br>
else x = z;<br>
<br>
to byæ mo¿e - w intencji, daj±cej siê odczytaæ z wciêcia else (podpisanie
go pod pierwszym if) - mia³o to oznaczaæ wykonanie instrukcji else gdy warunek
(a &gt; b) jest niespe³niony.<br>
Oczywi¶cie tak siê wcale nie stanie i else dotyczyæ bêdzie drugiego if.<br>
<br>

<center><div class="important"> Wciêcia nie maj± nic wspólnego z semantyk± programu.</div>
</center>

<br>
<p>Mo¿emy zmieniaæ naturalne dzia³anie pêtli iteracyjnych za pomoc± instrukcji:<br>
<ul>
  <li><A NAME="EDU.skorowidz.termin przerwanie_dzia³ania_pêtli 19_163"></A> przerwania dzia³ania pêtli</li>
  <li><A NAME="EDU.skorowidz.termin kontynuacja_dzia³ania_pêtli 19_164"></A> kontynuacji dzia³ania pêtli<br>
  </li>
</ul>

<div class="notel">W Javie s³u¿y temu instrukcja <b>break</b><br><br></div>

<div class="ddd">Przerwanie dzia³ania pêtli uzyskujemy w REXXie za pomoc± instrukcji <b>leave</b> (opu¶æ pêtlê). Przerywana jest najbardziej wewnêtrzna pêtla, lub je¶li w instrukcji leave u¿yjemy etykiety (<b>leave <i>jakasEtykieta</i></b>) - pêtla oznaczona t± etykiet±.
</div>

<br clear="all">

<p>Np.<br>

<pre>
do i = 1 to 100000
   n = i * i;
   if (n &gt; 20000) then leave;
end
say i n;
</pre>

<div class="listing25l">Wynik<br>
142 20164
</div>

<p>Pêtla wykona³a siê 142 razy (a nie 100000 jak wskazuje górna warto¶æ
licznika), poniewa¿ gdy n jest wiêksze od 20000 przerywamy dzia³anie pêtli
za pomoc± instrukcji leave (sterowanie zostaje przekazane poza end koñcz±ce
pêtlê).<br>
<br>
Kontynuacja dzia³ania pêtli polega na natychmiastowym przekazaniu sterowania na koniec pêtli, co inicjuje now± iteracjê. <br><br>

<div class="notel">W Javie mamy tu instrukcjê <b>continue</b><br><br></div>

<div class="ddd"><br>W Rexxie s³u¿y temu instrukcja <b>iterate</b> (tak samo jak leave mo¿e dotyczyæ najbardziej wewnêtrznej z zagnie¿d¿onych pêtli lub pêtli oznaczonej podan± etykiet±).
</div>

<br clear="all">
<p>Na przyk³ad w poni¿szym programie wczytujemy z konsoli wszystkie wprowadzone
przez u¿ytkownika napisy, pomijaj±c puste wiersze (np. spacje lub samo ENTER),
³±czymy je w jeden ³añcuch znakowy i wyprowadzamy po wprowadzeniu przez u¿ytkownika
s³owa quit, koñcz±c na tym dzia³anie programu.<br>
<br>

<pre>
out = '';

do forever
  txt = linein();
  if ( txt = "" ) then iterate;
  if ( txt = "quit" ) then leave;
  out = out txt;
end
say out;
</pre>

<br>
<div class="notel">W Javie tak± nieskoñczon± pêtlê mo¿emy zapisaæ jako <b>while ( true )</b> {...}</div>

<div class="ddd"><br>Warto tu zwróciæ uwagê na sk³adniow± konstrukcjê <b>do forever</b>, oznaczaj±c± pêtlê nieskoñczon± (wykonuje siê wiecznie; oczywi¶cie zawsze
trzeba mieæ jaki¶ sposób, warunek przerwania takiej pêtli).
</div>

<br clear="all"><br>

<p>Generalnie, warto szczególnie podkre¶liæ problem w³a¶ciwego koñczenia wykonywania
pêtli iteracyjnych. Niezwykle czêsto bowiem na skutek b³êdów w programie
pêtle nie koñcz± dzia³ania i program wykonuje siê bez koñca. Czasami jedynym
sposobem jego zatrzymania jest zakoñczenie procesu z poziomu systemu operacyjnego.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index18.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index20.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
