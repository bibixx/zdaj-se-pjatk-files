<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index64.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 6"></A><div class="tytulpunktu">6. Struktura programu. Dzia³anie aplikacji</div>

<a name="W8.7"></a><A NAME="EDU.skorowidz.termin program struktura 65_555"></A> <p>
Jak wiemy, program w Javie jest zestawem definicji klas.<br>
<br><A NAME="EDU.skorowidz.termin aplikacja dzia³anie 65_556"></A> 

<div class="important">Poza cia³em klasy nie mo¿e byæ ¿adnego kodu programu - oprócz dyrektywy package, dyrektyw importu oraz komentarzy.</div>

<br>
<p>
Strukturê programu obrazuje poni¿szy schemat.<br>

<pre>
package ...   // deklaracja pakietu (niekonieczna)
import ...    // deklaracje importu; zwykle, ale nie zawsze potrzebne
import ...


// To jest klasa A

public class A {
...
}


// To jest klasa B

class B {
...
}
...


</pre>

<p>
Dyrektywa package s³u¿y do "umieszczenia" kompilowanych klas w nazwanym pakiecie
(w tym semestrze nie bêdziemy si± ni± jednak zajmowaæ). Znaczenie importów
- poznali¶my przed chwil±.<br>
<br><A NAME="EDU.skorowidz.termin program w_Javie 65_557"></A> 
Program  mo¿e byæ zapisany w jednym lub wielu<A NAME="EDU.skorowidz.termin plik_¼ród³owy 65_558"></A> plikach ¼ród³owych (.java) <br>
(w szczególno¶ci: wszystkie klasy sk³adaj±ce siê na program mo¿na umie¶ciæ
w jednym pliku albo ka¿d± klasê mo¿na umie¶ciæ w odrêbnym pliku).<br>
<br>
Nie ma kodu poza klas±... A z drugiej strony wiemy te¿, ¿e klasa jest swoistym
wzorcem, szablonem okre¶laj±cym w³a¶ciwo¶ci obiektów.<br>
<br>
Jak zatem mo¿liwe jest w ogóle dzia³anie programu napisanego w Javie? Gdzie i jak zaczyna siê wykonanie?<br>
Powtórzmy sobie najpierw to wszystko co ju¿ wiemy <br>
<br>
Oczywi¶cie, najpierw jest kompilacja do B-kodu. <br>
Wszystkie wybrane pliki ¿ród³owe .java podlegaj± kompilacji za pomoc± kompilatora
Javy (javac.exe). Z ka¿dej klasy w pliku(ach) ¼ród³owym powstaje plik B-kodu
o rozszerzeniu .class <br>
<br>
Mamy teraz trzy mo¿liwo¶ci: albo nasz program jest aplikacj±, albo apletem,
albo serwletem. Zostañmy na razie przy pierwszej (dwie pozosta³e omówimy
w przysz³ym semestrze). <br>
 <br>
Je¿eli nasz program jest aplikacj±, to jedna z  klas musi zawieraæ metodê: <br>
<br>
   <A NAME="EDU.skorowidz.termin main 65_559"></A> <b>public static void main(String[ ] args) </b><br>
<br>
Np. spójrzmy na klasê Work i klasê Inna zdefiniowane w pliku Work.java <br>
<br>
public class Work { <br>
 public static void main(String[] args) { <br>
    ... <br>
  } <br>
... <br>
} <br>
class Inna { <br>
... <br>
} <br>
  <br>
// Koniec pliku Work.java <br>
<br>
Po kompilacji (javac Work.java) powstaj± dwa pliki: <br>
Work.class <br>
Inna.class <br>
  <br>
Maszyna wirtualna Javy jest wywo³ana za pomoc± polecenia java z argumentami: <br>
<ul>
  <li>nazwa_pliku_class_zawieraj±cego_metodê_main (bez rozszerzenia .class)</li>
  <li>argumenty_wo³ania </li>
</ul>
<p>
 java Work [ew. argumenty przekazywane do main jako String[ ] args] <br>
<br>
<b>Klasa Work zostaje za³adowana przez JVM i sterowanie zostaje przekazane
do metody main. W tej metodzie zaczyna siê "¿ycie": tworzenie obiektów, odwo³ania
do innych klas aplikacji. <br>
</b><br>
Zauwa¿my jednak szczególnie jedn± wa¿n± rzecz: metoda main jest metod± statyczn±.
Wobec tego - dzia³anie (jakiego¶) programu nie wymaga wcale by istnia³y lub
by³y tworzone obiekty (o ile pos³ugujemy siê w metodzie main tylko zmiennymi
typów pierwotnych).<br>
Nawet je¶li pos³ugujemy siê obiektami (takimi jak ³añcuchy znakowe) - nie
musimy tworzyæ obiektu klasy, w której zawarta jest metoda main.<br>
<br>
Takie podej¶cie jest jednak mo¿liwe tylko wtedy, gdy nasz program jest stosunkowo
niewielki. Wiêksze programy powinni¶my co najmniej dobrze strukturyzowaæ
(rozbiæ na funkcje - metody).<br>
<br>
Zobaczmy bardzo prosty przyk³ad. Mamy trzy liczby i powinni¶my policzyæ i
wyprowadziæ ich sumê oraz ¶redni±, po czym wszystkie trzy liczby dwa razy
zwiêkszyæ o 1, za ka¿dym razem wyprowadzaj±c now± sumê i ¶redni±.<br>
<br>
Bardzo z³e rozwi±zanie tego problemu mo¿e wygl±dac tak.<br>

<pre>
public class Main1 {

  public static void main(String[] args) {
    double a = 12.0,
           b = 14.0,
           c =  4.0;
    double sum = a + b + c;
    double avg = (a + b + c)/3;
    System.out.println("Suma " + sum);
    System.out.println("Srednia " + avg);
    a++;
    b++;
    c++;
    sum = a + b + c;
    avg = (a + b + c)/3;
    System.out.println("Suma " + sum);
    System.out.println("Srednia " + avg);
    a++;
    b++;
    c++;
    sum = a + b + c;
    avg = (a + b + c)/3;
    System.out.println("Suma " + sum);
    System.out.println("Srednia " + avg);

  }
</pre>

<p>
Oczywi¶cie na my¶l przychodzi od razu podzia³ programu na metody.<br>
Byæ mo¿e, d³ugo nie zastanawiaj±c siê napiszemy tak:<br>

<pre>
public class Main2 {

 double sum(double a, double b, double c) {
   return a + b + c;
 }

 double average(double a, double b, double c) {
   return (a + b + c)/3;
 }

 void report(double a, double b, double c) {
    System.out.println("Suma " + sum(a, b, c));
    System.out.println("Srednia " + average(a, b, c));
 }


  public static void main(String[] args) {
    double a = 12.0,
           b = 14.0,
           c =  4.0;
    report(a, b, c);
    a++;
    b++;
    c++;
    report(a, b, c);
    a++;
    b++;
    c++;
    report(a, b, c);
  }
} 
</pre>

<p>Chocia¿ wielko¶æ programu zmieni³a siê nieznacznie, to jednak klarowne wyodrêbnienie
pewnych powtarzalnych czynno¶ci w postaci metod czyni go bardziej czytelnym
i elastycznym (latwiej modyfikowalnym).<br>
Niestety, spotka nas rozczarowanie...<br>
Kompilator zg³osi:<br><br>

<div class="listing100"> <br>
Main2.java:21: non-static method report(double,double,double) cannot be referenced from a static context<br>
    report(a, b, c);<br>
    ^<br>
Main2.java:25: non-static method report(double,double,double) cannot be referenced from a static context<br>
    report(a, b, c);<br>
    ^<br>
Main2.java:29: non-static method report(double,double,double) cannot be referenced from a static context<br>
    report(a, b, c);<br>
    ^<br>
3 errors<br>
</div>

<br>
<p>
Aha, przecie¿ metoda main jest statyczna! Nie mo¿emy odwo³ywac siê z jej
wnêtrza do niestatycznych sk³adowych klasy Main2 (a tak± jest metoda report).<br>
<br>
Gdy uczynimy j± statyczn±:<br>
<br>
    <b>static void report(...)</b><br>
<br>
problem przeniesie siê w inne miejsce: ze statycznej metody report nie mo¿emy wywo³aæ niestatycznych metod sum i average. <br>
Mo¿emy uczyniæ je wszystkie statycznymi - i wtedy nasz program zadzia³a.<br>
Albo - pozostawiaj±c wszystkie metody niestatycznymi  - w metodzie main utworzyæ
obiekt klasy i na jego rzecz wywo³aæ metodê report().<br>
Mo¿e to wygl±daæ tak:<br>

<pre>
public class Main3 {

 double sum(double a, double b, double c) {
   return a + b + c;
 }

 double average(double a, double b, double c) {
   return (a + b + c)/3;
 }

 void report(double a, double b, double c) {
    System.out.println("Suma " + sum(a, b, c));
    System.out.println("Srednia " + average(a, b, c));
  }


  public static void main(String[] args) {
    double a = 12.0,
           b = 14.0,
           c =  4.0;

    Main3 m = new Main3(); // utworzenie obiektu
    m.report(a, b, c);
    a++;
    b++;
    c++;
    m.report(a, b, c);
    a++;
    b++;
    c++;
    m.report(a, b, c);

  }

}
</pre>

<p>
Ale skoro ju¿ tworzymy obiekt klasy, to nadajmy jej jaki¶ istotny sens. Na
przyk³ad - niech jej obiekty bêd± trójkami liczb rzeczywistych.<br>
<br>

<pre>
public class Trojka {

 double a, b, c;

 Trojka(double x, double y, double z) {
   a = x;
   b = y;
   c = z;
 }

 double sum() {
   return a + b + c;
 }

 double average() {
   return (a + b + c)/3;
 }

 void increase() {
   a++;
   b++;
   c++;
 }

 void report() {
    System.out.println("Suma " + sum());
    System.out.println("Srednia " + average());
  }


  public static void main(String[] args) {
    Trojka t = new Trojka(12, 14, 4);
    t.report();
    t.increase();
    t.report();
    t.increase();
    t.report();
  }

}

</pre>

<p>
G³ówna "procedura" main (zauwa¿my zreszt±, ¿e umieszczona w klasie Trojka;
metoda main mo¿e przecie¿ znajdowac siê w dowolnej klasie) sta³a sie dziêki
temu jeszcze bardziej klarowna, a ca³y program jeszcze ³atwiejszy do modyfikacji
i uzupe³nieñ, bowiem dane (zmienne a, b, c - zdefiniowane jako pola) sta³y
siê teraz dostêpne dla wszystkich metod klasy i jednocze¶nie zachowuj± swoje
warto¶ci pomiêdzy wywo³aniami metod, co wykorzystali¶my definiuj±c metodê
increase(), zwiêkszaj±c± o1  wszystkie trzy dane.<br>
<br>
Rozpatruj±c ró¿ne warianty strukturyzacji program warto podkre¶liæ, ¿e bardzo
czêsto obiekt klasy programu nie jest nam wcale potrzebny. "Praca" zapisywana
jest w konstruktorze i w metodzie main (rozpoczynaj±cej dzia³anie programu)
wystarczy samo wywo³anie konstruktora. Czyni siê tak szczegolnie czêsto,
gdy konstruktor tworzy graficzny interfejs u¿ytkownika.<br>
W naszym przypadku sumowania i u¶redniania trzech liczb takie rozwi±zanie jest raczej sztuczne, ale dla porz±dku mo¿na je podaæ.<br>

<pre>
public class Main4 {

 double a = 12, b = 14, c = 4;

 Main4() {
   report();
   increase();
   report();
   increase();
   report();
 }

 double sum() {
   return a + b + c;
 }

 double average() {
   return (a + b + c)/3;
 }

 void increase() {
   a++;   b++;   c++;
 }

 void report() {
    System.out.println("Suma " + sum());
    System.out.println("Srednia " + average());
  }

  public static void main(String[] args) {
    new Main4();
  }
}
</pre>

<p>
Zauwa¿my: <br>
<ul>
  <li>poniewa¿ odwo³ania do metod report i increase umie¶cili¶my w konstruktorze,
to nie musimy specyfikowac obiektu do którego siê odnosz± (niejawnie jest
to obiekt oznaczany przez <i><b>this</b></i>)</li>
  <li>metoda main s³u¿y tylko do utworzenia obiektu (i wywo³ania konstruktora);
niepotrzebna jest nam tu ¿adna do niego referencja - dlatego wynik opracowania
wyra¿enia new nie podstawiamy na ¿adn± zmienn±.<br>
  </li>
</ul><p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index64.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
