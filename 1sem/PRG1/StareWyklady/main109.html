<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index108.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index110.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><div class="tytulpunktu">4. Wyj±tki</div>

<a name="W14.4"></a>

<p>Jak wiemy, programowanie w Javie sprowadza siê tak naprawdê do tworzenia
obiektów i wywo³ywania na ich rzecz metod (albo te¿ - gdy nie mamy obiektów
- wywo³ywania metod statycznych). W trakcie wykonania metody mo¿e powstaæ
jaki¶ b³±d. <br>
W wielu innych jêzykach (np. w C czy C++) b³êdy powstaj± w trakcie wykonywania funkcji. <br>
Informacja o tym, ¿e wyst±pi³ b³±d winna byæ dostêpna dla innych (korzystaj±cych
z danej funkcji czy metody) czê¶ci programu i s³u¿yæ powinna do odpowiedniego
reagowania na powsta³y b³±d np. poinformowania u¿ytkownika o b³êdzie lub
próby jego poprawienia (poprzez zmianê jakich¶ warto¶ci) b±d¼ te¿ do przerwania
programu.<br><A NAME="EDU.skorowidz.termin obs³uga_b³êdów 109_758"></A> Sposoby w jaki b³êdy s± sygnalizowane innym czê¶ciom programu, a tak¿e  decyzje
i dzia³ania, które programista zapisuje w programie jako reakcje na powsta³e
b³êdy nazywaj± siê <b>obs³ug± b³êdów</b>.<br>
</p>

<p><A NAME="EDU.skorowidz.termin obs³uga_b³êdów tradycyjna 109_759"></A> Tradycyjna obs³uga b³êdów (a raczej ich sygnalizowanie)  polega³o na:</p>

<ul>
<li>zwracaniu przez funkcjê warto¶ci true | false | int, ¶wiadcz±cych o tym,
czy wykonanie zakoñczy³o siê sukcesem, czy te¿ powsta³ b³±d (i jaki ew. jest
jego kod),</li><li> ustawianiu przez funkcjê, w trakcie wykonania której
pojawi³ siê b³±d, flag b³êdów, dostêpnych z innych funkcji (w Javie flagi
takie mogliby¶my definiowaæ jako pola klasy).</li>
</ul>

<p>Problemy, które wystêpuj± przy takim podej¶ciu:

<ul>
<li>
trzeba pamiêtaæ, ¿eby sprawdziæ, czy wyst±pi³ b³±d (np. pamiêtaæ o sprawdzeniu wyniku metody),</li><li>
nie ma standardowych, zunifikowanych ¶rodków sygnalizowania b³êdów i ró¿ni programi¶ci robi± to w ró¿ny sposób,</li><li>
mo¿na pomin±æ sprawdzanie czy wyst±pi³ b³±d.</li>
</ul>

<p>W Javie (poszerzaj±cej do¶wiadczenia jêzyka C++) zaproponowany nowy sposób obs³ugi<br>
 b³êdów - za pomoc± obs³ugi wyj±tków.<br>
</p>
<p><A NAME="EDU.skorowidz.termin wyj±tek 109_760"></A> 
<div class="def">Wyj±tek - to sygna³ o b³êdzie w trakcie wykonania programu</div>

</p>
<p>Wyj±tek powstaje na skutek jakiego¶ nieoczekiwanego b³êdu.
<br>Wyj±tek jest <b>zg³aszany</b> (lub mówi±c inaczej - sygnalizowany).
<br>Wyj±tek jest (mo¿e lub musi byæ) <b>obs³ugiwany</b>.</p><A NAME="EDU.skorowidz.termin obs³uga_wyj±tku schemat 109_761"></A> 

<div class="notec">Prosty schemat obs³ugi wyj±tków<br>
<br>
    <b>try {</b><br>
        //<A NAME="EDU.skorowidz.termin blok_try 109_762"></A> ... w bloku <b>try</b> ujmujemy instrukcje, które mog± spowodowaæ wyj±tek
<br>
    }<A NAME="EDU.skorowidz.termin catch 109_763"></A> catch(<i><b>TypWyj±tku</b></i> exc)  { <br>
        // ... w klauzuli catch umieszczamy obs³ugê wyj±tku<br>
    } <br>
     <br>
Gdy w wyniku wykonania instrukcji w bloku try powstanie wyj±tek typu <i><b>TypWyj±tku</b></i>  to sterowanie zostanie przekazane do kodu umieszczonego w w/w klauzuli catch<br>
</div>

<br>

<p>
Przyk³ady.<br>
<br>
a) Brak jawnej obs³ugi wyj±tku - powsta³y b³±d (wyj±tek) powoduje zakoñczenie
programu, a JVM wypisuje komunikat o jego przyczynie.<br>

<pre>
public class NoCatch {

  public static void main(String[] args) {
    int a = 1, b = 0, c = 0;
    c = a/b;
    System.out.println(c);
  }

}
</pre>

<br>

<div class="listing100">
Exception in thread "main" java.lang.ArithmeticException: / by zero<br>
        at NoCatch.main(NoCatch.java:6)<br>
</div>

<br>
<p>
b) Zabezpieczamy siê przed mo¿liwymi skutkami ca³kowitoliczbowego dzielenia przez zero, obs³uguj±c<A NAME="EDU.skorowidz.termin ArithmeticException 109_764"></A> wyj±tek ArithmeticException<br>
<br>

<pre>
public class Catch1 {

  public static void main(String[] args) {
    int a = 1, b = 0, c = 0;
    String wynik;
    try {
      c = a/b;
      wynik = "" + c;
    } catch (ArithmeticException exc) {
        wynik = "***";
    }
    System.out.println(wynik);
  }

}
</pre>

<p>
W tym przypadku, wykonanie instrukcji c = a/b; spowoduje powstanie wyj±tku
(dzielenie przez zero), a poniewa¿ instrukcja ta znajduje siê w bloku try,
do którego "podczepiona" jest klauzula catch z odpowiednim typem wyj±tku,
to sterowanie zostanie przekazane do kodu w catch, zmienna wynik uzyska warto¶æ
"***", i wynik ten zostanie wyprowadzony na konsolê. Gdyby zmienna b nie
mia³a warto¶ci zero, wyj±tek by nie powsta³, kod w klauzuli catch nie zosta³
by wykonany i na konsolê wyprowadzony by zosta³ wynik dzielenia a/b.<br>
<br>
Mechanizm obs³ugi wyj±tków mo¿e byæ wykorzystywany w bardzo ró¿ny i elastyczny sposób.<br>
Typowym przyk³adem jest<A NAME="EDU.skorowidz.termin weryfikacja_wprowadzanych_przez_u¿ytkownika_danych 109_765"></A> weryfikacja wprowadzanych przez u¿ytkownika danych.<br>
Wielokrotnie w dot±d omawianych przyk³adowych programach ¿±dali¶my od u¿ytkownika
wprowadzania liczb ca³kowitych, a nastêpnie za pomoc± metody parseInt
przeksztalcali¶my ich znakow± reprezentacjê na binarn±. Jak wiemy, je¶li
przy tym wprowadzony napis nie reprezentuje liczby ca³kowitej, to powstaje
wyj±tek<A NAME="EDU.skorowidz.termin NumberFormatException 109_766"></A> NumberFormatException. Powinni¶my go zawsze obs³ugiwaæ.<br>
Mo¿emy wiêc teraz  zmodyfikowaæ np. program wykonywania operacji arytmetycznych na liczbach ca³kowitych:<br>

<pre>
import java.util.*;
import javax.swing.*;

public class Oper {

  public static void main(String[] args) {

    String normalQuest = "Liczba1 op Liczba2",
           errorQuest = "Wadliwe dane. Jeszcze raz.\n" + normalQuest,
           quest = normalQuest;

    String expr;
    int num1 = 0, num2 = 0, res = 0;

    while ((expr = JOptionPane.showInputDialog(quest)) != null) {

      StringTokenizer st = new StringTokenizer(expr);

      if (st.countTokens() != 3) {
          quest = errorQuest;
          continue;
      }

      String snum1 = st.nextToken(),
             sop  = st.nextToken(),
             snum2 = st.nextToken();

     <font color="#3366ff"><b> try {
        num1 = Integer.parseInt(snum1);
        num2 = Integer.parseInt(snum2);
      } catch (NumberFormatException exc) {
          quest = errorQuest;
          continue;</b>
      <b>}</b></font>

      char op = sop.charAt(0);

      switch (op) {
        case '+' : res = num1 + num2; break;
        case '-' : res = num1 - num2; break;
        case '*' : res = num1 * num2; break;
        case '/' : res = num1 / num2; break;
        default: {
          quest = errorQuest;
          continue;
        }
      }
      JOptionPane.showMessageDialog(null, "Wynik = " + res);
      quest = normalQuest;
    }
    System.exit(0);

  }

}
</pre>

<p>
A có¿ to jest NumberFormatException albo ArithmeticExcception? I dlaczego
w klauzuli catch u¿ywamy takich nazw z dodatkiem czego¶, co wygl±da jak zmienna np. catch (NumberFormatException exc) ...<br>

<br><A NAME="EDU.skorowidz.termin wyj±tek 109_767"></A> Otó¿ <b>wyj±tki s± obiektami<A NAME="EDU.skorowidz.termin klasa_wyj±tków 109_768"></A> klas wyj±tków</b>.<br><br>


<div><img src="images/jexcept.gif" hspace="15" height="428" width="553" alt="r" border="1"></div>
<p><b><font size="-1">            
(¯ród³o: Peter Haggar, Java Exception Handling, IBM 1999)</font></b>

<p>Zatem nazwy NumberFormatException, ArithmeticException itd. sa nazwami
klas, a zmienna exc we wczesniejszych przyk³adach jest faktycznie zmienn±
- zawiera referencjê do obiektu odpowiedniej klasy wyj±tku.</p>

<p>Wobec tej zmiennej mo¿emy np. u¿yæ metody toString() uzyskuj±c jako wynik
jej zastosowania opis wyj±tku, taki jaki daje JVM, gdy wyj±tek jest nieobs³ugiwany.
<br>
<br>
Nie zawsze jednak mo¿emy unikn±æ obs³ugi wyj±tku. <br><A NAME="EDU.skorowidz.termin wyj±tki_kontrolowane 109_769"></A> <p><b>WYJ¡TKI KONTROLOWANE I<A NAME="EDU.skorowidz.termin wyj±tki_niekontrolowane 109_770"></A> NIEKONTROLOWANE</b></p>

<ul>
<li>
S± dwa rodzaje wyj±tków: <b>kontrolowane</b> i <b>niekontrolowane</b></li>

<li><A NAME="EDU.skorowidz.termin RuntimeException 109_771"></A> Wyj±tki pochodne od klas RuntimeException i<A NAME="EDU.skorowidz.termin Error 109_772"></A> Error s± niekontrolowane:</li><ul><li>
oznaczaj± one b³êdy fazy wykonania (mniej powa¿ne i powa¿ne),</li>
<li>
mog± wyst±piæ w dowolnym miejscu kodu.</li></ul>
<li>
Pozosta³e wyj±tki s± kontrolowane, co oznacza, ¿e:</li><ul><li>
metody zg³aszaj±ce te wyj±tki wymieniaj± je jawnie w swojej deklaracji
w<A NAME="EDU.skorowidz.termin klauzula_throws 109_773"></A> klauzuli <b>throws,</b></li><li>
metody te mog± zg³aszaæ tylko wymienione w klauzuli <b>throws</b> 
wyj±tki lub wyj±tki ich podklas,</li><li>
odwo³ania do tych metod wymagaj± jawnej obs³ugi ew. zg³aszanych wyj±tków:</li><ul><li>
poprzez konstrukcje try - catch,</li><li>
poprzez wymienienie wyj±tku w klauzuli <b>throws</b> naszej metody (tej która
odwo³uje siê do metody, która mo¿e zg³osiæ wyj±tek) i "przesun±æ" obs³ugê
wyj±tku do miesca wywo³ania naszej metody.</li></ul></ul>
</ul>

<p>Wiele razy natkniemy siê na sytuacjê, w której musimy obslugiwaæ wyj±tki, które mog± powstaæ
 przy wywo³aniau jakich¶ metod ze standardowych klas Javy. Je¶li tego nie
zrobimy, kompilator wyka¿e b³±d w programie. Sytuacja taka dotyczy, na przyk³ad,
metod ze standardowego pakietu  java.io, zawieraj±cego klasy do operowania
na strumieniach danych (m.in. plikach).</p>
<p>Przyk³ad (je¶li oka¿e siê niezrozumia³y, proszê wróciæ do niego po lekturze nastêpnego punktu - o plikach) :</p>

<p>
 String inFname = ...;  // nazwa pliku wej¶ciowego<br>
 String outFname = ... ; // nazwa pliku wyj¶ciowego<br>


 FileInputStream in;
       // pik wej¶ciowy<br>
 FileOutputStream out;     // plik wyj¶ciowy

<br>
 try {
<br>
   in  = new FileInputStream(inFname);
<br>
   out = new FileOutputStream(outFname);
<br>
   int c = 0;
<br>
   while ((c = in.read()) != -1) out.write(c);   // czytanie <i><b>in</b></i> bajt po bajcie<br>
                                                                // zapis kolejnych bajtów do <i><b>out
</b></i>
<br>
<br>
 } catch(FileNotFoundException exc) {
 // obs³uga b³êdu:  nieznany plik<br>
     System.out.println("Plik " + inFname + " nie istnieje.");
<br>
     System.exit(1);

<br>
 }<br>
 } catch(IOException exc) {
  // obs³uga b³êdu:  inny b³±d wej¶cia-wyj¶cia<br>
     System.out.println(exc.toString());
// <br>
     System.exit(1);<br>
 }  <br>

<p>Gdyby¶my napisali metodê kopiuj±c± strumienie i nie obs³ugiwali w niej
wyj±tków wej¶cia-wyj¶cia - to musieliby¶my zaznaczyæ, ¿e przy wywo³anie takiej
metody moga powstaæ wyj±tki klasy IOException: </p>
<p>public static void copyStream(InputStream in, OutputStream out)
<br>             
<b><font color="#3333ff">throws IOException</font></b> {
</p>
<p>  int c = 0;
<br>  while ((c = in.read()) != -1) out.write(c);
<br>}
</p>
<p>a obs³uga wyj±tku IOException, który mo¿e powstaæ przy wywo³aniu read() musia³aby
byæ prowadzona w miejscu wywo³ania metody copyStream(...):
</p>
<p>try {
<br>   .....
<br>   copyStream(in, out);
<br>} catch(IOException exc) { ...  } </p>
<p><br>
Warto zwróciæ w tym momencie uwagê na to, ¿e w poprzednim przyk³adzie pojawi³o
siê kilka klauzuli catch odpowiadaj±cych jednemu blokowi try.<br> </p>
<p></p><A NAME="EDU.skorowidz.termin try-catch sekwencja_dzia³ania 109_774"></A> <p><b>SEKWENCJA DZIA£ANIA try-catch</b></p>

<ul>
<li>
Wykonywane s± kolejne instrukcje bloku try.</li><li>
Je¶li w której¶ instrukcji wyst±pi b³±d (na skutek czego powstanie wyj±tek), wykonanie bloku try jest przerywane <b>w miejscu wyst±pienia b³êdu</b>.</li><li>
Sterowanie przekazywane jest do <b>pierwszej w kolejno¶ci</b> klauzuli
catch, w której podana w nawiasach okr±g³ych po s³owie catch klasa wyj±tku <b>pasuje</b> do typu powsta³ego wyj±tku:</li><ul><li>
St±d wa¿ny wniosek: <b>najpierw podawaæ BARDZIEJ SZCZEGÓ£OWE TYPY WYJ¡TKÓW </b>np. najpierw FileNotFoundException, a pó¼niej IOException, bo klasa FileNotFoundException jest pochodna od IOException</li></ul><li>
Inne klauzule catch nie s± wykonywane.</li><li>
Obs³uguj±ca wyj±tek klauzula catch mo¿e zrobiæ wiele rzeczy: m.in. zmieniæ
sekwencjê sterowania (np. poprzez return lub zg³oszenie nowego wyj±tku
za pomoc± instrukcji <b>throw</b>). Je¶li nie zmienia sekwencji sterowania
to wykonanie programu jest kontynuowane od nastêpnej instrukcji <b>po bloku</b> try.</li>
</ul><A NAME="EDU.skorowidz.termin finally klauzula 109_775"></A> <p><br><b>KLAUZULA FINALLY</b></p>

<p>Klauzula finally s³u¿y do wykonania kodu niezale¿nie od tego czy wyst±pi³
wyj±tek czy nie.
</p>
<p>boolean metoda(...) {
<br>try {
<br>       // instrukcje, które mog± spowodowaæ
wyj±tek
<br>}
<br>catch(Exception e) {  return false; }
<br>finally {
<br>       // uporz±dkowanie, np. zamkniêcie
pliku
<br>       }
<br>return true;
<br>}
</p>
<p>Je¶li powsta³ wyj±tek - wykonywana jest klauzula catch.
<br>Mimo, i¿ zmienia ona sekwencjê sterowania (zwraca false na znak, i¿
nast±pi³o niepowodzenie), sterowanie przekazywane jest do klauzuli finally.
I dopiero potem zwracany jest wynik - false.
<br>Je¶li nie by³o wyj±tku, po zakoñczeniu instrukcji w bloku try sterowanie
od razu wchodzi do klauzuli finally, a po jej zakoñczeniu zwracany jest
wynik true (wykonywana jest ostatnia instrukcja metody).
<br> 
</p>
<p></p><A NAME="EDU.skorowidz.termin wyj±tek w³asny 109_776"></A> <p><b>W£ASNE WYJ¡TKI</b></p>

<p><A NAME="EDU.skorowidz.termin Throwable 109_777"></A> Wyj±tki s± obiektami klas pochodnych od Throwable.
<br>¯eby stworzyæ w³asny wyj±tek nale¿y zdefiniowaæ odpowiedni± klasê.
<br><A NAME="EDU.skorowidz.termin Exception 109_778"></A> Zgodnie z konwencj± dziedziczymy podklasê Throwable - klasê Exception.
</p>
<p>class NaszWyj extends Exception {
<br>...
<br>}
</p>
<p>Zwykle w naszej klasie wystarczy umie¶ciæ dwa konstruktory: bezparametrowy
oraz z jednym argumentem typu String (komunikat o przyczynie powstania wyj±tku).
W konstruktorach tych nalezy wywo³aæ konstruktor nadklasy (za pomoc± odwo³ania
<b>super(...)</b>, w drugim przypadku z argumentem String).
</p>
<p>U¿ycie wyj±tku:
</p><A NAME="EDU.skorowidz.termin instrukcja_throw 109_779"></A> 
<ul>
<li>
jaka¶ nasza metoda ma sygnalizowaæ wyj±tek NaszWyj -- musi podaæ w deklaracji,
¿e mo¿e to zrobiæ:</li><ul><li>
void naszaMetoda() <b>throws </b>NaszWyj</li></ul><li>
nasza metoda sprawdza warunki powstania b³êdu</li><li>
je¶li jest b³±d - tworzy wyj±tek (new NaszWyj(...)) i sygnalizuje go za
pomoc± instrukcji <b>throw</b> :</li><ul><li>
throw new NaszWyj(ew_param_konstruktora_z_info_o_b³êdzie)</li></ul>
</ul>

<p>
Poni¿szy przyk³ad ilustruje wy¿ej powiedziane.<br>
W klasie ZipAsk zdefiniowano metodê wprowadzania kodu pocztowego (getZip).
W metodzie tej sprawdzana jest poprawno¶æ struktury wprowadzonego kodu (nn-nnn,
gdzie n - cyfry). Je¿eli kod nie jest poprawny, zg³aszany jest wyj±tek w³asnej
klasy NotValidZipException. Metoda main klasy ZipAskTest s³u¿y do przetestowania
dzia³ania: obs³ugujemy w niej wyj±tek NotValidZipException, zmuszaj±c u¿ytkownika
programu do wprowadzenia trzech poprawnych kodów (lub ew. rezygnacji z dzia³ania
poprzez wybór Cancel w dialogu).<br>
<br>

<pre>
 import javax.swing.*;

class NotValidZipException extends Exception {   // Klasa wyj±tku

    NotValidZipException() {
      super();
    }

    NotValidZipException(String s)  {
      super(s+ "\nPoprawny kod ma postaæ: nn-nnn");
    }
}


public class ZipAsk {

 public ZipAsk() { }

 public String getZip() throws NotValidZipException {

    final int N = 6,        // d³ugo¶æ kodu
              P = 2;        // pozycja na której wystêpuje kreska

    String zip = JOptionPane.showInputDialog("Podaj kod pocztowy:");
    if (zip == null) return zip;

    boolean valid = true;   // czy kod poprawny?

    char[] c = zip.toCharArray(); // tablica znaków w podanym kodzie

    // je¿eli struktura wadliwa: nie ta d³ugo¶æ, brak kreski
    if (c.length != N || c[P] != '-') valid = false;

    // czy w kodzie wystêpuj± tylko cyfry?
    for (int i = 0; i&lt;N &amp;&amp; valid; i++) {
         if (i==P) continue;
         if (!Character.isDigit(c[i])) valid = false;
         }
    // w tej chwili wiemy ju¿, czy kod jest poprawny
    // je¶li nie:
    // - tworzymy i zg³aszamy wyj±tek
    if (!valid) throw new NotValidZipException("Wadliwy kod: " + zip);

    // w przeciwnym razie zwracamy kod
    return zip;
    }
}

class ZipAskTest {

  public static void main(String[] args) {

    JOptionPane.showMessageDialog(null, "Podaj trzy prawid³owe kody pocztowe");

    ZipAsk zask = new ZipAsk();
    String zip = null;
    int n = 3;

    while (n &gt; 0) {
      try {
        zip = zask.getZip();
        if (zip == null) break;
        n--;
      } catch (NotValidZipException exc) {
          JOptionPane.showMessageDialog(null, exc.getMessage());
          continue;
      }
      System.out.println("Kod " + (3-n) + " : " + zip);
    }
    System.exit(0);

  }

} </pre><p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index108.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index110.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
