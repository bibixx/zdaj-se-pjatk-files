<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index63.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index65.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><div class="tytulpunktu">5. Zasiêg identyfikatorów. Zmienne lokalne. Czas ¿ycia danych. Specyfikatory dostêpu</div>

<a name="W8.6"></a><A NAME="EDU.skorowidz.termin zasiêg_identyfikatorów 64_543"></A> <p>Gdy definiujemy jak±¶ klasê  niebagateln± kwesti± okazuje siê pytanie o
mo¿liwo¶ci dzia³ania na okre¶lonych zmiennych.  Zwykle sprawia to pocz±tkuj±cym
w Javie programistom wiele trudno¶ci.<br>
<br>
Zacznijmy od pewnego banalnego (ale wcale nie tak oczywistego dla  kogo¶ kto zaczyna przygodê z Jav±) stwierdzenia. <br>
<br>

<div class="important">Wszystkie instrukcje (oprócz deklaracji) mo¿na umieszczaæ wy³±cznie w metodach klasy</div>

<br><p>
(jest od tego wyj±tek: blok statyczny, ale w tym momencie go pominiemy)<br>
<br>
W samych metodach mo¿emy mieæ jednak pewne niejasno¶ci: kiedy  mo¿emy siê odwo³ywaæ do okre¶lonych zmiennych i innych metod?<br>
<br>
Jak pamiêtamy - nazwy zmiennych, sta³ych, metod, klas s± identyfikatorami. <br>
<br>

<div class="def"><b>Zasiêgiem</b> identyfikatora jest fragment programu, w którym mo¿e on
byæ u¿ywany (w którym identyfikator jest rozpoznawany przez kompilator).</div>

<br>
<div class="important">W ka¿dej metodzie klasy mo¿emy zawsze odwo³aæ siê do identyfikatorów sk³adowych klasy (pól i metod), <b>niezale¿nie od tego w którym miejscu klasy wystêpuje deklaracja tych pól i metod</b>.<br>
W inicjatorach zawartych w deklaracjach pól klasy mo¿emy odwo³ywac siê do
wcze¶niej inicjowanych (por. punkt o inicjacji) identyfikatorów pól klasy</div>

<br>
<div class="notel">Przypomnijmy: cia³o metody czyli jej kod ujmowany jest w nawiasy klamrowe. Ujêty w nawiasy klamrowe kod nazywa siê równie¿ <b>blokiem</b></div>

<div class="ddd"><br>W ka¿dej metodzie mo¿emy deklarowaæ nowe zmienne (lub sta³e). Zasiêg ich identyfikatorów jest <b>lokalny</b> - rozci±ga siê od miejsca deklaracji do koñca metody (koñca bloku stanowi±cego
cia³o metody) w której zosta³y zadeklarowane. Mówimy o nich<A NAME="EDU.skorowidz.termin zmienna_lokalna 64_544"></A> <b>zmienne (sta³e) lokalne</b>. 
</div><br clear="all">

<p>Dotyczy to równie¿ parametrów (których deklaracje wystêpuj± w nag³ówku
metody). Tak naprawdê, parametry s± zmiennymi lokalnymi o zasiêgu od miejsca
deklaracji do koñca bloku obejmuj±cego cia³o metody.<br>
Równie¿ wewn±trz<A NAME="EDU.skorowidz.termin blok_lokalny 64_545"></A> <b>bloków lokalnych</b> (zestawu instrukcji ujêtych w nawiasy
klamrowe wewn±trz metody) mo¿emy wprowadzaæ deklaracje zmiennych. Ich zasiêg
obejmuje obszar od miejca deklaracji do koñca bloku w którym zosta³y zadeklarowane.<br>
<br>
Zatem, je¶li mamy nastêpuj±c± klasê:<br>

<pre>
class A {

    int a;

    void metoda1() {
        int b;
        ... 
       }

    void metoda2() {
        int c;
        ...
         }
 }

</pre>

<p>to w metodzie metoda1 mo¿emy odwo³ywaæ siê do zmiennej a, zmiennej b, oraz
metody metoda2(), a w metodzie metoda2() mo¿emy odwo³ywac siê do zmiennej
a, zmiennej c i metody metoda1. Blêdem natomiast bêdzie próba odwo³ania siê
z metody1 do zmiennej c i z metody2 do zmiennej b.<br>
<br><A NAME="EDU.skorowidz.termin przes³anianie_zmiennych 64_546"></A> W konstruktorach i metodach mo¿emy przes³aniaæ identyfikatory pól klasy.<br>
Np. <br>
<br>

<pre>
class A {

     int a;

     void metoda() {
         int a = 0;     // przes³oniêcie identyfikatora pola
         a = a + 10;    // dotyczy zmiennej lokalnej;
         this.a++;      // dotyczy pola
     }

}
</pre>

<p>
Tutaj w metodzie metoda() wprowadzili¶my zmiennê lokaln± o tej samej nazwie
co pole klasy (przes³oniêcie identyfikatora). Samo odwo³anie <i><b>a</b></i>
 bêdzie dotyczyæ tej zmiennej lokalnej. Jak pamiêtamy, przy takim przes³oniêciu
mo¿emy odwolaæ siê do pola u¿ywaj±c zmiennej this.<br>
<br>
<div class="important">W Javie nie wolno przes³aniaæ zmiennych lokalnych w blokach wewnêtrznych.</div><br>
<p>
Np. konstrukcja:<br>
class A {<br>
 ....<br>
  void metoda() {<br>
     int a;<br>
     { <br>
       int a;<br>
         ...<br>
     }<br>
  }<br>
}<br>
<br>
jest niedopuszczalna.<br>
<br>
Wa¿na kwestia dotyczy<A NAME="EDU.skorowidz.termin inicjacja_zmiennych_lokalnych 64_547"></A> inicjacji zmiennych lokalnych. Otó¿ w przeciwieñstwie
do pól klasy, zmienne lokalne nie maj± zagwarantowanej inicjacji i je¶li
nie nadamy im warto¶ci (czy to w jawnej inicjacji, czy za pomoc± przypisania)
ich warto¶æ jest nieokre¶lona.<br>
 <br>

<div class="important">Zmienne lokalne musz± mieæ <b>na pewno</b> nadane warto¶ci. W przeciwnym razie wyst±pi b³±d w kompilacji, zwi±zany z naruszeniem tzw. "definite assignment rule"</div>

<br>
<p>
Np. poni¿szy program:<br>
<br>

<pre>
import javax.swing.*;

public class DefAssgnm {

  public static void main(String[] args) {
    int len;
    String s = JOptionPane.showInputDialog("Napis?");
    if (s != null) len = s.length();
    System.out.println("D³ugosc napisu : " + len);
  }


</pre>

<p>nie skompiluje siê poprawnie, a kompilator powiadomi nas, ¿e:<br>
<br>

<div class="listing100">DefAssgnm.java:9: variable len might not have been initialized<br>
    System.out.println("D³ugosc napisu : " + len);<br>
                                             ^<br>
1 error</div>

<br>
<p>
poniewa¿ zmienna len jest lokalna w metodzie main i w programie uzyska warto¶æ
tylko warunkowo (gdy s != null). Zatem mo¿e siê zdarzyæ, ¿e nie bêdzia mia³a
przypisanej ¿adnej warto¶ci.<br>
<br>
Rozwi±zaniem tego problemu, jest zainicjowanie zmiennej len w deklaracji:<br>
<br>
    int len = -1;<br>
<br>
lub te¿ w inny sposób zagwarantowanie, ¿e w ka¿dym przypadku bêdzie ona mia³a warto¶æ. Np.<br>

<pre>
import javax.swing.*;

public class DefAssgnm {

  public static void main(String[] args) {
    int len;
    String s = JOptionPane.showInputDialog("Napis?");
    if (s != null) len = s.length();
    else len = -1;
    System.out.println("D³ugosc napisu : " + len);
  }

}
</pre>

<p>
Z zasiêgiem identyfikatorów wi±¿e siê w pewnym sensie<A NAME="EDU.skorowidz.termin czas_¿ycia_danych 64_548"></A> <b>czas ¿ycia danych</b>, ale nie s± to pojêcia to¿same.<br><br>

<div class="def">Czas ¿ycia danych to okres od momentu wydzielenia pamiêci dla ich przechowywania do momentu zwolnienia tej pamiêci.</div>

<br>
<p>
Zmienne lokalne s± powo³ywane do ¿ycia w momencie deklaracji (automatyczne
wydzielenie pamiêci na stosie) i likwidowane przy wyj¶ciu sterowania z bloku,
w którym zosta³u zadeklarowane (automatyczne zwolnienie pamiêci). Dotyczy
to równie¿ tych zmiennych, które s± referencjami do obiektów.<br>
<br>

<div class="important">Warto¶ci zmiennych lokalnych s± tracone po wyj¶ciu sterowania z bloku - np. zakoñczeniu dzia³ania metody</div>

<br>
<p>
Ta oczywista prawda niekiedy jest niedostrzegana i niektórzy staraj± siê
np za pomoc± zmiennych lokalnych zliczaæ liczbê wywo³añ jakiej¶ metody (usi³uj±
wymy¶liæ sposob na to, a przecie¿ to niemo¿liwe).<br>
<br>
Natomiast pola klasy zachowuj± siê inaczej. Stanowi± one przecie¿ elementy
obiektów. Obiekty za¶ s± tworzone w momencie wykonania operacji new. Pamiêæ
dla nich wydzielana jest dynamicznie - na stercie i zostanie zwolniona automatycznie
tylko wtedy gdy ¿adna referencja nie odnosi siê ju¿ do danego obiektu.<br>
Zwalnianiem pamiêci zajmuje siê od¶miecacz (garbage collector), który wed³ug
okreslonej strategii zarz±dza pamiêci±. My tym zarz±dzaniem nie musimy siê
martwiæ.<br>
<br>
Zatem pola klasy mog± stanowiæ co¶ w rodzaju "zmiennych globalnych", które zachowuj± swoje warto¶ci pomiêdzy wywo³aniami metod.<br>
Na przyk³ad, poni¿szy program:<br>

<pre>
public class Count {

  private int counter;

  public void increase() {
    counter++;
  }

  public void show() {
    System.out.println(counter);
  }
}

class Test {

  public static void main(String[] args) {
    Count c = new Count();
    c.increase();
    c.increase();
    c.increase();
    c.show();
  }

}
</pre>

<p>
<a href="javascript:popUp('dodatki/W8Prb5.htm',50,50)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a>wyprowadzi na konsolê liczbê 3.</p>
<br clear="all">

<p>Ró¿nicê pomiêdzy ¿yciem zmiennych lokalnych i obiektów dobrze ilustruje poni¿szy przyk³ad:<br>

<pre>
class Pies {

  String s;

  void nowyPies() {
    String pies =  new String("pies g³ówny");
    s = pies;
  }

  void jakieMamyPsy() {
    System.out.println("Jest " + s);
    String pies2 = pobierzInnegoPsa();
    System.out.println("Jest te¿ " + pies2);
  }

  String pobierzInnegoPsa() {
    String p = new String("inny pies");
    return p;
  }

}

class Test {

  public static void main(String[] args) {
    Pies p =  new Pies();
    p.nowyPies();
    p.jakieMamyPsy();
  }
}
</pre>

<div class="listing33r">Jest pies g³ówny<br>
Jest te¿ inny pies</div>
<div class="ddd"><br>Program wyprowadzi nastêpuj±c± informacjê, gdy¿</div><br clear="all">

<ul>
  <li>obiekt "pies g³ówny" zosta³ stworzony w metodzie nowyPies(). Lokalna zmienna <i><b>pies,</b></i>
 zawieraj±ca referencjê do tego obiektu, po zakoñczeniu dzia³ania tej metody
przestaje istnieæ. Ale poniewa¿ w metodzie przypisali¶my jej warto¶æ  zmiennej
s  (polu klasy), to ta nadal wskazuje na obiekt "pies g³ówny" i obiekt nadal
istnieje. Odwolamy siê do niego za pomoca zmiennej s w metodzie jakieMamyPsy().</li>

  <li>w metodzie  pobierzInnegoPsa() tworzymy obiekt "inny pies" i przypisujemy referencjê do niego zmiennej p. Instrukcja <i><b>return p</b></i>
 powoduje przypisanie tej warto¶ci zmiennej p na zmienn± pies2 w metodzie
jakieMamyPsy  (w miejscu wywo³ania metody pobierzInnegoPsa). Zatem mimo,
¿e po zakoñczeniu dzia³ania metody pobierzInnegoPsa() lokalna zmienna p przestaje
istnieæ, to obiekt "inny pies" nadal istnieje, bo wskazuje na niego zmienna
pies2 w metodzie jakieMamyPsy.</li>

  <li>po zakoñczeniu dzia³ania metody jakieMamyPsy obiekt "inny pies" zostanie
usuniêty z pamiêci, bowiem nie wskazuje na niego ju¿ ¿adna referencja. <br>
  </li>
</ul>
<p>
A jak wygl±da sytuacja z dostêpem do pól i metod danej klasy w innej klasie?<br>
Destêp ten reguluj± tzw. specyfikatory dostêpu, których u¿ywamy w deklaracjach
zmiennych, sta³ych i metod ( i które ju¿ cze¶ciowo poznali¶my).<br>
<br>
Ka¿da sk³adowa klasy mo¿e byæ:<br>
<ul>
  <li><A NAME="EDU.skorowidz.termin sk³adowa_klasy prywatna 64_549"></A> prywatna - dostêpna tylko w danej klasie (specyfikator <b>private</b>)</li>

  <li><A NAME="EDU.skorowidz.termin sk³adowa_klasy o_dostêpie_pakietowym 64_550"></A> zaprzyja¼niona - dostêpna ze wszystkich klas danego pakietu; mówi
siê tu te¿ o dostêpie pakietowym lub domy¶lnym - domy¶lnym dlatego, i¿ ten
rodzj dostêpno¶ci wystêpuje wtedy, gdy w deklaracji sk³adowej nie u¿yjemy
¿adnego specyfikatora.</li>

  <li><A NAME="EDU.skorowidz.termin sk³adowa_klasy chroniona 64_551"></A> chroniona lub zabezpieczona - dostêpna z danej  klasy, wszystkich klas
j± dziedzicz±cych oraz klas bêd±cych w tym samym pakiecie co dana klasa (specyfikator
    <b>protected</b>)</li>
	
  <li><A NAME="EDU.skorowidz.termin sk³adowa_klasy publiczna 64_552"></A> publiczna - dostêpna zewsz±d (specyfikator <b>public</b>)</li>
</ul>
<p>
Pewne powody stosowania specyfikatorów dostêpu ju¿ omawiali¶my (zabronienie
bezpo¶redniego dostêpu do "wnêtrza" obiektów, udostêpnienie u¿ytkownikom
klasy okreslonego zestawu metod publicznych). Wiêcej o specyfikatorach dostêpu
dowiemy siê w nastêpnym semestrze, teraz zauwazmy tylko, ¿e stanowi± one
prawdziwe restrykcje.<br>
<br>
Np. nastêpuj±cy program:<br>

<pre>
import javax.swing.*;

public class Para {

  private int a;
  private int b;
  public String nazwa;

  public Para(int x, int y) {
    a = x;
    b = y;
  }

  private String makeString() {
    return nazwa + " " + a + " i " + b;
  }

  public void show() {
    JOptionPane.showMessageDialog(null, makeString()); // 6
  }
}


class Test {

  public static void main(String[] args) {
    Para p = new Para(17,20);
    p.nazwa = "Para liczb";               // 1

    p.a = 1;                              // 3
    System.out.println(p.makeString());   // 4

    p.show();                             // 5

  }

}
</pre>

<p>Spowoduje b³êdy w kompilacji:<br><br>

<div class="listing100">Para.java:30: a has private access in Para<br>
    p.a = 1;                              // 3<br>
     ^<br>
Para.java:31: makeString() has private access in Para<br>
    System.out.println(p.makeString());   // 4<br>
                        ^<br>
2 errors</div>

<p>przy czym:<br>
<ul>
  <li>wiersz oznaczony //1 jest prawid³owy, bo pole nazwa jest publiczne
(ale, jak wspomniano uprzednio, nie nale¿y deklarowaæ pól jako publicznych)</li>
  <li>wiersze oznaczone // 3 i // 4 powoduj± b³êdy, bo nie mamy prawa dostêpu do ptrywatnych sk³adowych klasy z innej klasy</li>
  <li>wiersz oznaczony // 5 jest poprawny, bo odwo³ujemy siê do publicznej metody </li>
  <li>wiersz // 6 jest poprawny, bo z klasy mo¿emy siê odwo³ywac do jej prywatnych sk³adowych<br>
  </li>
</ul>
<p>
Mamy te¿ w Javie pojêcie klas publicznych i pakietowych. Klasa pakietowa jest
dostêpna tylko z klas pakietu. Klasa publiczna jest dostêpna zewsz±d (z innych
pakietów).<br>
<br>
Klasê publiczn± deklarujemy ze specyfikatorem public:. <br>
<br>
 public class Para { <br>
 ... <br>
 } <br>
<br><A NAME="EDU.skorowidz.termin klasa publiczna 64_553"></A> 
<div class="important">W pliku ¼ród³owym mo¿e byæ zdefiniowana tylko jedna klasa publiczna (ale
nie musi byæ). Je¶li w pliku ¼ród³owym jest zdefiniowana klasa publiczna,
to plik musi mieæ tak± sam± nazwê jak ta klasa - z dok³adno¶ci± do wielko¶ci
liter</div>

<br>
<p>
Definicji klas pakietowych (bez specyfikatora public) mo¿e byæ w jednym pliku wiele.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index63.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index65.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
