<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index26.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index28.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Wprowadzenie do obiektowo¶ci</div>

<a name="W4.14"></a>

<p><A NAME="EDU.skorowidz.termin programowanie_obiektowe 27_265"></A> Jêzyki obiektowe pos³uguj± siê pojêciem <b>obiektu i klasy</b>.<br>Dok³adne
definicje tych pojêæ poznamy pó¼niej. Teraz zamiast rozmy¶lania nad abstrakcyjnymi
sformu³owaniami spróbujmy uruchomiæ wyobra¼niê i intuicjê, licz±c siê z tym
(i nie przera¿aj±c siê tym), ¿e niektóry rzeczy zostan± w pe³ni wyja¶nione
dopiero w toku dalszej nauki.</p>
<p>Có¿ to jest<A NAME="EDU.skorowidz.termin obiekt 27_266"></A> "obiekt" ? Intuicyjnie czujemy, ¿e to co¶ w rodzaju "przedmiotu",
czego¶ co mo¿na wyodrêbniæ, nazwaæ, okre¶liæ jego w³a¶ciwo¶ci.<br>
Na przyk³ad obiektami bêd±: rower, samochód, pies, cz³owiek.</p>
<p>Ka¿dy z tych obiektów ma inne w³a¶ciwo¶ci. Np. cz³owiek ma imiê, jest
w okre¶lonym wieku. Samochód ma kolor i mo¿e te¿ np. byæ charakteryzowany
moc± silnika czy liczb± drzwi. <br>
Dwa samochody maj± ten sam zestaw w³a¶ciwo¶ci (<b>atrybutów</b>) np. markê,
kolor i moc silnika. I choæ marki i kolory mog± byæ ró¿ne i ró¿na mo¿e byæ
moc silników - to w pewnym sensie samochody te s± podobne (bo opisujemy je
za pomoc± takich samych cech). Powiemy, ¿e obiekty-samochody s± obiektami
tej samej <b>klasy</b>.<br><br>

A<A NAME="EDU.skorowidz.termin klasa 27_267"></A> <b>klasa</b> stanowi opis takich cech grupy podobnych obiektów, które s± dla
nich niezmienne.<br>
</p>
<p>Zauwa¿my dalej, ¿e obiekty mog± wykonywaæ jakie¶ czynno¶ci.<A NAME="EDU.skorowidz.termin us³uga 27_268"></A> Powiemy: udostêpniaj± jakie¶ <b>us³ugi</b>. Inne obiekty mog± "poprosiæ" je o wykonanie tych us³ug.<br>
Np. obiekt-kierowca mo¿e "zleciæ" obiektowi-samochodowi. by ten ruszy³ lub
zatrzyma³ siê (poprzez w³±czenie silnika i naci¶niêcie na peda³ gazu lub
za pomoc± wci¶niecia hamulca).<br>
</p>
<p>Powiemy, ¿e do obiektów posy³ane s±<A NAME="EDU.skorowidz.termin komunikat 27_269"></A> <b>komunikaty</b>, ¿±daj±ce od nich wykonania okre¶lonych us³ug.</p>
<p>Obiekty nie mog± wykonywaæ dowolnych czynno¶ci (¶wiadczyæ dowolnych us³ug).
Samochód mo¿e ruszyæ lub stan±æ, ale nie zacznie ¶piewaæ.<br>
Mo¿na powiedzieæ, ¿e to, jakie us³ugi udostêpniaj± obiekty,  jakie komunikaty
mo¿emy do nich posy³±æ, prosz±c je o wykonanie jakich¶ czynno¶ci - równie¿
jest jak±¶ ich cech±.</p>
<p>Zatem klasa bêdzie opisywac nie tylko takie wspólne cechy grupy podobnych obiektów jak kolor, czy wiek, czy waga, ale równie¿ zestawy us³ug, które obiekty tej klasy mog± ¶wiadczyæ. A wiêc i komunikaty, które do tych obiektów mo¿na pos³aæ.<br>
</p>

<p>Rozumowanie powy¿sze stanowi± abstrakcyjne odzwierciedlenie cech
rzeczywisto¶ci.</p>
<p>Gdyby¶my mieli w jêzyku programowania podobne pojêcia, to mogliby¶my ujmowaæ
projekt rozwi±zania rzeczywistego problemu i jego oprogramowanie w jêzyku
adekwatnym do problemu. <br><A NAME="EDU.skorowidz.termin jêzyki_obiektowe 27_270"></A> I to zapewniaj± jêzyki obiektowe. Jest to ich bardzo
wa¿na cecha, znacznie u³atwiaj±ca tworzenie oprogramowania.</p>

<p>Mo¿emy mieæ np. klasê urz±dzeñ elektrycznych o nastêpuj±cych atrybutach:
szeroko¶æ, wysoko¶æ, stan (w³±czone-wy³±czone) oraz udostêpniaj±cych us³ugi:
w³±czania i wy³±czania.<br>Tak jest w rzeczywisto¶ci. I tak samo mo¿emy
to zapisaæ w (na razie wyimaginowanym) jêzyku obiektowym, w którym za pomoc±
definicji klasy opiszemy atrybuty urz±dzeñ elektrycznych oraz zestaw us³ug,
przez nie udostêpnianych - maj±cy odzwierciedlenie w komunikatach, które
mo¿na pos³aæ do tych obiektów. Ten ostatni  - w wielu jêzykach obiektowych
- nazywany jest zestawem <b>metod</b> klasy (metoda jest czym¶ bardzo podobnym do funkcji).<br>

<pre>
class ElDev {
  width, height; &lt;-- atrybuty: szeroko¶æ, wysoko¶æ, stan
  isOn;
================= Interfejs komunikatów
  method on()
   isOn = true; &lt;--- us³uga on (w³±cz), inaczej: metoda o nazwie on

  method off()
   isOn = false; &lt;--- us³uga off (wy³acz),inaczej: metoda o nazwie on
}
</pre>



<p>Gdy mamy dwa obiekty - egzemplarze klasy urz±dzeñ elektrycznych, oznaczane a
i b, to mo¿emy symulowaæ w programie sekwencjê dzia³añ: w³±czenie urz±dzenia a,
w³aczenie urz±dzenia b, wy³±czenie urz±dzenia a, za pomoc± komunikatów
posy³anych do obiektów (inaczej wywo³ania metod na rzecz obiektów), np. w Javie (czy C++):</p>

<pre>
a.on();  // komunikat: obiekcie a w³±cz siê
b.on();  // obiekcie b w³±cz siê
a.off(); // obiekcie a wy³±cz siê
</pre>

<p>Oprócz odzwierciedlenia w programie "jêzyka problemu"<A NAME="EDU.skorowidz.termin abstrakcja_obiektowa 27_271"></A> abstrakcja obiektowa
ma jeszcze jedn± wa¿n± przewagê nad ujêciami nieobiektowymi.</p>
<p>Mianowicie, zwykle atrybuty obiektu nie s± bezpo¶rednio dostêpne. W
programie z obiektami "rozmawiamy" za pomoc± komunikatów, obiekty same "wiedz±
najlepiej" jak zmieniaæ swoje stany. Dziêki temu nie mo¿emy nic nieopatrznie
popsuæ, co wiêcej nie mo¿emy za¿±daæ od obiektu us³ugi, której on nie
udostêpnia.</p>

<div class="important">Dane (atrybuty) s± (powinny byæ) ukryte i s± traktowane jako <b>nierozdzielna ca³o¶æ z
us³ugami</b> - metodami.</div>

<p><A NAME="EDU.skorowidz.termin hermetyzacja 27_272"></A> Nazywa siê to <b>hermetyzacj±</b><A NAME="EDU.skorowidz.termin enkapsulacja 27_273"></A> (enkapsulacj±) i oznacza znaczne
zwiêkszenie odporno¶ci programu na b³êdy.</p>

<p><A NAME="EDU.skorowidz.termin podej¶cie_obiektowe 27_274"></A> Podej¶cie obiektowe umo¿liwia ponowne wykorzystanie ju¿ gotowych klas przy
tworzeniu klas nowych, co znacznie oszczêdza pracê przy kodowaniu, a tak¿e
chroni przed b³êdami.<br>

Jest to równie¿ odzwierciedlenie rzeczywistych sytuacji.</p>
<p>Np. komputer jest niew±tpliwie urz±dzeniem elektrycznym. Jest obiektem klasy
ElDev. Ale komputery (oprócz okreslonych w klasie ElDev atrybutów: wysoko¶æ,
szeroko¶æ, stan: w³±czony-wy³±czony) maj± jakie¶ swoje specyficzne,
wyspecjalizowane cechy.<br>
Stanowi± wiêc podklasê klasy urz±dzeñ elektrycznych.<br>
Tak jest w rzeczywisto¶ci. A w programie mo¿emy to odzwierciedliæ za pomoc±
koncepcji<A NAME="EDU.skorowidz.termin dziedziczenie_klas 27_275"></A> <b>dziedziczenia</b> klas. Klasa dziedzicz±ca inn± przejmuje jej
w³a¶ciwo¶ci i ew. dodaje w³asne, wyspecjalizowane. Dziêki temu w klasie
dziedzicz±cej mo¿emy skupiæ siê na specyficznych cechach jej obiektów, wiedz±c,
¿e podstawowe atrybuty i funkcjonalno¶æ zosta³y ju¿ okre¶lone w klasie
dziedziczonej.<br>
Np. tworz±c klasê Komputer, dziedzicz±c± klasê urz±dzeñ elektrycznych nie
musimy od nowa zapisywaæ wszelkich cech i operacji na urz±dzeniu elektrycznym
(np. nie musimy oprogramowywaæ metod on() czy off()). Musimy tylko dodaæ cechy
wyspecjalizowane np. dla komputera - us³ugê wykonania jakiego¶ programu.</p>
<p>Oczywi¶cie program bêdzie obiektem klasy Program, a w komunikacie do
obiektu-komputera powinni¶my podaæ jako argument obiekt-program do
wykonania.<br>
Dziedziczenie klasy ElDev przez klasê Komputer i dostarczenie nowej us³ugi
(metody) run mo¿emy zapisaæ (jeszcze nie w w Javie) tak (s³owo extends oznacza tu
dziedziczenie):</p>

<pre>
class Komputer extends ElDev {
    method run(Program p)
       if (isOn()) wykonanie_programu_p;
}
</pre>
<p>a nastêpnie u¿yæ nowej klasy Komputer w programie:</p>
<pre>
Komputer a, b, c;
Program x, y, z;
...
a.on(); a.run(x); ... a.off();
</pre>

<p>Tyle wprowadzenia, o charakterze bardzo wstêpnym i raczej intuicyjnym.
<br>
Chodzi³o w nim o to, by zrozumieæ pewne wa¿ne cechy podej¶cia obiektowago na
poziomie ogólnym, nie wchodz±c jeszcze w szczegó³y sk³adni Javy. Dok³adnie
cechy podej¶cia obiektowego bêdziemy omawiaæ przez ca³e dwa semestry. <br>
Ju¿ za chwilê jednak zobaczymy - przy okazji aplikacji powitalnych w jaki
sposób w Javie operuje siê na obiektach.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index26.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index28.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
