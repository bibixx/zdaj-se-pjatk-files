<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index80.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index82.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Warunkowe pêtle iteracyjne: instrukcje while i do..while</div>

<a name="W10.2"></a><A NAME="EDU.skorowidz.termin instrukcja_while 81_612"></A> 
<div class="syntax">Instrukcja while ma nastêpuj±c± postaæ:<br>
<br>
        <b>while</b> (<i><b>wyr</b></i>) <i><b>ins</b></i><br>
<br>
gdzie:<br>
<ul>
  <li>wyr - wyra¿enie, daj±ce w wyniku warto¶æ typu boolean</li>
  <li>ins - dowolna instrukcja (w tym grupuj±ca)<br>
  </li>
</ul>
</div>

<br>
<p><A NAME="EDU.skorowidz.termin pêtla_while dzia³anie 81_613"></A> Dzia³anie pêtli while jest nastêpuj±ce. Wyra¿enie wyr reprezentuje podobny
"warunek" jak w instrukcji if : jego warto¶æ jest wyliczana i je¶li jest
równa true to wykonywana jest instrukcja ins, w przeciwnym razie sterowanie
przekazywane jest do pierwszej instrukcji po pêtli while. <br>
Po wykonaniu instrukcji ins ponownie "sprawdzany jest warunek" zawarty w
wyra¿eniu wyr i je¶li jest prawdziwy ca³± operacja znów jest powtarzana.
Ta petla koñczy dzia³anie gdy wyra¿enie wyr równe jest false lub gdy w instrukcji
ins zawarto instrukcjê <b>break</b>, lub <b>return</b>, które wyprowadzaj± sterowanie poza pêtlê.<br>
<br>

<div class="notel">Przypomnienie: znaki mo¿na traktowaæ jak liczby, bo s± w komputerze reprezentowane
za pomoc± kodów liczbowych</div>

<div class="ddd"><br>Na przyk³ad poni¿szy fragment wyprowadza wszystkie
ma³e litery alfabetu angielskiego (bêdzie on dzia³a³ prawid³owo dla wszystkich
tablic kodowych, w których ma³e litery alfabetu angielskiego zajmuj± ci±g³±
przestrzeñ tzn. po a nastêpuje b, po b c - itd; "nastêpowanie po" oznacza,
¿e kod nastêpnego znaku jest o 1 wiêkszy od kodu znaku poprzedniego).
</div>
<br clear="all">

<br>

<pre>
        char c = 'a';              
        while (c &lt;= 'z') System.out.print(c++);
</pre>

<p>
<b><font color="#ff0000">Proszê sprawdziæ dzia³anie tego fragmentu we w³asnym programie.</font></b><br>
<br>
Jak widaæ dla prawid³owego zakoñczenia pêtli wa¿ne jest aby w jej wnêtrzu
nastêpowa³y zmiany (modyfikacje warto¶ci zmiennych) wp³ywaj±ce na "warunek"
reprezentowany przez wyra¿enie w nawiasach while.<br>
Warunki mog± byæ oczywi¶cie z³o¿one. Aby wyprowadziæ "od koñca" m ostatnich liter mo¿emy napisaæ<br>

<pre>
        int n = 0;
        char c = 'z';
        while(c &gt;= 'a' &amp;&amp; n &lt; m)  {
          System.out.println(c--);
          n++;
        }
</pre>

<p>
<b><font color="#ff0000">Proszê sprawdziæ dzia³anie tego fragmentu we w³asnym programie (dla wybranych warto¶ci m).</font></b><br>
<br>
Dajemy tu podwójny warunek, nie wiadomo bowiem czy m nie przekroczy liczby ma³ych liter w tablicy kodowej.<br>
Jeszcze inaczej to samo mo¿na napisaæ w nastêpuj±cy sposób:<br>
<br>
int m = ...;<br>
char c = 'z';<br>
while(m-- &gt; 0) {<br>
    if (c  &lt;  'a') break;<br>
    System.out.println(c--);<br>
}<br>
<br>
Przed niedopuszczalnymi warto¶ciami m zabezpieczamy siê wewn±trz pêtli; gdy
kolejny kod znaku przekroczy zakres kodów dla ma³ych liter (bêdzie mniejszy
od kodu litery a) instrukcja <b>break</b> spowoduje przerwanie pêtli.<br>
<br>
Baczny Czytelnik zauwa¿y³ zapewne tu dwa ciekawe zjawiska. <br>
Po pierwsze w pêtli while mo¿emy stosowaæ licznik iteracji i wykonywaæ jak±¶
zadan± ich liczbê (tê rolê pe³ni³y w powy¿szych przyk³adach najpiewr zmienna
n, a pó¼niej m).<br>
Po drugie, pêtla mo¿e nie wykonaæ "pe³nej liczby" iteracji.  Gdy m ma warto¶æ
wiêksz± od liczby ma³ych liter w alfabecie angielskim ostatnia iteracja wykonywana
jest "w po³owie": z dwóch instrukcji zapisanych w pêtli wykonana zostanie
tylko pierwsza (if...) i na skutek break sterowanie opu¶ci pêtlê.<br>
Pêtla i pó³" (po angielsku "loop and half") jest typowym przypadkiem przy
wprowadzaniu jakich¶ danych i wykonywaniu na nich operacji w pêtli,<br>
<br>
Np. w poni¿szym programie w pêtli wprowadzamy i sumujemy liczby ca³kowite
dopóki ich suma nie osiagnie lub nie przekroczy podanego limitu. Dodatkowo
w ka¿dej chwili u¿ytkownik mo¿e zakoñczyæ sumowanie (przed osiagniêciem limitu),
je¶li tylko zrezygnuje z wprowadzenia danych w dialogu przez wybór Cancel.<br>

<pre>
import javax.swing.*;

public class Sumowanie {

  public static void main(String[] args) {

    final int LIMIT = 200;
    int sum = 0;

    while(sum &lt; LIMIT)  {
      String data = JOptionPane.showInputDialog("Podaj liczbê ca³kowit±:");
      if (data == null) break;
      sum += Integer.parseInt(data);
    }
    System.out.println("Suma: " + sum);
    System.exit(0);
  }
 }
</pre>

<p>
<a href="javascript:popUp('dodatki/W10Prb3.htm', 80,30)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a>Komentarze - przypomnienia:<br>
<ul>
  <li>sta³e deklarujemy jako final, u¿ywamy ich zamiast "wa¿nych" litera³ów (takich jak np limit sumowania,  liczba powtórzeñ, etc)</li>
  <li>je¶li zrezygnowano z wprowadzania danych (np. poprzez wybranie Cancel
w okienku dialogowym), to metoda showInputDialog zwraca null</li>
  <li>instrukcja break s³u¿y do przerywania pêtli</li>
  <li>liczby ca³kowite wprowadzone w dialogu s± napisami - trzeba je przekszta³ciæ
na postaæ binarn± i do tego s³u¿y statyczna metoda parseInt z klasy Integer</li>
  <li>mogliby¶my napisaæ int a = Integer.parseInt(data); sum = sum + a; jednak
krócej to samo zapisujemy jako: sum += Integer.parseInt(data);<br>
    <br>
  </li>
</ul>
</p>

<br clear="all">

<p>
<a href="javascript:popUp('dodatki/W10Prb2.htm', 80,50)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a><br>W tym momencie warto po¶wiêciæ czas na rozwi±zanie
trochê wiêkszego zadania, którego opis pojawi siê po klikniêciu ikonki "Problem
do rozwi±zania".</p>
<br clear="all">
<br>
<p>
Nieco inne podej¶cie do sterowania wykonaniem pêtli while mo¿na zrealizowaæ za pomoc± tzw. zmiennej steruj±cej:<br>
<br>

<pre>
boolean again = true;
while(again) {
  .....
  if (/*warunek zakoñczenia pêtli*/) again = false;
}
</pre>

<p>
Ten sam przyk³ad mo¿na zapisaæ za pomoca pêtli nieskoñczonej i z u¿yciem break:<br>
<br>
while (true) {<br>
    ...<br>
    if (/*warunek zakoñczenia petli*/) break;<br>
}<br>
<br><A NAME="EDU.skorowidz.termin pêtla instrukcja_do...while 81_614"></A> 
<div class="syntax">Instrukcja do ... while jest bardzo podobna do while. <br>
Ma ona postaæ:<br>
<br>
                <b>do</b> <i><b>ins</b></i> <b>while</b> (<i><b>wyr</b></i>)<br>
</div>

<br>
<p>
Znaczenie ins i wyr jest takie samo jak w przypadku instrukcji while. Jedyna
(zaznaczana zreszt± przez zapis) ró¿nica w stosunku do instrukcji while polega
na tym, ¿e warunek okre¶lony przez wyra¿enie wyr jest sprawdzany po ka¿dym
wykonaniu pêtli (instrukcji ins), a nie przed (jak to jest w przypadku while).<br>
<br>

<div class="important">Pêtla while mo¿e wiêc nie wykonaæ siê ani razu, natomiast pêtla do ... while zawsze wykona siê przynajmniej raz.</div>

<br>
<p><A NAME="EDU.skorowidz.termin pêtla_while 81_615"></A> Podsumujmy. Pêtle while lub do..while stosujemy <b>zwykle</b> wtedy, gdy
kontynuacja dzia³ania pêtli zale¿y od jakie¶ warunku, a liczba iteracji nie
jest z góry znana lub ³atwa do okre¶lenia.<br>
<br><A NAME="EDU.skorowidz.termin instrukcja_while praktyczny_przyk³ad 81_616"></A> Zobaczmy teraz bardziej praktyczny przyk³ad zastosowania instrukcji while.<br>
Bêdziemy symulowaæ zmiany stanu konta bankowego.<br>
Warunki s± takie:<br>
<ul>
  <li>konto ma jaki¶ dany stan (ilo¶æ pieniêdzy na koncie)</li>
  <li>co miesi±c na konto wp³ywa zadana suma i wyp³acana jest z niego inna zadana suma</li>
  <li>suma na koncie jest oprocentowana w skali rocznej wg podanej stopy procentowej</li>
  <li>odsetki s± doliczane do tej sumy co miesi±c, na pocz±tku miesi±ca, przed zaksiêgowaniem miesiêcznego wp³ywu i wydatku</li>
</ul>

<p>
Nale¿y stworzyæ klasê Konto (Account) o podanych charakterystykach i dostarczyæ
w niej metody np. o nazwie getMonthsToBalance, która (za pomoc± symulacji
miesiêcznych zmian konta) pozwala odpowiedzieæ po ilu miesi±cach suma na
koncie osi±gnie podan± jako argument docelow± wielko¶c<br>
<br>
Testowanie klasy Account mo¿e wygl±dac tak: <br>
<br>
// Tworzymy obiekt konto ze stanem 2000, wp³atami 2400, wyp³atami 1800 i oprocentowaniem 10% w skali roku<br>
<br>
Account ac = new Account(2000, 2400, 1800, 10); <br>
<br>
// ile miesiêcy zajmie uzyskanie na koncie  sumy co najmniej 10000<br>
<br>
int lMies =   ac.getMonthsToBalance(10000);<br>
<br>

<div class="important"><br>

<b>Przed lektur± dalszego tekstu proszê spróbowaæ samodzielnie rozwi±zaæ to zadanie.</b><br>
<br>
</div>

<br>
<p>Jedno z mo¿liwych rozwi±zañ jest nastêpuj±ce:<br>

<pre>
public class Account {

  private double balance;          // stan konta
  private double monthIncome;      // sta³e miesiêczne wp³ywy (dochód)
  private double monthExpend;      // sta³e miesiêczne wydatki
  private double interest;         // stopa oprocentowania (roczna)

  // Konstruktor

  public Account(double s, double wpl, double wypl, double p) {
    balance = s;
    monthIncome = wpl;
    monthExpend = wypl;
    interest = p;
  }

  // Metoda - zwraca aktualny stan konta

  public double getBalance() {
    return balance;
  }

  // Metoda - zwraca liczbê miesiêcy potrzebnych
  // by stan konta osi±gn±³ warto¶æ targetBalance

  public int getMonthsToBalance(double targetBalance) {

    int n = 0;                                // miesi±ce
    double diff = targetBalance - balance;    // ró¿nica miêdzy aktualnym
                                              // i docelowym stanem
    while (diff &gt; 0) {         // dopóki jest TA ró¿nica -
                               // symulujemy up³yw miesiêcy i zmiany konta
      n++;
      balance *= (1 + (interest/100)/12);     // doliczenie odsetek
      balance += monthIncome - monthExpend;   // dochody, wydatki
      double prevDiff = diff;                 // poprzednia ró¿nica
      diff = targetBalance - balance;         // bie¿±ca ró¿nica
      if (prevDiff &lt;= diff) return -1;        // je¿eli ró¿nica siê
    }                                         // nie zmniejsza - nie ma szans
    return n;                                 // osiagniêcia docelowego stanu
  }


}

// Klasa testuj±ca konto

class TestKonta {

  public static void main(String[] args) {

    Account ac = new Account(2000, 2400, 1800, 10);
    double cel = 10000;
    int m =  ac.getMonthsToBalance(cel);
    System.out.println("Miesiace do osiagniecia co najmniej " + cel + ":");
    System.out.println(m + " --- stan konta " + ac.getBalance());
  }


}
</pre>

<p>Wynik dzia³ania programu:<br><br>

<div class="listing100">Miesiace do osiagniecia co najmniej 10000.0:<br>
13 --- stan konta 10430.006715578125</div>

<br>
<p>
Klasa jest suto komentowana, zwróæmy wiêc uwagê tylko na to, ¿e staramy siê
tu zabezpieczyæ przed nieosi±galnymi docelowymi stanami konta (np. kiedy
wydatki s± wiêksze od dochodów, a - w którym¶ momencie - oprocentowanie nie pokryje tej ró¿nicy,
to docelowy stan, który jest wiêkszy od aktualnego nigdy nie zostanie osiagniêty).
Innymi s³owy staramy siê zapewniæ  zakoñczenie pêtli while. W tym programie
robimy to  sprawdzaj±c w pêtli - czy z ka¿d±  iteracj± ró¿nica pomiêdzy stanem
docelowym i aktualnym zmniejsza siê. Je¶li nie, to nie ma szansy na osi±gniêcie
stanu docelowego i metoda zwraca -1 jako liczbê miesiêcy.<br><br>
Zauwa¿my dalej, ¿e unikaj±c g³êbszego zastanawiania siê nad kszta³towaniem
comiesiêcznego stanu konta, rozbili¶my wyliczenia na dwa kroki: naliczenie
odsetek i dodanie "czystego" dochodu:<br>
<br>
     balance *= (1 + (interest/100)/12);     // doliczenie odsetek<br>
     balance += monthIncome - monthExpend;   // dochody, wydatki<br>
 <br>
Mamy tu dwa przypisania, a mo¿emy miec jedno. Mo¿emy zapisaæ:<br>
<br>
balance  +=  ((interest/100)/12)*balance + monthIncome - monthExpend;<br>
<br>
W istocie, dotknêli¶my tu problemu<A NAME="EDU.skorowidz.termin optymalizacja_struktury_programu 81_617"></A> <b>optymalizacji struktury programu</b> pod wzglêdem zwiêkszenia
szybko¶ci jego wykonania. Niegdy¶ kwestia ta zajmowa³a wiele uwagi programistów.
Dzisiaj - ze wzglêdu na du¿± moc obliczeniow± wspó³czesnego sprzêtu komputerowego
zesz³a jakby na plan dalszy. <br>
Poza tym same kompilatory (w jakim¶ zakresie) staraj± siê optymalizowac program.<br>
Czy warto wiêc o tym my¶leæ?<br>
S±dzê, ¿e - do pewnego przynajmniej stopnia - tak. <br>
<br>
Sprawa dotyczy szczególnie instrukcji zawartych w pêtlach iteracyjnych. Faktycznie
wykonuj± siê one wielokrotnie, czasami miliony razy - zatem ich optymalizacja
ma istotny sens.<br>
<br>
Optymalizacji nale¿y jednak dokonywaæ rozs±dnie.<br>
<br>Oto starali¶my siê przyspieszyæ dzia³anie pêtli poprzez usuniêcie instrukcji
przypisania ( podwójne przypisywanie warto¶ci zmiennej balance), gdy tymczasem znacznie bardziej obci±¿aj±ce
czasowo jest wyliczanie wspo³czynnika naliczania odsetek:  (interest/100)/12.<br>
Jest on wyliczany w ka¿dej iteracji, a przecie¿ mo¿na go policzyæ tylko raz
- przed pêtl±. Istotnie, jego warto¶æ jest dla ka¿dej iteracji sta³a.<br>
Powinni¶my wiêc raczej napisaæ:<br>
<br>
double wspOds  = (interest/100)/12;<br>
while (...) {<br>
    ....<br>
    balance += wspOds*balance + monthIncome - monthExpend;<br>
    ....<br>
}<br>
<br>

<div class="important"><br>
Przed lektur± dalszego tekstu proszê samodzielnie od podstaw przygotowaæ
ostateczn±, uwzglêdniaj±c± uwagi o optymalizacji instrukcji wykonywanych
w pêtli, wersjê metody monthsToBalance i przetestowac jej dzia³anie w klasie
Account<br>
<br>
</div>

<br>
<p>
Ostatecznie wiêc metodê monthsToBalance mogliby¶my zapisaæ nastêpuj±co.<br>
<br>

<pre>
  public int getMonthsToBalance(double targetBalance) {
    double wspOds = (interest/100)/12;
    double diff = targetBalance - balance;
    int n = 0;
    while (diff &gt; 0) {
      n++;
      balance += wspOds*balance +  monthIncome - monthExpend;
      double prevDiff = diff;
      diff = targetBalance - balance;
      if (diff &gt;= prevDiff) return -1;
    }
    return n;
  }
</pre>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index80.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index82.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
