<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index109.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><div class="tytulpunktu">5. Pliki - krótkie wprowadzenie</div>

<a name="W14.5"></a>

<p>
Operacje wprowadzania danych z plików i zapisywania danych do plików s±
realizowane w Javie za pomoc± tzw. klas strumieniowych z pakietu java.io. Omówimy
je dok³adnie w przysz³ym semestrze. Teraz zajmiemy siê wycinkiem tej problematyki,
skrótowo i niejako czysto "instrukta¿owo".<br>

<br><A NAME="EDU.skorowidz.termin plik 110_781"></A> 
<div class="def">Plik - to ci±g bajtów zapisanych na dysku lub w innej fizycznie trwa³ej formie</div>

<br>
<p>
Zauwa¿my: informacja któr± przetwarzaj± programy - to ci±gi bajtów. W trakcie
wykonania programu informacja taka jest umieszczona w pamiêci operacyjnej.
Po zakoñczeniu programu - zajmowana pamiêæ udostêpniana jest innym programom.
Informacja ginie. Sposobem na jej bardziej trwa³e zapamiêtanie jest w³a¶nie
zapis do pliku. Zapisana informacja mo¿e byæ pó¼niej odtworzona - przez odczytanie
jej z pliku.<br>
<br><A NAME="EDU.skorowidz.termin FileInputStream 110_782"></A> Ogólnie, pliki <b>jako ci±gi bajtów </b>(powiemy: pliki bajtowe) s± w Javie reprezentowane przez obiekty
klas FileInputStream (<A NAME="EDU.skorowidz.termin pliki_wej¶ciowe 110_783"></A> pliki wej¶ciowe - z których wczytujemy dane) i<A NAME="EDU.skorowidz.termin FileOutputStream 110_784"></A> FileOutputStream
(<A NAME="EDU.skorowidz.termin pliki_wyj¶ciowe 110_785"></A> pliki wyj¶ciowe - do których zapisujemy dane).<br>
<br><A NAME="EDU.skorowidz.termin plik otwarcie 110_786"></A> Przygotowanie pliku do przetwarzania przez program nazywa siê <b>otwarciem</b> pliku.<br>
 W Javie pliki s± otwierane automatycznie przy<A NAME="EDU.skorowidz.termin tworzeniu_obiektów_plikowych 110_787"></A> tworzeniu obiektów plikowych
(czyli obiektów oznaczaj±cych pliki, w tym obiektów wspomnianych wy¿ej klas FileInputStream
i FileOutputStream).<br>
Obiekty-pliki <b>bajtowe</b> mo¿emy tworzyæ za pomoc± konstruktorów klas
FileInputStream i
FileOutputStream, podaj±c jako argument nazwê pliku.<br>
<br>
Np. <br>
FileInputStream in = new FileInputStream("Program1.java");<br>
FileOutputStream in = new FileOutputStream("Program2.java");<br>
<br><A NAME="EDU.skorowidz.termin plik czytanie 110_788"></A> Z plików bajtowych mo¿emy czytaæ bajty za pomoc± metody<A NAME="EDU.skorowidz.termin read 110_789"></A> <b>int read() </b>i mo¿emy do nich<A NAME="EDU.skorowidz.termin plik zapis 110_790"></A> zapisywaæ bajty za pomoc± metody<A NAME="EDU.skorowidz.termin write 110_791"></A> <b>write(int)</b>.<br>
Zwróæmy uwagê - bajty doskonale mieszcz± siê w zmiennej typu byte, ale read()
zwraca warto¶æ typu int, gdy¿  przy próbie czytania bajtów spoza koñca pliku 
musi jako¶ poinformowaæ o koñcu pliku. Umownie zwraca wtedy warto¶æ -1 (typu
int), co oczywi¶cie jest zupe³nie inn± warto¶ci± ni¿ wszelkie mo¿liwe warto¶ci
bajtów. <br>
<br><A NAME="EDU.skorowidz.termin plik zamkniêcie 110_792"></A> Po wykonaniu operacji na pliku powinni¶my plik <b>zamkn±æ</b>, co np. powoduje
ostateczny, fizyczny zapis informacji, byæ mo¿e do tego momentu bêd±cej jeszcze
w buforach systemowych oraz inne dzia³ania porz±dkowe na poziomie systemu
operacyjnego (niekiedy np. zwi±zane z mo¿liwo¶ci± udostêpnienia pliku innym
programom, lub z umo¿liwieniem otwarcia przez nasz program innych plików).
<br>
<br><A NAME="EDU.skorowidz.termin close 110_793"></A> Do zamykania plików s³u¿y metoda <b>close()</b>.<br>
<br>
Mo¿emy teraz napisaæ program, który - bajt po bajcie - kopiuje dowolny plik
wej¶ciowy do dowolnego pliku wyj¶ciowego. Nazwy plików podajemy jako argumenty
wywo³ania programu.<br>
<br>

<pre>
import java.io.*;

public class CopyFile {

  public static void main(String[] args) {

    FileInputStream in;       // plik wej¶ciowy
    FileOutputStream out;     // plik wyj¶ciowy

    try {

      in  = new FileInputStream(args[0]);
      out = new FileOutputStream(args[1]);
      int c;
      while ((c = in.read()) != -1) out.write(c);  // kopiowanie
      in.close();
      out.close();

    } catch(ArrayIndexOutOfBoundsException exc) { // brak argumentu
        System.out.println("Syntax: CopyFile in out");
        System.exit(1);
    } catch(FileNotFoundException exc) {  // nieznany plik
        System.out.println("Plik " + args[0] + " nie istnieje.");
        System.exit(2);
    } catch(IOException exc) {   // inny b³±d wej¶cia- wyj¶cia
        System.out.println(exc.toString());
        System.exit(3);
    }

  }

}
</pre>

<p>
Ka¿dy plik jest sekwencj± bajtów. Ale znaczenie bajtów mo¿e byæ bardzo ró¿ne.
Mog± to byæ np. binarne reprezentacje jakich¶ liczb, albo mog± to byæ znaki
(wtedy bêdziemy mówiæ o plikach tekstowych).<br>
<br><A NAME="EDU.skorowidz.termin Unicod 110_794"></A> Zwróæmy jednak uwagê, ¿e w Javie
 znaki s± przedstawiane w Unicodzie (czyli
jako warto¶ci dwubajtowe). Je¿eli tekst w pliku zapisany jest w ten w³a¶nie sposób
- to nie ma problemu. Ale czêsto pliki tekstowe zapisywane s± w ró¿nych systemach
kodowania, niekoniecznie w Unicodzie. Sposób kodowania znaków tekstu nazywa
siê<A NAME="EDU.skorowidz.termin strona_kodowa 110_795"></A> stron± kodow±. Np. wiele polskich dokumentów HTML zapisanych jest z wykorzystaniem
strony  kodowej ISO8859-2, inne - z wykorzystaniem strony Cp1250 (inaczej
zwanej Windows 1250). To oczywi¶cie nie jest Unicode - znaki zajmuj± 1 bajt.<br><br>
W ka¿dym systemie operacyjnym  mo¿emy te¿ ustawiæ<A NAME="EDU.skorowidz.termin strona_kodowa domy¶lna 110_796"></A> tzw. domy¶ln± stronê kodow±,
która bêdzie wykorzystywana np. przy wczytywaniu i zapisie plików przez systemowe
edytory tekstu. Np. w systemie Windows tak± domy¶ln± stron± kodow± najczêsciej jest - w polskich warunkach - Cp1250.<br>
Przy wczytywaniu Java musi dokonaæ przekodowania plików zapisanych w domy¶lnej
stronie kodowej na Unicode, a przy zapisie wykonaæ operacjê odwrotn± - przekodowania
z Unicodu do domy¶lnej strony kodowej.<br>Metody klas FileInputStream i FileOutputStream
- nie wykonuj± tego zadania (czytaj± i pisz± bajt po bajcie, co w przypadku
plików tekstowych mo¿e powodowaæ utratê informacji).<br>
Zobaczmy przyk³ad.<br>
Poni¿szy program.<br>

<pre>
import java.io.*;

public class ReadBytesAsChars {

  public static void main(String[] args) {
    StringBuffer cont = new StringBuffer();

    try {
      FileInputStream in  = new FileInputStream(args[0]);
      int c;
      while ((c = in.read()) != -1) cont.append((char) c);
      in.close();
     } catch(Exception exc) {
       System.out.println(exc.toString());
       System.exit(1);
     }
    String s = cont.toString();
    System.out.println(s);
  }

}
</pre>

<p>
czyta plik tekstowy i zapisuje jego zawarto¶æ w ³añcuchu znakowym (String),
po czym wypisuje na konsoli  ten ³ancuch znakowy. Je¶li przeczytali¶my z
pliku zapisanego w Cp1250 nastêpuj±cy tekst:<br>
<br>
Pocz±tek <br>
pog³êbienia <br>
znajomo¶ci <br>
Javy<br>
<br>
to na konsoli uzyskamy:<br>
<br>
Pocz?tek<br>
pog??bienia<br>
znajomo?ci<br>
Javy<br>
<br><A NAME="EDU.skorowidz.termin FileReader 110_797"></A> Takich strat informacji nie bêdzie, je¶li do czytania plików wykorzystamy
obiekt klasy <b>FileReader</b>, a do zapisywania -<A NAME="EDU.skorowidz.termin FileWriter 110_798"></A> <b>FileWriter</b>, bowiem klasy te zapewniaj±<A NAME="EDU.skorowidz.termin konwersja_miêdzy_domy¶ln±_stron±_kodow±_systemu_operacyjnego_i_Unicodem 110_799"></A> konwersje miêdzy domy¶ln± stron± kodow± systemu operacyjnego i  Unicodem<br>
<br><A NAME="EDU.skorowidz.termin przetwarzanie_plików_tekstowych 110_800"></A> 
<div class="important">Do przetwarzania plików tekstowych nale¿y wykorzystywaæ klasy FileReader i FileWriter</div>

<br>
<p>
Poprzedni przyk³ad mo¿emy teraz zapisaæ tak:<br>

<pre>
import java.io.*;

public class ReadByReader {

  public static void main(String[] args) {
    StringBuffer cont = new StringBuffer();

    try {
      FileReader in  = new FileReader(args[0]);
      int c;
      while ((c = in.read()) != -1) cont.append((char) c);
      in.close();
     } catch(Exception exc) {
       System.out.println(exc.toString());
       System.exit(1);
     }
    String s = cont.toString();
    System.out.println(s);
  }

}
</pre>

<p>
Przy przetwarzaniu plików zetkniemy siê tak¿e z kwesti± efektywno¶ci.<br>
Np. przy czytaniu du¿ych plików tekstowych nale¿y unikaæ bezpo¶redniego
czytania za pomoc± klasy FileReader, bowiem ka¿de odczytanie znaku mo¿e powodowaæ
fizyczne odwo³anie do pliku (to samo dotyczy zapisu i klasy FileWriter).
<br>
Operacje fizycznych odwo³añ do pliku (dysku) s± czasoch³onne.<br><A NAME="EDU.skorowidz.termin buforowanie 110_801"></A> Aby je ograniczyæ - stosujemy tzw. buforowanie.<br> W pamiêci operacyjnej
wydzielany jest du¿y obszar pamiêci, który zape³niany jest przez jednorazowe
fizyczne odwo³anie do pliku. Instrukcje czytania pliku pobieraj± informacje
z tego<A NAME="EDU.skorowidz.termin bufor 110_802"></A> bufora. Gdy bufor jest pusty - nastêpuje kolejne jego wype³nienie poprzez
fizyczne odwo³anie do pliku. W ten sposób liczba fizycznych odwo³añ do pliku
(do dysku) jest mniejsza ni¿ liczba zapisanych w programie instrukcji czytania
danych.<br>
<br>
W Javie do buforowania wej¶ciowych plików tekstowych stosujemy klasê<A NAME="EDU.skorowidz.termin BufferedReader 110_803"></A> BufferedReader. <br>
Ale klasa ta nie pozwala - przy tworzeniu obiektów - bezpo¶rednio, w konstruktorze,
podawaæ ¼ród³a danych (np. nazwy pliku).
<br>
¯ród³o to podajemy przy tworzeniu obiektu typu FileReader, a po to,
¿eby uzyskaæ buforowanie, "opakowujemy" FileReader -  BufferedReaderem.
<br><br>
Wygl±da to tak:

<p>// tu powstaje zwi±zek z fizycznym ¼ród³em<br>
<b>FileReader fr = new FileReader("plik.txt"); </b> </p>
<p>// tu dodajemy "opakowanie",
umo¿liwiaj±ce buforowanie
  
<br><b>BufferedReader br = new BufferedReader(fr); </b></p>
<p>//...  teraz wszelkie odwo³ania czytania itp. kierujemy do obiektu
br
</p>
<p>Dodatkowo w klasie BufferedReader zdefiniowano wygodn± metodê czytania wierszy pliku: </p>
<p>        readLine() </p>
<p>która zwraca kolejny wiersz jako String lub null je¶li wyst±pi³ koniec pliku<br>
</p>

<p>Zarys czytania:
</p>
<p>  try {
<br>      String line;
<br>      FileReader fr = new FileReader(fname);         
// fname jest nazw± pliku
<br>      BufferedReader br = new BufferedReader(fr);
</p>
<p>      while  ((line = br.readLine()) !=
null) {   // kolejny wiersz pliku: metoda <b>readLine</b><br>         ...
<br>         // tu robimy co¶ z wierszami pliku<br>        }
<br>      br.close();  // zamkniêcie pliku
<br>      }
<br>    catch (IOException e) {
<br>      System.err.println(e);
<br>    }
</p>
<p>Np. metodê main w programie przyk³adowym z wyk³adu 12 (klasa TocTest,
testuj±ca odnajdywanie nag³ówków umieszczonych pomiêdzy znacznikami &lt;h2&gt;
i &lt;/h2&gt; za pomoc± klasy Toc) mo¿emy teraz napisaæ w takiej formie,
która umo¿liwi przetworzenie w ten sposób  pliku HTML podanego jako argument
wywo³ania programu:<br>
<br>

<pre>
import java.io.*;

class TocTest {

  public static void main(String[] args) {
    final String ls = System.getProperty("line.separator");
    StringBuffer doc = new StringBuffer();
    try {
     FileReader fr = new FileReader(args[0]);
     BufferedReader br = new BufferedReader(fr);
     String line;
     while ((line = br.readLine()) != null) doc.append(line).append('\n');
     br.close();
    } catch (Exception exc) { System.out.println(exc); System.exit(1); }

    System.out.println(new Toc(doc.toString()).getToc());
  }
}
</pre>

<p>
<b><font color="#ff6600">Proszê samodzielnie po³±czyæ now± klasê TocTest
z klas± Toc przedstawion± w wyk³adzie 12 i zobaczyæ jak dzia³a na przyk³adzie
ró¿nych (prostych!) dokumentów HTML</font></b>.<br>
<br>
Wszystko co powiedziano o buforowaniu tekstowych plików
wej¶ciwych dotyczy równie¿ buforowania tekstowych plików wyj¶ciowych. <br>
W tym przypadku stosujemy klasê<A NAME="EDU.skorowidz.termin BufferedWriter 110_804"></A> <b>BufferedWriter</b>.<br>
<br>
<b><font color="#ff0000">Proszê zapoznaæ siê w dokumentacji Javy z klasami FileReader, FileWriter, BufferedReader i BufferedWriter. </font></b></p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index109.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
