<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index90.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index92.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><div class="tytulpunktu">4. Tablice &quot;obiektowe&quot;</div>

<a name="W11.5"></a><A NAME="EDU.skorowidz.termin tablica referencje 91_653"></A> 
<p>
Jak wiemy ju¿, i jak widzieli¶my przed chwil± - tablice mog± zawieraæ referencje do dowolnych obiektów.<br>
Bardzo naturalnie wygl±da to w przypadku tablic elementów typu String.<br>
Mo¿emy np. zadeklarowaæ i stworzyæ tablicê:<br>
<br>
String[] town = { "Warszawa", "Poznañ", "Kraków", "Gdañsk" };<br>
<br>
i operowaæ na jej elementach, np. wypisaæ je:<br>
<br>
for (int i=0; i&lt;town.length; i++) System.out.println(town[i]);<br>
<br>
albo przestawiæ miejscami pierwszy i ostatni element:<br>
<br>
String last = town[town.length -1];<br>
town[town.length -1] = town[0];<br>
town[0] = last;<br>
<br>
<p>
<a href="javascript:popUp('dodatki/W11Prb2.htm',80,80)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a> <font color="#cc0000">Proszê sprawdziæ dzia³anie
tych fragmentów we w³asnym programie i - dodatkowo - rozwi±zaæ zadanie, którego
tre¶æ pojawi siê po klikniêciu w ikonkê "Problem do rozwi±zania".</font></p>

<br>
<p>Sk³adniowo wygl±da to identycznie jak operowanie na tablicach liczb
ca³kowitych czy rzeczywistych. Wydaje siê, ¿e nie ma ró¿nicy.<br>
Jednak ró¿nica jest, a niedostrzeganie jej prowadzi do czêstych b³êdów, szczególnie w pocz±tkowej fazie nauki jêzyka Java.<br>
<br>
Przypomnijmy sobie klasê Para z wyk³adu 8. Jej obiekty reprezentuj± pary liczb ca³kowitych.<br>
Powiedzmy, ¿e chcieliby¶my w programie operowaæ na tablicy par liczb ca³kowitych.<br>
<br>
Przede wszystkim konieczna jest deklaracja:<br>
<br>
Para[] tabPar;<br>
<br>
Dobrze ju¿ wiemy, ¿e taka deklaracja nie tworzy tablicy. <br>
Zatem nastêpny krok - stworzenie tablicy<br>
<br>
tabPar = new Para[10];<br>
<br>
Czy mamy ju¿ obiekty-pary? Czy mo¿emy zobaczyæ jak wygl±daj± "na samym pocz±tku"?<br>
Zobaczmy.<br>

<pre>
public class TabPar {

  public static void main(String[] args) {
    Para[] tabPar = new Para[10];
    for (int i=0; i &lt; tabPar.length; i++) tabPar[i].show("Para " + (i+1));
   }

}
</pre>

<p>Ten program skompiluje siê bezb³êdnie, ale przy jego wykonaniu otrzymamy nastêpuj±cy komunikat.<br>
<br>

<div class="listing100">Exception in thread "main" java.lang.NullPointerException<br>
        at TabPar.main(TabPar.java:6)</div>

<br>
<p>
Jest on skutkiem odwo³ania do nieistniej±cego obiektu - wywo³ania metody
show z klasy Para za pomoc± referencji o warto¶ci null.<br>
<br>
Faktycznie, <b>przecie¿ obiekty trzeba tworzyæ</b>! Stworzenie tablicy nie tworzy obiektów, które chcieliby¶my traktowaæ jako jej elementy.  <br>
<b><br>
Tablica przechowuje referencje do obiektów</b>, czyli jej elementy na
pocz±tku bêd± mia³y domy¶lne warto¶ci null - a dopiero po stworzeniu obiektów
i przypisaniu referencji (ich adresów) elementom tablicy bêdziemy mogli u¿ywaæ
elementów tablicy w operacjach na obiektach.<br>
<br>
Powinni¶my zatem napisaæ co¶ w rodzaju:<br>

<pre>
public class TabPar {

  public static void main(String[] args) {
    Para[] tabPar = new Para[10];
    for (int i=0; i &lt; tabPar.length; i++) tabPar[i] = new Para(i+1, i+2);
    for (int i=0; i &lt; tabPar.length; i++) tabPar[i].show("Para " + (i+1));
   }

}
</pre>

<p>co w wyniku da nastêpuj±cy wydruk:<br>
<br>

<div class="listing100">Para 1 ( 1 , 2 )<br>
Para 2 ( 2 , 3 )<br>
Para 3 ( 3 , 4 )<br>
Para 4 ( 4 , 5 )<br>
Para 5 ( 5 , 6 )<br>
Para 6 ( 6 , 7 )<br>
Para 7 ( 7 , 8 )<br>
Para 8 ( 8 , 9 )<br>
Para 9 ( 9 , 10 )<br>
Para 10 ( 10 , 11 )<br>
</div>

<br>
<p>
To co siê dzieje wyja¶nia nastêpuj±cy rysunek.<br><br>

<div>
<img src="images/tabref10.jpg" alt="r" width="538" height="439" border="1">
</div>

<br><p>
Mo¿na przypuszczaæ, ¿e w przypadku takiej klasy jak Para nie zdarzy nam siê
b³±d "braku obiektów" (bowiem zwykle bêdziemy chcieli mieæ jakie¶ konkretne
pary i bêdziemy pamiêtaæ, ¿e trzeba je stworzyæ za pomoc± wyra¿enia new).<br>
Jednak  nie jest to tak oczywiste w przypadku wielu klas zawartych w standardowych pakietcha Javy.<br>
Np.  mo¿emy mieæ do czynienia z zestawami przycisków (klasy Button czy JButton).
Naturalne jest my¶lenie o nich jako o tablicach przycisków (zreszt± taki
jest sens - i tak czêsto bêdziemy opisywaæ programy). Zatem -  mo¿emy pomy¶leæ,
¿e po:<br>
Button b = new Button[10];<br>
ju¿ mamy 10 przycisków i mo¿emy co¶ z nimi robiæ.<br>
<br>
Ale przycisków jeszcze nie ma i nasz program wpada w k³opoty.<br>
<br>

<div class="important"><br>
<div align="Center">Tworzenie tablic z elementami oznaczaj±cycmi obiekty - podsumowanie<br>

(na przyk³adzie klasy Button)<br>
<div align="Left">
<ol>
  <li>Deklaracja tablicy :  <b>Button[] b;</b></li>
  <li>Utworzenie tablicy:  <b>b = new Button[n];</b></li>
  <li>Tworzenie obiektów i przypisywanie referencji, które na nie wskazuj± - elementom tablicy, np.: <b>for (int i=0; i&lt;b.length; i++) b[i] = new Button(); </b></li>
</ol>
  </div>
</div>
</div>

<br><p>
Naturalnie, równie¿ w przypadku tablic referencji do obiektów mo¿emy
u¿yæ inicjatorów klamrowych, które pozwalaj± - przy deklaracji - stworzyæ
i zanicjowaæ tablicê. Robili¶my to ju¿ zreszt± przy okazji<A NAME="EDU.skorowidz.termin tablica inicjacja 91_654"></A> inicjacji tablicy
miast litera³ami ³añcuchowymi.<br>
<br>
Mo¿na podaæ przyk³ady takich inicjacji:<br>
<br>
    Para[] tabPara = { new Para(1,1), new Para(2,3), new Para(4,5) };<br>
    Button[] b = { new Button("A"), new Button("B") };<br>
    String[] s = { "Ala", "Kot", "Pies" };<br>
    <br>
    Para p1 = new Para(2,4);<br>
    Para p2 = new Para(7,8);<br>
    Para[] tabP = { p1, p2 };<br>
<br>
Tak naprawdê przyk³ady te nie ró¿ni± siê miêdzy sob±. We wszystkich w/w inicjacjach
zmiennych tablicowych w nawiasach klamrowych podajemy referencje do obiektów
odpowiedniej klasy.   <br>
<br>
W tym miejscu warto przypomnieæ klasê Publication z wyk³adu 7 i dziedzicz±ce
j± klasy Book, Journal i CDisk. Obiektowe konwersje rozszerzaj±ce pozwalaj±
przypisywaæ zmiennym oznaczaj±cym obiekty klasy bazowej referencje do obiektów
klas pochodnych. A poniewa¿ elementy tablic "obiektowych" zawieraj± referencje
- to na przyk³ad w przypadku naszych klas opisuj±cych publikacje  - elementom
<b>jednej</b> tablicy typu Publication[] mo¿na przypisaæ warto¶ci <b>ró¿nych</b> typów: Publication, Book, Journal i CDisk.<br>
<br>

<div class="notec">Elementy tablicy mog± zawieraæ referencje wskazuj±ce na obiekty ró¿nych
klas, pod warunkiem, ¿e klasy te dziedzicz± tê sam± klasê - okre¶laj±c± ogólny,
niejako wspólny dla wszystkich, typ elementów tablicy</div>

<br>
<p>
Do¶æ zawik³an± tre¶æ najlepiej wyja¶ni schematyczny przyk³ad:<br>
<br>
Publication[] p = new Publication[3];<br>
p[0] = new Book(...);<br>
p[1] = new Journal(...);<br>
p[2] = new CDisk(...);<br>
<br>
Mo¿emy powiedzieæ (stosuj±c skrót my¶lowy): pierwszy element tablicy publikacji
jest ksi±¿k±, drugi czasopismem, a trzeci - p³yt± CD. Jest to mo¿liwe dlatego,
¿e i ksi±¿ka i czasopismo i p³yta CD s± publikacjami (to znaczy oprócz tego,
¿e obiekty te s± obiektami specyficznych klas Book, Journal i CDisk - mog±
byæ równie¿ traktowane jako obiekty klasy Publication, poniewa¿ wszystkie
trzy klasy dziedzicz± klasê Publication).<br>
<br>
Oczywi¶cie, inicjacje s± przypisaniami, zatem mo¿emy pisaæ:<br>
<br>
Publication[] p = { new Book(..), new Book(...), new Journal() };<br>
<br>
Równie¿ przekazywanie argumentów i zwracanie wyników metod jest swoistym przypisaniem. <br>
W tym kontek¶cie bardzo wygodn± konstrukcj± sk³adniow± Javy jest wyra¿enie
ad hoc tworz±ce i inicjuj±ce tablicê referencji do obiektów.<br>
<br>

<div class="syntax">
        Wyra¿enie:<br>
                            <b>new <i>klasaA</i>[] { <i>refB</i>, <i>refC</i>, ... }</b><br>
<br>
tworzy tablicê typu <b><i>klasaA</i>[] </b>i inicjuje j± referencjami podanymi w nawiasach klamrowych, przy czym ka¿da z tych referencji mo¿e wskazywaæ obiekt klasy <i><b>klasaA</b></i> lub dowolnej klasy pochodnej od klasy <i><b>klasaA</b></i>.<br>
Wynikiem opracowania tego wyra¿enia jest referencja do zmiennej tablicowej typu <b><i>klasaA</i>[]</b><br>
</div>

<br>
<p>
Najczê¶ciej wyra¿enie to ma zastosowanie na li¶cie argumentów wywo³ania
metody, której parametrem jest tablica. W ten sposób mo¿emy uzyskaæ efekt<A NAME="EDU.skorowidz.termin wywo³anie_metody_ze_zmienn±_liczb±_i_zmiennymi_typami_argumentów 91_655"></A> wywo³ania metody ze zmienn± liczb± i (do pewnego stopnia) zmiennymi typami
argumentów.<br>
<br>
Na przyk³ad, metodê xyz , która jako parametr ma tablicê publikacji, mo¿emy wywo³aæ ze zmienn± liczb± i typami publikacji tak:<br>
<br>
xyz( new Publication[] { new Book(...), new Book(...) , new Journal(...) } );<br>
xyz( new Publication[] { new Journal(...),  new Journal(...) } );<br>
Book b1 = new Book(...),<br>
         b2 = new Book(...);<br>
xyz( new Publication[] { b1, b2 } );<br>
<br>
Bardziej rozbudowany przyk³ad prezentuje poni¿szy program.<br>
<b><font color="#ff0000">Proszê go przeanalizowac pod k±tem zastosowania omówionych wy¿ej regu³.</font></b><br>
<br>

<pre>
public class VarArg {

  public VarArg() {
    // wywo³anie metody "z dwoma" argumentami
    showMsgs( new String[] { "Warszawa", "Kraków" } );
    // wywo³anie metody "z trzema" argumemntami
    showMsgs( new String[] { "Ala", "Kot", "Pies" } );
    // "trzy argumenty": dwie ksi±¿ki, jedno czasopismo
    showIncome( new Publication[]
                { new Book("P. Pies", "Psy", "WydPP", 2002, "ISBN01", 25, 100),
                  new Book("K. Kot", "Koty", "WydPP", 2002, "ISBN02", 22, 90),
                  new Journal(1, "Kwiaty", "WydAN", 2002, "ISSN03", 10, 200),
                }
              );

    // "dwa argumenty": ksi±¿ka i czasopismo
    showIncome( new Publication[]
                { new Book("A. Koñ", "Konie", "Tur", 2001, "ISBN01", 35, 50),
                  new Journal(1, "Ryby", "W&amp;S", 2002, "ISSN03", 20, 100),
                }
              );
  }

  // Wypisuje w kolejnych wierszach napisy - elementy przekazanej tablicy
  public void showMsgs(String[] s) {
    for (int i=0; i&lt;s.length; i++) System.out.println(s[i]);
  }

  // Pokazuje dochód jaki mo¿na uzyskaæ ze sprzeda¿y publikacji
  // przekazanych w tablicy
 
  public void showIncome(Publication[] p) {
    double d = 0;
    String opis = "";
    for (int i=0; i&lt;p.length; i++) {
      opis += " " + p[i].getIdent();
      d += p[i].getPrice() * p[i].getQuantity();
    }
    System.out.println("Dochód z pozycji " + opis);
    System.out.println(d);
  }


  public static void main(String[] args) {
    new VarArg();
  }

}
</pre>

<p>
Wydruk dzia³ania programu:<br><br>

<div class="listing100"><br>
Warszawa<br>
Kraków<br>
Ala<br>
Kot<br>
Pies<br>
Dochód z pozycji  ISBN01 ISBN02 ISSN03<br>
6480.0<br>
Dochód z pozycji  ISBN01 ISSN03<br>
3750.0<br>
</div>

<br>
<p>
Zadanie.<br>
W ksiêgarni s± pó³ki. Ka¿da pó³ka ma numer i mo¿e pomie¶ciæ zadan± liczbê
publikacji (ksi±¿ek, czasopism, p³yt CD). Ka¿da ksi±¿ka, czasopismo i p³yta
zajmuj± tyle samo miejsca. <br>
Stworzyæ klasê Bookshelf reprezentuj±c± pó³ki, na ktore mo¿na wstawiaæ publikacje.
Jak pamiêtamy ka¿dy obiekt-publikacja przechowuje jako swój "stan" liczbê
sk³adowanych pozycji danej publikacji. Na pó³kê mo¿na wstawiæ ca³y taki komplet
albo nic (je¶li brakuje ju¿ miejsca).<br>
W klasie Bookshelf zapewniæ metodê uzyskiwania informacji o zawarto¶ci pó³ki.<br>
Zmodyfikowaæ klasê Publication w taki sposób, by o ka¿dej publikacji mo¿na by³o siê dowiedzieæ na której pó³ce stoi.<br>
Dla uproszczenia: proces wstawiania na pó³ki jest jednorazowy, nie ma zdejmowania z pó³ek.<br>
<br>
W klasie testuj±cej dostarczyæ:<br>
tablicê pó³ek,<br>
tablicê ksi±¿ek,<br>
tablicê czasopism.<br>
i po kolei wstawiaæ ksi±¿ki i czasopisma na pó³ki. Obiekty pó³iki (elementy
tablicy pó³ek) tworzyæ tylko w miarê potrzeby (np. je¶li tablica pó³ek ma
5 elementów, a ksi±¿ki i czasopisma mieszcz± siê na trzech pó³kach, to nie
ma potrzeby tworzyæ dwóch pó³ek - ostatnich elementów tablicy pó³ek).<br>

Pokazaæ, "przebiegaj±c po elementach" tablicy ksi±¿ek i tablicy czasopism
- na jakich pó³kach stoj±. Przebiegaj±c za¶ "po elementach" tablicy pó³ek
- wylistowaæ jakie pozycje wydawnicze znajduj± siê na ka¿dej z u¿ytych pó³ek.<br>
<br>

<div class="important"><br>
Przed lektur± dalszego tekstu proszê rozwi±zaæ to zadanie samodzielnie<br>
<br>
</div>

<br>
<p>
Mo¿liwe rozwi±zanie.<br>
<br>
W klasie Publication dodamy pole, które bêdzie referencj± do obiektu klasy
Bookshelf i bêdzie oznaczaæ pó³kê na której stoj± egzemplarze danej pozycji
wydawniczej.<br>
Inicjalnie (zgodnie z regulami inicjacji pól) - pole to bêdzie mia³o warto¶æ
null ( nie  na pó³ce). Dodatkowa metoda setBookshelf - wywo³ywana przy wstawianiu
egzemplarzy publikacji na pó³kê -  bêdzie ustalaæ warto¶æ pola-pó³ki (gdzie
stoj±). Metoda whereIs - zwróci tê warto¶æ i w ten sposób bêdziemy mogli dowiadywaæ
siê na której pó³ce stoj± dane publikacje.<br>
<br>

<pre>
// Modyfikacje klasy Publication
public class Publication {

  //...
  private Bookshelf bs;  // refrencja do pó³ki na której stoj± te publikacje

  // ustal pó³kê gdzie stoj± (przy wstawianiu)
  public void setBookshelf(Bookshelf b) {
    bs = b;
  }

  // zwraca pó³kê, gdzie stoj± te publikacje
  public Bookshelf whereIs() {
    return bs;
  }

// ...
}
</pre>

<p>
W klasie Bookshelf publikacje stoj±ce na pó³ce bêdziemy rejestrowaæ w tablicy
Publication[] pubs. Rozmiary tej tablicy okre¶laj± ile mo¿na wstawiæ egzemplarzy
ró¿nych publikacji. Po wstawieniu egzemplarzy jakiej¶ publikacji - zmienna
freeSpace (warto¶c której inicjalnie równa jest rozmiarowi pó³ki)  bêdzie
zmniejszona o liczbê egzemplarzy. Przy wstawianiu egzemplarzy publikacji
na pó³kê,  do tablicy pubs bêdziemy wpisywac referencjê do wstawianej publikacji
(da nam to informacje o tym jakie publikacje s± na pó³ce). takiego wpisu
dokonujemy jednokrotnie dla publikacji (a nie dla ka¿dego egzemplarza). W
rezultacie wiêkszo¶æ miejsca w tablicy pubs bêdzie niewykorzystana (zak³adamy
przecie¿, ¿e rozmiary tablicy okre¶laj± ile mo¿na wstawiæ na pó³kê egzemplarzy).
<br>
<br>

<pre>
public class Bookshelf {

  private int bsnr;             // numer pó³ki
  private Publication[] pubs;   // tablica publikacji
  private int freeSpace;        // wolne miejcce

  private int currIndex;        // bie¿±cy indeks tablicy publikacji,
                                // pod tym indeksem wpiszemy referencjê
                                // do publikacji umieszczanej w tablicy


  Bookshelf(int nr, int size) {
    pubs = new Publication[size];
    freeSpace = size;
    bsnr = nr;
  }

  // Zwraca numer pó³ki
  public int getNr() {
    return bsnr;
  }

  // Umieszcza egzemplarze przekazanej jako argument publikacji
  // na pó³ce. Zwraca true, je¶li to siê powiod³o - w przeciwnym razie false

  public boolean put(Publication p) {

    // je¿eli ju¿ na pó³ce - nie robimy nic
    if (p.whereIs() != null) {
      System.out.println("Publikacje ju¿ s± na pó³ce");
      return false;
    }

    int n = p.getQuantity();  // ile egzemplarzy danej pozycji wyd.

    if ( n &gt; freeSpace ) {    // gdy brak wolnego miejsca na pó³ce
      System.out.println("Brak miejsca na pó³ce");
      return false;
    }

    freeSpace -= n;        // zmniejszenie dostêpnego miejsca na pó³ce

    // referencja do obiektu-publikacji jest wpisywana do tablicy publikacji
    // indeks przesuwamy o 1 a nie o n, gdy¿ nie ma sensu powielaæ
    // informacji o publikacji dla wszystkich jej egzemplarzy

    pubs[currIndex++] = p;

    // w obiekcie-publikacji zapisujemy referencjê do pó³ki na której
    // znalaz³y siê egzemplarze tej publikacji

    p.setBookshelf(this);
    return true;
  }

  // zwraca tablicê publikacji na pó³ce
  // tablica ta ma currIndex elementów
  // gdy¿ nie powielamy informacji dla &gt; 1 egzemplarzy
  // tej samej publikacji, wobec czego pozosta³e elementy
  // tablicy publikacji pubs s± null i nie uwzglêdniamy ich

  public Publication[] getPubs() {
    Publication[] p = new Publication[currIndex];
    for (int i=0; i &lt; currIndex; i++) p[i] = pubs[i];
    return p;
  }
}
</pre>

<p>
W klasie testuj±cej pos³ugujemy siê tablicami pó³ek, ksi±¿ek i czasopism.<br>
Kolejne publikacje staramy siê wstawiæ na "bie¿±c±" pó³kê. Je¿eli brakuje miejsca - to tworzymy nowy obiekt pó³kê.<br>
<br>

<pre>
public class BookshelfTest {

  public static void main(String[] args) {

    final int BSNUM = 5;     // liczba pó³ek, których mo¿na u¿yæ
    final int BSIZE = 100;   // rozmiar pó³ki

    Bookshelf[] bs = new Bookshelf[BSNUM];  // tablica pó³ek;
                                            // samych pó³ek jeszcze nie ma

    Book[] bk = { new Book("P. Pies", "Psy", "WydPP", 2002, "ISBN01", 25, 100),
                  new Book("K. Kot", "Koty", "WydPP", 2002, "ISBN02", 22, 90),
                  new Book("A. Koñ", "Konie", "Tur", 2001, "ISBN01", 35, 50),
                };

    Journal[] jr = { new Journal(1, "Kwiaty", "WydAN", 2002, "ISSN03", 10, 20),
                    new Journal(1, "Ryby", "W&amp;S", 2002, "ISSN03", 20, 100),
                  };

    bs[0] = new Bookshelf(1, BSIZE);  // pierwsza pó³ka

    int k = 0;  // bie¿±cy indeks tablicy pó³ek -
                // daje nam tê pó³kê na któr± mamy wstawiaæ publikacje


    for (int i=0; i&lt;bk.length; i++) // wstawiamy po kolei wszystkie ksi±¿ki

       // je¿eli nie uda³o siê na pó³kê k - to bierzemy now± po³kê (k+1)
       while (!bs[k].put(bk[i]) &amp;&amp; k &lt; BSNUM ) {
         k++;
         bs[k] = new Bookshelf(k+1, BSIZE);
       }

    for (int i=0; i&lt;jr.length; i++) // wstawiamy po kolei wszystkie czasopisma

       // je¿eli nie uda³o siê na pó³kê k - to bierzemy now± po³kê (k+1)
       while (!bs[k].put(jr[i]) &amp;&amp; k &lt; BSNUM ) {
         k++;
         bs[k] = new Bookshelf(k+1, BSIZE);
       }


    // gdzie s± ksi±¿ki ?
    for (int i=0; i&lt;bk.length; i++) {
       Bookshelf b = bk[i].whereIs();
       String s = b == null ? " nie stoi na pó³ce"
                            : " jest na pó³ce "+ b.getNr();
       System.out.println( bk[i].getTitle() + s);
    }

    // gdzie s± czasopisma ?
    for (int i=0; i&lt;jr.length; i++) {
       Bookshelf b = jr[i].whereIs();
       String s = b == null ? " nie stoi na pó³ce"
                            : " jest na pó³ce "+ b.getNr();

       System.out.println(jr[i].getTitle() + s);
    }

    // co jest na pó³kach (tylko tych co zosta³y u¿yte)
    for (int i=0; i &lt; bs.length; i++) {
      if (bs[i] == null) break;
      Publication[] p = bs[i].getPubs();
      System.out.println("Pó³ka nr " +  bs[i].getNr());
      for (int j=0; j &lt; p.length; j++)  System.out.println(p[j].getTitle());
    }


  }

}
</pre>

<p>
Program wyprowadzi nastêpuj±ce wyniki.<br>
<br>

<div class="listing100">
Brak miejsca na pó³ce<br>
Brak miejsca na pó³ce<br>
Brak miejsca na pó³ce<br>
Psy jest na pó³ce 1<br>
Koty jest na pó³ce 2<br>
Konie jest na pó³ce 3<br>
Kwiaty jest na pó³ce 3<br>
Ryby jest na pó³ce 4<br>
Pó³ka nr 1<br>
Psy<br>
Pó³ka nr 2<br>
Koty<br>
Pó³ka nr 3<br>
Konie<br>
Kwiaty<br>
Pó³ka nr 4<br>
Ryby<br>
</div><p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index90.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index92.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
