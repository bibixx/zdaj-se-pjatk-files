<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index98.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 1"></A><div class="tytulpunktu">1. Napisy</div>

<p>
W praktycznych programach bardzo czêsto bêdziemy operowaæ na<A NAME="EDU.skorowidz.termin ³añcuch_znakowy 97_663"></A> ³añcuchach
znakowych (napisach). Wiemy doskonale, ¿e s± one reprezentowane przez obiekty
klasy String. W klasie tej znajdziemy wiele u¿ytecznych metod przeznaczonych
do operowania na ³añcuchach znakowych.<br>
<br><A NAME="EDU.skorowidz.termin dokumentacja 97_664"></A> Dokumentacjê klas i ich metod standardowych pakietów Javy znajdziemy w podkatalogu
docs katalogu instalacyjnego Java SDK. Jest ona w postaci HTML: klasy podzielone
s± wed³ug pakietów a tak¿e dostêpna jest alfabetyczna lista wszystkich klas.<br>
<b><font color="#ff6600"><br>

Proszê koniecznie otworzyæ dokumentacjê i oswoiæ siê z metodami nawigacji po¶ród ró¿nych pakietów, klas oraz ich metod.</font></b><br>
<br>

Dla wygody poni¿ej przedstawiono wybrane metody klasy String.<br>

Zwróæmy uwagê, ¿e:<br>
<ul>
<li>kolejne znaki napisów wystêpuj± na pozycjach, które s± indeksowane
poczynaj±c od 0: np. napis "Ala" ma trzy znaki na pozycjach 1, 2, 3; pierwsza
pozycja ma indeks 0, druga - 1, trzecia 2. Mo¿emy te¿ powiedzicæ, ¿e pierwszy
znak ma indeks 0, a ostatni - indeks o 1 mniejszy od d³ugo¶ci napisu,</li><li>czê¶ci napisów (³añcuchów znakowych) okre¶la siê terminem "pod³añcuch" (substring),</li><li>wiêkszo¶æ z omawianych dalej metod (wszystkie metody niestatyczne)
u¿ywana jest "na rzecz" obiektow klasy String; o obiekcie na rzecz którego
wywo³ano metodê mówimy <i><b>ten</b></i> napis,<br></li><li>przedstawiono tu nie wszystkie metody klasy String, a jedynie te najbardziej
u¿yteczne; o niektórych innych u¿ytecznych metodach dowiemy siê przy okazji
omawiania wyra¿eñ regularnych w przysz³ym semestrze.<br></li>
</ul><A NAME="EDU.skorowidz.termin string wybrane_metody 97_665"></A> 
<p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr><td colspan="2"><div align="Center"><b>Wybrane metody klasy String</b><br></div></td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> char</code></font></td><td><code><b>charAt</b>(int index)</code><br>
          Zwraca znak na pozycji, oznaczonej indeksem index. Pierwsza pozycja ma indeks 0.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>compareTo</b>(String anotherString)</code><br>
          Porównuje dwa napisy: <i><b>ten</b></i>  (this) na rzecz którego u¿yto metody oraz przekazany jako argument.<br>
Metoda zwraca 0, gdy napisy s± takie same.<br>
Je¿eli siê ró¿ni±, to - gdy wystêpuj± w nich ró¿ne znaki - zwracana jest warto¶æ: <br>
             this.charAt(k) - anotherString.charAt(k), <br>
gdzie k - indeks pierwszej pozycji, na której wystêpuje ró¿nica znaków. Je¿eli
d³ugo¶æ napisów jest ró¿na (a znaki napisów s± takie same w czê¶ci okre¶lanej
przez dlugo¶c krótszego napisu) - zwracana jest ró¿nica dlugo¶ci:<br>
            this.length() - anotherString.length().<br><br>
Oznacza to, ¿e wynik jest ujemny, gdy <i><b>ten</b></i> (this) ³añcuch poprzedza leksykograficznie (alfabetycznie) argument (anothetString) oraz dodatni - gdy <i><b>ten</b></i> ³añcuch jest leksykograficznie wiêkszy od argumentu.<br></td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>compareToIgnoreCase</b>(String str)</code><br>
           Porównuje leksykograficznie dwa napisy, bez rozró¿nienia ma³ych i wielkich liter.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> boolean</code></font></td><td><code><b>endsWith</b>(String suffix)</code><br>
          Zwraca true, gdy napis koñczy siê ³añcuchem znakowym podanym jako argument, false - w przeciwnym razie.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> boolean</code></font></td><td><code><b>equals</b>(Object anObject)</code><br>
          Zwraca true gdy anObject jest takim samym co do zawarto¶ci napisem jak <i><b>ten</b></i> napis; w ka¿dym innym przypadku - zwraca false.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> boolean</code></font></td><td><code><b>equalsIgnoreCase</b>(String anotherString)</code><br>
          J.w. - ale bez rozró¿niania ma³ych i wielkich liter.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>indexOf</b>(String str)</code><br>
           Zwraca indeks pozycji pierwszego wyst±pienia w danym napisie napisu
podanego jako argument str; je¿eli str nie wystêpuje w tym napisie - zwraca
-1</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>indexOf</b>(String str,
        int fromIndex)</code><br>           Poszukuje pierwszego wyst±pienia
napisu str poczynaj±c od pozycji oznaczonej przez indeks fromIndex; zwraca
indeks pozycji na której zaczyna siê str lub - 1 gdy str nie wystêpuje w
      <i><b>tym</b></i> napisie.<br>
Je¶li fromIndex jest ujemne lub zero - przeszukiwany jest ca³y napis; je¶li
fromIndex jest wiêksze od d³ugo¶ci napisu - zwracane jest -1.<br></td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>lastIndexOf</b>(String str)</code><br>
          Jak indexOf - ale zwracany jest indeks pozycji ostatniego wyst±pienia.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>lastIndexOf</b>(String str,
            int fromIndex)</code><br>          J.w.<br>
Uwaga: metody indexOf i lastIndexOf maj± równie¿ swoje wersje dla argumentów - znaków (typu char).<br></td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> int</code></font></td><td><code><b>length</b>()</code><br>
          Zwraca d³ugo¶æ napisu.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>replace</b>(char oldChar,
        char newChar)</code><br>
          Zwraca nowy obiekt klasy String, w którym zast±piono wszystkie wyst±pienia znaku oldChar na znak newChar.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> boolean</code></font></td><td><code><b>startsWith</b>(String prefix)</code><br>
          Zwraca true, gdy napis zaczyna siê podanym jako argument ³añcuchem znakowym; false - w przeciwnym razie.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> boolean</code></font></td><td><code><b>startsWith</b>(String prefix,
           int toffset)</code><br>           Zwraca true, gdy pod³añcuch
tego ³añcucha znakowego zaczynaj±cy siê na pozycji o indeksie toffset zaczyna
siê napisem prefiks; zwraca false w przeciwnym razie, lub gdy toffset jest
&lt; 0 albo wiêkszy od dlugo¶ci napisu.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>substring</b>(int beginIndex)</code><br>
          Zwraca pod³añcuch <i><b>tego</b></i> ³añcucha znakowego zaczynaj±cy siê na pozycji o indeksie beginIndex (do koñca ³añcucha).</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>substring</b>(int beginIndex,
          int endIndex)</code><br>
          Zwraca pod³añcuch <i><b>tego</b></i> ³añcucha jako nowy obiekt
klasy String.  Pod³añcuch zaczynay siê na pozycji o indeksie beginIndex,
a koñczy (uwaga!) - na pozycji o indeksie endIndex-1. D³ugo¶æ podlañcucha
równa jest endIndex - beginIndex.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> char[]</code></font></td><td><code><b>toCharArray</b>()</code><br>
          Znaki ³añcucha -&gt; do tablicy znaków (typ char[]).</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>toLowerCase</b>()</code><br>
          Zamiana liter na ma³e.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>toUpperCase</b>()</code><br>          Zamiana liter na du¿e.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code> String</code></font></td><td><code><b>trim</b>()</code><br>
           Usuwa znaki spacji, tabulacji, koñca wiersza itp. tzw. biale znaki
z obu koñców ³añcucha znakowego. Zwraca wynik jako nowy ³añcuch.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(boolean b)</code><br>
          Zwraca warto¶æ boolowsk± (boolean) jako napis (String).</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(char c)</code><br>
          Zwraca warto¶æ typu char jako napis.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(char[] data)</code><br>
         Zwraca napis z³o¿ony ze znakow tablicy. </td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(double d)</code><br>
          Zwraca znakow± treprezentacjê liczby typu double.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(float f)</code><br>
          Zwraca znakow± treprezentacjê liczby typu <code>float</code>.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(int i)</code><br>
          Zwraca znakow± treprezentacjê liczby typu <code>int</code>.</td></tr><tr><td align="Right" valign="Top" width="1%"><font size="-1"><code>static String</code></font></td><td><code><b>valueOf</b>(long l)</code><br>
          Zwraca znakow± reprezentacjê liczby typu <code>long</code>.</td></tr></tbody>
</table>

<br>
<p>

W pierwszym przyk³adowym programie wykorzystamy<A NAME="EDU.skorowidz.termin charAt metoda 97_666"></A> metodê charAt, zwracaj±c± znak znajduj±cy siê w napisie na podanej pozycji.<br>

<p>
<img src="images/wycieczki.jpg" alt="r" hspace="15" width="293" height="214" border="1" align="Right">
Problem: napisaæ program, który prosi u¿ytkownika o wybranie jednej z mo¿liwych
wycieczek oznaczanych du¿ymi literami A, B, C ..., po czym podaje cenê tej
wycieczki. Miejsca docelowe wycieczek oraz ich ceny maj± byæ zapisane w tablicach, np.:<br>
<br>

    String[] dest  = { "Bali", "Cypr", "Ibiza",<br>

                               "Kenia", "Kuba" };<br>

    double[] price = { 5000, 2500, 2800, 4500,<br>

                                6000 };<br>
<br>

a program winien dawaæ u¿ytkownikowi mo¿liwo¶æ wyboru za pomoc± pokazanego obok okna dialogowego.</p>
<br clear="all">



<div class="important">
Przed lektur± dalszego tekstu proszê to zadanie rozwi±zaæ samodzielnie<br>
</div>

<br>

<p>

A zatem u¿ytkownik wprowadza napis, sk³adaj±cy siê z jednej litery "A" lub "B" lub "C', ... itd.<br>

Dalsze dzia³anie programu zale¿y od tego jak± literê wprowadzil.<br>

Je¶li res oznacza wprowadzony napis, to mogliby¶my np. napisaæ:<br>
<br>

if (res.equals("A")) System.out.println(dest[0] + " - cena: " + price[0]);<br>

else if (res.equals("B")) System.out.println(dest[1] + " - cena: " + price[1]);<br>

      else if (res.equals("C")) ..<br>

            else if (res.equals("D")) ...<br>

                  else if (res.equals("E")) ..<br>

                         else ...<br>
<br>

Ale jest to do¶æ uci±¿liwe i nieeleganckie. Nara¿one na b³êdy. Trudne do modyfikacji.<br>
<br>

A przecie¿ wprowadzona litera daje nam natychmiastowe odniesienie do odpowiednich
elementów tablic dest i price. Litera to znak.<A NAME="EDU.skorowidz.termin kod_znaku 97_667"></A> Znak ma swój kod. Kod jest
liczb±. £atwo jest wiêc przekszta³ciæ znaki w odpowiednie indeksy tablic.
<br>

Znak A powinien daæ indeks 0, znak B - indeks 1, znak C - indeks 2.<br>

Zauwa¿my, ¿e: 'A' - 'A' = 0 , 'B'- 'A' = 1, 'C' - 'A' = 2 ...<br>

Zatem wyliczenie odpowiedniego indeksu mo¿na zapisac tak:<br>

indeks = &lt;wprowadzony_znak&gt; - 'A'<br>
<br>

No, ale musimy jeszcze siêgn±æ po ten znak. Z dialogu dostajemy napis (³añcuch
znakowy). To jest dana typu String, a nie char. Napis ten sk³ada siê z jednego znaku,
znajduj±cego siê na pierwszej pozycji ³añcucha (czyli pod indeksem 0). Znak
ten otrzymamy stosuj±c metodê <b>charAt</b> z klasy String.<br>
<br>

Je¶li res oznacza wprowadzony napis, to - zamiast poprzedniej "piêtrowej" konstrukcji if-else mo¿emy po prostu napisaæ:<br>
<br>

      int i = res.charAt(0) - 'A';<br>

     System.out.println(dest[i] + " - cena: " + price[i]);<br>
<br>

Ca³y program pokazano poni¿ej.<br>

<pre>
import javax.swing.*;

public class Wycieczki {

  public static void main(String[] args) {

    String[] dest  = { "Bali", "Cypr", "Ibiza", "Kenia", "Kuba" };
    double[] price = { 5000, 2500, 2800, 4500, 6000 };

    String msg = "Wybierz kierunek - " +
                 " wpisuj±c literê A-"+ (char) ('A'+dest.length-1)+ ":\n";

    for (int i=0; i &lt; dest.length; i++)
      msg += (char) ('A' + i) + " - " + dest[i] + '\n';

    String res;
    while ((res = JOptionPane.showInputDialog(msg)) != null) {
      int i = res.charAt(0) - 'A';
      if (i &lt; 0 || i &gt; dest.length -1) continue;
      JOptionPane.showMessageDialog(null, dest[i] + " - cena: " + price[i]);
    }
   System.exit(0);

  }

}
</pre>

<p>
Dodatkowe komentarze:<br>
<ul>
<li>w oknie dialogowym wprowadzania danych tekst komunikatu (msg) sk³ada
siê z kilku wierszy; tekst dzielimy na wiersze za pomoc± znaku '\n',</li><li>program napisano w taki sposób, ¿e przy zmianie liczby wycieczek nale¿y
zmieniæ tylko inicjacje tablic dest i price; inne fragmenty kodu nie ulegn±
zmianie!,</li><li>przy tworzeniu komunikatu (msg) znowu wykorzystano mo¿liwo¶æ traktowania
znaków jako liczb (kody znaków); jednak operacje arytmetyczne na znakach
daj± w wyniku warto¶ci typu int, a poniewa¿ chcemy pokazaæ znak , a nie jego
kod (int) - to musimy jawnie przekszta³ciæ te warto¶ci do typu char - st±d
konieczno¶æ u¿ycia operatora konwersji (char)</li><li>poprawno¶æ pierwszego znaku wprowadzonego napisu (czy mie¶ci siê w
przedziale A-E) sprawdzamy za pomoc± if; innym sposobem obs³ugi b³êdu by³aby
obs³uga wyj±tku (ArrayIndexOutOfBoundsException).<br></li>
</ul>

<p>Spróbujmy teraz rozwi±zaæ inne zadanie. Wyobra¼my sobie, ¿e mamy dokument
html o prostej strukturze, w którym kolejne tytu³y punktów tre¶ci znajduj±
siê miêdzy znacznikami &lt;h2&gt; ... &lt;/h2&gt; (tekst zawarty pomiêdzy
otwieraj±cym znacznikiem &lt;h2&gt; i zamykaj±cym znacznikiem &lt;/h2&gt;
- traktowany jest jako nag³ówek drugiego poziomu i odpowiednio do tego formatowany
przy wy¶wietlaniu w przegl±darce).<br>

Naszym zadaniem jest wypisanie wszystkich takich nag³ówków. <br>

<div class="notel">Uwaga. W tej chwili zajmujemy siê najbardziej prymitywnym rozwi±zaniem
problemu, w oparciu o "tradycyjne" metody klasy String. G³ównie po to, by
przeæwiczyæ  stosowanie tych metod. Inne rozw±zania mog± wykorzystywac parsery
HTML lub wyra¿enia regularne</div>

<div class="ddd"><br>
Na razie jeszcze nie umiemy wczytywac plików,
ale mo¿emy ju¿ przygotowaæ i przetestowaæ klasê, która pozwoli "wy³uskiwaæ"
z dokumentu nag³ówki drugiego poziomu.
</div>
<br clear="all">

<br>
<p>
Niech ta klasa (trochê na wyrost) nazywa siê  Toc. Przy tworzeniu obiektu
tej klasy przekazujemy konstruktorowi ca³y dokument HTML w postaci ³añcucha
znakowego, a wywo³anie metody String getToc() - ma zwróciæ listê nag³ówków
drugiego pioziomu, rozdzielonych separatorami nowego wiersza. Listê tê mo¿emy
nastêpnie wypisaæ na konsoli lub skierowaæ standardowy strumieñ wyj¶ciowy
do pliku.<br>
<br>

Jak podej¶æ do tego problemu?<br>

W tek¶cie dokumentu musimy kolejno znajdowaæ pocz±tki nag³ówków ("&lt;h2&gt;"),
a nastêpnie "wy³uskiwaæ" pod³añcuchy, które s± zawarte pomiêdzy znacznikami
"&lt;h2&gt;" i "&lt;/h2&gt;". Do znajdowania napisów w napisie s³u¿y<A NAME="EDU.skorowidz.termin indexOf metoda 97_668"></A> metoda
indexOf, do "wy³uskiwania" pod³acuchów metod  substring. Uwaga: powinni¶my
zastosowaæ tê wersjê metody indexOf, która zaczyna poszukiwanie od podanej
pozycji ³añcucha i wraz z postêpem przeszukiwania odpowiednio zmieniaæ tê
pozycjê.<br>
<br>

<div class="important"><br>
Przed lektur± dalszego tekstu proszê to zadanie rozwi±zaæ samodzielnie
<br>
<br>
</div>

<br>
<p>

Klasa Toc mo¿e wygl±daæ tak.<br>
<br>

<pre>
import javax.swing.*;

public class Toc {

   private String doc;           // przekazany dokument
   private String toc = "";      // wynikowy spis tre¶ci

   // separator koñca wiersza; poniewa¿ jest zale¿ny od systemu
   // pobieramy go jako warto¶æ tzw. w³a¶ciwo¶ci systemowej

   private final String ls = System.getProperty("line.separator");

   public Toc(String doc) { // Konstruktor
     this.doc = doc;
   }

  public String getToc() {

     int p = 0; // pozycja od której zaczynamy szukanie "&lt;h2&gt;"

     while ((p = doc.indexOf("&lt;h2&gt;", p)) != -1) { // dopóki s± "&lt;h2&gt;"

       // poszukajmy znacznika zamykaj±cego
       // end jest indeksem pozycji na której on wystêpuje

       int end = doc.indexOf("&lt;/h2&gt;", p+4);

       // je¿eli go nie ma ...

       if (end == -1) return Emsg("Invalid document structure");

       // w przeciwnym razie: wy³uskujemy nag³ówek
       toc += doc.substring(p+4, end) + ls;  // ls - separator wierszy

       p = end + 5;  // i przesuwamy pozycjê od której bêdziemy dalej szukaæ
     }

     return toc;
  }

  private String Emsg(String txt) {  // komunikat o b³êdzie
    JOptionPane.showMessageDialog(null, txt);
    return toc;
  }
  
</pre>

<p><i>
Uwaga: powy¿sza wersja programu nie obs³uguje przypadku wadliwej struktury
dokumentu, gdy znacznik &lt;h2&gt; wystêpuje pomiêdzy znacznikami &lt;h2&gt;
i &lt;/h2&gt;.<br>
</i><br>
Przy okazji tego programu wykorzystali¶my mo¿liwo¶æ pobierania<A NAME="EDU.skorowidz.termin systemowe w³a¶ciwo¶ci 97_669"></A> w³a¶ciwo¶ci systemowych. Za pomoc± odwo³ania:<br>
<br><A NAME="EDU.skorowidz.termin System.getProperty 97_670"></A> System.getProperty("line.separator") <br>
<br>
 zapytali¶my Javy jaki na danej platformie systemowej obowi±zuje separator
wierszy (w plikach), Zauwa¿my, ¿e ró¿ne systemy stosuj± ró¿ne separatory (np.
pod Unixem jest to 0d , a pod Windows 0d0a - szesnastkowo). Poniewa¿ nasz
spis tre¶ci chcemy zapisywaæ do pliku to musimy u¿yæ znaku separatora wierszy.
A zgodnie z za³o¿eniami Javy (wieloplatformowo¶æ) powinni¶my przygotowaæ
program tak by dzia³al bez rekompilacji na ka¿dej platformie. <br>

<br>
<div>
[ <a href="javascript:popUp('dodatki/W12D1.htm',75,75)">wiêcej o w³a¶ciwo¶ciach systemowych</a> ]</div>

<br>
<p>

Klasê Toc mo¿emy na razie przetestowaæ na "sztywno" zadanym dokumencie. Za
chwilê, gdy nauczymy siê wczytywaæ pliki - zobaczymy jak dzia³a na konkretnych
plikach html.<br>
<br>

<pre>
class TocTest {

  public static void main(String[] args) {
    String doc = "&lt;h2&gt;1.1. Punkt 1&lt;/h2&gt;" +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "&lt;h2&gt;1.2. Punkt 2&lt;/h2&gt;" +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "&lt;h2&gt;1.3. Punkt 3&lt;/h2&gt;" +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "&lt;h2&gt;1.4. Punkt 4&lt;/h2&gt;" +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " +
                 "&lt;h2&gt;1.5. Punkt 5&lt;/h2&gt;" +
                 "ble ble ble ble ble  " +
                 "ble ble ble ble ble  " ;

    System.out.println(new Toc(doc).getToc());
  }
}
</pre>

<p>
Wydruk programu (mo¿emy go przekierowaæ do pliku np. tak: java TocTest &gt; out):<br><br>

<div class="listing100">1.1. Punkt 1<br>

1.2. Punkt 2<br>

1.3. Punkt 3<br>

1.4. Punkt 4<br>

1.5. Punkt 5</div>

<br>
<p>

Pewn± zaskakuj±c± mo¿e w³a¶ciwo¶ci± klasy<A NAME="EDU.skorowidz.termin string 97_671"></A> String jest to, ¿e jej obiekty s± <b>niemodyfikowalne</b> - to znaczy utworzonych za pomoc± klasy String napisów  nie mo¿emy zmieniaæ (np. do napisu dodaæ inny). <br>

Jak to ??? Przecie¿ wielokrotnie zajmowali¶my siê konkatenacj± ³añcuchów.<br>

No tak, ale wynikowy napis, powstaj±cy z dodania do ³añucha znakowego innego napisu, <b>jest nowym obiektem</b> i np. w takiej sekwencji:<br>
<br>

String s = "Ala";<br>

s = s + " ma kota";<br>
<br>

tworzony jest nowy obiekt, zawieraj±cy napis "Ala ma kota" i referencja do
niego przypisywana jest zmiennej s, która poprzednio zawiera³a referencjê do napisu "Ala".<br>
<br>

Zwróæmy te¿ uwagê, ¿e w klasie String nie ma ¿adnych metod pozwalaj±cych modyfikowaæ istniej±cy obiekt-napis. <br>
<br><A NAME="EDU.skorowidz.termin StringBuffer klasa 97_672"></A> Czasami jednak zmiany obiektów napisów s± potrzebne. <br>
<br>

<div class="important">Modyfikowalne obiekty-³añcuchy znakowe definiuje klasa <b>StringBuffer</b>.</div>

<br>
<p>

Obiekty klasy StringBuffer to "bufory", które dynamicznie mo¿emy wype³niaæ
napisami. W szczególno¶ci mo¿emy utworzyæ pusty - na razie - bufor:<br>
<br>

StringBuffer sb = new StringBuffer();<br>
<br>

po czym wupelniaæ go zawarto¶æi± dopisuj±c do niego jakie¶ kolejne napisy:<br>
<br>

sb.append("jaki¶ napis 1");<br>

sb.append("jaki¶ napis 2");<br>

...<br>
<br>

Obiekt klasy StringBuffer ³atwo mo¿na przekszta³æiæ w obiekt klasy String za pomoc± metod toString():<br>
<br>

String s = sb.toString();<br>
<br>
<font color="#ff6600"><b>Proszê zapoznaæ siê z dokumentacj± klasy StringBuffer</b></font>.<br>
<br>

Wykorzystanie klasy StringBuffer zamiast String jest wskazane przy du¿ej liczbie<A NAME="EDU.skorowidz.termin kumulatywna_operacja_konkatenacji 97_673"></A> "kumulatywnych" operacji konkatenacji.<br>

Jak ju¿ wspomniano, ka¿da operacja konkatenacji obiektów klasy String zapisana
za pomoc± operatora + powoduje stworzenie nowego obiektu klasy String i skopiowanie
do "jego wnêtrza" znaków ³±czonych ³añcuchów. Jest to dosyæ czasoch³onne.<br>
<br>

Ró¿nicê pokazuje poni¿szy program (przygotowany w oparciu o materia³y JDC TechTips - biuletynu Java Developer Connection).<br>

Do<A NAME="EDU.skorowidz.termin mierzenie_czasu_operacji 97_674"></A> mierzenia czasu operacji korzystamy w nim z klasy QTimer, w której zdefiniowali¶my
metodê getElapsed() zwracaj±c± up³yw czasu od mometu utworzenia obiektu tej
klasy. Czas mierzymy za pomoc± statycznej metody klasy System currentTimeMillis(),
która zwraca bie¿±cy czas w milisekundach.<br>
<br>

<pre>
import javax.swing.*;

class QTimer {

   private final long start;

   public QTimer() {
     start = System.currentTimeMillis();
   }

   public long getElapsed() {
      return System.currentTimeMillis() - start;
   }
}

public class Test {


  public static void main(String args[]) {

    int n = Integer.parseInt(JOptionPane.showInputDialog("Liczba operacji"));


    QTimer t = new QTimer();
    String strA = "";
    for (int i = 1; i &lt;= n; i++)  strA += "A";
    long etA = t.getElapsed();
    System.out.println("String operator +;   Czas: " + etA  + " ms");


    t = new QTimer();
    StringBuffer sb = new StringBuffer();
    for (int i = 1; i &lt;= n; i++) sb.append("B");
    String strB = sb.toString();
    long etB = t.getElapsed();
    System.out.println("StringBuffer append. Czas: " +  etB + " ms");
    System.out.println("Wykonano " + n + " operacji.");
    System.out.println("Relacja A/B = " + (double) etA/etB);
    System.exit(0);
  }
}

</pre>

<p>Wynik:<br><br>

<div class="listing100"><br>

String operator +;   Czas: 3900 ms<br>

StringBuffer append. Czas: 60 ms<br>

Wykonano 9000 operacji.<br>

Relacja A/B = 65.0<br>

</div>

<br>
<p>

Jak widaæ, "kumulatywna" konkatenacja za pomoc± klasy StringBuffer jest (przy
9 tys. operacji konkatenacji) 65-krotnie szybsza ni¿ za pomoc± operatora
+.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index98.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
