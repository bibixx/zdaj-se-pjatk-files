<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index19.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index21.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 3"></A><div class="tytulpunktu">3. Tablice</div>

<a name="W3.3"></a>

<p>Czêsto dane w programie bêdziemy chcieli grupowaæ w pewne zestawy, które
stanowi± logiczn± ca³o¶æ, choæ sk³adaj± siê z poszczególnych elementów. Taki
zestaw powinien mieæ jedn± nazwê (bo przecie¿ oznacza logiczn± ca³o¶æ), a
poszczególne jego elementy powinny byæ dostêpne przez tê nazwê oraz jak±¶
dodatkow± informacjê, pozwalaj±c± odnale¼æ element w zestawie.  <br>
Szczególnym przypadkiem takich zestawów danych s± <b>tablice</b>.<br>
<br><A NAME="EDU.skorowidz.termin tablica 20_166"></A> 

<div class="def"><b>Tablice</b> s± zestawami<A NAME="EDU.skorowidz.termin tablica element 20_167"></A> elementów danych, u³o¿onych na okre¶lonych
<b>pozycjach</b>. Do ka¿dego z tych elementów mamy <b>bezpo¶redni</b> (<b>
swobodny</b> - nie wymagaj±cy przegl±dania innych elementów zestawu) dostêp
poprzez <b>nazwê tablicy</b> i pozycjê elementu w zestawie, okre¶lan± przez<A NAME="EDU.skorowidz.termin tablica indeks 20_168"></A> <b>indeks</b> lub indeksy.</div>

<br>
<p>Wyobra¼my sobie np., ¿e chcemy pos³ugiwaæ siê zestawem dni tygodnia.<br>
Zestaw ten - tablicê - nazwiemy <b><i>dni</i></b>.<br>
Kolejne jego elementy (kolejne dni tygodnia) ponumerujemy za pomoc± indeksów
(jedynka bêdzie oznaczaæ poniedzia³ek, dwójka - wtorek itd.).<br>
Musimy mieæ jeszcze jak±¶ konstrukcjê sk³adniow±, która pozwoli oznaczaæ
kolejne elementy tablicy.<br> W naszym uproszczonym jêzyku (bazuj±cym na
REXXie) tak± konstrukcj± - podobnie jak w Javie (C i C++) - bêd± nawiasy
kwadratowe, w których umieszczaæ bêdziemy indeksy (uwaga: jest to zmiana
sk³adniowa w stosunku do klasycznego REXXa, zastosowana w uproszczonej, zmodyfikowanej
wersji tego jêzyka, któr± siê pos³ugujemy w naszych æwiczeniach).<br><br>
Mo¿emy zatem zapisaæ:<br>
<br>
dni[1] = "poniedzia³ek";<br>
dni[2] = "wtorek";<br>
dni[3] = "¶roda";<br>
dni[4] = "czwartek";<br>
dni[5] = "pi±tek";<br>
dni[6] =  "sobota";<br>
dni[7] =  "niedziela";<br>
<br>
Jak widaæ elementy tablic mo¿emy traktowaæ jako zmienne. Zmiennym tym (tak
jak ka¿dym innym zmiennym) poprzez przypisanie nadawane s± podane warto¶ci.<br>
Nie jest to jedyny sposób ustalenia warto¶ci elementów tablicy.<br>
<br>

<div class="notel33">Uwaga! W uproszczonym Rexx-ie inicjacja tablicy za pomoc± nawiasów klamrowych
musi znajdowaæ siê w jednym wierszu programu i mo¿e dotyczyæ tylko tablic
jednowymiarowych.<br>
Nie wolno przy tym zapomnieæ o umieszczeniu pustych nawiasów <b>[ ]</b> po
nazwie tablicy.</div>

<div class="ddd">
<br><A NAME="EDU.skorowidz.termin tablica inicjacja 20_169"></A> Tablice mo¿emy <b>inicjowaæ</b> w szybszy sposób za pomoc± specjalnych konstrukcji
syntaktycznych. W naszym uproszczonym, zmodyfikowanym REXXie, inicjacja tablic 
bêdzie dokonywana (podobnie jak w Javie) za pomoca nawiasów klamrowych:<br>
<br>
dni[] = {"poniedzia³ek", "wtorek", "¶roda", "czwartek", "pi±tek", "sobota",
"niedziela" };
</div>

<br clear="all">

<p>Ten zapis oznacza dok³adnie to samo, co poprzedni: elementowi
z indeksem 1 tablicy <i><b>dni</b></i> nadawana jest warto¶æ "poniedzia³ek",
elementowi z indeksem 2 - warto¶æ "wtorek" itd.<br>
<br>
Oczywi¶cie, mo¿emy nie tylko ustalaæ, ale  równie¿ pobieraæ warto¶ci elementów
tablicy.<br>
W poni¿szym programie wypisujemy aktualny dzieñ tygodnia, korzystaj±c przy
tym z wbudowanej funkcji <b>date</b>().<br>
<br>

<pre>
/* Podaje aktualny dzieñ tygodnia */

dni[]={"poniedzia³ek", "wtorek", "¶roda", "czwartek", "pi±tek", "sobota", "niedziela"};
ldni = date('B'); /* liczba dni od 1 stycznia 0001 */
nrDnia = ldni // 7 + 1;
say 'Dzisiaj jest :' dni[nrDnia];
</pre>

<p>Wbudowana funkcja <i><b>date</b></i> wywo³ana z argumentem 'B' zwraca liczbê
dni, które minê³y od 1 stycznia 0001 roku (kalendarza gregoriañskiego) do
wczoraj w³±cznie. Poniewa¿ wiadomo, ¿e wtedy by³a niedziela, to reszta z
dzielenia tej liczby dni przez 7 da: dla poniedzia³ku 0, dla wtorku 1,...
dla niedzieli 6. Dodaj±c do tego wyniku 1 uzyskamy odpowiedni indeks naszej
tablicy dni.<br>
<br>
<font color="#ff6600"><b>Proszê zapisaæ i uruchomiæ omawiany wy¿ej program na w³asnym komputerze. </b></font><br>
<br>
Inny przyk³ad: znów trochê lepsza wersja liczenia ceny komputera. Tym razem
nazwy sk³adowych komputera i odpowiadaj±ce im ceny bêdziemy przechowywaæ
w tablicach. Dziêki temu modyfikacje programu (np. wyszczególnienie wiêkszej
liczby sk³adników) bêd± bardzo ³atwe. Ponadto uzyskamy ³atw± (przy poprzednim
sposobie oprogramowania nieosiagaln± ) mo¿liwo¶æ interakcyjnej zmiany ceny
dowolnego wybranego sk³adnika.<br>

<pre>
/* Obliczenie ceny komputera */

N = 6 /* liczba sk³adników */

/* Tablica nazw sk³adników */
elt[] = { "Procesor", "P³yta", "Pamiêæ", "Dysk", "Monitor", "Inne" };

/*
   Pobieramy ceny ka¿dego sk³adnika
   i liczymy ich sumê
*/
suma = 0
do i = 1 to N
   say elt[i] "- podaj cenê: ";
   cena[i] = linein();
   suma = suma + cena[i];
end

say "Cena komputera wynosi :" suma;
say "Udzia³ ceny procesora :" cena[1]/suma;

/*
   Dajemy u¿ytkownikowi mo¿liwo¶æ
   zmiany ceny dowolnego sk³adnika
*/
say "Któr± cenê chcesz zmieniæ ? Wybierz";
do i = 1 to n
   say i '-' elt[i];
end
say "Podaj wybrany numer:"
nr = linein();

/*
   Podany numer musi zawieraæ siê
   w zakresie od 1 do N - liczby sk³adników
*/

if (nr &lt; 1 | nr &gt; N) then do
   say "Z³y wybór";
   exit;
end

/* zachowujemy star± cenê wybranego sk³adnika */
stara_cena = cena[nr];

/*
   Pobieramy now± cenê wybranego skladnika
   i obliczamy now± cenê komputera
*/

say elt[nr] " - wprowadz now± cenê";
cena[nr] = linein();
suma = suma - stara_cena + cena[nr];

say "Cena komputera wynosi :" suma;
say "Udzia³ ceny procesora :" cena[1]/suma;
</pre>

<br>

<div class="listing33r">
<i>Przyk³adowy wydruk dzia³ania programu</i><br>
Procesor - podaj cenê:<br>
500<br>
P³yta - podaj cenê:<br>
500<br>
Pamiêæ - podaj cenê:<br>
500<br>
Dysk - podaj cenê:<br>
500<br>
Monitor - podaj cenê:<br>
1000<br>
Inne - podaj cenê:<br>
500<br>
Cena komputera wynosi : 3500<br>
Udzia³ ceny procesora : 0.142857143<br>
Któr± cenê chcesz zmieniæ ? Wybierz<br>
1 - Procesor<br>
2 - P³yta<br>
3 - Pamiêæ<br>
4 - Dysk<br>
5 - Monitor<br>
6 - Inne<br>
Podaj wybrany numer:<br>
1<br>
Procesor  - wprowadz now± cenê<br>
700<br>
Cena komputera wynosi : 3700<br>
Udzia³ ceny procesora : 0.189189189
</div>

<div class="ddd">
<br>
W tym programie warto zwróciæ uwagê
na zastosowanie zmiennej o nazwie N dla oznaczenia liczby skladników. Mogliby¶my
jej nie u¿ywaæ, pisz±c <i><b>do i = 1 to 6</b></i>. Ale wtedy zmiana liczby sk³adników poci±ga³aby za sob± konieczno¶æ zmian
kodu w wielu miejscach programu. Maj±c <i><b>N</b></i> i pisz±c zawsze <i><b>
do i =1 to N</b></i>, mo¿emy zmieniæ warto¶æ <i><b>N</b></i> tylko raz, w
jednym miejscu i w ten sposób mamy zarówno mniej pracy jak i w mniejszym
stopniu nara¿eni jeste¶my na b³êdy.<br>
<br>
<font color="#ff6600"><b>Proszê zapisaæ i uruchomiæ omawiany wy¿ej program na w³asnym komputerze. </b></font>
</div>

<br clear="all">

<p>Dot±d pos³ugiwali¶my siê tablicami jednowymiarowymi. Nic nie stoi na przeszkodzie,
by tworzyæ i u¿ywaæ<A NAME="EDU.skorowidz.termin tablica_wielowymiarowa 20_170"></A> tablic wielowymiarowych. W naszym uproszczonym REXXie
odwo³ania do tablic wielowymiarowych bêdê mia³y postaæ:<br>
<br>
                a[i][j][k]...<br>
<br>
gdzie kolejne nawiasy kwadratowe s³u¿± indeksowaniu w ka¿dym z wymiarów.<br>
<br>
Typowym przyk³adem tablicy dwuwymiarowej jest<A NAME="EDU.skorowidz.termin macierz 20_171"></A> macierz (czyli tablica liczb,
u³o¿onych w wierszach i kolumnach).<br>
Poni¿szy program realizuje algorytm mno¿enia macierzy (dla uproszczenia:
kwadratowych). Element i-go wiersza i j-ej kolumny macierzy C, bêd±cej iloczynem
macierzy A i macierzy B,  jest sum± iloczynów elementów i-go wiersza macierzy
A przez elementy j-ej kolumny macierzy B.<br>
<br>

<pre>
/* Mno¿enie macierzy kwadratowych */

N = 2;

a[1][1] = 1;  b[1][1] = 2;
a[1][2] = 2;  b[1][2] = 2;
a[2][1] = 3;  b[2][1] = 3;
a[2][2] = 7;  b[2][2] = 2;

do i = 1 to N;
  do j = 1 to N;
    c[i][j] = 0;
    do k = 1 to N;
       c[i][j] = c[i][j] + a[i][k] * b[k][j];
    end
  end
end

say 'Wynik'
do i = 1 to N
  out = '';
  do j = 1 to N
    out = out right(c[i][j], 8);
  end
  say out;
end
</pre>

<br>

<div class="listing33r"> Wynik:<br>
        8        6<br>
       27       20
<br><br>
</div>

<div class="ddd">
<br>
Wynik podajemy "wierszami", sk³adaj±c elementy ka¿dego
wiersza w zmiennej out. Funkcja right umieszcza swój pierwszy argument (w
tym przypadku c[i][j] w polu o rozmiarach, podanych jako drugi argument (8)
z wyrównaniem do prawej strony. Dziêki temu uzyskujemy "³adny" wydruk.
</div>

<br clear="all">

<p>W tym intuicyjnym wprowadzeniu do tablic pominêli¶my sporo istotnych szczegó³ów:<br>

<ul>
  <li>jakie warto¶ci mog± przybieraæ indeksy?</li><li>czy pierwszy element tablicy zawsze ma ustalony indeks i - je¶li tak - to jaki?<br>
  </li>

  <li>czy rozmiary tablicy mog± byæ ustalane w trakcie wykonania programu?</li>
  <li>czy rozmiary te mog± w trakcie wykonania programu zmieniaæ siê?</li>
  <li>w jaki sposób tablice s± lokowane w pamiêci komputera?<br>
  </li>
</ul>

<p>Ka¿dy jêzyk programowania odpowiada nieco inaczej na te pytania.<br>
W szczególno¶ci w REXXie (równie¿ w naszej uproszczonej i zmodyfikowanej
wersji tego jêzyka) indeksy mog± przybieraæ dowolne warto¶ci, a tablice s± tworzone dynamicznie w trakcie
dzia³ania programu i mog± dynamicznie siê rozszerzaæ. <br><br>
Natomiast w Javie: <br>

<ul>
  <li>
indeksy
mog± przybieraæ tylko nieujemne warto¶ci ca³kowitoliczbowe,</li>
  <li>
tablice zawsze s± indeksowane od 0 - pierwszy element tablicy ma indeks 0
(jest to kolejne ¶wiadectwo niskopoziomowej sk³adni Javy, przejêtej od C:
nienaturalne zero odzwierciedla techniczne w³a¶ciwo¶ci implementacyjne -
jest warto¶ci±, któr± trzeba dodaæ do adresu pocz±tku tablicy by uzyskaæ
dostêp do pierwszego jej elementu),</li>
  <li>
rozmiary tablicy
mog± byæ dynamicznie podane przy jej tworzeniua, </li>
  <li>
ale potem nie mog± siê ju¿
zmieniaæ. </li>
</ul>

<p>Nale¿y dodaæ, ¿e do odzwierciedlania bardziej zaawansowanych przypadków - np. dynamicznie
rozszerzalnych tablic - s³u¿± w Javie  inne ni¿ tablice struktury danych, (o czym bêdziemy mówiæ w drugim semestrze).
</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index19.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index21.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
