<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index107.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 1"></A><div class="tytulpunktu">1. Proste sortowanie i wyszukiwanie</div>

<a name="W14.1"></a>

<p>
Wielokrotnie zetkniemy siê z potrzeb± uporz±dkowania informacji, u³o¿enia
danych w okre¶lonej kolejno¶ci. W uporz±dkowanych zestawach informacji ³atwiej
jest odnajdywaæ dane, zreszt± samo uporz±dkowanie mo¿e byæ niezbêdn± cech±
jakiego¶ zbioru danych. Najprostsze przyk³ady:<br>
<ul>
  <li>lista plików uporz±dkowanych
wed³ug nazw lub wed³ug daty ostatniej modyfikacji, </li>
  <li>lista 10 pierwszych zawodników,
którzy zdobyli najwiêcej punktów.</li>
</ul>

<p>
U³o¿enie danych w okre¶lonej kolejno¶ci oznacza jaki¶ ich porz±dek. Zwykle przy takim uk³adaniu
bêdziemy pos³ugiwaæ siê tutaj rosn±cymi (lub malej±cymi) warto¶ciami jakiej¶
cechy danych. Np. lista 10 zawodników, którzy zdobyli najwiêksz± liczbê punktów
powinna byæ uporz±dkowana wed³ug liczby punktów - od najwiêkszej do najmniejszej
(wtedy bêdziemy mogli stwierdziæ kto wygra³ zawody i  jakie miejsca zajêli
poszczególni zawodnicy)<br>

Samo porz±dkowanie zbioru danych nazywa siê sortowaniem.<A NAME="EDU.skorowidz.termin sortowanie 106_734"></A> Bêdziemy mówiæ wiêc o sortowaniu w porz±dku rosn±cym lub malej±cym.<br>
<br> Istnieje wiele algorytmów sortowania. Studenci poznaj± je w trakcie
zajêæ z przedmiotu "Algorytmy i struktury danych". Tutaj postaramy siê przedstawiæ
najprostszy (ale za to ma³o efektywny - czyli wolny) z tych algorytmów  zwany
po angielsku<A NAME="EDU.skorowidz.termin selection_sort 106_735"></A> <i><b>selection sort</b></i> (co mo¿emy przet³umaczyæ jako<A NAME="EDU.skorowidz.termin sortowanie_przez_wybór 106_736"></A> "sortowanie przez
wybór").<br>
<br> Za³ó¿my, ¿e mamy tablicê 5 liczb ca³kowitych i chcemy je u³o¿yæ w porz±dku
niemalej±cym (czyli w kolejno¶ci wzrostu liczb - od najmniejszej do najwiêkszej
- z uwzglêdnieniem tego, ¿e niektóre liczby w tablicy mog± byæ takie same
i wtedy znajd± siê na kolejnych pozycjach, mimo, ¿e nie wystêpuje ich wzrost).<br>
<br>
Przyk³adowo mo¿emy mieæ tak± tablicê.<br>
<br>
int[] a = {  52, 3, 33, 56, 14 };<br>
<br>
Na ostatniej pozycji w tablicy powinna znale¼æ siê najwiêksza liczba. Mo¿emy
j± znale¼æ przegl±daj±c tablicê od pocz±tku do ostatniego elementu tablicy
i okre¶laj±c na której pozycji znajduje siê wielko¶æ maksymalna. Aha, maksymaln±
liczb± jest 56 i znajduje siê na pozycji 4 (indeks 3). Powinna znale¼æ siê
na ostatniej pozycji (pozycja 5, indeks 4), Ale tam stoi liczba 14. Gdyby¶my po prostu
zapisali: a[4] = a[3] - straciliby¶my liczbê 14. Musimy tê liczbê gdzie¶
zapisaæ. Musi ona byæ uwzglêdniona przy dalszym porz±dkowaniu tablicy, zatem
nie mo¿e byæ zapisana gdzie¶ poza tablic±. Je¶li liczbê 56 zapiszemy z pozycji
4 na pozycjê 5, to pozycja 4 bêdzie wolna i tam w³a¶nie mo¿emy umie¶ciæ liczbê
14. Oznacza to, ¿e musimy przestawiæ elementy tablicy np. tak:<br>
int temp = a[3];<br>
a[3] = a[4];<br>
a[4] = temp;<br>
<br>
W tej chwili nasza tablica bêdzie wygl±daæ tak:<br>
<br>
52 3 33 14 56<br>
<br>
i kawa³ek tej tablicy jest ju¿ uporz±dkowany (ostatni element zawiera w³a¶ciw±,
najwiêksz±, liczbê). Teraz poszukamy kolejnego najwiêkszego elementu. Szukamy
od pocz±tku tablicy, ale nie musimy ju¿ braæ pod uwagê ostatniego elementu
(bo ju¿ jest w³a¶ciwie umiejscowiony i na pewno nie bêdziemy go przestawiaæ).
Tym razem przeszukiwanie tablicy zakoñczymy na przedostatnim elemencie. Znaleziony
element maksymalny to 52 i ma indeks 0. Powinien znale¼æ siê w tablicy jako
jej przedostatni element. Zatem znowu dokonujemy przestawienia (14 &lt;-&gt;
52) i otrzymujemy tablicê:<br>
<br>
14 3 33 52 56<br>
<br>
W tej tablicy we w³asciwym porz±dku s± ju¿ dwa ostatnie elementy, zatem dalsze
kroki ograniczamy do trzech pierwszych elementów: znowu wyszukujemy najwiêkszy.
Tym razem okazuje siê, ¿e jest to 33 i ¿e ju¿ znajduje siê na w³a¶ciwej pozycji.
Uporz±dkowana czê¶æ tablicy zwiêkszy³a siê do trzech elementów. Pozosta³o
zobaczyæ, który z pierwszych dwóch elementów jest wiêkszy i ewentualnie je
przestawiæ. Zamieniamy miejscami 14 i 3. Tablica jest posortowana.<br>
<br>
Kolejne kroki  ilustruje poni¿szy rysunek na którym kolorem ¿ó³tym zaznaczono
nieposortowan± czê¶æ tablicy, kolorem niebieskim - ju¿ posortowan±, a niebieskim
kó³kiem - maksymalny element odszukiwany w ka¿dym kroku w nieposortowanej
czê¶ci tablicy.<br><br>

<div>
<img src="images/Selsort.jpg" alt="r" width="399" height="351" border="1">
</div>

<br>

<div class="important">
Zadanie: przed lektur± dalszego tekstu proszê spróbowaæ samodzielnie
napisaæ metodê void selectionSort(int[] a), sortuj±c± w porz±dku niemalej±cym
tablicê przekazan± jako argument>
<br>
</div>

<br>

<p>
Mo¿liwe rozwi±zanie:<br>
<br>

<pre>
  public void selectionSort(int[] a) {

    // toInd - oznacza ostatni indeks nieposortowanej czê¶ci tablicy
    // na pocz±tku jest to ostatni indeks tablicy
    // w kolejnych krokach toInd bêdzie zmniejszany o 1
    // bo zmniejszaj± siê rozmiary nieposortowanej czêsci tablicy

    // Gdy toInd osi±gnie warto¶æ 0 - "nieposortowany" bêdzie pierwszy
    // element. Ale nie mamy go ju¿ gdzie przestawiæ, faktycznie znajduje siê
    // on na w³asciwym miejscu.
    // Zatem nie musimy dokonywaæ ¿adnego przestawienia.
    // Tablica jest posortowana. Koñczymy pêtle.

    for (int toInd=a.length-1; toInd&gt;0; toInd--) {

      int indMax = 0;   // indeks maksymalnego elementu
                        // w nieposortowanej czê¶ci tablicy

      // szukamy tego indeksu, przegl±daj±c nieposortowan± czê¶æ tablicy
      for (int k=1; k &lt;= toInd; k++)
 	if (a[indMax] &lt; a[k]) indMax = k;

      // Przestawiamy elementy:
      // maksymalny element idzie na ostatni± pozycjê w nieposortowanej
      // czê¶ci tablicy; a liczba spod tego indeksu jest zapisywana
      // w miejscu okupowanym poprzednio przez max element

      int temp = a[toInd];
      a[toInd] = a[indMax];
      a[indMax] = temp;
    }
  }

</pre>

<p>
Do przetestowania napisanej metody mo¿emy u¿yæ nastêpuj±cej klasy:<br>
<br>

<pre>
import java.util.*;

public class SelSort {

  public SelSort(int n, int m) {

    Random rand = new Random();

    int[] a = new int[n];
    for (int i=0; i &lt; n; i++) {
      a[i] = rand.nextInt(m+1);
      System.out.print(" " + a[i]);
    }
    selectionSort(a);
    System.out.print('\n');
    for (int i=0; i &lt; n; i++) System.out.print(" " + a[i]);
  }

  public void selectionSort(int[] a) {
    // ...
  }


  public static void main(String[] args) {
     new SelSort(Integer.parseInt(args[0]), Integer.parseInt(args[1]));
   }

}
</pre>

<p>Jako argumenty wywo³ania podajemy rozmiar tablicy oraz maksymaln± liczbê,
jaka mo¿e znale¼æ siê w tablicy (powiedzmy max). Warto¶ci elementów tablicy
zostan± utworzone przez generator liczb pseudolosowych (0 &lt;= a[i] &lt;=
max). Nastêpnie wywo³ana zostanie metoda selectionSort.<br>
Wydruk programu pokazuje tablicê nieposortowan± oraz posortowan± np. <br><br>

<div class="listing100">
 5 72 58 39 75 18 92 79 35 63<br>
 5 18 35 39 58 63 72 75 79 92<br>
</div>

<br>
<p>
Algorytm sortowania przez wybór nale¿y do najwolniejszych algorytmów sortowania.<br>
Jest wiele innych, lepszych algorytmów.<br>

<div class="notel">Jednak w <b>nauce programowania</b> opanowanie ró¿nych algorytmow sortowania
 jest bardzo istotne, bowiem wyrabia umiejêtno¶æ my¶lenia i rozwi±zywania
problemów programistycznych oraz umo¿liwia pó¼niejsz± adaptacjê standardowych algorytmów
sortowania do specyficznych sytuacji</div>

<div class="ddd"><br><A NAME="EDU.skorowidz.termin Arrays klasa 106_737"></A> W praktycznym programowiu nikt nie
pisze algorytmow sortowania - korzysta siê zwykle z gotowego oprogramownia.
Równie¿ Java dostarcza  oprogramowanych algorytmów w postaci gotowych metod.
Poznamy je bli¿ej przy okazji omawiania  kolekcji w drugim semestrze.<br>
Teraz mo¿e warto powiedzieæ tylko, ¿e w pakiecie java.util istnieje klasa <b>Arrays</b>, w której zdefiniowano<A NAME="EDU.skorowidz.termin sort metoda 106_738"></A> metody <b>sort</b>
, umo¿liwiaj±ce sortowanie m.in. tablic liczb ca³kowitych i rzeczywistych.
Dla ciekawo¶ci mo¿emy sprawdziæ jaka jest ró¿nica czasowa zastosowania algorytmu
selection sort oraz tego, który poslu¿y³ do sformu³owania metod sort w klasie
Arrays<A NAME="EDU.skorowidz.termin quicksort algorytm 106_739"></A> (jest to zmodyfikowany algorytm quicksort; studenci poznaj± go na
zajêciach z przedmiotu "Algorytmy i struktury danych").
</div>
<br clear="all">

<br>

<pre>
import java.util.*;

class QTimer {

   private final long start;

   public QTimer() {
     start = System.currentTimeMillis();
   }

   public long getElapsed() {
      return System.currentTimeMillis() - start;
   }
}


public class SelSort1 {

static public void selectionSort(int[] a) {
// ... jak na poprzednim wydruku
}


  public static void main(String[] args) {
     int n = Integer.parseInt(args[0]);
     Random rand = new Random();
     int[] a = new int[n];
     int[] b = new int[n];
     for (int i=0; i &lt; n; i++) {
        a[i] = rand.nextInt(n*10);
        b[i] = a[i];
     }
    System.out.println("Liczba elementów tablicy " + n);
    QTimer qt = new QTimer();
    selectionSort(a);
    System.out.println("Czas selection sort: " + qt.getElapsed());
    qt = new QTimer();
    Arrays.sort(b);
    System.out.println("Czas quicksort: " + qt.getElapsed());
  }
}
</pre>

<p>
Przyk³adowo, dla losowo wygenerowanych tablic 50000 liczb ca³kowitych mogliby¶my uzyskaæ nastêpuj±cy wynik:<br><br>

<div class="listing100">
Liczba elementów tablicy 50000<br>
Czas selection sort: 43830<br>
Czas quicksort: 110<br>
</div>

<br><p>
Widzimy wiêc, ¿e dobry algorytm sortowania mo¿e byæ - przy du¿ej liczbie
elementów tablicy - nawet  kilkaset razy szybszy ni¿ bardzo proste, ale wolne
sortowanie przez wybór.<br>
<br><A NAME="EDU.skorowidz.termin napisy sortowanie 106_740"></A> A jak posortowaæ napisy? <br>
<br>

<div class="important"> <br>
Zadanie:  napisaæ metodê sortuj±c± tablicê ³añcuchów znakowych w porz±dku niemalej±cym.<br>
Przed lektur± dalszego tekstu - proszê wykonaæ to zadanie samodzielnie
<br>
<br>
</div>

<br>
<p><A NAME="EDU.skorowidz.termin compareTo metoda 106_741"></A> Oczywi¶cie - powinni¶my skorzystaæ z metody compareTo z klasy String.<br>

<pre>
public class SortString {

  static public void selectionSort(String[] s) {
    for (int toInd=s.length-1; toInd&gt;0; toInd--) {
      int indMax = 0;
      for (int k=1; k &lt;= toInd; k++)
 	if (s[indMax].compareTo(s[k]) &lt; 0) indMax = k;
      String temp = s[toInd];
      s[toInd] = s[indMax];
      s[indMax] = temp;
    }
  }


  public static void show(String[] s) {
    System.out.print('\n');
    for (int i=0; i &lt; s.length; i++) System.out.print(" " + s[i]);
  }


  public static void main(String[] args) {
    String[] s =  {"A", "Z", "C", "B", "1", "3", "2", "A", "C" };
    show(s);
    selectionSort(s);
    show(s);
  }

}
</pre>

<p>
Wydruk programu:<br><br>

<div class="listing100">
 A Z C B 1 3 2 A C<br>
 1 2 3 A A B C C Z<br>
</div>

<br>
<p>
Czêsto te¿ w programowaniu bêdziemy stykaæ siê z problemem odnalezienia konkretnego elementu tablicy.<br>
W najprostszy sposób mo¿emy to zrobiæ przegl±daj±c po kolei wszystkie elementy
tablicy, dopóki nie natrafiimy na poszukiwan± warto¶æ.<br>
Np. odnale¼æ w tablicy liczb ca³kowitych  podan± liczbê, a nastêpnie - je¶li
wystêpuje - zwróciæ jej indeks, a je¶li takiej liczby w tablicy nie ma -
zwróciæ -1.<br>
<br>

<pre>
public class Search {

  public static int linearSearch(int[] tab, int v) {
    for (int i=0; i &lt; tab.length; i++)
      if (tab[i] == v) return i;
    return -1;
  }

}
</pre>

<p><A NAME="EDU.skorowidz.termin wyszukiwanie 106_742"></A> Taki sposób wyszukiwania nazywany jest<A NAME="EDU.skorowidz.termin wyszukiwanie_liniowe 106_743"></A> wyszukiwaniem liniowym.<br>
<br>

<div class="def">Wyszukiwanie liniowe polega na przegl±daniu kolejnych elementów tablicy i porównywaniu ich  z poszukiwan± warto¶ci±</div>

<br>
<p>
Wyszukiwanie liniowe mo¿e okazaæ siê  bardzo wolne. Je¶li np. szukany element
znajduje siê w tablicy na ostatniej pozycji, to liczba wykonanych iteracji
i porównañ bêdzie równa liczbie elementów tablicy, co przy bardzo du¿ych
tablicach prowadzi do d³ugiego dzia³ania programu.<br>
<br><A NAME="EDU.skorowidz.termin wyszukiwanie_binarne 106_744"></A> Istnieje  nieco lepszy sposób przeszukiwania tablic nazywany wyszukiwaniem binarnym.<br>
Rozwa¿my przyk³ad.<br>
Mamy posortowan± w porz±dku niemalej±cym tablicê liczb ca³kowitych.<br>
2 3 4 5 7 11 14 20<br>
<br>
Bêdziemy szukaæ w tej tablicy liczby 14.<br>
Podzielmy tablicê na dwie po³owy. Ostatni element w lewej po³owie = 5, jest
mniejszy od szukanej liczby. Oznacza to, ¿e (poniewa¿ tablica jest posortowana)
szukana liczba znajduje siê w prawej po³owie tablicy. Podzielmy tê po³owê
znowu na dwie.  Ostatni element w "nowej" lewej po³owie to 11 - znowu mniejszy
od 14. Zatem szukana liczba znajduje siê w "nowej" prawej po³owie. Dzielimy
j± znowu na dwie (w tym przypadku w ka¿dej nowej po³ówce znajduje siê jedna
liczba) i odkrywamy ¿e nowa "jednoliczbowa" lewa po³ówka zawiera poszukiwan±
warto¶æ<br>
Ilsutruje to poni¿szy rysunek:<br><br>

<div>
<img src="images/binSrch.jpg" alt="r" width="563" height="213" border="1">
</div>

<br><p>
Gdyby¶my natomiast szukali liczby 4, to sekwencja kroków by³aby nastêpuj±ca:<br>
<br>

<div>
<img src="images/binSrch2.jpg" alt="r" width="540" height="196" border="1">
</div>

<br><p>
Zwróæmy uwagê, ¿e w ka¿dym kroku binarnego wyszukiwania porównujemy poszukiwan±
warto¶æ z  warto¶ci± elementu znajduj±cego siê na pozycji "dziel±cej" tablicê
na kolejne po³ówki (element ten na rysunkach zaznaczany jest na ¿ó³to, pokazano
te¿ jego indeks).<br>
Mo¿na powiedzieæ, ¿e zawsze jest to "¶rodkowy" element kolejnych podzia³ów.<br>
Je¶li w tablicy znajduje siê szukana warto¶æ, to w ostatnim kroku binarnego
wyszukiwania ten "¶rodkowy" element bêdzie jej równy. Je¶li nie, je¶li jej nie ma -
to oka¿e siê, ¿e nie mo¿na ju¿ wiêcej dzieliæ tablicy na kolejne po³ówki;
stwierdzamy wiêc, ¿e tablica nie zawiera poszukiwanej warto¶ci.<br>
<br>
Zatem mo¿emy zdefiniowac nastêpuj±c± metodê binarnego wyszukiwania:<br>
<br>

<pre>
public class Search {

  // v - poszukiwana warto¶æ w tablicy tab
  static public int binarySearch(int[] tab, int v)   {
    int low = 0;                // lewy skrajny indeks "aktualnej" po³ówki
    int high = tab.length - 1;  // prawy skrajny indeks "aktualnej" po³owki

    // dopóki mo¿emy dzieliæ tablicê
    while (low &lt;= high) {
      int mid = (low + high) / 2;  // indeks ¶rodkowego elementu
                                   // zakresu low..high

      if (v  &lt; tab[mid])         // je¿eli warto¶æ jest w lewej po³ówce:
        high = mid - 1;          // zmodyfikowaæ skrajny prawy indeks
      else if (v &gt; tab[mid])     // w przeciwnym razie je¿eli w prawej po³ówce:
              low = mid + 1;     // zmodyfikowaæ skrajny lewy indeks
           else return mid;      // w przeciwnym razie: zanleziony!
    }
    return -1;                    // w tablicy nie znaleziono warto¶ci v
  }
</pre>

<br><A NAME="EDU.skorowidz.termin wyszukiwanie_binarne 106_745"></A> 
<div class="def">Binarne wyszukiwanie jest szybkim algorytmem odnajdywania informacji
w posortowanych tablicach. W ka¿dym jego kroku zakres rozpatrywanych elementów
tablicy zmniejsza siê o po³owê</div>

<br>
<p>
Nale¿y wyra¼nie podkre¶liæ, ¿e binarne wyszukiwanie wymaga posortowanych
danych. Czêsto jednak op³aca siê najpierw posortowaæ dane, by pó¼niej móc
szybko odnajdywaæ w¶ród nich potrzebn± informacjê.<br>
<br>
Jako praktyczny przyk³ad rozwa¿ymy nowe podej¶cie do wycieczek (przyk³ad
z wyk³adu 12). Wycieczki bêdziemy przedstawiaæ jako obiekty klasy Travel,
zawieraj±ce cel podró¿y oraz cenê wycieczki.<br>
<br>

<pre>
public class Travel {

   private String dest;
   private double price;

   public Travel(String s, double p) {
     dest = s;
     price = p;
   }

   public String getDest() { return dest; }
   public double getPrice() { return price; }

}
</pre>

<p>
Stworzymy nastêpnie klasê TravelSearcher, której obiekty bêd± zawieraæ tablicê
wycieczek. Z tablicy tej mo¿na bêdzie za pomoc± metody search uzyskiwaæ referencjê
do obiektu-wycieczki, której cel podano jako argument.<br>
<br>

<pre>
public class TravelSearcher {

  private Travel[] travel;

  public TravelSearcher(Travel[] t) {
    travel = new Travel[t.length];
    for (int i=0; i &lt; t.length; i++) travel[i] = t[i];
    sortByDest();
  }


  public Travel search(String dest) {
    int low = 0;
    int high = travel.length - 1;
    while (low &lt;= high) {
      int mid = (low + high) / 2;
      int compRes = dest.compareToIgnoreCase(travel[mid].getDest());
      if (compRes &lt; 0) high = mid - 1;
      else if (compRes &gt; 0) low = mid + 1;
           else return travel[mid];
    }
    return null;
  }

 public Travel[] getTravels() { return travel; }

 private void sortByDest() {
   for (int to=travel.length-1; to&gt;0; to--) {
      int i = 0;
      for (int k=1; k &lt;= to; k++)
 	if (travel[i].getDest().compareTo(travel[k].getDest()) &lt; 0) i = k;
      Travel temp = travel[to];
      travel[to] = travel[i];
      travel[i] = temp;
    }
  }

}
</pre>

<p>
Komentarze:<br>
<ul>
  <li>przy inicjacji obiektu przepisujemy podan± jako argument konstruktora
tablicê wycieczek (referencji do obiektów klasy Travel) do  nowej tablicy
i sortujemy tê tablicê. W ten sposób oryginalna (przekazana) tablica nie
bêdzie posortowana. Sta³o by siê tak gdyby¶my w konstruktorze, zmiennej travel
przypisali referencjê do tablicy przekazanej jako argument. Posortowan± tablicê
zawsze mo¿na uzyskaæ poprzez odwo³anie getTravels().</li>

  <li>tablicê sortujemy po to, by zastosowaæ binarne wyszukiwanie. W trakcie
wyszukwania nie rozró¿niamy ma³ych i wielkich liter (metoda compareToIgnoreCase
 z klasy String), bowiem nie ma znaczenia czy u¿ytkownik napisa³ np. "zanzibar"
czy "ZANZIBAR" czy mo¿e "Zanzibar", aby odnale¼æ w tablicy wycieczkê do Zanzibaru.</li>
</ul>

<p>I wreszcie klasa testuj±ca (z niewielk± przyk³adow± liczb± wycieczek,
ale mo¿na j± zwiêkszyæ wczytuj±c np. wycieczki z jakiego¶ pliku).<br>
W klasie tej - u¿ytkownik podaje w dialogu cel podró¿y, po czym otrzymuje informacjê ile taka wycieczka mo¿e kosztowaæ.<br>
Dialogi wygl±daj± w nastêpuj±cy sposób:<br><br>

<div>
<img src="images/trav141.jpg" alt="r" width="293" height="119" border="1" align="Left">
<img src="images/trav142.jpg" alt="r" width="268" height="113" border="1" align="Right">
</div>

<br clear="all"><br>

<pre>
import javax.swing.*;
public class Test {

  public static void main(String[] args) {
    String[] dest  = { "Bali", "Cypr", "Ibiza", "Kenia", "Kuba" };
    double[] price = { 5000, 2500, 2800, 4500, 6000 };
    Travel[] t = new Travel[dest.length];
    for (int i = 0; i &lt; t.length; i++) t[i] = new Travel(dest[i], price[i]);
    TravelSearcher ts = new TravelSearcher(t);
    String d;
    while((d=JOptionPane.showInputDialog("Podaj cel podró¿y:")) != null) {
      Travel trav = ts.search(d);
      String msg;
      if (trav == null) msg = "Nie znaleziono takiej podró¿y";
      else msg = trav.getDest() + " - cena: " + trav.getPrice();
      JOptionPane.showMessageDialog(null, msg);
    }
    System.exit(0);
  }

}
</pre>

<p>Zauwa¿my jeszcze, ¿e dla tablic referencji do obiektów klasy Travel
musieli¶my zdefiniowaæ specjalne, tylko dla nich wa¿ne, metody sortowania
i wyszukiwania.<br>
<br>
O bardziej ogólnym podej¶ciu do sortowania i wyszukiwania tablic dowolnych
obiektów bêdziemy mówiæ w drugim semestrze przy okazji omawiania kolekcji.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index107.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
