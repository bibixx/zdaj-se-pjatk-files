<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index43.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index45.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Wyj±tkowa klasa String</div>

<a name="W6.2"></a>

<p>Oczywi¶cie,<A NAME="EDU.skorowidz.termin ³añcuch_znakowy 44_414"></A> ³añcuchy znakowe s± obiektami klasy<A NAME="EDU.skorowidz.termin String 44_415"></A> String, zatem wszystko co
dot±d powiedziano o obiektach i referencjach dotyczy tak¿e obiektów klasy
String.<br>


Dodatkowo jednak, poniewa¿<A NAME="EDU.skorowidz.termin operacja_na _³añcuchach_znakowych 44_416"></A> operacje na ³añcuchach znakowych s± w programowaniu
do¶æ czêste, kompilator dostarcza nam tu pewnych udogodnieñ (specjalnych
w³a¶ciwo¶ci), które - niestety - powoduj± te¿ trochê zamieszania pojêciowego.<br>
<br>


Powtórzmy sobie znowu. <br>


Gdy napiszemy<br>
<br>

String napis;<br>
<br>


to w tym momencie  nie bêdzie jeszcze ¿adnego ³añcucha znakowego, jedynie
zmienn± napis, która mo¿e zawieraæ referencjê do obiektu (ale jeszcze nie
zawiera).<br>
<p>
Tak jak w przypadku ka¿dej innej klasy obiekty klasy String musimy
bezpo¶rednio tworzyæ.<br><br>


<div class="notel33">
Mówimy tu o "sztuczkach kompilatora", gdy¿ omawiane tu wyj±tkowe w³a¶ciwo¶ci
klasy String s± zapewnianie dziêki niewidocznemu dla programisty przekszta³ceniu
przez kompilator fragmentów kodu w inne (od zastosowanych) konstrukcje sk³adniowe
Javy</div>




<div class="ddd"><br>
Pierwsza <b>"sztuczka" kompilatora</b> polega na tym, ¿e zamiast:<br><br>

String s = new String("Ala ma kota");<br><br>

mo¿emy napisaæ:<br><br>

String s = "Ala ma kota";
</div>

<br clear="all">

<p>Zapis ten spowoduje:<br>
<ul>
<li>stworzenie obiektu klasy String z zawarto¶ci± "Ala ma kota"</li><li>przypisanie referencji do tego obiektu zmiennej s</li>
</ul>

<p>
Zatem, <b>wyj±tkowo</b>, tworz±c obiekty klasy String nie musimy u¿ywaæ wyra¿enia new.<br>
<br>
<br><A NAME="EDU.skorowidz.termin konkatenacja_³añcuchów_znakowych 44_417"></A> 
Innym (wyj±tkowym) udogodnieniem przy korzystaniu z ³añcuchów znakowych jest
mo¿liwo¶æ u¿ycia operatora + w znaczeniu konkatenacji (³±czenia ³añcuchów
znakowych).<br>


Np.<br>

<pre>
String s1 = "Ala ma kota";
String s2 = " szaroburego";
String s3;
s3 = s1 + s2;
</pre>

<p>
spowoduje, ¿e:<br>
<ul>
<li>wyra¿enie s1 + s2 stworzy obiekt klasy String, który jest po³±czeniem napisów oznaczanych przez zmienne s1 i s2</li><li>referencja do nowoutworzonego obiektu zostanie przypisana zmiennej s3</li><li>s3 bêdzie teraz oznaczaæ napis "Ala ma kota szaroburego"<br></li>
</ul>
<br>

<p>
Takie zastosowanie operatora + jest wyj±tkowe, gdy¿ (wizualnie) stosujemy
go wobec referencji (np. s1 + s2), co jest niedozwolone. Ale <b>"druga sztuczka"</b>
 kompilatora (i tylko kompilatora, bo definicja klasy String w ¿aden sposób
nie umo¿liwia takiego zastosowania) powoduje, ¿e mo¿emy to zrobiæ.<br>
<br>


Co wiêcej, za pomoc± operatora + do ³añcuchów znakowych mo¿emy do³±czaæ innego
rodzaju dane, np. liczby (a tak¿e dane reprezentuj±ce obiekty dowolnych klas).
<br>


Na przyk³ad:<br>
<br>

<pre>
String s1 = "Ala ma kota";
String s2 = " szaroburego";
String s3;
s3 = s1 + s2 + " w wieku " + 3 + " lat ";
</pre>


<p>Teraz zmienna s3 bêdzie oznaczaæ napis "Ala ma kota szaroburego w wieku 3 lat".<br>


Oczywi¶cie, nic nie stoi na przeszkodzie, by w konkatenacji zamiast litera³u 3 pojawi³a siê zmienna typu int o warto¶ci 3. Np.<br>
<br>


int lata = 3;<br>


...<br>


s3 = s1 + s2 + " w wieku " + lata + " lat ";<br>
<br>


Zwróæmy uwagê, zmienna <b><i>lata</i></b> lub litera³ 3 w wyra¿eniu konkatenacji
³añcuchów znakowych s± typu int. Przy opracowaniu wyra¿enia (wyliczeniu jego
wyniku) nastêpuje przekszta³cenie warto¶ci zmiennej lub litera³u (dziesiêtne
3, binarne 00000011 - to jest tzw. wewnêtrzna reprezentacja warto¶ci) w kod
znaku Unicodu (dziesiêtnie 33) i dziêki temu znak cyfry ('3') pojawi siê
w ³añcuchu znakowym (znak cyfry 3 jest znakow± reprezentacj± warto¶ci 3).<br>


To samo dotyczy innych warto¶ci numerycznych (typów float, double, itp.)<br>

 Jest to trzecia sztuczka kompilatora, bowiem sk³adnia jêzyka nie umo¿liwia
wykonywania takich przekszta³ceñ w innych ni¿ przy okazji konkatenacji ³añcuchow
znakowych kontekstach.<br>
<br>


Je¶li w wyra¿eniu konkatenacji ³añcuchow znakowych wyst±pi referencja do
obiektu jakiej¶ klasy, to równie¿ obiekt (dane zawarte w obiekcie) zostan±
przekszta³cone do postaci znakowej i do³±czone do ³añcucha. Znowu jest to
udogodnienie ze strony kompilatora, ale sposób reprezentacji danych obiektu
okre¶la definicja klasy (jest to bardzo wygodna w³a¶ciwo¶æ; o tym dlaczego
i w jaki sposob jest mo¿liwa i jak z niej korzystaæ - dowiemy siê pó¼niej).<br>
<br>


Na przyk³ad je¶li napiszemy:<br>
<br>


Date data = new Date();<br>


String s = "Teraz jest " + data;<br>
<br>


to zostanie utworzony obiekt klasy Date (jedna ze standardowych klas Javy;
jej obiekty opisuj± daty), który "w ¶rodku" zawiera dane (w postaci binarnej)
opisuj±ce bie¿±c± datê i czas. Po konkatenacji, zmienna s bêdzie oznaczaæ
napis, w którym data i czas s± podane w postaci znakowej np. "Teraz jest
: Mon Jul 01 05:55:25 CEST 2002".<br>
<br><A NAME="EDU.skorowidz.termin operator_+ jako_operator_konkatenacji 44_418"></A> Nale¿y tak¿e zwróciæ uwagê na dwie wa¿ne kwestie:<br>
<br>


<div class="notec"><b>Operator +</b> jest traktowany jako operator konkatenacji ³añcuchów znakowych tylko wtedy, gdy jeden z jego argumentów jest typu String</div>

<br>
<p>


Zatem np. takie fragmenty bêd± niepoprawne:<br>
<br>


String s = 1 + 3; <br>


wynikiem prawej strony operatora przypisania jest liczba 4 (typ int), a danej
typu int nie mo¿na podstawiæ na zmienn± typu referencyjnego (któr± jest s)<br>
<br>


int a = 1, b = 3;<br>


String s = a + b;<br>


j.w.<br>
<br>

<div class="notec">Przy konkatenacji nale¿y baczn± uwagê zwracaæ na kolejno¶æ opracowywania wyra¿eñ</div>

<br>
<p>


Np.<br>
<br>


String s = "Nr " + 1 + 2;<br>
<br>


da napis "Nr 12", bo: najpierw zostanie wyliczone wyra¿enie "Nr " + 1, co
w wyniku da napis "Nr 1", po czym drugi operator + do³±czy do tego napisu
napis "2" (znakow± warto¶æ liczby 2). <br>
<br>


Natomiast:<br>
<br>


String s = 100 + " Nr " + (1 +2);<br>
<br>


da napis "100 Nr 3", bo:<br>
<ul>
<li>najpierw bêdzie opracowane wyra¿enie 100 + " Nr " (jego wynik - napis " 100 Nr ")</li><li>nastêpnie zostanie opracowane wyra¿enie  1 + 2 (poniewa¿ nawiasy zmieniaj±
kolejno¶æ opracowania wyra¿eñ), a jego wynikiem bêdzie liczba 3</li><li>
w koñcu zostanie zastosowany drugi operator +, który do wyniku pierwszego
wyra¿enia (napisu "100 Nr ") do³±czy przeksztalcon± do postaci znakowej warto¶æ
drugiego wyra¿enia (liczbê 3)</li>
</ul>
<br>

<p>
Przy operowaniu na ³añcuchach znakowych trzeba szczególnie pamiêtaæ, ¿e dostêp
do nich uzyskujemy za pomoc± referencji, co ma swoje konsekwencje przy operacjach
porównania na równo¶æ - nierówno¶æ.<br>
<br>


Jeszcze raz:<br>
<br>


<div class="important"> Operatory równo¶ci (==) i nierówno¶ci (!=) zastosowane wobec zmiennych
oznaczaj±cych obiekty , porównuj± referencje do obiektów, a nie zawarto¶æ
obiektów</div>

<br>
<p>


Zatem poni¿szy fragment:<br>
<pre>
String s1 = "Al";
String s2 = "a";
String s3 = s1 + s2;
String s4 = "Ala";
System.out.println(s3 + " " + s4);
if (s3 == s4) System.out.println("To jest Ala");
else System.out.println("To nie Ala"
</pre>


<p>wyprowadzi (wbrew intuicyjnym oczekiwaniom):<br>


Ala Ala<br>


To nie Ala<br>
<br>


Zwróæmy uwagê: zawarto¶ci± obiektu oznaczanego przez s3 jest napis "Ala".<br>


Równie¿ - zawarto¶ci± obiektu oznaczanego przez s4 jest taki sam napis "Ala".<br>


Ale porównanie obu zmiennych da warto¶æ false, bo s3 wskazuje na inny obiekt ni¿ s4.<br>


Porównanie by³oby prawdziwe tylko wtedy, gdyby s3 wskazywa³o na ten sam obiekt co s4.<br>
<br><A NAME="EDU.skorowidz.termin ³añcuchy_znakowe porównywanie 44_419"></A> 
<div class="important">Do porównywania ³±ñcuchów znakowych (ich zawarto¶ci) <b>nie nale¿y</b> u¿ywaæ operatorów == i != </div>

<br>
<p>


Zamiast operatorów == i != u¿ywamy metody (polecenia) equals.<br>
<br>


<div class="syntax">Aby porównaæ dwa napisy reprezentowane przez zmienne typu String s1 i s2 piszemy:<br>
<br><A NAME="EDU.skorowidz.termin equals 44_420"></A> 
<div align="Left">                s1.equals(s2)<br></div>
<br>


Aby porównaæ napis reprezentowany przez zmienn± s typu String z litera³em ³añcuchowym piszemy:<br>
<br>                s.equals(<i><b>litera³_³añcuchowy</b></i>)<br>
<br>


Wynikiem jest warto¶æ <b>true</b> je¶li oba napisy s± takie same i <b>false</b> w przeciwnym razie.</div>

<br>
<p>


Poni¿szy przyk³adowy program pokazuje ró¿ne niuanse operowania na ³añcuchach znakowych.<br>

<pre>
public class Strings1 {

  public static void main(String[] args) {

    String napis = "Waga ";
    double w = 10.234;
    System.out.println(napis + w + " kg");

    String txt = napis + w + 10 + " kg";
    System.out.println(txt);               // dlaczego 10.23410?
    txt = napis + (w + 10) + " kg";
    System.out.println(txt);               // a tu  20.234?
    txt = napis + w * 10 + " kg";          // w*10 bez nawiasów ?..
    System.out.println(txt);               // ... i dobrze - dlaczego?
                                           // (pomoc: priorytety operatorow)

    String bzdura = "Bzdura";
    bzdura = napis;
    System.out.println(bzdura);  // dlaczego wyprowadzi "Waga " a nie "Bzdura"

    txt = napis;
    txt = txt + "Ali ?";
    System.out.println(txt);      // a tu inaczej:
    System.out.println(napis);    // dlaczego napis jest "Waga "?
                                  // a nie "Waga Ali ?"

    System.out.println( napis == bzdura );           // dlaczego true?
    System.out.println( txt == napis );              // dlaczego false?
    System.out.println( txt == "Waga Ali ?");        // dlaczego false?
    System.out.println( txt.equals("Waga Ali ?") );  // dlaczego true?

    // a teraz co¶ dziwnego:
    napis = "Ala";
    System.out.println( napis == "Ala");      // true czy false???

  }
}
</pre>


<div class="listing33r">Waga 10.234 kg<br>

Waga 10.23410 kg<br>


Waga 20.234 kg<br>


Waga 102.34 kg<br>


Waga<br>


Waga Ali ?<br>


Waga<br>


true<br>


false<br>


false<br>


true<br>


true</div>

<div class="ddd">
<br>
Dzia³anie programu przedstawia wydruk (obok). Warto  zauwa¿yæ, ¿e
jako informacjê do wyprowadzenia przez println  (argument w nawiasach okr±g³ych)
mo¿emy podawaæ równie¿ wyra¿enia (dodajmy, ¿e dowolnego typu!). Fenomen ten
wyja¶nimy sobie w nastêpnych wyk³adach.<br><br>

<b><font color="#ff0000">Proszê dok³adnie przeanalizowaæ tekst programu i przy okazji, odpowiadaj±c
na pytania zawarte w komentarzach, sprawdziæ swoje rozumienie materialu wykladu.</font></b>
</div>

<br clear="all">
<p>
Ostatni fragment programu pokazuje kolejne "odchylenie" Javy od prostych
regu³. Okazuje siê oto, ¿e wszystkie litera³y ³añcuchowe maj±ce ten sam tekst
s± jednym i tym samym obiektem. W instrukcji:   napis = "Ala"; jest tworzony
nowy obiekt, zawieraj±cy napis "Ala". Przy ka¿dym kolejnym u¿yciu litera³u
"Ala" w miejsce litera³u podstawiona bêdzie referencja do tego obiektu (a
nie do ew. nowotworzonego innego obiektu zawieraj±cego napis "Ala"; taki obiekt nie bêdzie ponownie tworzony).<br>


Dlatego ostatnie porównanie da warto¶æ true.<br>
<br>


<div class="important">Jednak nie nale¿y wykorzystywaæ tej w³a¶ciwo¶ci jêzyka i zawsze, zamiast operatora ==,  nale¿y stosowaæ polecenie equals</div>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index43.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;<A HREF="index45.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
