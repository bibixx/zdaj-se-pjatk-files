<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index37.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><div class="tytulpunktu">5. Konwersje arytmetyczne</div>

<a name="W5.5"></a>

<p>Ogólnie, je¿eli zmienna jest typu A to nie mo¿na jej przypisaæ warto¶ci typu
B. Np. taki zapis w programie spowoduje b³±d w kompilacji:<br>
<br>
int a = "Ala ma kota";<br>
<br>
gdy¿ <i><b>a</b></i> jest zmienn± typu int, a wyra¿enie "Ala ma kota" jest litera³em ³añcuchowym i  jest typu  String.<br>
<br>
By³oby jednak nierozumnie stosowaæ tê zasadê w ca³ej rozci±g³o¶ci wobec typów
arytmetycznych. Przecie¿ to s± liczby i czêsto chcieliby¶my jak±¶ warto¶æ
liczbow± przypisaæ zmiennej typu arytmetycznego nie bacz±c na typy. <br>
<br>

<div class="def">
Zmiana typu wyra¿enia nazywa siê konwersj± lub - inaczej - rzutowaniem (ang. cast)</div>
<br>
<p>
Te konwersje arytmetyczne, które nie mog± doprowadziæ do utraty informacji
reprezentowanej przez warto¶æ wyra¿enia dokonywane s± w sposób niejawny,
niejako automatyczny.<br>
Mo¿emy np. bez przeszkód przypisaæ zmiennej typu double warto¶æ zmiennej typu int:<br>
<br>
int a = 10;<br>
double d = a;<br>
<br>
bowiem ka¿da warto¶æ zmiennej typu int "zmie¶ci siê" w zmiennej typu double.<br>
<br>
Takie<A NAME="EDU.skorowidz.termin konwersja rozszerzaj±ca 38_388"></A> konwersje nazywaj± siê rozszerzaj±cymi, bo przekszta³cane s± "wê¿sze"
typu do "szerszych" (mog±cych reprezentowaæ wiêksze spektrum warto¶ci).<br>
<br>
Gdyby¶my jednak chcieli wykonaæ operacjê odwrotn±:<br>
<br>
double d = 10.1;<br>
...<br>
int a = d;<br>
<br>
to kompilator bêdzie sygnalizowa³ b³±d. Taki zapis jest niedopuszczalny,
poniewa¿ przy  okazji takiego przypisania mo¿emy straciæ informacjê zawart±
w zmiennej "szerszego" typu. <br>
Konwersja w tym przypadku nazywa siê<A NAME="EDU.skorowidz.termin konwersja zwê¿aj±ca 38_389"></A> konwersj± zawê¿aj±c± i mo¿liwa jest
do wykonania tylko pod warunkiem u¿ycia operatora konwersji. Mówimy, ¿e konwersje
zawê¿aj±ce musz± byæ wykonywane jawnie, za pomoc± operatora konwersji. U¿ycie
operatora konwersji oznacza, ¿e programista ¶wiadomie decyduje siê na przekszta³cenie
typów, przy którym mo¿e nast±piæ strata informacji. ¯e nie jest to przypadkowy
b³±d w programie.<br>
<br><A NAME="EDU.skorowidz.termin operator konwersji 38_390"></A> 
<div class="syntax"> Operator konwersji (rzutowania) ma postaæ:<br>
<br>
        <b>(<i>nazwa_typu</i>)</b> <i><b>wyra¿enie</b></i><br>
<br>
gdzie <i><b>nazwa_typu</b></i> - typ do jakiego przekszta³cany jest aktualny typ <i><b>wyra¿enia</b></i> <br>
</div>

<br>
<p>
W poprzednim przyk³adzie powinni¶my wiêc napisaæ:<br>
<br>
double d = 10.9;<br>
...<br>
int a = (int) d;<br>
<br>
i teraz kompilator pozwoli nam na pozostawienie takiego zapisu w programie.<br>
<br>
Warto zwróciæ uwagê, ¿e przy tej okazji mo¿e faktycznie nast±piæ utrata informacji. W naszym przyk³adzie zmienna <i><b>a</b></i>
  bêdzie mia³a warto¶æ 10 - stracili¶my ca³± czê¶æ u³amkow± liczby. Podkre¶lmy:
to nie jest zaokr±glenie, czê¶æ ulamkowa jest po prostu odrzucana. Oczywi¶cie
nie zawsze informacja bêdzie tracona (gdy d = 10.0, to a = 10 i mamy praktycznie
to samo).<br>
<br>
Bardzo czêsto przy operowaniu na znakach (typo char) i ich kodach liczbowych potrzebne jest wykonywanie konwersji.<br>
Obrazuje to poni¿szy program:<br>
<br>

<pre>
public class Char {

  public static void main(String[] args) {

     char c = 'a';
     int kod = c;
     System.out.println("Kod znaku " + c + " = " + kod);
     kod = 77;
     c = (char) kod;
     System.out.println("Kod znaku " + c + " = " + kod);

     // Czasem trzeba u¿yæ jawnej konwersji rozszerzaj±cej
     System.out.println("Kod znaku " + '*' + " = " + (int) '*');

     // Oczywi¶cie - zawê¿aj±ce zawsze trzeba podawaæ jawnie
     System.out.println("Kod znaku " + (char) 66 + " = " + 66);

  }

}
</pre>

<br>

<div class="listing33r">Kod znaku a = 97<br>
Kod znaku M = 77<br>
Kod znaku * = 42<br>
Kod znaku B = 66
</div>

<div class="ddd">
<br>który wyprowadzi na konsolê nastêpuj±c± informacjê:
</div>
<br clear="all">

<p>
W trakcie wyliczania warto¶ci wyra¿eñ arytmetycznych dokonywane s± automatyczne konwersje nazywane<A NAME="EDU.skorowidz.termin promocja_numeryczna 38_391"></A> promocjami numerycznymi.<br>
<br>

<div class="def">
<b>Promocja</b> numeryczna polega na przekszta³ceniu typów argumentów operatorów arytmetycznych do typu <b>wspólnego</b> dla ich argumentów</div>

<br>
<p>
Odpowied¼ na pytanie jaki jest ten wspólny typ daje nastêpuj±ca regu³a.<br>
<br>

<div class="syntax"><br>Promocje argumentów operatorów dwuargumentowych s± wykonywane w nastêpuj±cy sposób:<br>
<ul>
  <li>je¿eli jeden z argumentów jest typu double, drugi przekszta³cany jest do typu double,</li>
  <li>w przeciwnym razie, je¿eli jeden z argumentów jest typu float, drugi przekszta³cany jest do typu float,</li>
  <li>w przeciwnym razie, je¿eli jeden z argumentów jest typu long, drugi przekszta³cany jest do typu long,</li>
  <li>w przeciwnym razie oba argumenty przekszta³cane s± do typu int.</li>
</ul>
 </div>
</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index37.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
