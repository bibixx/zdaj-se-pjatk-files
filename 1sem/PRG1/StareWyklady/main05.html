<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index04.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><div class="tytulpunktu">2. Algorytmy i jêzyki programowania</div>

<a name="W1.2"></a>

<p>Instrukcje zapisane w programie  powinny ³±cznie realizowaæ jakie¶ zadanie,
rozwi±zywaæ  jaki¶ problem. Jest oczywi¶cie mo¿liwe napisanie programu,
który  sk³ada  siê z jakich¶ przypadkowych instrukcji, ale nie ma w tym za
wiele sensu. <br>
<br>
     Powinni¶my zatem spojrzeæ na pojêcie programu z innego (ni¿ "techniczny",
  zwi±zany z wykonywaniem przez procesor instrukcji) punktu widzenia.<br>
<br>
     Skoro programy s³u¿± do rozwi±zywania jakich¶ problemów, realizacji zadañ, to punktem wyj¶cia programowania
   powinno byæ sformu³owanie problemu lub zadania, sposobu jego rozwi±zania,
  kroków prowadz±cych do realizacji celu. Innymi s³owy - sformu³owanie <b>
   algorytmu</b>   rozwi±zania problemu lub wykonania zadania.<br>
<br>

<center>
<div class="def"><A NAME="EDU.skorowidz.termin algorytm 5_20"></A> <b>ALGORYTM</b>  to  przepis postêpowania prowadz±cy
  do rozwi±zania okre¶lonego zadania; zbiór poleceñ dotycz±cych pewnych obiektów
  (danych) - ze wskazaniem kolejno¶ci, w jakiej maj± byæ wykonane; wykonawc±
  jest uk³ad, który na sygna³y reprezentuj±ce polecenia reaguje ich realizowaniem
  - mo¿e nim byæ cz³owiek lub urz±dzenie automatyczne, np. komputer.<br>
     (<i>¼ród³o: Encyklopedia PWN</i>) </div>
</center>

<p>
     Algorytmy mo¿emy wyraziæ w ró¿ny sposób: w jêzyku naturalnym, graficznie
  - w postaci<A NAME="EDU.skorowidz.termin schemat_blokowy 5_21"></A> schematu blokowego lub te¿ w tzw.<A NAME="EDU.skorowidz.termin pseudo-kod 5_22"></A> <b>pseudo-kodzie</b> (wybranym
  jêzyku opisu algorytmów, który jest niezale¿ny od konkretnych, dostêpnych
  jêzyków programowania).<br>
<br>
     Wyobra¼my sobie np., ¿e zamierzamy kupiæ nowy komputer i stoi przed
nami   zadanie skonfigurowania go i policzenia ca³kowitej ceny (wg dostêpnego
cennika   czê¶ci). <br>
    W pierwszym przybli¿eniu najprostszy algorytm realizacji tego zadania
mo¿emy  opisaæ w kolejnych krokach<br>

<pre>
<ol>
<li>Wybierz  z cennika procesor, zapisz jego cenê</li><li>Wybierz z cennika pamiêæ RAM, zapisz jej cenê</li><li>Wybierz z cennika p³ytê g³ówn±, zapisz jej cenê</li><li>Wybierz z cennika kartê graficzn±, zapisz jej cenê
</li><li>Wybierz z cennika dysk twardy, zapisz jego cenê</li><li>Wybierz z cennika CDROM lub DVD, zapisz jego  cene</li><li>Wybierz z cennika kartê d¼wiêkow±, zapisz jej cenê</li><li>Wybierz obudowê i potrzebne akcesoria, zapisz ich ceny</li><li>Zsumuj wszystkie ceny</li></ol>
</pre>

<p>Jest to zapis w jêzyku naturalnym. Graficznie algorytm ten (z pewnymi
 skrótami,  ale bez zmniejszenia ogólno¶ci) mogliby¶my przedstawiæ w nastêpuj±cy
 sposób.<br>
<br>

<img src="images/Alg_cena.jpg" alt="Rysunek - alg 1" width="401" height="661" align="Right" hspace="10" vspace="10" border="1">

    Widzimy tu ¶ci¶le okre¶lon± sekwencjê kolejnych kroków  Algorytm ma swój
  pocz±tek, jego wykonalno¶æ i zakoñczenie pracy s± gwarantowane, mo¿e byæ
 tak¿e wykonywany wielokrotnie, z ró¿nymi danymi - w naszym przypadku ró¿nymi
 opcjami, dotycz±cymi konfiguracji komputera.<br>
<br>
    Ten algorytm jest dla nas zrozumia³y. Potrafimy go wykonaæ, choæby z
o³ówkiem   i kartk± papieru.<br>
    Powstaje pytanie, w jaki sposób zadanie wyliczenia ceny mo¿na powierzyæ
 komputerowi?<br>
<br>
    Oczywi¶cie, domy¶lamy siê, ¿e algorytm nale¿y zapisaæ w jakim¶<A NAME="EDU.skorowidz.termin jêzyk_programowania 5_23"></A> jêzyku
programowania  (otrzymamy wtedy<A NAME="EDU.skorowidz.termin program_¼ród³owy 5_24"></A> <b>program w postaci ¼ród³owej</b>), przet³umaczyæ
na jêzyk  zrozumia³y dla procesora (<A NAME="EDU.skorowidz.termin program_wykonywalny 5_25"></A> <b>program w postaci wykonywalnej</b>
 ), nastêpnie  ten "wykonywalny" program  uruchomiæ. <br>
<br>
    Od razu jednak natkniemy siê  na pewien podstawowy problem: co tak naprawdê
  znaczy sformu³owanie "wybierz ..., zapisz cenê."; kogo ma dotyczyæ ta sekwencja
  instrukcji do wykonania - tylko komputera, czy równie¿ nas samych - jako
 u¿ytkowników programu realizuj±cego dany algorytm?<br>
<br>
    Skoro na podstawie algorytmu mamy stworzyæ program, a program ma byæ
wykonywany   przez komputer, to <b>algorytm powinni¶my formu³owaæ w kategoriach
czynno¶ci   wykonywanych przez komputer</b>.<br>
<br>
    Zauwa¿my wiêc, ¿e w ogólnym sensie omawiany algorytm realizuje <b>przetwarzanie</b>
     jakich¶<A NAME="EDU.skorowidz.termin dana_wej¶ciowa 5_26"></A> <b>danych wej¶ciowych</b> (podawanych przez u¿ytkownika) w<A NAME="EDU.skorowidz.termin dana_wyj¶ciowa 5_27"></A> <b>
  dane  wyj¶ciowe</b> (wynik dzia³ania algorytmu).<br>
    Musimy sprecyzowaæ: jakie dane i kiedy ma podawaæ u¿ytkownik i co z tymi
  danymi ma robiæ komputer.<br>
    Mamy co najmniej trzy mo¿liwo¶ci:<br>
<ul>
  <li>u¿ytkownik podaje konkretne ceny, program wylicza ich sumê;</li>
  <li>u¿ytkownik podaje charakterystyki sk³adników, program odszukuje np.
  w jakiej¶ internetowej  bazie danych ich ceny i sumuje je;<br>
  </li>
  <li>u¿ytkownik podaje kryteria wyboru konfiguracji sprzêtowej, program
wed³ug tych kryteriów dokonuje wyboru konkretnych opcji sprzêtowych i sumuje
ich ceny.</li>
</ul>

<p>W pierwszym przypadku nasz algorytm tylko nieco siê zmieni. Pamiêtajmy:
 formu³ujemy go w kategoriach czynno¶ci wykonywanych przez komputer.<br>
 
<pre>
1. Zapytaj u¿ytkownika o cenê procesora
2. Zapytaj u¿ytkownika o cenê p³yty g³ównej
...
n-1. Zsumuj podane ceny
n.   Podaj u¿ytkownikowi wynik (cenê komputera)
</pre>

<p>Inne, przedstawione wy¿ej przypadki,  prowadz± do algorytmów znacznie
bardziej  skomplikowanych. <br>
<br>
    Zauwa¿my jeszcze, ¿e ten prosty algorytm ma bardzo ogóln± postaæ. Prze³o¿enie
  go na jaki¶ jêzyk programowania wymaga podjêcia wielu decyzji, np.<br>
<ul>
  <li> w jaki sposób ma odbywaæ siê interakcja z u¿ytkownikiem: w jaki sposób
  pytaæ go o dane wej¶ciowe i jak pokazywaæ wynik (dane wyj¶ciowe) ?</li>
  <li>w jaki sposób wykonywaæ sumowanie: czy przechowywaæ ceny poszczególnych
  sk³adników, czy sk³adaæ je inkrementalnie maj±c na wyj¶ciu do dyspozycji
 tylko wynikow±, sumaryczn± cenê?</li>
  <li>w jaki sposób reagowaæ na b³êdy danych ?<br>
  </li>
</ul>

<p>Decyzje te dotycz± zaprojektowania tzw.<A NAME="EDU.skorowidz.termin interfejs_u¿ytkownika 5_28"></A> <b>interfejsu u¿ytkownika</b>
 (czyli  sposobu komunikowania siê programu z u¿ytkownikiem) oraz przemy¶lenia
 struktury  algorytmu pod wzglêdem <b>odporno¶ci na b³êdy</b> i  <b>³atwo¶ci
 modyfikacji</b>. Np. w naszym algorytmie powinni¶my sprawdzaæ, czy u¿ytkownik
nie wprowadzi³  czasem danych, które nie s± liczb±  i zastanowiæ siê, czy
 nie przechowywaæ  cen poszczególnych sk³adników komputera, bo byæ mo¿e za
jaki¶ czas zmienimy  zestaw danych wyj¶ciowych i bêdziemy chcieli pokazaæ
u¿ytkownikowi  "raport  z obliczeñ", przedstawiaj±cy, oprócz sumarycznej ceny,
 ceny poszczególnych  sk³adników, a mo¿e nawet ich procentowy udzia³ w ³±cznym
koszcie.<br>
<br>
    Ju¿ tylko reagowanie na b³êdy danych zmieni sekwencjê kroków
naszego  algorytmu.<br>
    Zazwyczaj zreszt±  rozwi±zanie jakiego¶ problemu lub wykonanie jakiego¶
 zadania wymaga - oprócz jakich¶ prostych sekwencji kroków: :<br>
<ul>
  <li>sprawdzania jakich¶ warunków i na tej podstawie <b>podejmowania decyzji</b>
   o wyborze dalszych  kroków algorytmu</li>
   
  <li><A NAME="EDU.skorowidz.termin iteracja 5_29"></A> <b>iteracyjnego wykonania</b> jakich¶ fragmentów algorytmu (powtarzania
ich   wykonania wielokrotnie, zadan± liczbê razy lub dopóki spe³nione sa
jakie¶   warunki)</li>
</ul>

<p>Uwzglêdniaj±c mo¿liwe b³êdy przy podawaniu danych przez u¿ytkownika oraz
  potrzebê przechowywania danych o podanych cenach sk³adników, algorytm
wyliczenia  ceny komputera mo¿e wygl±dac tak:<br>
<br>

<pre>
1. Zapytaj u¿ytkownika o cenê procesora
2. Je¿eli podana cena nie jest liczb±,
   powiadom u¿ytkownika o b³êdzie
   i wróæ do kroku 1
3. Zapisz cenê procesora (do ew. pó¼niejszego u¿ycia)
4. Zapytaj u¿ytkownika o cenê p³yty g³ównej
5. Je¿eli podana cena nie jest liczb±,
   powiadom u¿ytkownika o b³êdzie
   i wróæ do kroku 4
6. Zapisz cenê p³yty g³ównej (do ew. pó¼niejszego u¿ycia)
... inne sk³adniki
... inne sk³adniki
n-1. Wylicz sumê cen sk³adników
n.   Poka¿ wyniki
</pre>

<p><A NAME="EDU.skorowidz.termin schemat_blokowy 5_30"></A> Na schematach blokowych podejmowanie decyzji przedstawia siê w postaci rombu.<br>
 Przyk³ad: schemat blokowy algorytmu obliczania podatku.<br><br>

<center>
<img src="images/Alg_pod.jpg" alt="Rysunek - algorytm 2" width="641" height="749" border="1">
</center>

<br clear="all">

<p>Algorytmy mo¿emy zapisywaæ równie¿ w<A NAME="EDU.skorowidz.termin pseudo-kod 5_31"></A> <b>pseudo-kodzie</b>, czyli skróconej i
do pewnego stopnia sformalizowanej  formie jêzyka naturalnego, niezale¿nej
od konkretnego jêzyka programowania. Pseudo-kod jest znacznie bli¿szy
jêzykom programowania ni¿ jêzyk naturalny  i ³atwiej jest przek³adaæ go na
program zapisany w konkretnym jêzyku programowania. W ró¿nych podrêcznikach
programowania znale¼æ mo¿na ró¿ne formy pseudo-kodu, sami mo¿emy tak¿e opracowaæ
dla siebie w³asny pseudo-kod.<br>

W pseudo-kodzie mo¿emy  pos³ugiwaæ siê pojêciem<A NAME="EDU.skorowidz.termin zmienna 5_32"></A> <b>zmiennej</b>, czyli symbolicznego
oznaczenia danych (wiêcej o pojêciu zmiennej w nastêpnym wyk³adzie; teraz
mo¿emy traktowaæ je nieco podobnie jak w matematyce).<br>

Operacje na zmiennych mo¿emy zapisaæ skrótowo za pomoc±<A NAME="EDU.skorowidz.termin operator 5_33"></A> <b>operatorów</b>
 czyli symboli dodawania, odejmowania, mno¿enia, porównania itp. (wiêcej
o operatorach w nastêpnym wyk³adzie).<br>
W pseudo-kodzie musz± znajdowaæ siê tak¿e s³owa i  wyra¿enia, precyzyjnie okreslaj±ce
znaczenie fragmentów algorytmu (czynno¶ci, instrukcje do wykonania).  Np.
podejmowanie<A NAME="EDU.skorowidz.termin decyzja 5_34"></A> decyzji mo¿e byæ zapisane w postaci: <br><br>

<center><div class="ddd"><b>je¿eli</b> (warunek)  <b>to</b> ...<br>
<br>
albo<br>
<br>
<b>je¿eli</b> (warunek)  <b>to</b> ...<br>
<b> w przeciwnym razie</b> ...
</div>
</center>

<p>
a<A NAME="EDU.skorowidz.termin pêtla_iteracyjna 5_35"></A> pêtle iteracyjne (czyli powtarzanie fragmentów algorytmu):<br><br>

<center><div class="ddd"><b>wykonuj dopóki</b> (warunek) ...<br>
<br>
<b>wykonuj zmieniaj±c warto¶æ zmiennej <i>i</i> od <i>p</i> do <i>l</i></b> ...</div>
</center>

<p>Natomiast wprowadzanie i wyprowadzanie danych  mo¿na wyraziæ np. za pomoc±
s³ów <b>czytaj</b>, <b>pisz</b>. <br>
<br>
U¿ywaj±c symboli +, - i * dla wyra¿enia operacji dodawania, odejmowania i
mno¿enia, nawiasów (jak w matematyce) do grupowania operacji i specjalnych
s³ów dla wyra¿enia czynno¶ci i<A NAME="EDU.skorowidz.termin decyzja 5_36"></A> decyzji, algorytm wyliczenia podatku mo¿emy
teraz zapisaæ jako:<br>
<br>

<pre>
<b>czytaj</b> dochód
<b>je¿eli</b> (dochód &gt; 74048) <b>to</b> podatek = 17048.44 + 0.4 * (dochód - 74048)
<b>w przeciwnym razie</b> <b>je¿eli</b> (dochód &gt; 37024) <b>to</b>
   podatek = 6541.24 + 0.3 * (dochód - 37024)
<b>w przeciwnym razie</b> podatek = 0.19 * dochód - 493.32
<b>pisz</b> podatek
</pre>

<p>Przy zapisie w ten sposób algorytmu obliczenia ceny komputera natkniemy siê
jednak na dwa problemy.<br>
<br>
Po pierwsze, b³±d przy  wprowadzaniu danych zmienia sekwencjê kroków algorytmu
i powoduje powrót do kroku wczytywania danych. W pseudo-kodzie mogliby¶my to
zapisaæ jako instrukcjê przej¶cia do konkretnego fragmentu algorytmu (<b>
id¿ do ..</b>), oznaczonego jak±¶ etykiet± (etykieta bêdzie s³owem zakoñczonym
dwukropkiem). Przy okazji, wprowadzimy do naszego pseudo-kodu nawiasy klamrowe,
które bêd±<A NAME="EDU.skorowidz.termin grupowanie 5_37"></A> grupowaæ czynno¶ci; np.  w kontek¶cie:<br>
<br>

<dir><p><b>je¿eli (warunek) to {</b><br>
  czynno¶æ 1<br>
  czynno¶æ 2<br>
  <b>}</b>
  </dir>
  
<p>przy zaj¶ciu warunku zostan± wykonane po kolei czynno¶ci podane w nawiasach
klamrowych.<br>
<br>
  
<pre>
pobieranieDanych1:
  <b>pisz</b> "Podaj cenê procesora"
  <b>czytaj</b> cenaProcesora
  <b>je¿eli</b> (cenaProcesora nie jest liczb±) <b>to {
     pisz </b>"Wadliwe dane"
     <b>id¼ do</b> pobieranieDanych1
  <b>}</b>
pobieranieDanych2:
  <b>pisz</b> "Podaj cenê p³yty g³ównej"
  <b>czytaj</b> cenaP³yty
  <b>je¿eli</b> (cenaP³yty nie jest liczb±) <b>to {
</b><b>     pisz </b>"Wadliwe dane"
<b>     id¼ do</b> pobieranieDanych2
  <b>}</b>
...

cenaWynikowa = suma cen czê¶ci

<b>pisz</b> cenaWynikowa  

</pre>

<p>Taki sposób zapisu powoduje jednak, ¿e algorytmy (i programy) staj± siê trudno
czytelne, a ich logika zawik³ana i  nara¿ona na b³êdy. <br>

Dlatego w wiêkszo¶ci jêzyków programowania nie ma ju¿<A NAME="EDU.skorowidz.termin instrukcja_goto 5_38"></A> instrukcji <b>goto</b>
 ( id¼ do). Zamiast tego stosowane s±  instrukcje iteracyjne. Jest to równie¿
powód dla którego straci³y na popularno¶ci schematy blokowe (okazuje siê
bowiem, ¿e schematy blokowe nie zawsze, a zawsze niezbyt bezpo¶rednio przek³adaj±
siê na "programowanie bez goto"). <br>
Algorytm wyliczenia ceny komputera  powinni¶my wiêc wyraziæ w inny sposób,
np. wprowadzaj±c zmienn± logiczn± o nazwie trzebaPobraæDane, która mo¿e przyjmowaæ
dwie symboliczne warto¶ci <b>tak</b> i <b>nie, </b> oraz u¿ywaj±c instrukcji
iteracyjnych.<br>
<br>

<pre>
trzebaPobraæDane = <b>tak</b>
<b>wykonuj dopóki</b> (trzebaPobraæDane) <b>{</b>
  <b>pisz</b> "Podaj cenê procesora"
  <b>czytaj</b> cenaProcesora
  <b>je¿eli</b> (cenaProcesora nie jest liczb±) <b>to</b> <b>pisz</b> "Wadliwe dane"
  <b>w przeciwnym razie</b> trzebaPobraæDane = <b>nie</b>
<b>}</b>  

trzebaPobraæDane = <b>tak</b>
<b>wykonuj dopóki</b> (trzebaPobraæDane) <b>{</b>
  <b>pisz</b> "Podaj cenê p³yty g³ównej"
  <b>czytaj</b> cenaP³yty
  <b>je¿eli</b> (cena
P³yty nie jest liczb±) <b>to</b> <b>pisz</b> "Wadliwe dane"
  <b>w przeciwnym razie</b> trzebaPobraæDane = <b>nie</b>
<b>}</b>  
...
cenaWynikowa = suma cen czê¶ci
<b>pisz</b> cenaWynikowa

</pre>

<p>Na pocz±tku zmienna trzebaPobraæDane ma warto¶æ <b>tak </b>i  warunek w <b>
wykonuj dopóki</b> jest prawdziwy, zatem rozpoczyna siê wykonanie instrukcji
w nawiasach klamrowych. Je¿eli wprowadzone dane (cenaProcesora) nie s± liczb±,
to wypisywany jest komunikat "Wadliwe dane", warto¶æ zmiennej trzebaPobraæDane
nie zmienia siê i czynno¶ci zapisane w nawiasach klamrowych wykonywane s±
ponownie (bowiem warunek w <b>wykonuj dopóki </b>nadal jest prawdziwy). W
przeciwnym razie (je¶li cenaProcesora jest liczb±),  zmienna trzebaPobraæDane 
przybiera warto¶æ <b>nie</b>, wobec czego warunek w <b>wykonuj dopóki</b>
 przestaje byæ prawdziwy i  czynno¶ci w nawiasach klamrowych nie s± kolejny
raz wykonywane, a algorytm kontynuuje dzia³anie  od miejsca po zamykaj±cym
nawiasie klamrowym - rozpoczyna pobieranie danych dotycz±cych ceny p³yty
g³ównej.<br>
  <br>
Drugi problem, zwi±zany z tym algorytmem polega na  powielaniu bardzo podobnych
(niemal identycznych) czynno¶ci. Zwróæmy uwagê: pobieranie cen dla  procesora,
p³yty, innych komponentów - wygl±da praktycznie tak samo. Mogliby¶my wiêc
wyodrêbniæ te czynno¶ci i zapisaæ je jeden raz w postaci tzw.<A NAME="EDU.skorowidz.termin procedura 5_39"></A> <b>procedury
  </b>lub<A NAME="EDU.skorowidz.termin funkcja 5_40"></A> <b>funkcji</b>, a jednokrotnie zapisane w niej czynno¶ci wykonywaæ
wielokrotnie  dla ró¿nych komponentów komputera. <br>
Oznacza to, ¿e dzielimy nasz problem obliczenia ceny komputera na dwa podproblemy:
podproblem wprowadzania i  weryfikacji danych oraz g³ówny problem w³a¶ciwych
obliczeñ.  Ka¿dy z tych problemów mo¿emy rozwi±zywaæ w du¿ym stopniu  niezale¿nie,
skupiaæ siê ka¿dorazowo na specyficznych w danym kontek¶cie cechach.  <br>

Ten sposób tworzenia algorytmów i programów nazywa siê<A NAME="EDU.skorowidz.termin programowanie_strukturalne 5_41"></A> <b>programowaniem
strukturalnym</b>.<br>
  <br>
W nastêpnych wyk³adache poznamy bli¿ej pojêcie funkcji i zastosujemy je w 
praktyce.<br>
  <br>
  
Podsumujmy:

  <ul>
    <li>programy piszemy po to, by rozwi±zywaæ jakie¶ problemy lub realizowaæ jakie¶ zadania;</li>

    <li>zanim napiszemy program, który realizuje jakie¶ zadanie, musimy opracowaæ
algorytm postêpowania, prowadz±cego do realizacji tego zadania;</li>

    <li>algorytm jest  przepisem, zbiorem poleceñ wykonywanych na danych,
opisem sposobu przekszta³cenia danych wej¶ciowych w dane wyj¶ciowe;</li>

    <li>program jest zapisem algorytmu <b>oraz danych</b> w konkretnym<A NAME="EDU.skorowidz.termin jêzyk_programowania 5_42"></A> jêzyku
programowania;</li>

    <li>po to by program móg³ byæ wykonany przez komputer jego zapis w konktretnym
jêzyku programowania musi byæ przet³umaczony na jêzyk instrukcji rozumianych
przez procesor; takiego t³umaczenia dokonuj± specjalne programy nazywane translatorami,
kompilatorami i interpreterami.<br>
    </li>
  </ul>
  
<p>Zwróæmy szczególn± uwagê na to, ¿e w programach nie tylko odzwierciedlamy
kroki ( polecenia, czynno¶ci) algorytmów, ale równie¿ musimy w jaki¶ sposób
przedstawiaæ dane, których czynno¶ci te dotycz±.   Dane mog±  byæ obrazowane
w ró¿ny sposób - mog±  byæ opisywane jako pojedyncze egzamplarze albo jako
zestawy, (powi±zanych i/lub w okreslony sposób uporz±dkowanych) danych. W
tym kontek¶cie mówimy o<A NAME="EDU.skorowidz.termin struktury_danych 5_43"></A> <b>strukturach danych</b>.<br>
  <br>
Mo¿emy zatem podaæ inn±  od poprzedniej definicjê programu (autorstwa N.
Wirtha).<br><br>

<center>
<div class="def"><A NAME="EDU.skorowidz.termin program 5_44"></A> <b>PROGRAM</b> - to skonkretyzowane sformu³owanie
abstrakcyjnego algorytmu na podstawie okre¶lonej reprezentacji i struktury
danych.</div>
</center>

<p>Obie definicje nie s± sprzeczne. Pierwsza, przytoczona na wstêpie tego wyk³adu
("program jako zestaw instrukcji wykonywanych przez procesor") akcentuje
dzia³anie, druga ("program jako konkretny zapis algorytmu") akcentuje tworzenie
programu. <br>

<br>
Tekst programu zapisujemy w wybranym jêzyku programowania. <br>
Ka¿dy jêzyk programowania  posiada swój<A NAME="EDU.skorowidz.termin alfabet_jêzyka_programowania 5_45"></A> <b>alfabet</b>, czyli zbiór znaków
(liter i cyfr) z których mog± byæ konstruowane symbole jêzyka (ci±gi znaków).<A NAME="EDU.skorowidz.termin regu³y_sk³adniowe 5_46"></A> <b>Regu³y sk³adniowe</b> definiuj± dopuszczalne sposoby tworzenia  symboli
oraz  dopuszcalne porz±dki ich wystêpowania w programie, za¶<A NAME="EDU.skorowidz.termin semantyka 5_47"></A> <b>semantyka</b>
 jêzyka okresla znaczenie wybranych symboli. Np. w jakim¶ jêzyku programowania
mo¿emy siê pos³ugiwaæ alfabetem sk³adaj±cym siê z liter, cyfr, znaków specjalnych
(alfabet jêzyka);  z liter i cyfr mo¿emy tworzyæ nazwy zmiennych, niektóre
ci±gi znaków (np. if ) mog± byæ zarezerwowane i oznaczaj± instrukcje jêzyka,
sposób ³±czenia ze sob± symboli jest okre¶lony (np. napis if (a == b) a =
0; bêdzie poprawny sk³adniowo, a napis if a = b  a = 0 bêdzie niepoprawny);
znaczenie ci±gów symboli jest okreslone np. a = 3 oznacza przypisanie zmiennej
a warto¶ci 3). <br>
<br>

Istnieje wiele (dziesi±tki tysiêcy)<A NAME="EDU.skorowidz.termin jêzyk_programowania 5_48"></A> jêzyków programowania. Mo¿na je klasyfikowaæ
wed³ug ró¿nych kryteriów.<br>
Niewatpliwie najwazniejszym jest logiczna struktura jêzyka i sposób tworzenia programów w danym
jêzyku.<br>
  <b><br><A NAME="EDU.skorowidz.termin jêzyk_imperatywny 5_49"></A> Jêzyki imperatywne </b> wymagaj± od programisty wyspecyfikowania konkretnej
sekwencji kroków realizacji zadania, natomiast<A NAME="EDU.skorowidz.termin jêzyk_deklaratywny 5_50"></A> <b>jêzyki deklaratywne</b>
 - opisuj±  relacje pomiêdzy danymi w kategoriach funkcji<A NAME="EDU.skorowidz.termin jêzyk_funkcyjny 5_51"></A> (<b>jêzyki funkcyjne</b>
) lub regu³<A NAME="EDU.skorowidz.termin jêzyk_relacyjny 5_52"></A> (<b>jêzyki relacyjne</b>,<A NAME="EDU.skorowidz.termin jêzyk_programowania_logicznego 5_53"></A> <b>jêzyki programowania logicznego</b>
), a wynik dzia³ania programu uzyskiwany jest poprzez zastosowanie wobec
opisanych relacji okre¶lonych gotowych,  wbudowanych "w jêzyk" algorytmów. <A NAME="EDU.skorowidz.termin podej¶cie_obiektowe 5_54"></A> <b>Podej¶cie obiektowe</b> polega przede wszystkim na ³±cznym rozpatrywaniu
danych i mo¿liwych operacji na nich, daj±c mo¿liwo¶æ tworzenia i u¿ywania
w programie nowych typów danych, odzwierciedlaj±cych dziedzinê problemu,<A NAME="EDU.skorowidz.termin programowanie_proceduralne 5_55"></A> <b>programowanie proceduralne</b> (czasami kojarzone z imperatywnym) rozdziela
dane i funkcje i nie dostarcza sposobów prostego adekwatnego odzwierciedlenia
dziedziny rozwi±zywanego problemu w strukturach danych, u¿ywanych w programie.<br>
  <br>

<center>
  <img src="images/Jezyki.jpg" alt="Rysunek - jezyki" width="700" height="210" border="1">
</center>

<br>
<p>Przyk³adami jêzyków proceduralnych s±:<A NAME="EDU.skorowidz.termin ALGOL 5_56"></A> ALGOL,<A NAME="EDU.skorowidz.termin FORTRAN 5_57"></A> FORTRAN,<A NAME="EDU.skorowidz.termin PL/I 5_58"></A> PL/I,<A NAME="EDU.skorowidz.termin C 5_59"></A> C. Jêzyki obiektowe
to np.<A NAME="EDU.skorowidz.termin SmallTalk 5_60"></A> SmallTalk,<A NAME="EDU.skorowidz.termin Java 5_61"></A> Java,<A NAME="EDU.skorowidz.termin C++ 5_62"></A> C++,<A NAME="EDU.skorowidz.termin C# 5_63"></A> C#. Najbardziej znanym jêzykiem funkcyjnym jest
Haskell, za¶ jêzykiem programowania logicznego -<A NAME="EDU.skorowidz.termin Prolog 5_64"></A> Prolog.<br><br>

Inny podzia³ dotyczy sposobu w jaki tekst programu przekszta³cany jest na
instrukcje dla procesora.<br>
Mamy tu podzia³ na <A NAME="EDU.skorowidz.termin jêzyk_kompilowany 5_65"></A> <b>jêzyki kompilowane i interpretowane</b>.<br>

<div class="notel"> <b>Kompilator</b> t³umaczy program ¼ród³owy na instrukcje, które mog±
byæ wykonane przez procesor  i jednocze¶nie sprawdza sk³adniow± poprawno¶æ
programu, sygnalizuj±c wszelkie b³êdy. Proces kompilacji jest wiêc nie tylko
porcesem t³umaczenia, ale równie¿ weryfikacji sk³adniowej poprawno¶ci programu.</div>

<div class="ddd">
<br>
W <b>jêzykach kompilowanych</b> tekst programu (<A NAME="EDU.skorowidz.termin program_¼ród³owy 5_66"></A> <b>program ¼ród³owy</b>)
t³umaczony jest na<A NAME="EDU.skorowidz.termin kod_binarny_(po¶redni) 5_67"></A> <b>kod binarny (po¶redni)</b> przez specjalny program
nazywany<A NAME="EDU.skorowidz.termin kompilator 5_68"></A> <b>kompilatorem</b>.  Zazwyczaj inny program zwany <b>linkerem </b>
- generuje z kodu po¶redniego gotowy do dzia³ania binarny <A NAME="EDU.skorowidz.termin kod_wykonywalny 5_69"></A> <b>kod wykonywalny</b>
 i zapisuje go na dysku w postaci pliku typu wykonywalnego (np. z rozszrzeniem 
EXE lub z nadanym atrybutem "zdolny do wykonywania"). W ten sposób dzia³aj±
takie jêzyki jak C czy C++. Czasem kompilator produkuje symboliczny  kod
binarny, który jest wykonywany za pomoc±<A NAME="EDU.skorowidz.termin interpretacja 5_70"></A> <b>interpretacji</b> przez program
zwany<A NAME="EDU.skorowidz.termin interpreter 5_71"></A> <b>interpreterem</b>. Tak w³a¶nie dzieje siê w przypadku jêzyka Java.
</div>

<br clear="all">
<br>

<div class="notel"> <b>Interpreter</b> wykonuje bezpo¶rednio tekst programu. Zatem sk³adniowa
poprawno¶æ jest sprawdzana zazwyczaj dopiero w trakcie dzia³ania programu,
aczkolwiek niektóre jêzyki interpretowane udostêpniaj± fazê symbolicznej
kompilacji do kodu po¶redniego, podczas której sprawdzana jest poprawno¶æ
¼ród³a.</div>

<div class="ddd">
<br>
W<A NAME="EDU.skorowidz.termin jêzyk_interpretowany 5_72"></A> <b>jêzykach interpretowanych</b> kod programu (¼ród³owy lub
po¶redni) jest odczytywany przez specjalny program zwany <b>interpreterem.</b>
 który na bie¿±co - w zale¿no¶ci od przeczytanych fragmentów programu - przesy³a
odpowiednie  polecenia procesorowi i w ten sposób wykonuje program. <br>
Przyk³adami jêzyków interpretowanych s±:<A NAME="EDU.skorowidz.termin REXX 5_73"></A> REXX,<A NAME="EDU.skorowidz.termin ObjectREXX 5_74"></A> ObjectREXX,<A NAME="EDU.skorowidz.termin Perl 5_75"></A> Perl,<A NAME="EDU.skorowidz.termin PHP 5_76"></A> PHP.
</div>

<br clear="all">
  
<br>
<p>Reasumuj±c, proces programowania mo¿na przedstawiæ na poni¿szym rysunku za pomoc± nastêpuj±cego algorytmu.<br><br>
  <center>
  <img src="images/Programowanie.jpg" alt="Rysunek - programowanie" width="561" height="617" border="1">
  </center>
</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index04.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
