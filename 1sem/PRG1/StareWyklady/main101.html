<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index100.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><div class="tytulpunktu">5. Operacje na bitach</div>
<a name="W12.5"></a><A NAME="EDU.skorowidz.termin operacje_na_bitach 101_712"></A> <p><A NAME="EDU.skorowidz.termin liczby_ca³kowite 101_713"></A> Liczby ca³kowite (typów byte, short, int, long) s± reprezentowane w pamiêci
komputera w postaci binarnej jako ci±gi bitów. Bit, który znajduje siê w
takim zapisie najbardziej z lewej strony nazywa siê<A NAME="EDU.skorowidz.termin bit najbardziej_znacz±cy 101_714"></A> bitem najstarszym (najbardziej znacz±cym), a
ten najbardziej  z prawej -<A NAME="EDU.skorowidz.termin bit najmniej_znacz±cy 101_715"></A> najm³odszym (najmniej znacz±cym).<br>

Najstarszy bit jest<A NAME="EDU.skorowidz.termin bit znaku 101_716"></A> tzw. bitem znaku - je¶li jest ustawiony (ma warto¶æ
1) to liczba jest ujemna, a je¶li nie (ma warto¶æ 0) - to liczba jest dodatnia.
<br><br>

<div>
<img src="images/bity.jpg" alt="r" width="402" height="196" border="1">
</div>
<br>

<p>

Jak pamiêtamy z wyk³adu 1 - dziesiêtn± warto¶æ liczby zapisan± w systemie
dwójkowym mo¿emy uzyskaæ sumuj±c kolejne iloczyny warto¶ci bitów (1 lub 0)
i odpowiednich potêg 2.  Uwzglêdnienie liczb ujemnych wymaga, by warto¶æ
bitu znaku "brana by³a" z minusem. Dlatego na powy¿szym rysunku:<br>

7 = -0*2<sup>7</sup> + 0*2<sup>6</sup> + 0*2<sup>5</sup> + 0*2<sup>4</sup> +0*2<sup>3</sup> + 1*2<sup>2</sup> + 1*2<sup>1</sup> + 1*2<sup>0</sup><br>

-7 = -1*2<sup>7</sup> + 1*2<sup>6</sup> + 1*2<sup>5</sup> + 1*2<sup>4</sup> +1*2<sup>3</sup> + 0*2<sup>2</sup> + 0*2<sup>1</sup> + 1*2<sup>0</sup><br>
<br>

<div class="notel"><br>Taki zapis liczb ca³kowitych nazywa siê zapisem <b>z uzupe³nieniem do dwóch</b><br><br>
</div>

<div class="ddd"><br><A NAME="EDU.skorowidz.termin uzupe³nienie_do_dwóch 101_717"></A> £atwo dostrzec, ¿e z tego powodu warto¶æ bezwzglêdna najwiêkszej ca³kowitej liczby
ujemnej jest zawsze wiêksza od warto¶ci bezwglêdnej najwiêkszej ca³kowitej liczby dodatniej.
W przypadku warto¶ci typu byte najmniejsza mo¿liwa warto¶æ równa jest 100000000,
czyli -1*2<sup>7</sup> = - 128, natomiast najwiêksza mo¿liwa licznba dodatnia równa jest 01111111 = 127.
</div>
<br clear="all">

<br>
<p>
Pamiêtamy te¿, ¿e warto¶ci typu char<A NAME="EDU.skorowidz.termin znak 101_718"></A> (reprezentuj±ce znaki) mog± byæ traktowane
jak liczby ca³kowite. W tym przypadku jednak najstarszy bit nie jest traktowany
jako bit znaku - zatem warto¶ci typu char (zajmuj±ce 2 bajty) mog± kszta³towaæ
siê w przedziale od 0 do 65536.<br>
<br>

Na bitach warto¶ci wszystkich ca³kowitych typów numerycznych (w tym bitach warto¶ci typu  char) mo¿emy wykonywaæ operacje.<br>

Do operowania na bitach liczb ca³kowitych s³u¿± nastêpuj±ce operatory:<br>
<ul>
<li><A NAME="EDU.skorowidz.termin operator uzupe³nienia_jedynkowego 101_719"></A> jednoargumentowy operator uzupe³nienia jedynkowego ~ , </li>

<li><A NAME="EDU.skorowidz.termin operator przesuniêcia_bitowego 101_720"></A> dwuargumentowe operatory przesuniêcia bitowego &gt;&gt; (w prawo) i
&lt;&lt; (w lewo) oraz operator  przesuniêcia bitowego w prawo bez propagacji
bitu znakowego (&gt;&gt;&gt;),</li>

<li><A NAME="EDU.skorowidz.termin operator koniunkcji_bitowej 101_721"></A> dwuragumentowy operator koniunkcji bitowej &amp;, </li>

<li><A NAME="EDU.skorowidz.termin operator bitowej_ró¿nicy_symetrycznej 101_722"></A> dwuargumentowy operator bitowej ró¿nicy symetrycznej ^ (wykluczaj±ce ALBO), </li>

<li><A NAME="EDU.skorowidz.termin operator alternatywy_bitowej 101_723"></A> dwuargumentowy operator alternatywy bitowej | .</li>
</ul>

<p>
Ka¿dy z argumentów wszystkich wymienionych operatorów bitowych musi byæ typu ca³kowitego.<br>

Operatory przesuniêcia bitowego powoduj±<A NAME="EDU.skorowidz.termin przesuniêcie_bitów 101_724"></A> przesuniêcie bitów swojego lewego
argumentu o liczbê pozycji specyfikowan± przez prawy argument w lewo (operator
&lt;&lt;), lub w prawo (operator &gt;&gt;). Przy przesuwaniu w lewo, m³odsze
(zwalniane) bity zape³niane s± zerami; przy przesuniêciu w prawo zwalniane
bity zape³niane s± warto¶ci± bitu znakowego (najstarszego). co nazywa siê
propagacjê bitu znakowego. W przypadku u¿ycia operatora &gt;&gt;&gt; taka
propagacja nie wystêpuje i niezale¿nie od warto¶ci bitu znaku zwalniane bity
s± zape³niane zerami.<br>
<br>

Rozpatrzmy przyk³ady:<br>
<br>

byte b = 1; -&gt; bitowa reprezentacja: 00000001  (1)<br>

b &lt;&lt; 1       -&gt;                                 00000010  (2)<br>

b &lt;&lt; 4       -&gt;                                 00010000  (16)<br>
<br>
 A zatem w przypadku, gdy a jest któr±¶ z potêg dwójki, kolejne przesuniêcie
w lewo mno¿y warto¶æ a przez 2. A co siê stanie gdy bêdziemy chcieli przesun±æ
w lewo bity najwiêkszej z mo¿liwych liczb danego typu?<br>

Warto wiedzieæ, ¿e lewy argument operatora &lt;&lt;  (je¶li by³ typu byte,
short lub char) jest promowany do typu int i ca³e wyra¿enie ma warto¶æ typu
int (je¶li argument by³ typu long   - warto¶æ wyra¿enia jest typu long).<br>

Zatem taki program:<br>

<pre>
public class Test {

  public static void main(String[] args) {
    byte b = Byte.MAX_VALUE;
    System.out.println(b + " " + (b &lt;&lt; 1));
    System.out.println(b + " " + (byte) (b &lt;&lt; 1));
    int i = Integer.MAX_VALUE;
    System.out.println(i + " " + (i &lt;&lt; 1));
  }

}
</pre>

<p>
wyprowadzi:<br>

127 254<br>

127 -2<br>

2147483647 -2<br>
<br>

Pierwszy wynik jest faktycznie rezultatem mno¿enia warto¶ci b przez dwa tylko
dlatego, ¿e nast±pi³a promocja warto¶ci b do typu int i typem wyniku wyra¿enia
b &lt;&lt; 1 jest int.<br>

Trzeci wynik pokazuje, ¿e przesuniêcie bitów mo¿e doprowadziæ do zmiany bitu
znaku z 0 na 1. W tym przypadku nie by³o miejsca na promocjê (czyli faktycznie
zwiêkszenie liczby bitów zajmowanych przez liczbê) w konsekwencji bit znaku
sta³ siê 1 i otrzymali¶my liczbê ujemn±. <br>

Po¶redni, drugi wynik uwidacznia dok³adnie to samo. Dokonali¶my tu konwersji
do typu byte, zatem rezultat jest taki jakby¶my operowali na warto¶ciach typu
byte (bez promocji):<br>
<br>

127 =  01111111<br>
<br>

a po przesuniêciu bitów o jedno miejsce, otrzymujemy:<br>
<br>

11111110<br>
<br>

co jest równe dok³adnie -2.<br>
<br>

Zobaczmy jak dzia³a operator &gt;&gt; (przesuniêcie bitów w prawo - z propagacj± znaku)<br>
<br>

byte b = 127;     -&gt;  01111111<br>

b &gt;&gt; 1               -&gt;  00111111 (63)<br>

b &gt;&gt; 2               -&gt;  00011111 (31)<br>

b &gt;&gt; 3               -&gt;  00001111 (15)<br>
<br>

Operacja a &gt;&gt; n dla liczb ca³kowitych jest równowa¿na ca³kowitoliczbowemu
dzieleniu (daj±cemu w rezultacie ca³kowit± czê¶æ rezultatu dzielenia) a/2<sup>n</sup>.<br>
<br>

Dla liczb ujemnych wygl±da to w nastêpuj±cy sposób:<br>

byte b = -64; -&gt;    11000000<br>

b &gt;&gt; 1          -&gt;    11100000  (-32)<br>

b &gt;&gt; 2          -&gt;    11110000  (-16)<br>

b &gt;&gt; 3          -&gt;    11111000  (-8)<br>

c &gt;&gt; 4          -&gt;    11111100  (-4)<br>
<br>

(zwalniane bity s± zape³niane warto¶ci± bitu znakowego tj. 1)<br>

Zauwa¿my wiêc, ¿e je¶li b = -1 (11111111), to przesuniêcie bitów w prawo da wynik -1.<br>

<br><A NAME="EDU.skorowidz.termin operator_bitowy logiczny 101_725"></A> Logiczne operatory bitowe ( ~,^, &amp;, |) s³u¿± do ustalania warto¶ci
bitów rezultatu za pomoc± warto¶ci bitów argumentów. Operator uzupe³nienia
jedynkowego ~ zamienia w swoim jedynym argumencie wszystkie zerowe bity na
1, a 1 na 0. Sposób w jaki okre¶lane s± bity rezultatu pozosta³ych logicznych
operacji bitowych obrazuje poni¿sza tablica, w której a1 i a2 oznaczaj± argumenty
operatorów bitowych.<br>
<br>

<table border="1" width="100%" cellpadding="1" cellspacing="1">
<tbody><tr valign="Top"><td rowspan="2">
      <div align="Center">Warto¶æ
bitu<br>
w a1</div>
</td><td rowspan="2">
      <div align="Center">Wart. odpo-<br>
wiadajêcego<br>
mu bitu w
a2</div>
</td><td colspan="3">
      <div align="Center">Wart. odpowiadaj±cego bitu rezultatu
oper.</div>
</td></tr><tr valign="Top"><td>
      <div align="Center"><strong>a1 &amp; a2</strong></div>
</td><td>
      <div align="Center"><strong>a1 ^ a2</strong></div>
</td><td>
      <div align="Center"><strong>a1 | a2</strong></div>
</td></tr><tr valign="Top"><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">0</font></td></tr><tr valign="Top"><td align="Center"><font face="Courier">1</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier"
>1</font></td><td align="Center"><font face="Courier">1</font></td></tr><tr valign="Top"><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">1</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">1</font></td><td align="Center"><font face="Courier">1</font></td></tr><tr valign="Top"><td align="Center"><font face="Courier">1</font></td><td align="Center"><font face="Courier">1</font></td><td align="Center"><font face=
"Courier">1</font></td><td align="Center"><font face="Courier">0</font></td><td align="Center"><font face="Courier">1</font></td></tr></tbody>
</table>

<p>Np. je¶li a1 = 5, a2 = 7, to logiczne operacje bitowe s±
przeprowadzane w nastêpuj±cy sposób:</p>

<table border="1" width="100%" cellpadding="1" cellspacing="1">
<tbody><tr valign="Top"><td><tt>a1 &amp; a2 =  ...0101<br>
        &amp; ...0111<br>
         ---------<br>
          ...0101
= 5</tt></td><td><tt>a1 ^ a2 =  ...0101<br>
        ^ ...0111<br>
         ---------<br>
          ...0010
= 2</tt></td><td><tt>a1 | a2 =  ...0101<br>
        | ...0111<br>
        ---------<br>
          ...0111
= 7</tt></td></tr></tbody>
</table>

<br><p>
Zwróæmy uwagê, ¿e operacje te dotycz± tylko najm³odszych 3 bitów, niezale¿nie
od tego jakiego s± typu i ile miejsca w pamiêci zajmuj± argumenty a1 i a2.
<br>
Np. aby wyzerowaæ najm³odszy bit ca³kowitej zmiennej x - niezale¿nie od jej typu  mo¿emy napisaæ:<br>
<br>
x = x &amp; ~0x1;  <br>
<br>
zerowe bity sta³ej 0x1 stan± siê 1, a jedyny bit o warto¶ci 1 - zerem; w
rezultacie w x zerowany bêdzie najm³odszy bit - niezale¿nie od tego jakiego
typu jest i ile miejsca zajmuje x.<br>
<br><A NAME="EDU.skorowidz.termin operacja_bitowa zastosowanie 101_726"></A> Operacje bitowe s± w³a¶nie najbardziej przydatne do ustawiania i testowania
warto¶ci bitów. Czêsto w programowaniu wykorzystuje siê<A NAME="EDU.skorowidz.termin flaga 101_727"></A> tzw. flagi - znaczniki,
których warto¶ci okre¶laj± np. charakterystyki jakiego¶ zdarzenia, albo jaki
jest stan jakiego¶ obiektu. Flagi maj± zwykle charakter zero-jedynkowy -
szkoda wiêc by³oby na ka¿d± z nich traciæ 8 bitów, gdy wystarczy 1. Zestawy
flag zapisujemy wiêc zwykle jako bity warto¶ci jakiej¶ zmiennej - typu byte (8 flag),
albo int (32 flagi), albo long (64 flagi). Za pomoc± operatorów bitowych
mo¿emy sprawdzaæ które z flag przechowywanych w tych zmiennych s± ustawione
i modyfikowaæ ich ustawienie.<br>
<br>
Popatrzmy na nastêpuj±cy przyk³adowy program (wykorzystamy w nim statyczn±
metodê getBits(wart) z klasy Unspec, która zwraca tablicê znaków
0 - 1, pokazuj±cych bitow± reprezentacjê przekazanej jako argument warto¶ci;
klasê tê za chwilê zbudujemy i omówimy).<br>

<pre>
public class Flags {

  public static void main(String[] args) {

    final int  FL1 = 0x01,    // sta³e pokazuj±ce które bity (flagi) maj±
               FL2 = 0x02,    // byæ testowane lub ustawiane
               FL3 = 0x04,
               FL4 = 0x08;

    int flags = 0;
    flags = flags | FL1;                   // ustawia flagê 1 (najm³odszy bit)
    show("flags = flags | FL1",
          flags);
    flags = 0;
    flags =  flags | FL3;                  // ustawia flagê 3 (trzeci bit)
    show("flags = flags | FL3",
          flags);
    flags = 0;
    flags = flags | (FL1 | FL4);           // ustawia 1 i 4 flagê
    show("flags = flags | (FL1 | FL4)",
          flags);

   // czy flaga 1 ustawiona
   if ((flags &amp; FL1) &gt; 0) System.out.println("Flaga 1 ustawiona");
   else System.out.println("Flaga 1 NIE ustawiona");

   // czy flaga 2 ustawiona
   if ((flags &amp; FL2) &gt; 0) System.out.println("Flaga 2 ustawiona");
   else System.out.println("Flaga 2 NIE ustawiona");

   // czy flagi 1 i 4 ustawione (jednoczesnie)
   int mask = FL1 | FL4;
   if ((flags  &amp;  mask) ==  mask) System.out.println("Flagi 1 i 4 ustawione");
   else System.out.println("Flagi 1 i 4 NIE ustawione");

   // czy flagi 1 i 2 ustawione (jednoczesnie)
   mask = FL1 | FL2;
   if ((flags &amp; mask) == mask) System.out.println("Flagi 1 i 2 ustawione");
   else System.out.println("Flagi 1 i 2 NIE ustawione");

  }

  static void show(String s, int flags) {
    System.out.println(s);
    char[] bits =  Unspec.getBits(flags);
    System.out.println(new String(bits) + "   --- val: " + flags);
  }

}
</pre>

<p>
Program wyprowadzi nastêpuj±ce informacje:<br><br>

<div class="listing100">
flags = flags | FL1<br>
00000000000000000000000000000001   --- val: 1<br>
flags = flags | FL3<br>
00000000000000000000000000000100   --- val: 4<br>
flags = flags | (FL1 | FL4)<br>
00000000000000000000000000001001   --- val: 9<br>
Flaga 1 ustawiona<br>
Flaga 2 NIE ustawiona<br>
Flagi 1 i 4 ustawione<br>
Flagi 1 i 2 NIE ustawione<br>
</div><br>

<p><b><font color="#ff6600">Proszê przeanalizowaæ dzia³anie programu i przetestowaæ inne ustawienia flag.</font></b><br>
<br>
Znaj±c ju¿ dzia³anie operatorów bitowych mo¿emy pokusiæ siê o stworzenie
klasy Unspec, która dostarczy nastêpuj±cych statycznych metod, zwracaj±cych
w tablic<A NAME="EDU.skorowidz.termin bitowa_reprezentacje_warto¶ci 101_728"></A> bitowe reprezentacje warto¶ci ró¿nych typów:<br>
<br>
public static char[]  getBits(byte)<br>
public static char[]  getBits(char)<br>
public static char[]  getBits(int)<br>
public static char[]  getBits(long)<br>
<br>



<div class="important"><br>
Przed lektur± dalszego tekstu proszê to zadanie rozwi±zaæ samodzielnie
<br>
<br>

</div>

<br>
<p>
Mo¿liwe rozwi±zanie:<br>
<br>

<pre>
public class Unspec {

  public static char[] getBits(byte v)  {
    return getBits(8, (long) v);
  }

  public static char[] getBits(char v)  {
    return getBits(16, (long) v);
  }


  public static char[] getBits(int v)  {
    return getBits(32, (long) v);
  }


  public static char[] getBits(long v)  {
    return getBits(64, v);
  }

  private static char[] getBits(int n, long v)  {
    char[] bits = new char[n];
    long mask = 1;
    for (int k = n-1; k &gt;= 0; k--) {
      if ((v &amp; mask) != 0) bits[k] = '1';
      else bits[k] = '0';
      mask =  mask &lt;&lt; 1;
    }
    return bits;
  }
}
</pre>

<p>
oraz program testuj±cy, w którym - jako argumenty wywo³ania podajemy kolejno
liczbê typu long, liczbê typu int, znak, liczbê typu byte:<br>
<br>

<pre>
class Test {
  public static void main(String[] args) {
   long l = Long.parseLong(args[0]);
   int i  = Integer.parseInt(args[1]);
   char c = args[2].charAt(0);
   byte b = Byte.parseByte(args[3]);
   System.out.println("Warto¶æ typu long " + l);
   System.out.println(new String(getBits(l)));
   l = Long.MAX_VALUE;
   System.out.println("Maksymalna warto¶æ typu long " + l);
   System.out.println(new String(getBits(l)));
   l = Long.MIN_VALUE;
   System.out.println("Minimalna warto¶æ typu long " + l);
   System.out.println(new String(getBits(l)));
   System.out.println("Warto¶æ typu int " + i);
   System.out.println(new String(getBits(i)));
   System.out.println("Warto¶æ typu char: znak " + "'" + c + "'" + ", kod " + (int) c);
   System.out.println(new String(getBits(c)));
   System.out.println("Warto¶æ typu byte " + b);
   System.out.println(new String(getBits(b)));
  }
}
</pre>

<p>
Program ten - przy podanych argumentach: 1 -1 a -7 wyprowadzi:<br>
<br>

<div class="listing100">
Warto¶æ typu long 1<br>
0000000000000000000000000000000000000000000000000000000000000001<br>
Maksymalna warto¶æ typu long 9223372036854775807<br>
0111111111111111111111111111111111111111111111111111111111111111<br>
Minimalna warto¶æ typu long -9223372036854775808<br>
1000000000000000000000000000000000000000000000000000000000000000<br>
Warto¶æ typu int -1<br>
11111111111111111111111111111111<br>
Warto¶æ typu char: znak 'a', kod 97<br>
0000000001100001<br>
Warto¶æ typu byte -7<br>
11111001<br>
</div><p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left"><A HREF="index100.html" TARGET="_top"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td></tr></table></td>
</tr>
</table>
</body>
</html>
