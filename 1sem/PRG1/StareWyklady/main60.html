<!DOCTYPE HTML PUBLIC "-//W3C//DTD html 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="main.css">
<script language="JavaScript" src="skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="white" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="100%" cellspacing="4" cellpadding="4" border="0">
<tr>
    <td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index61.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 1"></A><div class="tytulpunktu">1.  Odwo³ania do sk³adowych klasy. Zmienna this</div>
<a name="W8.1"></a>

<p><A NAME="EDU.skorowidz.termin sk³adowa_klasy odwo³anie 60_512"></A> Nareszcie nadesz³a pora na szczegó³owe omówienie konstrukcji klasy Para. <br>
 Teraz (na chwilê) nie bêdziemy zwracaæ uwagi na specyfikatory dostêpu
(dla omawianego przyk³adu nie maj± one znaczenia). Klasê Para zdefiniujemy
te¿ troszkê inaczej ni¿ dotychczas (w programach przyk³adowych z katalogu
samples do poprzednich wyk³adów), tak by móc rozwa¿aæ ró¿ne ciekawe sytuacje.<br>
<br>

<pre>
class Para {

    int a;    // To s± "dane" (zwane polami klasy).
              // Okre¶laj± one z jakich elementów sk³adaæ siê
    int b;    // bêd± obiekty tej klasy.
              // a = pierwszy sk³adnik pary, b - drugi


 Para(int x, int y) {   // konstruktor: nadaje warto¶æ parze
   a = x  ;             // na podstawie przekazanych warto¶ci x i y
   b = y;
 }

 Para(int x) {          // inny konstruktor: nadaje obu sk³adnikom pary
   a = b = x;                  // (a i b) tê sam± warto¶æ x
 }


 void set(Para p)  {    // metoda ustalenia warto¶ci pary
   a = p.a;             // na podstawie sk³adników przekazanej pary
   b = p.b;
 }


 Para add(Para p) {             // metoda dodawania dwóch par
   Para wynik = new Para(a, b);
   wynik.a += p.a;
   wynik.b += p.b;
   return wynik;
 }

                               // metoda pokazuj±ca parê
 void show(String s)  {
   System.out.println(s + " ( " + a + " , " + b + " )" );
 }

}
</pre>

<p>
W innej klasie mo¿emy u¿yæ klasy Para, np. tak:<br>
<br>

<pre>
class ParaTest {

  public static void main(String[] args) {
    Para para1 = new Para(1,5);
    Para para2 = new Para(2,4);
    para1.show("Para 1 =");
    para2.show("Para 2 =");
    Para sumaPar = para1.add(para2);
    sumaPar.show("Suma par =");
    para1.set(para2);
    para1.show("Teraz para 1 = ");

  }

}
</pre>

<br>

<div class="listing33r">Para 1 = ( 1 , 5 )<br>
Para 2 = ( 2 , 4 )<br>
Suma par = ( 3 , 9 )<br>
Teraz para 1 =  ( 2 , 4 )<br>
 </div>

<div class="ddd"><br>
Powy¿szy program wyprowadzi na konsolê nastêpuj±ce wyniki. <br>
Zobaczmy co siê naprawdê dzieje.
</div>
<br clear="all">

<p>
Gdy piszemy: <br>
Para para1 = new Para(1, 5);<br>
wyra¿enie new tworzy obiekt tzn.: <br>
<ul>
  <li>wydziela miejsce w pamiêci do przechowania obiektu-pary (miejsce na dwie liczby ca³kowite)</li>
  <li>elementy pary odpowiadaj± polom a i b zadeklarowanym w klasie</li>
  <li>elementy te otrzymaj± warto¶æ 0 (domy¶lna inicjacja)</li>
  <li>wywo³ywany jest konstruktor klasy Para z argumentami 1 i 5, a jego
wykonanie powoduje, ¿e elementy utworzonej pary odpowiadaj±ce polom a i b
otrzymuj± odpowiednio warto¶ci 1 i 5 </li>
  <li>wyra¿enie new zwraca referencjê do nowoutworzonego obiektu</li>
  <li>referencja ta podstawiana jest na zmienn± para1 (w tej chwili zmienna
para1 zawiera referencjê - inaczej odniesienie - do nowoutworzonej pary)</li>
</ul>

<p>
Podobnie mo¿emy napisaæ:<br>
<br>
Para para2 = new Para(2,4);<br>
<br>
Mamy teraz dwa obiekty para1 i para2. <br>
<pre>
para1 "wygl±da" tak        para2 "wygl±da" tak

Pola:                      Pola:

  int a; ( = 1)              int a; ( = 2)
  int b; ( = 5)              int b; ( = 4)
---------------------------------------------
Metody:                    Metody:

  void set(...)              void set(...)
  Para add(...)              Para add(...)
  void show(...)             void show(...)

</pre>

<p>
Identyfikatory pól i metod s± takie same! <br>
Zatem trzeba ich u¿ywaæ "na rzecz" konkretnego obiektu (para1 albo para2). <br>
<br>
Do tego rozró¿niania s³u¿y kropka (nareszcie naocznie widaæ jej u¿yteczno¶æ): <br>
<br>
para1.a - oznacza element a obiektu para1 <br>
para2.a - oznacza element a obiektu para2 <br>
<br>
To samo z metodami: <br>
<br>
para1.show();  // obiektowi oznaczonemu para1 wysy³amy komunikat show (poka¿ siê) <br>
                      // co oznacza wywo³anie metody show na rzecz obiektu para1 <br>
<br>
para2.show();  // obiektowi oznaczonemu para2 wysy³amy komunikat show (poka¿ siê) <br>
                      // co oznacza wywo³anie metody show na rzecz obiektu para2 <br>
<br>

<div class="notec"><i><b>Uwagi:<br>
</b></i>
<ul>
  <li><i><b>o ile elementy obiektów (odpowiadaj±ce polom) s± zawarte
w obiektach, to metody - s± "wspólne" dla wszystkich obiektów klasy; podpisanie
ich pod ka¿dym obiektem oznacza tylko, ¿e mog± one byæ u¿ywane dla tego obiektu,
a nie, ¿e zajmuj± jakie¶ miejsce "w obiekcie"</b></i></li>

  <li><i><b>w opisie u¿yto "skrótu my¶lowego" dla uproszczenia tekstu;
mówi±c o obiektach para1 i para2 pamiêtamy, ¿e tak naprawde zmienne te s±
referencjami do obiektów.</b></i></li>
</ul>
</div>

<br>
<p>
Zajrzyjmy teraz do wnêtrza klasy. Sk±d wiadomo co konkretnie oznacza a i b w konstruktorze albo w metodzie set?<br>
Rozwa¿my konstruktor<br>
<br>
class Para {<br>
   int a, b; <br>
<br>
public Para(int x, int y) {   // s³owo public - niekonieczne<br>
   a = x  ;                             <br>
   b = y;<br>
}<br>
....<br>
}

<!-- @ -->

<p>
Wyra¿enie new najpierw
tworzy obiekt, a pó¼niej wywo³ywany jest konstruktor. Zatem w momencie rozpoczêcia
dzia³ania konstruktora obiekt ju¿ istnieje (jest mu przydzielona pamiêæ na
przechowanie dwóch liczb ca³kowitych,  ich warto¶ci  zosta³y inicjalnie okre¶lone,
w naszym przypadku jako zera). Wykonanie konstruktora dotyczy w³a¶nie tego
nowoutworzonego  obiektu. W konstruktorze dostêpna jest referencja do tego
obiektu w postaci niejawnie zdefiniowanej zmiennej o nazwie<A NAME="EDU.skorowidz.termin this 60_513"></A> <b>this</b>. (this = TEN).</p>

<div class="notel">S³owo <b>this</b> jest s³owem kluczowym jêzyka</div>

<div class="ddd"><br>
Zatem this.a i this.b - zgodnie z interpretacj± znaczenia kropki to pola
a i  b tego obiektu,  którego dotycz± inicjacje wykonywane przez konstruktor.</div>
<br clear="all">

<br>

<div>
<img src="images/new8.jpg" alt="Rys" width="553" height="449" border="1">
</div>

<br>
<div class="important">Poniewa¿ i tak wiadomo, ¿e samo a i b dotyczy pól (elementów) tego obiektu,
dla którego akurat wo³any jest konstruktor, to s³owo <b>this</b> mo¿emy pomin±æ.</div>

<br>
<p>
To samo dotyczy<A NAME="EDU.skorowidz.termin metoda wywo³ywanie_na_rzecz_obiektu 60_514"></A> metod wywo³ywanych na rzecz obiektów.<br>Wyobra¼my sobie, ¿e na rzecz obiektu para1 wywo³ano metodê set z argumentem  para2.<br>
Dzia³anie metody set ma polegaæ na przepisaniu zawarto¶ci pary para2 do pary para1.<br>
<br>
"Algorytm" metody set jest taki:<br>
<ol>
  <li>polu a tego obiektu na rzecz którego wywo³ano metodê przypisz warto¶æ pola a obiektu przekazanego jako argument </li>

  <li>polu b tego obiektu na rzecz którego wywo³ano metodê przypisz warto¶æ pola b obiektu przekazanego jako argument </li>
</ol>
<p>TEN obiekt na rzecz którego wywo³ano metodê jest wewn±trz metody reprezentowany s³owem kluczowym<A NAME="EDU.skorowidz.termin this 60_515"></A> <b>this</b>.<br><br>

<div>
<img src="images/set8.jpg" alt="Rys" width="499" height="184" border="1">
</div>

<br>
<p>
I znowu mo¿emy pomin±æ s³ówko this, bo tu jasne jest z kontekstu.<br>
<br>
<p>
<a href="javascript:popUp('dodatki/W8Prb1.htm',50,50)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a> <br>
void set(Para p) {<br>
   a = p.a;<br>
   b = p.b;<br>
}</p>
<br clear="all">

<p>
Zobaczmy teraz jak dzia³a metoda dodawania dwóch par.<br>
<br>

<div class="important">Po pierwsze: mamy dwie pary, które chcemy dodaæ - wobec tego silna jest
pokusa by u¿yæ metody z dwoma argumentami. Ale przecie¿ programujemy obiektowo:
pierwsza z par do której dodajemy drug± bêdzie obiektem do którego po¶lemy
polecenie add:<br>
<br>
    para1.add(para2);</div>

<br>
<p>
Po drugie: co zrobiæ z wynikiem dodawania?<br>
W rezultacie dodawania powinna powstaæ nowa para - suma dwóch dodanych par.<br>
Ta nowa para winna byæ stworzona w metodzie add, a referencja do niej zwrócona jako wynik tej metody. Dlatego:<br><br>

<div>
<img src="images/add8.jpg" alt="Rys" width="527" height="204" border="1">
</div>

<p>
<a href="javascript:popUp('dodatki/W8Prb2.htm',50,50)"><img src="images/Problem.jpg" alt="Problem" hspace="15" width="137" height="84" border="1" align="Right"></a> <br>

Zauwa¿my te¿, ¿e wszystko co analizowali¶my dot±d na przyk³adzie pól - dotyczy równie¿ metod.
<br clear="all">
<p>
Gydby¶my w klasie Para mieli na przyk³ad dwie metody getA() i getB(), które
zwracaj± odpowiednie sk³adniki pary, to w innej metodzie klasy (np. metodzie
sumuj±cej sk³adniki pary) mogliby¶my siê do nich odwo³aæ:<br>
<br>
class Para {<br>
    int a, b;<br>
    ...<br>
    int getA() { return a; }<br>
    int getB() { return b; }<br>
<br>
    int sum() {<br>
        int pierwsza = this.getA();<br>
        int druga = this.getB();<br>
        return pierwsza + druga;<br>
    }<br>
}<br>
<br>
co oznacza³oby, ¿e wywo³ujemy metody getA i getB na rzecz tego obiektu, na rzecz którego zosta³a wywywo³ana metoda sum.<br>
Poniewa¿ jest to jasne z kontekstu, mo¿emy napisac pro¶ciej:<br>
<br>
int sum() {<br>
    return getA() + getB();<br>
}<br>
    <br>
<br>
S± przypadki, kiedy u¿ycie s³owa kluczowego<A NAME="EDU.skorowidz.termin this 60_516"></A> this jest istotne. Na przyk³ad, gdy identyfikatory
parametrów przes³aniaj± (s± takie same jak) identyfikatory pól klasy.<br>
<br>
class Para {<br>
    int a, b; <br>
<br>
Para (int a,  int b) {<br>
     a = ... //<font color="#ff0000"> o które a chodzi: parametr czy pole???</font><br>
...<br>
}<br>
<br>
void set(int a, int b) {<br>
    a = ... // <font color="#ff0000">o które a chodzi: parametr czy pole???</font><br>
}<br>
}<br>
<br>
Dla rozró¿nienia nale¿y u¿yæ s³owa this.<br>
Zapis <b>this.a</b> zawsze oznacza pole a obiektu inicjowanego przez konstruktor
lub tego na rzecz którego wywo³ano metodê. Zatem w powy¿szym kontek¶cie piszemy:<br>

<pre>
class Para {
  int a;
  int b;

  Para(int a, int b) {
    this.a = a;    // polu a obiektu przypisz warto¶æ parametru a
    this.b = b;    // polu b obiektu przypisz warto¶æ parametru b
  }

  void set(int a, int b) {
    this.a = a;
    this.b = b;
  }
}
</pre>

<p>
Wiêcej na temat przes³aniania identyfikatorów pod koniec wyk³adu.</p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="right">&nbsp;<A HREF="index61.html" TARGET="_top" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table></td>
</tr>
</table>
</body>
</html>
