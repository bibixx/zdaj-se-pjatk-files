<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
<style>
<!--
 li.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	margin-left:0cm; margin-right:0cm; margin-top:0cm}
-->
</style>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>

<td align="left"><A HREF="main07_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main07_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all">
<A NAME="EDU.wyklad.punkt 2"></A>
<br clear="all">

<div class="tytulpunktu">2. Drzewa binarnych poszukiwañ.</div> 

    <p>Niech v bêdzie wierzcho³kiem drzewa binarnego i niech LD(v) oznacza jego lewe poddrzewo  (tzn. drzewo, którego 
    korzeniem jest lewy syn wierzcho³ka v), a PD(v) - jego prawe poddrzewo.</p>





    <p><div class="def">
  <p style="text-align: justify">Definicja 2.1&nbsp; Niech &lt;Et, <span lang="en">
  <font face="Symbol">&pound;</font></span>&gt; bêdzie niepustym zbiorem etykiet, liniowo 
  uporz±dkowanym przez relacjê <span lang="en"><font face="Symbol">&pound;</font></span>. 
  Drzewem binarnych poszukiwañ nazywamy etykietowane drzewo binarne z 
  wyró¿nionym korzeniem D = &lt;V, E, et &gt; takie, ¿e et jest funkcj± 
  ró¿nowarto¶ciow±&nbsp; przyporz±dkowuj±c± wierzcho³kom drzewa etykiety w taki 
  sposób, ¿e dla dowolnego v <span lang="en"><font face="Symbol">Î</font></span>V,</p>
  <blockquote>
    <blockquote>
      <p>
  (1) je¶li x <span lang="en"><font face="Symbol">Î</font></span>LD(v), to et(x)
  <font face="Symbol"><span lang="en">&pound;</span> </font>et(v),<br>
  <br>
  (2) je¶li x <span lang="en"><font face="Symbol">Î</font></span>PD(v), to et(v)
  <font face="Symbol"><span lang="en">&pound;</span> </font>et(x).<br>

    </p>

    </blockquote>
  </blockquote>
</div></p>





    <p>Przyk³ad 2.1</p>





    <p>Drzewo binarne przedstawione na rysunku 7.1(a) jest etykietowanym drzewem 
    binarnym, ale nie jest drzewem binarnych poszukiwañ, poniewa¿ porz±dek 
    etykiet nie zosta³ zachowany. Drzewa na rysunku 7.3(a) i 7.3(b) s± drzewami 
    binarnych poszukiwañ. Dla ka¿dego wierzcho³ka, etykiety wierzcho³ków 
    nale¿±cych do&nbsp; lewego poddrzewa s± mniejsze, a etykiety wierzcho³ków 
    nale¿±cych do prawego poddrzewa s± wiêksze od etykiety tego 
    wierzcho³ka.</p>





    <table border="1" cellpadding="0" cellspacing="0" width="80%" id="AutoNumber1" bordercolorlight="#808080" bordercolordark="#808080">
      <tr>
        <td width="50%">
        <img border="0" src="Rysunki/Rysunek7_3a.gif" width="300" height="250"></td>
        <td width="50%">
        <img border="0" src="Rysunki/Rysunek7_3b.gif" width="300" height="250"></td>
      </tr>
</table>





    <p>&nbsp;<br>
    <b>Uwaga</b>. Zauwa¿my, ¿e warunki (1), (2) definicji 2.1 nie mog± byæ 
    zast±pione warunkiem</p>





    <p style="text-align: center">(*) dla dowolnego wierzcho³ka v, etykieta 
    lewego syna jest mniejsza, a etykieta prawego syna jest wiêksza ni¿ etykieta 
    wierzcho³ka v.</p>





    <p>Zamieniaj±c w drzewie 7.3(b) etykiety 8 i 9 miejscami, otrzymamy drzewo, 
    dla którego warunek (*) jest spe³niony, a które mimo to nie jest drzewem 
    binarnych poszukiwañ, bo nie spe³nia warunków (1) i (2) definicji 2.1. </p>





    <p>Drzewa BST, bêdziemy implementowali tak jak inne drzewa binarne, jako 
    obiekty klasy <i>node</i> (por. wyk³ad VI p4.). Dostêp do innych wierzcho³ków 
    bêdzie umo¿liwiony zawsze przez korzeñ drzewa i jego atrybuty left i right.&nbsp; 
    Warto¶ci funkcji etykietuj±cej bêd± zapamiêtane jako parametr val, tzn. 
    je¶li et(v) = e, to v.val = e.</p>





    <p>W dalszych punktach tego wyk³adu omówimy podstawowe operacje na drzewach 
    BST, których wykonanie prowadzi znów do drzew BST.&nbsp; Teraz zauwa¿my 
    tylko, ¿e, je¶li zbiór X jest reprezentowany przez drzewo BST, to wyszukanie 
    w tym zbiorze elementu najmniejszego lub najwiêkszego jest niezwykle proste. 
    Aby ustaliæ warto¶æ elementu najmniejszego musimy &quot;przej¶æ&quot; po lewej 
    skrajnej ga³êzi tego drzewa. Element na koñcu tej ¶cie¿ki jest elementem 
    najmniejszym. Element na koñcu skrajnej, prawej ¶cie¿ki jest elementem 
    najwiêkszym w X. Algorytmy znajdowania minimum i maksimum s± zamieszczone 
    poni¿ej.</p>





    <p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 680; height: 186">
   <TABLE frame="void" rules="none" width="670" height="158" bordercolorlight="#808080" bordercolordark="#FFFFFF" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="571" height="12" colspan="2">minBST(d : node) {</TD>
             
            <TD width="43" height="12">|</TD>
             
            <TD width="589" height="12"> maxBST(d : node) {</TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="512" height="12">v := d;</TD> 
            <TD width="43" height="12">|</TD> 
            <TD width="589" height="12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            v := d;</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="512" height="12"><strong>&nbsp;while&nbsp; </strong>(v.left
            <font face="Symbol"><span lang="en">&sup1;</span> </font>null) <strong>do</strong></TD> 
            <TD width="43" height="12">|</TD> 
            <TD width="589" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp; </strong>
            (v.right <font face="Symbol"><span lang="en">&sup1;</span> </font>null) <strong>do</strong></TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="512" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp; 
            v := v.left;</TD> 
            <TD width="43" height="12">|</TD> 
            <TD width="589" height="12"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v := v.right</TD> 
         </TR>
         <tr>
            <TD width="59" height="12"></TD>
            <TD width="512" height="12">   &nbsp;<b>od;</b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
            <TD width="43" height="12">   |</TD>
            <TD width="589" height="12">   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            od;</b></TD>
         </tr>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="512" height="12">   &nbsp;return v.val <STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="43" height="12">   |</TD>
            <TD width="589" height="12">   &nbsp;return v.val&nbsp; </TD>
         </TR>
         <TR>
            <TD width="59" height="1"><strong>}</strong></TD>
            <TD width="512" height="1">   <strong>&nbsp;&nbsp;&nbsp;</strong></TD>
            <TD width="43" height="1">   |</TD>
            <TD width="589" height="1">   </TD>
         </TR>
         </TABLE>
</div>





<p>Koszt wyszukiwania minimum i maksimum jest proporcjonalny do d³ugo¶ci 
przegl±danej ¶cie¿ki. Zatem dla drzewa o wysoko¶ci h wynosi O(h). Nie musimy wykonywaæ operacji porównywania 
elementów, a tylko instrukcje przypisania. Dla drzewa o n wierzcho³kach, w 
najgorszym razie wykonamy ich&nbsp; n, a w najlepszym tylko jedn±. Interesuj±cy jest 
te¿ koszt ¶redni, który wynosi O(lg n), ale o tym bêdzie mowa w dalszej czê¶ci wyk³adu.<p><b>
Pytanie 4</B>:&nbsp;
    Jaka jest minimalna i maksymalna liczba etykiet, które mog± byæ 
    przechowywane w drzewie BST o wysoko¶ci h?<br>
<FORM>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'min = h+1&nbsp;&nbsp; max = 2^(h+1)-1');">
</form>


<p><br clear="all">
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main07_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main07_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>