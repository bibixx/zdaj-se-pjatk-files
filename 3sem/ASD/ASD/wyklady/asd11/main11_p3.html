<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main11_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main11_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<br clear="all">
<br clear="all"><div class="tytulpunktu">
3. Konstrukcja drzewa kodowego Huffmana</div>

<p>Konstrukcjê optymalnego kodu prefiksowego zaproponowa³ David Huffman. W tym 
punkcie wyk³adu przedstawimy metodê budowy drzewa kodowego dla optymalnego kodu 
prefiksowego Huffmana.</p>

<p>Drzewo kodowe Huffmana jest drzewem binarnym, lokalnie pe³nym. W ka¿dym 
wierzcho³ku wewnêtrznym tego drzewa pamiêtamy sumê czêsto¶ci znaków 
wystêpuj±cych w poddrzewach tego wierzcho³ka.&nbsp; Ka¿dy wierzcho³ek drzewa 
bêdzie wiêc mia³, oprócz referencji do lewego i prawego poddrzewa, atrybut f, 
oznaczaj±cy czêsto¶æ wystêpowania znaku lub grupy znaków odpowiadaj±cych drzewu 
o korzeniu w tym wê¼le.&nbsp; W li¶ciach bêd± pamiêtane dodatkowo znaki 
kodowanego alfabetu. Do zapamiêtania alfabetu oraz wierzcho³ków tworzonego 
drzewa, algorytm Huffmana u¿ywa kolejki priorytetowej.</p>

<p><b>Szkic algorytmu</b></p>

<p>1. Utwórz kolejkê priorytetow± pq zawieraj±c± wêz³y tworzonego drzewa. 
Pocz±tkowo elementami kolejki s± li¶cie drzewa. Porz±dek elementów w kolejce 
priorytetowej zale¿y od czêsto¶ci przypisanej znakom.</p>

<p>2. Drzewo kodowe buduje siê od do³u, od li¶ci, które s± traktowane jako 
drzewa z jednym tylko wêz³em. W ka¿dym kroku algorytmu, zamiast kolejnych dwóch wierzcho³ków, których czêsto¶ci s± najmniejsze, 
wstawiamy do kolejki priorytetowej&nbsp; pq nowy wêze³, którego&nbsp; etykiet± jest suma 
czêsto¶ci przypisanych 
usuniêtym wêz³om.&nbsp; Punkt 2 powtarzamy, tak d³ugo, a¿ w kolejce priorytetowej 
pozostanie tylko jeden element. Bêdzie to korzeñ drzewa kodowego.</p>

<p>Algorytm Huffmana mo¿na zaimplementowaæ na wiele sposobów, które zale¿± od 
konkretnej implementacji kolejki priorytetowej. Jedn± z mo¿liwo¶ci, jest u¿ycie 
kopca zaimplementowanego w tablicy. Opracowanie szczegó³ów tego algorytmu 
pozostawiamy Czytelnikowi jako æwiczenie. Zwróæmy uwagê, ¿e algorytm Huffmana w 
pewnych przypadkach mo¿e dzia³aæ 
niejednoznacznie, w tym sensie, ¿e je¶li&nbsp; czêsto¶ci wystêpowania dwóch grup 
znaków s± takie same, to wybór kolejno¶ci odpowiadaj±cych im wêz³ów mo¿na 
ustaliæ dowolnie, gdy¿ nie ma on wp³ywu na d³ugo¶æ otrzymanego kodu, ale drzewa 
kodowe mog± siê ró¿niæ. </p>
<p>W przedstawionym poni¿ej algorytmie &quot;HuffmanKod&quot; zak³adamy, ¿e TAB jest 
tablic±,w której znajduj± siê znaki 
kodowanego alfabetu oraz ich czêsto¶ci wystêpowania w pewnym pliku.&nbsp; </p>
<p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 713; ">
   <TABLE frame="void" rules="none"  >
         <TR>
            <TD width="544" height="12" colspan="2">HuffmanKod(TAB : tablica){</TD>
             
            <TD width="634" height="12"> </TD>
             
         </TR>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">      //utwórz kolejkê priorytetow± z 
            elementów<br>
&nbsp;//danej tablicy TAB , uporz±dkowan± <br>
&nbsp;//ze wzglêdu na atrybut f &nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="634" height="12">      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </TD>
             
         </tr>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">      &nbsp;n := TAB.length;</TD>
             
            <TD width="634" height="12">      // n jest liczb± znaków alfabetu</TD>
             
         </tr>
         <TR>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12"><strong>for </strong>i :=1<strong> to&nbsp; </strong>(n-1) <strong>do&nbsp; </strong> </TD> 
            <TD width="634" height="12"></TD> 
         </TR>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v := new 
            node;</TD>
            <TD width="634" height="12">   </TD>
         </tr>
         <TR>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>v.left 
            := min(pq); pq := delmin(pq); </TD> 
            <TD width="634" height="12">// min(pq) wybiera wêze³ o najmniejszym 
            atrybucie f</TD> 
         </TR>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">   &nbsp;&nbsp;&nbsp;&nbsp; <strong>&nbsp;</strong>v.right 
            := min(pq); pq := delmin(pq); </TD>
            <TD width="634" height="12">   &nbsp;</TD>
         </tr>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.f := 
            v.left.f + v.right.f</TD>
            <TD width="634" height="12">   </TD>
         </tr>
         <tr>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pq := 
            insert(v,pq);</TD>
            <TD width="634" height="12">   //do³±czenie nowego wêz³a do kolejki 
            priorytetowej</TD>
         </tr>
         <TR>
            <TD width="56" height="12"></TD>
            <TD width="488" height="12">   <STRONG>od;</STRONG>&nbsp;&nbsp;&nbsp;&nbsp; <STRONG>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="634" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
         </TR>
         <TR>
            <TD width="56" height="1"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="488" height="1"></TD>
            <TD width="634" height="1"> &nbsp;</TD>
         </TR>
   </TABLE>
</div>

<p><b>Koszt algorytmu</b></P>

<p>Algorytm rozpoczynamy od utworzenia kolejki priorytetowej, której elementami 
s± li¶cie tworzonego drzewa kodowego. Koszt utworzenia tej kolejki, o ile 
zastosujemy algorytm konstrukcji kopca w tablicy, wynosi O(n), gdzie n jest 
liczb± znaków kodowanego alfabetu. W drugiej czê¶ci algorytmu konstruujemy 
drzewo. Zauwa¿my, ¿e po n-1 krokach, gdzie n jest liczb±&nbsp; znaków kodowanego 
alfabetu, kolejka zawiera tylko jeden wêze³. Rzeczywi¶cie, w ka¿dej iteracji, z 
kolejki s± wyjmowane dwa elementy i wstawiany jeden nowy wêze³. Oznacza to, ¿e po ka¿dej 
iteracji liczba elementów zmniejsza siê o jeden. Je¶li kolejka 
priorytetowa zosta³a zaimplementowana jako kopiec, to ka¿da z wykonywanych w 
pêtli operacji kosztuje O(lg n) porównañ. Wynika st±d, ¿e koszt wykonania pêtli 
&quot;for&quot; mo¿emy oszacowaæ z góry przez O(n <font face="Symbol"><span lang="en">´</span>
</font>lg n). Ostatecznie, koszt ca³ego algorytmu mo¿emy oszacowaæ przez O(n
<font face="Symbol"><span lang="en">´</span> </font>lg n).</P>

<p><b>Uwaga</b> Algorytm Huffmana jest algorytmem zach³annym w tym sensie, ¿e w 
ka¿dym kroku wybiera wêz³y o najmniejszej czêsto¶ci.</P>

<p>&nbsp;<div class="lemat">
  Twierdzenie 4.1&nbsp; Algorytm HuffmanKod buduje drzewo optymalnego kodu 
  prefiksowego.
</div>

<p><b>Przyk³ad 3.1</b></p>

<p>Przyjmijmy, ¿e w pewnym tek¶cie wystêpuj± tylko litery A, F, H, M, N, U, a 
ich czêsto¶ci wystêpowania w tysi±cach wynosz± odpowiednio:40,8,9,11,7,25. Kolejne fazy dzia³ania algorytmu Huffmana przedstawiono na rysunku 11.3.</p>

<table border="0" cellpadding="0" cellspacing="0" 
style="border-collapse: collapse" bordercolor="#111111" width="80%" id="AutoNumber1">
  <tr>
    <td width="48%">
    <img border="0" src="Rysunki/Rysunek11_3abbis.gif" width="280" height="250"></td>
	<td width="4%"></td>
    <td width="48%">
    <img border="0" src="Rysunki/Rysunek11_3cbis.gif" width="280" height="250"></td>
  </tr>
  <tr> <p></p></tr>
  <tr>
    <td width="48%">
    <img border="0" src="Rysunki/Rysunek11_3d.gif" width="280" height="250"></td>
	<td width="4%"></td>
    <td width="48%">
    <img border="0" src="Rysunki/Rysunek11_3ex.gif" width="280" height="250"></td>
  </tr>
</table>
<p>&nbsp;</p>


<p>Z otrzymanego drzewa kodowego ³atwo odczytujemy kody liter A - 0, F - 1101, H 
- 1110, M - 1111, N - 1100, U - 10 . Ci±g 11101011011101111101100 jest kodem s³owa 
HUFFMAN.</p>

<p><b>Pytanie 4:&nbsp; </b>Czy koszt algorytmu Huffmana zmieni siê, je¶li 
zamiast struktury kopca, u¿yjemy tablicy uporz±dkowanej za pomoc± optymalnego 
algorytmu sortowania, a wstawianie nowego wêz³a do tablicy zrealizujemy tak jak 
w algorytmie InsertionSort? <br>
&nbsp;</p>

<FORM>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'Tak');">
</p>
</form>
<p></p>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main11_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main11_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>