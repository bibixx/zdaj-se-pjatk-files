<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>

<td align="left"><A HREF="main11_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main11_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all">
<br clear="all">

<div class="tytulpunktu">2. Problem kodowania</div> 

    <p>Jednym z problemów, z którymi spotykamy siê w informatyce, jest problem 
    w³a¶ciwego wykorzystania pamiêci. Konstruuj±c algorytm staramy siê zwykle nie tylko o 
    zminimalizowanie kosztów czasowych algorytmu, ale tak¿e o&nbsp; dobr± z³o¿ono¶æ pamiêciow± 
    algorytmu. Ale co zrobiæ, je¶li to dane s± bardzo du¿e? Jak je przechowywaæ 
    w pamiêci komputera? I tu przychodz± nam z pomoc± techniki kompresji danych, 
    tzn. metody kodowania danych w takiej postaci, która pozwala zapisaæ ten sam 
    zbiór informacji wykorzystuj±c du¿o mniej miejsca. Oczywi¶cie, zale¿y nam 
    tylko na takich metodach, które pozwalaj± szybko zakodowaæ dane, oraz szybko 
    i jednoznacznie odkodowaæ zakodowan± informacjê.</p>





    <p><b>Przyk³ad 2.1</b></p>





    <p>Przypu¶æmy, ¿e pewien zbiór danych zawiera 10<sup><font face="Verdana">6</font></sup> 
    znaków. Je¶li ka¿dy z tych znaków jest reprezentowany przez liczbê z 
    przedzia³u 0-255, to&nbsp; na zapisanie jednego znaku musimy zu¿yæ 8 bitów 
    (256 = 2<sup><font face="Verdana">8</font></sup>). Wynika st±d, ¿e na 
    zapisanie ca³ego pliku zu¿yjemy 8 <font face="Symbol"><span lang="en">´</span>
    </font>10<sup><font face="Verdana">6</font></sup> bitów. Gdyby¶my jednak 
    mieli dodatkow± informacjê, np. ¿e w danych wystêpuj± jedynie cyfry od 0 do 
    9, to mogliby¶my na znak przeznaczyæ tylko 4 bity co pozwoli³oby zakodowaæ 
    ca³y zbiór na 4&nbsp;<font face="Symbol"><span lang="en">´</span> </font>10<sup><font face="Verdana">6</font></sup> 
    bitach. Przyporz±dkowanie znakom kodu mog³oby wygl±daæ np. tak:</p>





    <p style="text-align: center">0- 0000, 1- 0001, 2- 0010, 3- 0011 itd... 
    9-1001.</p>





    <p>Dekodowanie zakodowanego pliku jest, przy takim kodzie, banalnie proste: 
    odczytujemy kolejne cztery bity (s³owo kodowe) i w s³owniczku sprawdzamy 
    jaki to znak. Na przyk³ad, ci±g bitów 0010001100100011 jest kodem liczby 
    2323. Poniewa¿ s³ownik sk³ada siê tylko z dziesiêciu elementów, wiêc w 
    najgorszym razie odszukanie jednego znaku wymagaæ bêdzie porównania z 
    dziesiêcioma s³owami kodowymi. Nie musimy jednak przeszukiwaæ s³ownika 
    sekwencyjnie.&nbsp; Przedstawmy zbiór s³ów kodowych w postaci drzewa 
    binarnego (drzewa kodowego), w którego li¶ciach&nbsp; przechowywane s± kodowane znaki, a ka¿de 
    przej¶cie w lewo odpowiada bitowi 0, a przej¶cie w prawo- bitowi 1. W ten 
    sposób ka¿da ¶cie¿ka od korzenia do li¶cia odpowiada&nbsp; s³owu koduj±cemu 
    znak zapamiêtany w li¶ciu, por. rysunek 11.2.<font face="Wingdings">J</font></p>



<center>

    <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="40%" id="AutoNumber1">
      <tr>
        <td width="100%">
        <p align="center" style="text-align: center">
        <img border="0" src="Rysunki/Rysunek11_2bb.gif" width="300" height="250"></td>
      </tr>
</table> </center>
<br>
<div class="def">Definicja 2.1 Sposób kodowania, w którym na ka¿dy znak 
  przeznaczamy tak± sam± liczbê bitów nazywamy kodem sta³ej d³ugo¶ci.</div>





<p><b>Pytanie 2</B>: Ile bitów trzeba przeznaczyæ na zakodowanie tekstu 
z³o¿onego z 10<sup><font face="Verdana">7</font></sup> znaków, je¶li u¿yto kodu 
o sta³ej d³ugo¶ci, a tekst sk³ada siê tylko z liczb naturalnych oddzielonych 
przecinkami lub spacjami, oraz z liter x, y, z?</p>

<FORM>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'Do zakodowania znaków tego tekstu wystarcz± cztery bity. Czyli razem potrzeba 4*10^7 bitów.');">
</p>
</form>
<p></p>





<p>Zauwa¿my, ¿e w przyk³adzie 2.1 niektóre li¶cie drzewa kodowego 
nigdy nie bêd± potrzebne, bo ci±g bitów prowadz±cy do nich, nigdy nie wyst±pi w 
zakodowanym tek¶cie. Na przyk³ad ci±g 1111 nie jest kodem ¿adnego ze znaków&nbsp; 
tego tekstu, wiêc nie wyst±pi w zakodowanym tek¶cie. Co wiêcej, gdyby cyfry 9 i 
8 wystêpowa³y w tek¶cie tylko niewielk± liczbê razy, to i tak do ich zakodowania 
u¿yjemy a¿ 4 bitów. Czy to nie jest marnotrawstwo?&nbsp; A mo¿e zrezygnowaæ ze 
sta³ej d³ugo¶ci kodu i d³ugo¶æ kodu uzale¿niæ od czêsto¶ci wystêpowania tego 
znaku w kodowanym tek¶cie. Zasada jest prosta: znakom, które wystêpuj± czêsto 
przypisujemy krótkie kody. Wynika st±d, ¿e kody bêd± mia³ ró¿ne d³ugo¶ci.<p>&nbsp;<p><div class="def">
  Definicja 2.2 Sposób kodowania, w którym znakom przypisujemy ró¿ne d³ugo¶ci 
  nazywamy kodem zmiennej d³ugo¶ci.</div>
<p></p>





<p><b>Przyk³ad 2.2</b><p>Niech w danym pliku,&nbsp; cyfry 0 i 1&nbsp; wystêpuj± 
3
<span lang="en"><font face="Symbol">´</font></span>10<sup><font face="Verdana">6</font></sup> 
razy, a pozosta³e cyfry jedynie po 5<span lang="en"><font face="Symbol">´</font></span>10<sup><font face="Verdana">5</font></sup> 
razy. Wtedy plik zawieraj±cy  10<sup><font face="Verdana">7</font></sup> znaków mo¿na 
zakodowaæ u¿ywaj±c tylko&nbsp; 8<span lang="en"><font face="Symbol">´</font></span>10<sup><font face="Verdana">6</font></sup>&nbsp; 
bitów, stosuj±c kod 00 dla cyfry 0, 01 dla cyfry 1 oraz czterobitowe kody dla 
cyfr 2, 3, ..., 8, 9.<p>Liczba bitów potrzebna do zakodowania tekstu, dla którego znamy czêsto¶ci 
wystêpowania znaków  , wynosi





<p style="text-align: center"> <font face="Symbol" size="3">S</font><sub>a<font face="Symbol" size="3"><span lang="en">Î</span>A</font></sub> 
f(a) <font face="Symbol">
<span lang="en">´</span> </font>dT(a), 





<p>gdzie f(a) jest czêsto¶ci± wystêpowania 
znaku a, a dT(a) jest d³ugo¶ci± kodu dla znaku a.<p>Problem, który siê teraz 
pojawia, to jak zbudowaæ  kod  uzale¿niaj±cy d³ugo¶æ kodu od czêsto¶ci 
wystêpowania znaków, w taki sposób, by mo¿na go by³o jednoznacznie odczytaæ 
(dekodowaæ). Warunek ten 
spe³niaj± kody prefiksowe.<p>&nbsp;<p><div class="def">Definicja 2.3 Kod 
  posiadaj±cy w³asno¶æ, ¿e ¿adne s³owo kodowe nie jest prefiksem ¿adnego innego 
  s³owa kodowego, nazywa siê kodem prefiksowym, dok³adniej nie istniej± dwa 
  s³owa kodowe, ¿e&nbsp; a=(a<sub><font face="Verdana">1</font></sub>,...,a<sub><font face="Verdana">n</font></sub> 
  ) i b= (b<sub><font face="Verdana">1</font></sub>,..., b<sub><font face="Verdana">m</font></sub>) 
  takie ¿e n&lt;m oraz a<sub><font face="Verdana">1</font></sub>=b<sub><font face="Verdana">1</font></sub>, 
  a<sub><font face="Verdana">2</font></sub>=b<sub><font face="Verdana">2</font></sub>,..., 
  a<sub><font face="Verdana">n</font></sub>=b<sub><font face="Verdana">n</font></sub>.</div>
<p></p>





<p>Kody prefiksowe s± bardzo wygodne, gdy¿ dekodowanie jest niezwykle proste: 
odczytujemy pierwsze s³owo kodowe znajduj±ce siê na pocz±tku zakodowanego tekstu 
i usuwamy go. Poniewa¿ ¿adne s³owo kodowe nie jest prefiksem innego s³owa, wiêc 
to pierwsze s³owo jest jednoznacznie wyznaczone. Po jego usuniêciu postêpowanie 
mo¿emy powtórzyæ.&nbsp; Identyfikacjê s³owa znakomicie upraszcza reprezentacja 
kodu w postaci drzewa binarnego (drzewa kodowego), por. przyk³ad 2.1. <p>&nbsp;<div class="lemat">
  Twierdzenie 1.1&nbsp; Je¶li istnieje optymalne kodowanie, to zawsze mo¿na 
  znale¼æ kod prefiksowy, który go realizuje.
</div>
<p><b>Uwaga</b> Optymalny kod jest zawsze reprezentowany przez lokalnie pe³ne 
drzewo binarne, por. wyk³ad V, definicja 1.1. Zatem, je¶li dany jest alfabet A, 
to drzewo optymalnego kodu ma |A| li¶ci oraz dok³adnie |A|-1 wierzcho³ków 
wewnêtrznych.<p><b>Pytanie 3: </b>Ile bitów wymaga kod sta³ej d³ugo¶ci, a ile kod zmiennej 
d³ugo¶ci, dla zakodowania tekstu z³o¿onego z 1000 znaków, w którym wystêpuje 8 ró¿nych znaków, a ka¿dy z tak± sam± czêsto¶ci±?&nbsp; 
<br>
&nbsp;<FORM>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'3000 bitów w obu przypadkach.');">
</form>
</p>


<p><br clear="all">
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main11_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main11_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>