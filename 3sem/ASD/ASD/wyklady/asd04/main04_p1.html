<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
<td align="left"><A HREF="main04_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main04_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
    </tr>
</table>

<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">1. Sortowanie przez wybór</div> 

    <p>Problem sortowania mo¿emy zdefiniowaæ nastêpuj±co: Dany jest skoñczony ci±g&nbsp; 
    e<sub><font face="Verdana">1</font></sub>, ..., e<sub><font face="Verdana">n</font></sub> 
    elementów pewnego zbioru&nbsp;&nbsp; liniowo 
    uporz±dkowanego (E,<font face="Symbol"> <span lang="en">&pound;</span></font>). Znale¼æ tak± permutacjê&nbsp; i<sub><font face="Verdana">1</font></sub>, 
    ..., i<sub><font face="Verdana">n</font></sub> liczb  1,..., n, ¿e e<sub><font face="Verdana">i1</font></sub> 
    <font face="Symbol"><span lang="en">&pound;</span></font> ... 
    <font face="Symbol"><span lang="en">&pound;</span> </font>e<sub><font face="Verdana">in</font></sub>.&nbsp; </P>

    <p><b>Przyk³ad 1.1</b></P>

    <p>Je¿eli elementami ci±gu e s± liczby&nbsp; 6,2,8,9,1, to szukan± 
    permutacj± jest&nbsp; 5,2,1,3,4. Rzeczywi¶cie, pi±ty element jest najmniejszym 
    elementem tego ci±gu, a czwarty jest elementem najwiêkszym. Ustawiaj±c 
    elementy w kolejno¶ci: najpierw pi±ty, potem drugi, pierwszy, trzeci i 
    czwarty, ustawimy wszystkie elementy danego ci±gu w porz±dku niemalej±cym.<FONT FACE="Wingdings"> &#74;</FONT> </P>

    <p>W tym i w nastêpnych punktach tego wyk³adu, bêdziemy poszukiwaæ takich 
    algorytmów rozwi±zywania problemu sortowania, które u¿ywaj± tylko operacji 
    porównywania elementów (mówimy, ¿e sortuj± w modelu drzew decyzyjnych (por. 
    wyk³ad II, p.5). We wszystkich przedstawionych&nbsp; algorytmach zak³adaæ 
    bêdziemy, ¿e ci±g jest reprezentowany przez tablicê e o elementach e[1],..., e[n].&nbsp; 
    Ponadto, zamiast szukaæ odpowiedniej permutacji indeksów ci±gu, bêdziemy 
    dokonywaæ bezpo¶redniej permutacji elementów, tak by po zakoñczeniu 
    algorytmu, zawarto¶ci± tablicy e by³ ci±g uporz±dkowany niemalej±co.</P>

    <p>Specyfikacjê zadania sortowania ci±gu e<sub><font face="Verdana">1</font></sub>, ..., 
    e<sub><font face="Verdana">n</font></sub>&nbsp; scharakteryzujemy 
    nastêpuj±cymi warunkami:</P>

    <p style="text-align: center">wp = {n &gt; 0, e[1] = e<sub><font face="Verdana">1</font></sub>, 
    ..., e[n] = e<sub><font face="Verdana">n</font></sub> }, </P>

    <p style="text-align: center">wk = {e[1] <font face="Symbol"><span lang="en">&pound;</span> </font>e<font face="Symbol">[2]&nbsp;  <span lang="en">&pound;</span> ...&nbsp;  <span lang="en">&pound;</span> </font>e[n] 
    oraz istnieje taka permutacja&nbsp; i<sub><font face="Verdana">1</font></sub>, 
    ..., i<sub><font face="Verdana">n</font></sub> liczb 1,..., n,e[1] = e<sub><font face="Verdana">i1</font></sub>, 
    e[n]= e<sub><font face="Verdana">in</font></sub> }.</P>

    <p>Warunek pocz±tkowy stwierdza tylko, ¿e&nbsp; ci±g, który chcemy posortowaæ 
jest niepusty, a jego elementy zosta³y umieszczone w tablicy e. Warunek koñcowy natomiast 
stwierdza, ¿e warto¶ci tablicy e (po wykonaniu algorytmu) tworz± ci±g uporz±dkowany niemalej±co i&nbsp; 
warto¶ci te s± permutacj± elementów danego ci±gu&nbsp; e<sub><font face="Verdana">1</font></sub>, ..., 
    e<sub><font face="Verdana">n</font></sub>.</P>
<p>Najprostszym algorytmem sortowania jest algorytm sortowania przez wybór 
(inaczej &quot;przez selekcjê&quot;). Wymaga on wielokrotnego wyszukiwania elementu 
minimalnego. Aby nie powtarzaæ kodów ju¿ omówionych algorytmów, za³o¿ymy, ¿e 
min(e,i,j) jest optymalnym algorytmem, który dla dowolnej tablicy e i dowolnych 
liczb i, j <font face="Symbol"><span lang="en">&pound;</span> </font>n, znajduje 
pozycjê najmniejszego elementu w ci±gu e[i], e[i+1], ... , e[j], a swap(e[i], 
e[j]) jest procedur±, która dokonuje zamiany miejscami elementów i-tego i j-tego 
tablicy e.</p>
<p><b>Idea algorytmu </b></p>
<p>Idea tego algorytmu polega na sukcesywnym wybieraniu 
elementu najmniejszego z tych, które znajduj± siê w jeszcze nieuporz±dkowanej 
czê¶ci tablicy. Dok³adniej, sortowanie odbywaæ siê bêdzie w n-1 etapach. W i-tym 
etapie i-1 pierwszych pozycji tworzy ju¿ ci±g uporz±dkowany. Znajdujemy pozycjê, na której znajduje siê element najmniejszy w¶ród 
elementów e[i],...,e[n], a nastêpnie umieszczamy go na i-tej pozycji w tablicy, 
rozszerzaj±c w ten sposób ju¿ uporz±dkowany fragment.&nbsp; </p>
<p><b>Przyk³ad 1.2</b></p>
  <p>Niech dany ci±g sk³ada siê z liczb ca³kowitych, 4,2,6,1,7,5. Kolejne stany 
  tablicy e w trakcie wykonywania algorytmu s± nastêpuj±ce:</p>
  <p style="text-align: center"><b>1</b>,2,6,<b>4</b>,7,5&nbsp;&nbsp;&nbsp; 1,<b>2</b>,6,4,7,5&nbsp;&nbsp;&nbsp; 1,2,<b>4</b>,<b>6</b>,7,5&nbsp;&nbsp;&nbsp; 
  1,2,4,<b>5</b>,7,<b>6</b>&nbsp;&nbsp;&nbsp; 1,2,4,5,<b>6</b>,<b>7</b></p>
  <p>Elementy, które zamieni³y siê miejscami zosta³y zaznaczone t³ust± czcionk±.<FONT FACE="Wingdings"> &#74;</FONT> </p>
<p>Algorytm sortowania przez wybór zapiszemy w postaci&nbsp; procedury 
SelectionSort z jednym parametrem formalnym typu &quot;ci±g&quot;. Zak³adamy, ¿e obiekty 
tego abstrakcyjnego typu&nbsp; maj± okre¶lony atrybut lenght, który mówi o 
liczbie elementów ci±gu.</p>
<p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 750; height: 225">
   <TABLE frame="void" rules="none" width="720" height="204">
         <TR>
            <TD width="398" height="12" colspan="2">SelectionSort (e : ci±g){</TD>
             
            <TD width="30" height="12"></TD>
             
            <TD width="825" height="12"> </TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12"><strong>&nbsp;</strong>i := 1;&nbsp; n 
            := e.length;</TD> 
            <TD width="30" height="12"></TD> 
            <TD width="825" height="12"></TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12"><strong>&nbsp;while&nbsp; </strong>(i
            <font face="Symbol">&lt;</font> n) <strong>do </strong> </TD> 
            <TD width="30" height="12"></TD> 
            <TD width="825" height="12">// e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-1], i<font face="Symbol"> <span lang="en">&pound;</span> </font>
            n oraz e[i-1] <font face="Symbol"> <span lang="en">&pound;</span> </font>
            {e[i],...,e[n]}</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>j := min(e, i, n);&nbsp;</TD> 
            <TD width="30" height="12"></TD> 
            <TD width="825" height="12">// j jest pozycj± elementu najmniejszego 
            w¶ród e[i],...,e[n]</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            swap(e[j], e[i]);<STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="30" height="12">   </TD>
            <TD width="825" height="12">   //   e[1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i-1]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i]&nbsp; oraz e[i] <font face="Symbol"> <span lang="en">&pound;</span> </font>
            {e[i+1],...,e[n]}</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i 
            := i + 1;</TD>
            <TD width="30" height="12">   </TD>
            <TD width="825" height="12">   //   e[1]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            ... <font face="Symbol"> <span lang="en">&pound;</span> </font>e[i-1]&nbsp; 
            oraz e[i-1] <font face="Symbol"> <span lang="en">&pound;</span> </font>
            {e[i],...,e[n]}</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="339" height="12">   &nbsp;<STRONG>od;</STRONG></TD>
            <TD width="30" height="12">   </TD>
            <TD width="825" height="12">   // e[1]<font face="Symbol"> <span lang="en">
            &pound;</span></font> ... <font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i-1],&nbsp; i = n oraz e[i-1] <font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[n]</TD>
         </TR>
         <TR>
            <TD width="59" height="1"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="339" height="1"></TD>
            <TD width="30" height="1"></TD>
            <TD width="825" height="1"> </TD>
         </TR>
   </TABLE>
</div>

<p style="text-align: left">&nbsp;</P>

<p style="text-align: left"><b>Analiza poprawno¶ci</b>. Na rysunku 4_1 
przedstawili¶my sytuacjê w naszym ci±gu na pocz±tku i-tej iteracji:</P>

<p style="text-align: center">
<img border="0" src="Rysunki/Rysunek4_1.gif" width="405" height="168"></P>

<p style="text-align: left">Uzasadnienie poprawno¶ci tego algorytmu jest 
bardzo proste. Niech przy wej¶ciu do pêtli bêd± spe³nione w³asno¶ci</P>

<p style="text-align: center">&nbsp;i<font face="Symbol"> &lt; </font>n+1,&nbsp; e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
e[i-1],&nbsp; e[i-1] <font face="Symbol"> <span lang="en">&pound;</span> </font>
e[k] dla wszystkich k, takich ¿e&nbsp; i<font face="Symbol"> <span lang="en">&pound;</span> </font>
k<font face="Symbol"> <span lang="en">&pound;</span> </font>n.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(*)</P>

<p style="text-align: left">Dodatkowo wiemy, ¿e spe³niony jest test (i &lt; n), 
tzn. i+1&lt; n+1.&nbsp; Po wykonaniu instrukcji&nbsp; &quot;j := min(e,i,n);&quot;&nbsp; nie 
zmieni³a siê warto¶æ ¿adnego parametru z wyj±tkiem j, dla którego (na mocy 
za³o¿enia o poprawno¶ci algorytmu min) e[j] <font face="Symbol"> <span lang="en">&pound;</span> </font>
e[k] dla i<font face="Symbol"> <span lang="en">&pound;</span> </font>k<font face="Symbol"><span lang="en">&pound;</span> </font>
n. Po wykonaniu zamiany pozycji itej i jtej (swap(e[j],e[i])), wiemy, ¿e</P>

<p style="text-align: center">i+1 &lt; n+1 oraz e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
e[i],&nbsp; e[i] <font face="Symbol"> <span lang="en">&pound;</span> </font>e[k] 
dla wszystkich k, takich ¿e&nbsp; i<font face="Symbol"> <span lang="en">&pound;</span> </font>
k<font face="Symbol"><span lang="en">&pound;</span> </font>n.</P>

<p style="text-align: left">Wykonanie instrukcji &quot;i := i+1&quot;, spowoduje, ¿e znów 
prawdziwa bêdzie formu³a (*). Zatem znale¼li¶my niezmiennik pêtli. Poniewa¿ 
przed pierwszym wej¶ciem do pêtli, w³asno¶ci (*) s± trywialnie spe³nione, wiêc, 
gdy po n-1 krokach, nie bêdzie ju¿ spe³niony warunek i&lt;n, znów spe³nione bêd± 
warunki (*).&nbsp; Co wiêcej, warto¶ci± zmiennej i jest wtedy n, czyli </P>

<p style="text-align: center">e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
e[n-1] oraz e[n-1] <font face="Symbol"> <span lang="en">&pound;</span> </font>
e[n].</P>

<p style="text-align: left">Ponadto, dla ka¿dego i istnieje dok³adnie jedna 
liczba naturalna j niewiêksza od n, dla której e[i] = e <sub>
<font face="Verdana">j</font></sub>&nbsp;&nbsp; algorutmu.(jest to pozycja, na 
której znale¼li¶my element minimalny w i-tym kroku. To dowodzi ca³kowitej poprawno¶ci algorytmu SelectionSort wzglêdem przyjêtej specyfikacji. </P>

<p style="text-align: left">Zauwa¿my jeszcze, ¿e ¿adne szczególne cechy 
struktury danych nie by³y tu wykorzystywane, poza za³o¿eniem, ¿e relacja <font face="Symbol"> <span lang="en">&pound;</span></font> 
jest porz±dkiem liniowym. Zatem prawdziwe jest twierdzenie:</P>

<p></P>

<div class="twier">
<p>Twierdzenie 1.1&nbsp;&nbsp; Dla dowolnego niepustego ci±gu, o elementach nale¿±cych do 
dowolnej struktury danych, w której jest okre¶lony liniowy porz±dek, algorytm SelectioSort&nbsp; zatrzymuje siê, a otrzymany wynik spe³nia warunek koñcowy </P>
<p style="text-align: center">wk ={e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
e[n-1]<font face="Symbol"><span lang="en">&pound;</span> </font>
e[n]}.</P>
</div>

<p></P>
<DIR>
<DIR>

<p></P></DIR>
</DIR>

<p style="text-align: left"><b>Analiza kosztu:</b> Koszt tego algorytmu mierzymy 
liczb± wykonanych porównañ. S± one wykonywane w tre¶ci funkcji min. Poniewa¿ i 
zmienia siê od 1 do n-1, zatem w kolejnych iteracjach szukamy minimum w coraz 
krótszych fragmentach ci±gu. Zgodnie z przeprowadzon± wcze¶niej dyskusj± kosztu 
algorytmu min, wyszukanie pozycji, na której znajduje siê element minimalny w ci±gu n-(i-1) elementowym 
wymaga dok³adnie&nbsp; n-i porównañ. Liczba wykonanych porównañ jest sum± 
kolejnych liczb naturalnych od n-1 do 1.</P>

<p style="text-align: center">T(SelectionSort, n) = (n-1) + (n-2) + ... + 2 +1 = 
n(n-1)/2</p>
<p>Funkcja ta jest niestety kwadratowa, asymptotycznie d±¿y do nieskoñczono¶ci 
tak jak funkcja n<sup><font face="Verdana">2</font></sup>.</p>
<p>Du¿o lepiej wypadnie koszt&nbsp; je¶li mierzyæ go bêdziemy liczb± wykonanych 
operacji &quot;swap&quot;.&nbsp; Poniewa¿ w ka¿dej iteracji pêtli &quot;while (i&lt;n)&quot; wykonujemy 
tylko jedn± tak± operacjê, zatem wykonamy ich ³±cznie n-1. Koszt mierzony liczb± 
operacji swap jest wiêc liniowy.</p>
<p>Zauwa¿my jeszcze, ¿e liczba wykonanych porównañ nie zale¿y ani od warto¶ci 
elementów, ani od kolejno¶ci w jakiej elementy wystêpuj± w danym ci±gu. </p>
<p>Algorytm sortowania przez wybór sortuje w miejscu, tzn. wykorzystuje tylko 
pamiêæ konieczn± do przechowywania danych i kilka zmiennych pomocniczych. Jego 
koszt pamiêciowy jest wiêc liniowy w stosunku do rozmiaru danych, S(SelectionSort,n) = <font face="Symbol">Q</font>(n)</p>
<p><b>Pytanie 1</B>:&nbsp; W pewnej implementacji algorytmu SelectionSort, 
wszystkie wykonywane porównania zosta³y zilustrowane graficznie. Porównywane 
elementy s± przez 30 milisekund wy¶wietlane na ekranie, innym, ni¿ pozosta³e 
elementy ci±gu, kolorem.&nbsp; Ile czasu zajmie nam ogl±danie wykonania tego 
algorytmu dla n=200?  </p>

<!-- Odpowied¼: Ok 10 minut</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'Oko³o 10 minut.')">
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main04_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main04_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>