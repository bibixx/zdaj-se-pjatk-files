<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>

<td align="left"><A HREF="main04_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main04_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all">
<A NAME="EDU.wyklad.punkt 2"></A>
<br clear="all">

<div class="tytulpunktu">2. Sortowanie przez wstawianie</div> 

    <p><b>Idea</b> tego algorytmu polega na sukcesywnym wstawianiu kolejnych 
elementów na w³a¶ciw± pozycjê w ju¿ uporz±dkowanym fragmencie ci±gu.&nbsp; Dok³adniej, sortowanie odbywaæ siê bêdzie w n-1 etapach. W i-tym 
etapie zapamiêtujemy i-ty element i porównujemy go z elementami poprzedzaj±cymi. 
    W przypadku, gdy s± one wiêksze ni¿ i-ty, zostan± przesuniête o jedno 
    miejsce w prawo zwalniaj±c w ten sposób zajmowan± pozycjê i robi±c ew. 
    miejsce&nbsp; dla elementu i-tego. Zauwa¿my, ¿e w wyniku przesuniêæ nie 
    &quot;zgubili¶my, ¿adnego elementu, bo element i-ty zosta³ na pocz±tku 
    zapamiêtany na zmiennej pomocniczej pom. W ten sposób zwolni³a siê pozycja 
    i-ta i mogli¶my na niej umie¶ciæ element z pozycji s±siedniej, itd. Przesuniêcia w prawo kontynuujemy tak 
    d³ugo, a¿ znajdziemy element, który jest&nbsp; mniejszy b±d¼ równy 
    elementowi i-temu i wówczas wpisujemy element zapamiêtany na woln± pozycjê z 
    jego prawej&nbsp; strony (por. Rysunek 4.2).  

    <p style="text-align: center">
    <img border="0" src="Rysunki/Rysunek4_2.gif" width="600" height="200"><p>
Algorytm realizuj±cy opisan± wy¿ej ideê nosi nazwê sortowania przez wstawianie (InsertionSort). Zauwa¿my, ¿e strategia 
    postêpowania&nbsp; jest w tym algorytmie inna ni¿ w algorytmie SelectionSort. Tam nigdy nie 
    wracali¶my do elementów, które wcze¶niej zosta³y wybrane. Natomiast 
    wielokrotnie przegl±dali¶my elementy, które tworzy³y blok elementów jeszcze 
    nieuporz±dkowanych. Tu odwrotnie. Z segmentu nieuporz±dkowanego bierzemy po 
    jednym elemencie i wstawiamy go na w³a¶ciw± pozycjê w segmencie 
    uporz±dkowanym &quot;przepychaj±c&quot;, je¶li trzeba, elementy wiêksze, ju¿ 
uporz±dkowane, o jedn± 
    pozycjê w prawo.<p>Algorytm mo¿emy zapisaæ w nastêpuj±cej postaci:<p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 820; height: 261">
   <TABLE frame="void" rules="none" width="782" height="227">
         <TR>
            <TD width="515" height="12" colspan="2">InsertionSort (e : ci±g){</TD>
             
            <TD width="30" height="12"></TD>
             
            <TD width="770" height="12"> </TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12"><strong>&nbsp;</strong>i := 2; n := 
            e.length;</TD> 
            <TD width="30" height="12"></TD> 
            <TD width="770" height="12"></TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12"><strong>&nbsp;while&nbsp; </strong>(i <font face="Symbol"> <span lang="en">&pound;</span></font>
            n) <strong>do </strong> </TD> 
            <TD width="30" height="12"></TD> 
            <TD width="770" height="12">// e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-1], i<font face="Symbol"> <span lang="en">&pound;</span> </font>
            n+1&nbsp; oraz i<font face="Symbol">&nbsp; <span lang="en">&pound;</span> </font>n</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>j := i; pom := e[i];&nbsp;</TD> 
            <TD width="30" height="12"></TD> 
            <TD width="770" height="12">// e[i] = pom</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            <b>while</b> (j&gt;1 and e[j-1]&gt;pom) <b>do</b><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //   pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]&nbsp; 
            oraz e[j-1]&gt;pom</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>e[j] := e[j-1];</TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   // pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            j := j - 1;</TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //   pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]&nbsp;&nbsp; </TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   &nbsp;<STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; od;</STRONG></TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   //&nbsp; e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j-1]&nbsp;<font face="Symbol"><span lang="en">&pound;</span></font>
            
            pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e[j] 
            := pom;</TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   // e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-1]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i]</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i := 
            i+1;</TD>
            <TD width="30" height="12">   </TD>
            <TD width="770" height="12">   &nbsp;// e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-2]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i-1],&nbsp; i<font face="Symbol"> <span lang="en">&pound;</span> </font>
            n+1</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="456" height="12">      &nbsp;<strong>od</strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="30" height="12">      </TD>
             
            <TD width="770" height="12">      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      </TD>
             
         </TR>
         <TR>
            <TD width="59" height="1"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="456" height="1"></TD>
            <TD width="30" height="1"></TD>
            <TD width="770" height="1"> &nbsp; // e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-2]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i-1]&nbsp; oraz i=n+1</TD>
         </TR>
   </TABLE>
</div>

<p style="text-align: left"><b>Analiza poprawno¶ci</b></P>

<p>Niech&nbsp; e<sub><font face="Verdana">1</font></sub>, ..., e<sub><font face="Verdana">n </font></sub>
bêdzie ci±giem,&nbsp; którego elementy stanowi± pocz±tkowe warto¶ci tablicy e 
oraz n&gt;0, czyli spe³niony jest warunek pocz±tkowy specyfikacji algorytmów 
sortowania. Mamy wykazaæ, ¿e po wykonaniu algorytmu spe³niony bêdzie tak¿e 
warunek koñcowy</P>

<p style="text-align: center">wk = {e[1] <font face="Symbol"><span lang="en">&pound;</span> </font>e<font face="Symbol">[2]&nbsp;  <span lang="en">&pound;</span> ...&nbsp;  <span lang="en">&pound;</span> </font>e[n] 
    oraz istnieje taka permutacja&nbsp; i<sub><font face="Verdana">1</font></sub>, 
    ..., i<sub><font face="Verdana">n</font></sub> liczb 1,..., n, e[1] = e<sub><font face="Verdana">i1</font></sub>, 
    e[n]= e<sub><font face="Verdana">in</font></sub> }.</P>

<p>Rozwa¿ymy najpierw pêtlê wewnêtrzn±. Za³ó¿my, ¿e wszystkie elementy od 
pozycji 1 a¿ do pozycji i-1 zosta³y ju¿ uporz±dkowane i wchodzimy do pêtli 
wewnêtrznej &quot;while&quot; wiedz±c, ¿e wszystkie elementy na pozycjach od&nbsp; 
j+1,..., i s± wiêksze od elementu pom. Przed pierwszym wej¶ciem do 
pêtli wewnêtrznej tak w³a¶nie jest, bo j=i. Je¶li warunek pêtli wewnêtrznej jest spe³niony, to prawdziwe 
s± w³asno¶ci:</P>

<p style="text-align: center">pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]&nbsp; 
oraz e[j-1]&gt;pom oraz j&gt;1.</P>

<p style="text-align: left">Zatem przesuwaj±c na pozycjê j-t± element e[j-1], 
otrzymamy pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j] <font face="Symbol"> <span lang="en">&pound;</span> </font>e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]. 
Po wykonaniu przypisania &quot;j:= j-1;&quot;, ponownie prawdziwa jest w³asno¶æ </P>

<p style="text-align: center">pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i].</P>

<p>Ta ostatnia formu³a jest wiêc niezmiennikiem pêtli &quot;while <strong>&nbsp;</strong>(i <font face="Symbol"> <span lang="en">&pound;</span></font>
            n) &quot;. Na mocy twierdzenia o niezmiennikach (por. wyk³ad I, p.4), po 
wykonaniu pêtli wewnêtrznej spe³niony jest niezmiennik oraz, albo j=1, albo 
e[j-1]<font face="Symbol"><span lang="en">&pound;</span> </font>
            pom. Poniewa¿ ¿adna z pozycji e[1] do e[j-1] nie zosta³a w tej pêtli 
zmieniona, zatem, korzystaj±c z za³o¿enia i z niezmiennika mo¿emy w obu 
przypadkach stwierdziæ, ¿e prawdziwa jest formu³a</P>

<p style="text-align: center">e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j-1]&nbsp;<font face="Symbol"><span lang="en">&pound;</span></font>
            
            pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i]. </P>

<p>Zauwa¿my jeszcze, ¿e aktualne warto¶ci e[1],...,e[j-1], pom, e[j+1],...,e[i] 
s± permutacj± oryginalnych warto¶ci danego ci±gu&nbsp; e<sub><font face="Verdana">1</font></sub>, ..., e<sub><font face="Verdana">i</font></sub>.</p>

<p>&nbsp;Zajmijmy siê teraz pêtl± zewnêtrzn±. Tu niezmiennikiem jest formu³a</p>
<p style="text-align: center">e[1]<span lang="en"><font face="Symbol">&pound;</font></span>...<span lang="en"><font face="Symbol">&pound;</font></span>e[i-1]
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>&nbsp;i<font face="Symbol"> <span lang="en">&pound;</span> </font>
            n+1. (*)</p>
<p>Je¶li w kolejnej iteracji pêtli zewnêtrznej spe³niony jest warunek pêtli <strong>&nbsp;</strong>(i <font face="Symbol"> <span lang="en">&pound;</span></font>
            n) oraz formu³a (*), to na mocy poprzednich rozwa¿añ, po wykonaniu 
pêtli wewnêtrznej mamy e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j-1]&nbsp;<font face="Symbol"><span lang="en">&pound;</span></font>
            
            pom <font face="Symbol"><span lang="en">&pound;</span> </font>
            e[j+1]<font face="Symbol"> <span lang="en">&pound;</span> </font>...<font face="Symbol"> <span lang="en">&pound;</span> </font>e[i].&nbsp; 
Wstawiaj±c na miejsce j-te zapamiêtany wcze¶niej na zmiennej pom element e[i], 
otrzymujemy&nbsp; e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-1]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            e[i].&nbsp; Ponadto nadal (i <font face="Symbol"> <span lang="en">&pound;</span></font>
            n). Po zmianie warto¶ci i, mamy e[1]<font face="Symbol"> <span lang="en">&pound;</span></font>...<font face="Symbol"><span lang="en">&pound;</span> </font>
            e[i-1]<font face="Symbol"> </font>
            &nbsp;<font face="Symbol"><span lang="en">&Ugrave;</span> </font>&nbsp;i<font face="Symbol"> <span lang="en">&pound;</span> </font>
            n+1.</p>

<p>Poniewa¿ formu³a (*) jest prawdziwa trywialnie przy pierwszym wej¶ciu i w 
ka¿dej iteracji pêtli zewnêtrznej, to jest równie¿ prawdziwa w chwili wyj¶cia. 
Zewnêtrzna pêtla zakoñczy siê, gdy i &gt;n, co ³±cznie z formu³± (*) daje e[1]<span lang="en"><font face="Symbol">&pound;</font></span>...<span lang="en"><font face="Symbol">&pound;</font></span>e[n]. 
Poniewa¿ w i-tym kroku, warto¶ci pierwszych i elementów stanowi± permutacjê 
pierwszych i elementów danego ci±gu e<sub><font face="Verdana">1</font></sub>, ..., e<sub><font face="Verdana">i</font></sub>, 
zatem po zakoñczeniu pêtli zewnêtrznej elementy tablicy e s± permutacj± 
elementów danego ci±gu.</p>

<p><div class="lemat">
  <p>Twierdzenie 2.1&nbsp; Algorytm InsertionSort jest ca³kowicie  poprawnym rozwi±zaniem problemu sortowania, 
  w ka¿dej strukturze danych z liniowym porz±dkiem <span lang="en"><font face="Symbol">&pound;</font></span>.</p>
</div>
<p></p>
<p><b>Analiza kosztu:</b></p>
<p>Zastanówmy siê najpierw nad przypadkami szczególnymi. Za³ó¿my ¿e dany ci±g, 
do którego chcemy zastosowaæ algorytm InsertionSort jest ju¿ uporz±dkowany 
niemalej±co. Wykonanie pêtli wewnêtrznej za ka¿dym razem zakoñczy siê na 
zbadaniu warunku (j&gt;1 and e[j-1]&gt;pom). ¯aden element nie bêdzie 
przesuniêty. W ka¿dej iteracji zewnêtrznej pêtli, wykonamy wiêc tylko jedno 
porównanie. Razem n-1 porównañ.</p>
<p>A jak siê zachowa nasz algorytm w przypadku ci±gu odwrotnie uporz±dkowanego?&nbsp; 
Ka¿dy element trzeba bêdzie przenie¶æ na pozycjê pierwsz±. Ale w tym celu pêtla 
wewnêtrzna bêdzie musia³a przesun±æ ca³y ju¿ uporz±dkowany fragment o jedno 
miejsce w prawo, wykonuj±c w i-tym kroku i-1 porównañ. Razem 1 + 2 + ...+ n-1 
porównañ. Przypadek tu rozpatrywany jest najgorszy dla algorytmu InsertionSort, 
zatem&nbsp; koszt czasowy pesymistyczny wynosi W(n) = n(n-1)/2. </p>
<p>A jaki jest ¶redni koszt czasowy algorytmu? W pêtli zewnêtrznej nie 
wykonujemy porównañ. Policzymy wiêc jaka jest oczekiwana liczba porównañ 
wykonanych przez pêtlê wewnêtrzn±. W i-tym kroku mamy ju¿ uporz±dkowane elementy 
na pozycjach e[1],...,e[i-1], a zadanie pêtli wewnêtrznej polega na wstawieniu 
elementu e[i] na jedn± z pozycji 1,2,...,i. Za³ó¿my, ¿e z takim samym 
prawdopodobieñstwem element e[i] mo¿e zaj±æ ka¿de z tych i miejsc. Zatem 
prawdopodobieñstwo, ¿e e[i] zajmie miejsce j-te wynosi 1/i. Je¶li e[i] ma trafiæ 
na miejsce j-te, to musieli¶my element e[i] porównaæ z e[i-1],..., e[j], e[j-1] 
wykonuj±c przy tym i-j+1 porównañ. Wynika st±d, ¿e ¶redni liczba porównañ 
wykonanych przez pêtlê wewnêtrzn± wynosi</p>
<p style="text-align: center">&nbsp;<font face="Symbol" size="3">S</font> <sub>
<font face="Verdana">j=1,...,i</font></sub> (1/i)(i-j+1) = (1/i)(1+2+...+i) = 
(i+1)/2.</p>
<p>Sumuj±c&nbsp; po wszystkich i otrzymujemy:</p>
<p style="text-align: center">A(n) = <font face="Symbol" size="3">S</font> <sub>
<font face="Verdana">i=2,...,n</font></sub> (¶rednia liczba porównañ wykonanych 
w i-tym kroku algorytmu) = <font face="Symbol" size="3">S</font> <sub>
<font face="Verdana">i=2,...,n</font></sub> (i+1)/2 .</p>
<p style="text-align: left">Ostatecznie A(n) = (1/4)n<sup><font face="Verdana">2</font></sup> 
+O(n). Koszt ¶redni algorytmu InsertionSort niewiele odbiega od kosztu w 
przypadku pesymistycznym: te¿ jest kwadratowy.</p>
<p>Algorytm sortowania przez wstawianie sortuje w miejscu, tzn. wykorzystuje tylko 
pamiêæ konieczn± do przechowywania danych i kilka zmiennych pomocniczych. Jego 
koszt pamiêciowy jest wiêc liniowy w stosunku do rozmiaru danych, S(n) = <font face="Symbol">Q</font>(n)</p>

  <p><b>Przyk³ad 2.1</b></p>
  <p>Niech dany ci±g sk³ada siê z liczb ca³kowitych, 4,2,6,1,7,5. Stany 
  tablicy e w kolejnych iteracjach pêtli zewnêtrznej&nbsp; algorytmu 
  InsertionSort s± nastêpuj±ce:</p>
  <p style="text-align: center"><b>4</b>,2,6,1,7,5&nbsp;&nbsp;&nbsp; <b>2,4,</b>6,1,7,5&nbsp;&nbsp;&nbsp; 
  <b>2,4,6,</b>1,7,5&nbsp;&nbsp; <b>1,2,4,6,</b>7,5&nbsp;&nbsp;&nbsp; 
  <b>1,2,4,6,7,</b>5&nbsp;&nbsp;&nbsp; <b>1,2,4,5,6,7.</b></p>
  <p>Pogrubion± czcionk± zaznaczono segmenty uporz±dkowane.<FONT FACE="Wingdings"> &#74;</FONT> </p>
<p><b>Pytanie 2</B>: Algorytm InsertionSort wykonuje do¶æ du¿o instrukcji 
przypisania. Policzmy tylko te, które dotycz± elementów ci±gu. Ile&nbsp; ich 
wykonamy w przypadku pesymistycznym, je¿eli ci±g sk³ada siê z n elementów? 
 </p>

<!-- <p>Odpowied¼: w kazdej iteracji i+1 przypisañ dla i=2,...,n = (n+1)(n+2)/2 -3.</P> -->

<FORM>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'(n+1)(n+2)/2 - 3');">
</form>
<p><br clear="all">
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main04_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main04_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>