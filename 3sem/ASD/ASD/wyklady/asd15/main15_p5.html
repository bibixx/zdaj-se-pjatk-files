<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main15_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main15_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><br clear="all"><div class="tytulpunktu">
5. Rozstrzygalno¶æ i nierozstrzygalno¶æ </div>


 &nbsp;<p>Problemy klasy NPC, o których mówili¶my w poprzednich punktach 
wyk³adu, by³y problemami &quot;trudnymi&quot;, jednak nie mo¿emy z ca³± stanowczo¶ci± 
powiedzieæ, ¿e nie da siê ich rozwi±zaæ w sposób &quot;³atwy&quot;. Po prostu nie wiemy, 
czy istniej± dla nich wielomianowe algorytmy. S± jednak problemy, dla których 
udowodniono, ¿e s± trudne, ¿e nie istniej±&nbsp; i nigdy nie bêd± mog³y byæ 
wynalezione wielomianowe algorytmy ich rozwi±zywania. Do takich problemów nale¿y 
m.in. problem &quot;wie¿ Hanoi&quot;, nale¿± uogólnione wersje gry w szachy, w której gra 
toczy siê na planszy n <font face="Symbol"><span lang="en">´</span> </font>n, 
problem spe³niania w³asno¶ci algorytmicznych wyra¿onych w pewnym rozszerzeniu 
rachunku zdañ.&nbsp; Dla tych problemów udowodniono, wyk³adnicze dolne 
oszacowanie z³o¿ono¶ci.</p>





<p>Zapomnijmy na chwilê o sprawie kosztu algorytmów. Wszystkie problemy omawiane 
do tej pory mia³y jakie¶ rozwi±zania w postaci algorytmów. Nawet, je¶li to 
rozwi±zanie wymaga³o bardzo du¿o czasu, to jednak mogli¶my okre¶liæ metodê 
postêpowania prowadz±c± do rozwi±zania problemu. O problemach decyzyjnych tego 
typu mówimy, ¿e s± rozstrzygalne. S± jednak problemy, które tej cechy nie 
posiadaj±: nie istnieje dla nich metoda postêpowania, która po skoñczonej 
liczbie kroków da rozwi±zanie. Takie problemy&nbsp; nazywamy nieobliczalnymi, a 
problemy decyzyjne tego typu nazywamy nierozstrzygalnymi.</p>





<div class="def">
<p>Definicja 15.5&nbsp;&nbsp; Powiemy, ¿e problem decyzyjny jest rozstrzygalny, je¶li 
istnieje algorytm, który dla dowolnych danych po skoñczonej liczbie kroków daje 
rozwi±zanie problemu. W przeciwnym razie, tzn. je¶li taki algorytm nie istnieje,  mówimy, ¿e problem jest nierozstrzygalny. </P>
</div>

<p>

<b>

<br>

Przyk³ad 5.1</b></p>

<p>

Problem sprawdzenia, czy formu³a klasycznej logiki predykatów jest tautologi±, 
jest 
nierozstrzygalny. Je¶li dana formu³a rachunku predykatów jest tautologi±, to 
umiemy siê o tym przekonaæ w skoñczonym czasie. Je¶li jednak nie jest to 
tautologia, to nie ma takiej metody, która po skoñczonej liczbie kroków 
pozwoli³aby przerwaæ postêpowanie i zdecydowaæ, ¿e to nie jest tautologia.
<font face="Wingdings" size="3">J</font></p>

<p>

<b>Przyk³ad 5.2</b></p>

<p>

Rozwa¿my problem, który przypomina zadanie uk³adania kafelków w domu. Niech bêd± 
dane &quot;kafelki&quot; -kwadraty podzielone przek±tnymi na cztery czê¶ci, z których 
ka¿da zosta³a w pewien sposób pokolorowana. Mamy skoñczony zbiór X wzorców 
&quot;kafli&quot;. Zadanie polega na znalezieniu odpowiedzi na pytanie, czy dowoln± 
skoñczon± powierzchniê mo¿na pokryæ za pomoc± &quot;kafli&quot; takich jak w zbiorze X, w 
taki sposób, ¿e s±siaduj±ce &quot;kafelki&quot; pasuj± do siebie ( np. zgadzaj± siê ich 
kolory). Zak³adamy, podobnie jak w problemie uk³adanki (por. punkt 15.1), ¿e 
&quot;kafle&quot; maj± ustalon± orientacjê i nie mo¿na ich obracaæ, oraz ¿e liczba kafli 
ka¿dego typu jest nieograniczona. Problem ten nazywa siê problemem domina (por. 
D. Harel, Rzecz o istocie informatyki, WNT 1992). Udowodniono, ¿e nie ma i nigdy 
nie bêdzie w przysz³o¶ci, algorytmu, który po skoñczonej liczbie kroków 
odpowiada³by, ¿e pokrycie danej powierzchni jest lub, ¿e pokrycie nie jest 
mo¿liwe. Problem domina jest nierozstrzygalny. <font face="Wingdings" size="3">J</font></p>

<p>

&nbsp;</p>

<p>

Do klasy problemów nierozstrzygalnych nale¿± te¿ problemy szczególnie wa¿ne dla 
informatyków. Jednym z nich jest problem stopu.</p>
<p></P>

<p>Dany jest pewien algorytm i dane do tego algorytmu. Zadanie polega na sprawdzeniu, 
czy dla tych danych algorytm koñczy obliczenia po skoñczonym czasie, czy nie. </P>

<p style="text-align: center">Stop(A, d) = true&nbsp; wttw A koñczy obliczenie dla danych d. </P>

<p>Mo¿emy sprawdziæ, co siê stanie, uruchamiaj±c po prostu algorytm A na jakim¶ 
komputerze. Je¶li jednak algorytm A dla pewnych danych ma obliczenie 
nieskoñczone, to jak siê o tym przekonaæ? A mo¿e uda siê znale¼æ postêpowanie 
algorytmiczne, metodê, która potrafi przeanalizowaæ nasz algorytm A i jego dane, 
i odpowie na nasze pytanie, bez konieczno¶ci wykonywania algorytmu A?</P>

<p>Rozwa¿my  zadanie ogólniejsze: 
spytajmy, czy istnieje algorytm (jednorodna metoda postêpowania), który dla 
dowolnego algorytmu i danych do niego potrafi stwierdziæ, czy algorytm zatrzyma 
siê dla tych danych, czy te¿ nie zatrzyma siê?<b> </b>Tak sformu³owany problem 
nosi nazwê problemu stopu (halting problem). Niestety odpowied¼ jest negatywna: 
nie istnieje algorytm, który rozwi±zuje problem stopu.</P>


<p></P>



<div class="lemat" style="width: 683; height: 42">
<p>Twierdzenie 15.1 Problem stopu jest nierozstrzygalny.</P>
 </div>
 
<p></P>

<p>Dowód. Za³ó¿my przeciwnie, ¿e istnieje algorytm Q(A,x), który dla dowolnego 
algorytmu A napisanego w pewnym ustalonym jêzyku programowania i dla ustalonych 
danych x, po skoñczonej liczbie kroków odpowiada na pytanie, czy A zapêtla siê 
dla danych x, czy te¿ nie. Przyjmijmy, ¿e Q daje wynik &quot;tak&quot;, gdy dany program 
A 
zatrzymuje siê, i daje wynik &quot;nie&quot;, gdy program A ma dla danych x nieskoñczon± pêtlê. 
U¿yjemy 
teraz algorytmu Q do skonstruowania nowego programu S. Po pierwsze wej¶ciem do 
programu S bêdzie tre¶æ badanego algorytmu A, nastêpnie wykonamy algorytm Q dla 
danych&nbsp; (A, A), tzn. A jest raz traktowane, jako tekst algorytmu, a drugi 
raz jako napis opisuj±cy jego dane wej¶ciowe. Ponadto w przypadku, gdy Q(A,x) 
odpowiada&nbsp; &quot;tak&quot; dopiszmy nieskoñczon± pêtlê. Nowy algorytm S ma wiêc 
np. postaæ:</P>

<p style="text-align: center">S(A) = {x := kopia(A); Q(A,x); <b>if</b>&nbsp; wynik=&quot;tak&quot; 
<b>then</b> <b>while</b> true <b>do</b> i := i <b>od</b> <b>fi</b>}</P>

<p>Program S dla dowolnego algorytmu A albo powinien siê zatrzymaæ, albo nie. 
U¿yjmy programu S do sprawdzenia, jak zachowuje siê sam program S. Je¿eli&nbsp; 
S(S) zatrzymuje siê, to znaczy, ¿e algorytm Q(S,S) odpowiedzia³ &quot;nie&quot;. Oznacza 
to jednak, ¿e algorytm S nie zatrzymuje siê dla danych S. Otrzymali¶my 
sprzeczno¶æ. Przypu¶æmy wiêc przeciwnie, ¿e program S(S) nie zatrzyma³ siê. 
Mog³o siê tak staæ tylko wtedy, gdy program S wpad³ w nieskoñczon± pêtlê, któr± 
dopisali¶my do programu Q. To oznacza, ¿e algorytm Q musia³ odpowiedzieæ &quot;tak&quot;. 
Jednak taka odpowied¼ znaczy, ¿e program bêd±cy argumentem Q, tzn. S, nie 
zapêtla siê dla rozwa¿anych danych, czyli program S nie zapêtla siê dla danych S. 
Znów sprzeczno¶æ. Ale przecie¿ zgodzili¶my siê na pocz±tku, ¿e program albo siê 
zatrzymuje, albo nie zatrzymuje siê.&nbsp; Wynika st±d, ¿e S nie ma prawa 
istnieæ, a dok³adniej, nie istnieje hipotetyczny algorytm Q.
<font face="Wingdings" size="3">J</font></P>

<p><b>Pytanie 8</B>: Czy problem spe³niania dla formu³ rachunku zdañ jest 
rozstrzygalny ? 
<br clear="all"></P>


<!-- <p>Odpowied¼: TAK.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'Tak, np. metoda zerojedynkowa daje algorytm rozwi±zywania tego problemu.')"> 
</form>

<BR> 


<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main15_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main15_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
</dir>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>