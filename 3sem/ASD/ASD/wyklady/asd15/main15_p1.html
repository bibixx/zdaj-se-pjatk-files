<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
<td align="left"><A HREF="main15_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main15_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
    </tr>
</table>

<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">1. Problemy &quot;rozs±dne&quot; i inne</div> 

  


    <p>Wiêkszo¶æ algorytmów, o których by³a mowa o tej pory mia³a koszt czasowy 
    i pamiêciowy wielomianowy, tzn. rz±d wielko¶ci czasu potrzebnego do ich 
    wykonania by³ ograniczony z góry przez funkcjê wielomianow± wzglêdem 
    rozmiaru danych. Takie by³y algorytmy wyszukiwania, sortowania, algorytmy 
    realizuj±ce ró¿ne operacje na grafach i ogólniej na zbiorach. Wszystkie te 
    algorytmy uwa¿amy za realizowalne w rozs±dnym czasie. </p>
  


    
    <p><div class="def">Definicja 1.1&nbsp; Powiemy, ¿e problem jest 
  rozwi±zywalny w czasie wielomianowym, je¿eli istnieje algorytm rozwi±zuj±cy 
  ten problem w czasie O(n<sup><font face="Verdana">k</font></sup>) dla pewnego 
  k, gdzie n jest rozmiarem danych w tym problemie.</div></p>


    <p>Problem znajdowania najd³u¿szego wspólnego podci±gu jest wielomianowy, chocia¿ mo¿na 
    przedstawiæ rozwi±zanie, którego koszt jest wyk³adniczy. Problem mno¿enia 
    ci±gu macierzy&nbsp; te¿ jest wielomianowy, znalezienie pe³nego nawiasowania, 
    przy którym liczba mno¿eñ skalarnych bêdzie najmniejsza metod± programowania 
    dynamicznego zajmuje O(n<sup><font face="Verdana"> 3</font></sup>) czasu. 
    Zwróæmy jeszcze raz uwagê, ¿e problem jest wielomianowy, je¶li chocia¿ jeden 
    algorytm potrafi go rozwi±zaæ z kosztem wielomianowym. Istniej± jednak zadania, których nie umiemy rozwi±zaæ 
    ¿adn± ze znanych nam technik w czasie wielomianowym. </p>
  


    <p><b>Problem &quot;Wie¿e Hanoi&quot;</b></p>
  


    <p>Danych jest n kr±¿ków, umieszczonych w porz±dku rosn±cych ¶rednic, na 
    dr±¿ku A. Zadanie polega na przeniesieniu wszystkich kr±¿ków na dr±¿ek B, 
    przy czym mo¿na wykorzystywaæ pomocniczy dr±¿ek C. Pocz±tkowo dr±¿ki B i C 
    s± puste. Przenoszenie dr±¿ków odbywa siê wg. zasady : mniejszy kr±¿ek mo¿e 
    byæ po³o¿ony tylko na kr±¿ku wiêkszym. </p>
  


    <p><b>Pytanie 1:</b> Ile pojedynczych przeniesieñ kr±¿ków trzeba wykonaæ, 
    dla n=3? <br>
  
<!-- Odpowied¼: 7 przeniesieñ kr±¿ków.</P> -->

</p>
  


<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Sprawd¼ odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'7 przeniesieñ kr±¿ków.')">
</p>
</form>

<p><br clear="all">Tybetañczycy, którzy rozwa¿ali ten problem dla n = 64, wierzyli, ¿e ¶wiat 
    skoñczy siê wcze¶niej nim zostanie przeniesiony ostatni z kr±¿ków. Dlaczego? Istnieje 
przecie¿ prosty, rekurencyjny algorytm rozwi±zuj±cy ten problem, por. algorytm &quot;move&quot;.
  




    <p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 700; height: 184">
   <TABLE frame="void" rules="none" width="670" height="158" bordercolorlight="#808080" bordercolordark="#FFFFFF" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="526" height="12" colspan="2">move (n : int, A, B, C: 
            dr±¿ek) {</TD>
             
            <TD width="637" height="12"> //przenie¶ n kr±¿ków z A na B 
            wykorzystuj±c C</TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><b>if</b>&nbsp; (n <span lang="en">
            <font face="Symbol">&sup1;</font></span>0) <b>then</b> </TD> 
            <TD width="637" height="12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><strong>&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp; 
            move (n-1, A, C, B);</TD> 
            <TD width="637" height="12"><strong>&nbsp;</strong>//przenie¶ n-1 
            kr±¿ków z A na C wykorzystuj±c B<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>
            </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp; </strong>&nbsp; przenie¶ 
            jeden kr±¿ek z A na B;</TD> 
            <TD width="637" height="12"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD> 
         </TR>
         <tr>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12">   &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;move(n-1, 
            C, B, A)&nbsp;</TD>
            <TD width="637" height="12">   <b>&nbsp;</b>//przenie¶ n-1 kr±¿ków z 
            C na B wykorzystuj±c A<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </b></TD>
         </tr>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12">   &nbsp;<b>fi</b><STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="637" height="12">   </TD>
         </TR>
         <TR>
            <TD width="59" height="1"><strong>}</strong></TD>
            <TD width="467" height="1">   <strong>&nbsp;&nbsp;&nbsp;</strong></TD>
            <TD width="637" height="1">   </TD>
         </TR>
         </TABLE>
</div>





    <p>Zauwa¿my, ¿e skoro n-1 pierwszych kr±¿ków zosta³o ju¿ prze³o¿onych z 
    dr±¿ka A na dr±¿ek C (w wyniku wywo³ania&nbsp; move (n-1, A, C, B)), 
    to na dr±¿ku A pozosta³ tylko jeden kr±¿ek (najwiêkszy), a dr±¿ek B jest 
    pusty. Mo¿emy wiêc bezpiecznie przenie¶æ ten jedyny kr±¿ek na dr±¿ek B, a 
    nastêpnie, stosuj±c to samo postêpowanie, przenie¶æ&nbsp; z C pozosta³e n-1 
    kr±¿ków na dr±¿ek B.</p>
  


    <p>Koszt  algorytmu &quot;move&quot;, mierzony liczb± przeniesieñ kr±¿ków, wyra¿a siê 
    nastêpuj±cym równaniem rekurencyjnym:</p>
  


    <p style="text-align: center">T(1) = 1,&nbsp;&nbsp; T(n) = T(n-1) + 1 + 
    T(n-1).</p>
  


    <p>Rozwi±zaniem tego równania jest funkcja wyk³adnicza T(n) = 
    2<sup><font face="Verdana">n </font></sup>- 1. Przy tempie przek³adania 10<sup><font face="Verdana">6
    </font></sup>kr±¿ków/sek. dla n= 64 praca zajê³aby wiêcej ni¿ 0.5 miliona lat. Nie ma 
    co siê dziwiæ Tybetañczykom! Niestety nie jest znany ¿aden algorytm 
    wielomianowy, który rozwi±zywa³by ten problem. Co wiêcej mo¿na wykazaæ, ¿e 2<sup><font face="Verdana">n </font></sup>
    - 1 jest te¿ dolnym ograniczeniem koniecznej liczby ruchów w rozwi±zaniu 
    tego problemu.</p>
  


    <p><b>Problem permutacji</b></p>
  


    <p>Dana jest liczba naturalna n. Wypisaæ wszystkie mo¿liwe permutacje liczb 
    od 1 do n.</p>
  


    <p>Jest wiele ró¿nych sposobów tworzenia kolejnych permutacji. Jedn± z 
    prostszych metod jest nastêpuj±ca: aby wypisaæ wszystkie permutacje liczb od 
    1 do n, wypiszmy wszystkie permutacje liczb od 2 do n, i w ka¿dej z nich 
    umie¶æmy liczbê 1 na wszystkich mo¿liwych n pozycjach: przed pierwszym 
    elementem przed drugim itd.... przed (n-1)szym i po (n-1)szym. Taka metoda 
    wydaje siê byæ bardzo dobra, ale po zastanowieniu dojdziemy do wniosku, ¿e 
    pojawia siê problem przechowywania wygenerowanych permutacji. (n-1)! ci±gów 
    do zapamiêtania to bardzo du¿o. Ju¿ dla ma³ych n, mo¿emy przekroczyæ 
    mo¿liwo¶ci naszego komputera.  </p>
  


    <p><b>Pytanie 2: </b>W jakiej kolejno¶ci zostan± wypisane permutacje dla 
    n=3, je¶li stosujemy opisan± wy¿ej metodê rekurencyjnie?  </p> <br>

<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Sprawd¼ odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'123, 132, 213,312, 231, 321.')">
</p>
</form>
  


    <p>Na szczê¶cie istniej± algorytmy, które 
    potrafi± wypisaæ na bie¿±co, kolejno tworzone permutacje, bez konieczno¶ci ich 
    pamiêtania. Przyk³adem niech bêdzie algorytm <i>permutacje</i> przedstawiony 
    poni¿ej, por. R. Sedgewick, Algorithms, Addison Wesley Pub. 1983. W 
    algorytmie tym permutacje s± tworzone w tablicy tab[0:n] na pozycjach od 1 
    do n. Pozycja tab[0] jest pomocnicza. Generowanie permutacji odbywa siê za 
    pomoc± rekurencyjnej procedury <i>generuj</i>, która dla danego k wypisuje 
    wszystkie permutacje z ustalon± warto¶ci± now+1 na pozycji k-tej.</p>
  




    <p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 700; height: 184">
   <TABLE frame="void" rules="none" width="670" height="158" bordercolorlight="#808080" bordercolordark="#FFFFFF" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="526" height="12" colspan="2">permutacje (n : int) { </TD>
             
            <TD width="637" height="12"> | generuj (k : int){</TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12">&nbsp;int&nbsp; now, i ;</TD> 
            <TD width="637" height="12">|&nbsp; int t;</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><b>if</b>&nbsp; (n <span lang="en">
            <font face="Symbol">&sup1;</font></span>0) <b>then</b> </TD> 
            <TD width="637" height="12">|&nbsp; now := now+1; tab[k]:= now;&nbsp;&nbsp; </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><strong>&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;
            <b>for</b> i := 1 <b>to</b> n <b>do</b> tab[i] := 0 <b>od;</b></TD> 
            <TD width="637" height="12">| <strong>&nbsp;</strong><b>if </b>(now= 
            n) <b>then</b>&nbsp;&nbsp; Wypisz(tab)<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>
            </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp; </strong>&nbsp; 
            now := -1; </TD> 
            <TD width="637" height="12"> |&nbsp;&nbsp;<b>else</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD> 
         </TR>
         <tr>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12">   &nbsp; &nbsp;&nbsp;&nbsp;generuj(0);</TD>
            <TD width="637" height="12">   |<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            for</b> t := 1 <b>to</b> n <b>do</b></TD>
         </tr>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="467" height="12">   <b>fi</b><STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="637" height="12">   |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <b>if</b> tab[t]=0 <b>then</b> generuj(t);<b>fi</b></TD>
         </TR>
         <TR>
            <TD width="59" height="1"><strong>}</strong></TD>
            <TD width="467" height="1">   <strong>&nbsp;&nbsp;&nbsp;</strong></TD>
            <TD width="637" height="1">   |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <b>od</b>;</TD>
         </TR>
         <TR>
            <TD width="59" height="1"></TD>
            <TD width="467" height="1">   </TD>
            <TD width="637" height="1">   |&nbsp; <b>fi</b>;</TD>
         </TR>
         <TR>
            <TD width="59" height="1"></TD>
            <TD width="467" height="1">   </TD>
            <TD width="637" height="1">   |&nbsp; now := now-1; tab[k] := 0;</TD>
         </TR>
         <TR>
            <TD width="59" height="1"></TD>
            <TD width="467" height="1">   </TD>
            <TD width="637" height="1">   |<b>}</b></TD>
         </TR>
         <TR>
            <TD width="59" height="1"></TD>
            <TD width="467" height="1">   </TD>
            <TD width="637" height="1">   </TD>
         </TR>
         </TABLE>
</div>





    <p>Chocia¿ problem wykorzystania pamiêci zosta³ w tym algorytmie pomy¶lnie 
    rozwi±zany (ale uwaga na stos rekurencyjnych wywo³añ), to jednak koszt 
    algorytmu nadal jest rzêdu n!. Rozwi±zaniem problemu permutacji jest przecie¿ ci±g z³o¿ony 
    z n! ci±gów. Nie powinni¶my siê dziwiæ, ¿e wymaga to sporo czasu, bo nawet 
    dla n=16, liczba n! jest olbrzymia ( 16! &gt; 2<sup><font face="Verdana">50</font></sup>).&nbsp; </p>
  


    <p>Trudno nazwaæ przedstawione tu algorytmy rozs±dnymi.&nbsp; Uznajmy wiêc, 
    ¿e rozs±dne bêd± te algorytmy, dla których koszt czasowy realizacji jest 
    wielomianowy. Ka¿dy algorytm mo¿emy wiêc zaklasyfikowaæ do jednej z dwu klas 
    tak jak na rysunku 15.1.</p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="40%" id="AutoNumber1">
  <tr>
    <td width="100%">
    <img border="0" src="Rysunki/Rysunek15_1.gif" width="300" height="250"></td>
  </tr>
</table>
<p>Linia prosta na tym rysunku ma symbolizowaæ granicê podzia³u. 
    Ale w rzeczywisto¶ci granica miêdzy tym co rozs±dne i nierozs±dne nie jest 
    wcale oczywista. Rozwa¿my nastêpuj±cy przyk³ad.</p>
  


    <p><b>Przyk³ad 1.1</b></p>
  


    <p>Przypu¶æmy, ¿e mamy dwa algorytmy rozwi±zuj±ce ten sam problem: pierwszy, 
    A1, o koszcie O(n<sup><font face="Verdana">100</font></sup>) i drugi, A2, o 
    koszcie O(2<sup><font face="Verdana">n</font></sup>). Który z nich wybraæ? 
    Algorytm A1 jest wielomianowy, a zatem &quot;rozs±dny&quot;, zgodnie z klasyfikacj± na 
    rysunku 15.1 Natomiast algorytm A2 jest algorytmem wyk³adniczym i nie 
    chcemy, &quot;z zasady&quot;, uznaæ go za rozs±dny. Tymczasem&nbsp; dla bardzo wielu n, algorytm A2 
    wygrywa w czasie z algorytmem A1. Wynika st±d, ¿e granica miêdzy tym co 
    rozs±dne i mo¿liwe do zastosowania, a tym czego w praktyce nie da siê 
    zastosowaæ jest do¶æ nieostra.<font face="Wingdings"> J</font></p>
  


    <p style="text-align: left"><b>Pytanie 3</B>: Czy algorytm Dijkstry 
    znajdowania najkrótszej ¶cie¿ki&nbsp; z ustalonego ¼ród³a w grafie 
    zorientowanym z dodatnimi wagami nale¿y do algorytmów &quot;rozs±dnych&quot; w naszej 
    klasyfikacji?&nbsp; <br>
  
<!-- Odpowied¼: Tak, ma przecie¿ koszt wielomianowy O(n*n) dla grafu o n wêz³ach.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Sprawd¼ odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'Tak, ma przecie¿ koszt wielomianowy O(n*n) dla grafu o n wêz³ach.')">
</form>
</p>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main15_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main15_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>