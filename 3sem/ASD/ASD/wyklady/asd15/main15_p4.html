<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main15_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main15_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<br clear="all"><A NAME="EDU.wyklad.punkt 4"></A>

<br clear="all">
<div class="tytulpunktu">4. Algorytmy aproksymacyjne</div>
</p>
<p>Wiele problemów optymalizacyjnych to problemy NP-zupe³ne. Wiele z nich 
to problemy o istotnym praktycznym znaczeniu. Jak mamy wiêc postêpowaæ z 
zagadnieniem, o którym wiadomo, ¿e jest NP-trudne, a jednak jego rozwi±zanie 
jest dla nas niezbêdne?&nbsp;Czy jest sposób rozwi±zania takiego problemu, mimo 
wszystko?</p>
<p>Rozwa¿my problem komiwoja¿era. Skoro znalezienie najkrótszej drogi 
przechodz±cej przez wszystkie miasta jest w³a¶ciwie niemo¿liwe, bo problem jest 
NP-trudny, wydaje siê byæ rozs±dnym rozwa¿yæ ew. algorytmy znajduj±ce &quot;prawie 
najkrótsz±&quot; drogê komiwoja¿era. Je¶li zrezygnujemy z wymagania, by szukana droga 
by³a najkrótsza, to okazuje siê, ¿e&nbsp; mo¿emy zastosowaæ np. algorytm 
Kruskala, do skonstruowania minimalnego drzewa rozpinaj±cego, i na tej podstawie 
utworzyæ co najwy¿ej dwukrotnie tak d³ug± drog± komiwoja¿era, jak droga 
najkrótsza. Czasami takie rozwi±zanie jest lepsze ni¿ ¿adne!</p>
<p>Klasa algorytmów pozwalaj±cych rozwi±zaæ trudne problemy optymalizacyjne, w 
sposób, który nie daje rozwi±zania optymalnego, ale jednak rozwi±zanie bliskie 
optymalnemu, za to z rozs±dnym kosztem,&nbsp; nazywana jest klas± algorytmów 
aproksymacyjnych.&nbsp; Zak³adamy, ¿e w wielu przypadkach rozwi±zanie &quot;prawie 
dobre&quot; otrzymane w rozs±dnym czasie jest lepsze, ni¿ rozwi±zanie najlepsze, 
którego znalezienie wymaga &quot;nierozs±dnie du¿o&quot; czasu.</p>
<p><b>Przyk³ad 4.1</b></p>
<p>Rozwa¿my problem plecakowy sformu³owany w punkcie 3 tego wyk³adu (por. Sara 
Baase, Computer Algorithms). Niech&nbsp;&nbsp; 
s<sub><font face="Verdana">1</font></sub>,...,s<sub><font face="Verdana">n</font></sub> 
bêdzie ci±giem wag przypisanych obiektom i niech c bêdzie maksymaln±, dopuszczaln± wag± 
wybranych obiektów. Szukamy&nbsp; takiego algorytmu, który znajduje wektor (x<sub><font face="Verdana">i</font></sub>)<sub><font face="Verdana">i</font>
<span lang="en"><font face="Symbol">&pound;</font></span>n</sub> o elementach 0, 
1, tak by suma</p>
   
<p style="text-align: center">s = <font face="Symbol" size="4">S</font> <sub>
<font face="Verdana">i=1,...,n</font></sub> s<sub><font face="Verdana">i</font></sub> 
*x<sub><font face="Verdana">i</font></sub>&nbsp;  </p>
   
<p>przyjmowa³a warto¶æ blisk± najwiêkszej mo¿liwej.   </p>
   
<p>Idea rozwi±zania przybli¿onego jest nastêpuj±ca: skoro nie mo¿emy przejrzeæ 
wszystkich mo¿liwych podzbiorów zbioru obiektów, to przynajmniej przejrzyjmy 
podzbiory o mocy co najwy¿ej k i na ich bazie spróbujmy zbudowaæ rozwi±zanie. W 
przedstawionym algorytmie przyjmujemy, ¿e obiekty s± ponumerowane liczbami 
naturalnymi {1, ..., n}, a Set oznacza podzbiór zbioru {1, ..., n} i s³u¿y do 
zapamiêtania wybranego podzbioru obiektów.</p>
   




    <p style="text-align: left">&nbsp;<p>
<div class="def" style="width: 676; height: 414">
   <TABLE frame="void" rules="none" width="650" height="254" bordercolorlight="#808080" bordercolordark="#FFFFFF" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="1043" height="24" colspan="2">Knapsack_k {</TD>
             
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">Ustaw&nbsp; obiekty w porz±dku 
            nierosn±cych warto¶ci ich&nbsp; wag.</TD> 
         </TR>
         <TR>
            <TD width="59" height="24"></TD>
            <TD width="984" height="24">Niech to bêdzie ci±g s<sub><font face="Verdana">i1</font></sub>, 
            s<sub><font face="Verdana">i2</font></sub>,...,s<sub><font face="Verdana">in</font></sub>.</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">MaxSum := 0;</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">Set := {};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            // Set jest na pocz±tku zbiorem pustym </TD> 
         </TR>
         <TR>
            <TD width="59" height="17"></TD>
            <TD width="984" height="17"><b>for</b> ka¿dego podzbioru T zbioru 
            {1,..., n} o co najwy¿ej k elementach <b>do</b></TD> 
         </TR>
         <TR>
            <TD width="59" height="30"></TD>
            <TD width="984" height="30">&nbsp;&nbsp;&nbsp; sum := suma wag 
            obiektów w zbiorze T;</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">&nbsp;&nbsp; <b>&nbsp;for</b> j := 1 <b>
            to</b> n <b>do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </b>//przegl±damy pozosta³e obiekty</TD> 
         </TR>
         <TR>
            <TD width="59" height="23"></TD>
            <TD width="984" height="23">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <b>if </b>&nbsp;(obiekt i<sub><font face="Verdana">j</font></sub> 
            nie nale¿y do T) <b>then </b>&nbsp;&nbsp; //i ewentualnie 
            uzupe³niamy zbiór T</TD> 
         </TR>
         <TR>
            <TD width="59" height="24"></TD>
            <TD width="984" height="24"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</b>&nbsp; 
            ((sum + s<sub><font face="Verdana">ij</font></sub>)
            <font face="Symbol"><span lang="en">&pound;</span> </font>c ) <b>then</b> </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            sum := sum + s<sub><font face="Verdana">ij</font></sub>;</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            T := T<span lang="en"><font face="Symbol">&Egrave;</font></span> {i<sub><font face="Verdana">j</font></sub>}</TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12"><strong>&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>fi</b><STRONG> </STRONG>
             </TD> 
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12"><strong>&nbsp;&nbsp;&nbsp;&nbsp; </strong>&nbsp; <b>&nbsp; fi</b><STRONG> </STRONG>
             </TD> 
         </TR>
         <tr>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">   &nbsp; &nbsp;&nbsp;&nbsp;<b>od</b>;&nbsp;</TD>
         </tr>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong><b>if </b>&nbsp;(MaxSum &lt; sum) <b>then&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </b>//je¶li znalezione w³a¶nie rozwi±zanie jest lepsze</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            MaxSum := sum;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // zapamiêtujemy je
             </TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            Set := T;</TD>
         </TR>
         <TR>
            <TD width="59" height="12"></TD>
            <TD width="984" height="12">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong><b>fi</b><STRONG> </STRONG>
             </TD>
         </TR>
         <TR>
            <TD width="59" height="22"></TD>
            <TD width="984" height="22">   &nbsp;<b>od</b><STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
         </TR>
         <TR>
            <TD width="59" height="17"><strong>}</strong></TD>
            <TD width="984" height="17">   <strong>&nbsp;&nbsp;&nbsp;</strong></TD>
         </TR>
         </TABLE>
</div>





<p>Ten prosty schemat definiuje ci±g algorytmów Knapsack_k dla wszystkich k. Im 
wiêksze k, tym rozwi±zanie uzyskane przez ten algorytm jest bli¿sze optymalnemu. 
Natomiast dla ustalonego k,&nbsp; koszt algorytmu Knapsack_k mo¿na oszacowaæ 
przez O(k* n <sup><font face="Verdana">k+1</font></sup>). Jest to wiêc dla 
ka¿dego k, algorytm wielomianowy ze wzglêdu na rozmiar danych n.<font face="Wingdings" size="3">J<br>
&nbsp;</font></p>

<p>Nie do wszystkich problemów da siê zastosowaæ podej¶cie aproksymacyjne. 
Udowodniono na przyk³ad dla problemu kolorowania grafu, ¿e je¶li istnieje 
algorytm, który w czasie wielomianowym wyznacza kolorowanie co najwy¿ej dwa razy 
wiêksz± liczb± kolorów ni¿ liczba minimalna, to istnieje tak¿e algorytm 
wielomianowy, który rozwi±zuje ten problem. Poniewa¿ problem kolorowania grafu 
jest problemem NP-zupe³nym, wynika st±d, ¿e znalezienie algorytmu 
aproksymacyjnego, daj±cego &quot;prawie&quot; dobre wyniki, jest tak samo trudne, jak&nbsp; 
problem P = NP.</p>

<p><b>Pytanie 7</B>: Przypu¶æmy, ¿e dane s± obiekty o wagach&nbsp; 54, 45, 43, 29, 
23, 21, 14, 1, oraz c= 110. Jakie rozwi±zanie znajdzie algorytm Knapsack_2? </P>

<!-- <p>Odpowied¼: {43, 29, 32, 14, 1}.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'Rozwi±zanie optymalne: {43, 29, 32, 14, 1}.')"> 
</form>

<BR> 


<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main15_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main15_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
 
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>