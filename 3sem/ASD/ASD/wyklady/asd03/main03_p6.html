<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p5.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>


<br clear="all"><A NAME="EDU.wyklad.punkt 6"></A><br clear="all">
<div class="tytulpunktu">6. Algorytm Hoare</div> 

<p></P>

<p>Przedstawiony w poprzednim punkcie problem jest szczególnym przypadkiem 
nastêpuj±cego zadania:<p>Dany jest ci±g, którego elementy nale¿± do pewnej 
przestrzeni liniowo uporz±dkowanej. Niech np. <i>elem</i> bêdzie typem elementów 
tego ci±gu. Znale¼æ k-ty najwiêkszy element tego ci±gu, 
tzn. element, który ma dok³adnie k-1 wiêkszych od siebie elementów.<p>
<b>Przyk³ad 6.1</b><p>Dla ci±gu 3,5,20,7,11,60,32,19,8, drugi najwiêkszy element 
to 32, trzeci najwiêkszy to 20, a czwarty najwiêkszy element to 19.<font face="Wingdings">J</font><p>Niech dany 
ci±g bêdzie reprezentowany przez tablicê o elementach e[1],...,e[n].
Specyfikacja naszego zadnia mo¿e mieæ nastêpuj±c± postaæ:<p style="text-align: center">wp ={n<font face="Symbol"> <span lang="en">&sup3;</span></font>k 
&gt;0, e[i] <font face="Symbol"><span lang="en">&sup1;</span> </font>e[j] dla i
<font face="Symbol"><span lang="en">&sup1;</span> </font>j}<p style="text-align: center">
wk = {istnieje dok³adnie k-1 elementów e[j<sub><font face="Verdana">1</font></sub>],..., 
e[j<sub><font face="Verdana">k-1</font></sub>] takich, ¿e result &lt; e[j]&nbsp; 
dla j= j<sub><font face="Verdana">1</font></sub>,..., j<sub><font face="Verdana">k-1</font></sub>.}.<p style="text-align: left">
Najprostszy algorytm rozwi±zania tego zadania polega na k krotnym wyszukiwaniu 
maksimum. W przedstawionym tu algorytmie, znalezione kolejno elementy maksymalne 
s± przestawiane na kolejne, pocz±tkowe pozycje ci±gu. U¿yli¶my w tym celu 
operacji swap(e[i], e[j]), która powoduje zamianê itej i jtej pozycji ci±gu. 
Dok³adniej swap(x,y) = {z := x; x := y; y := z}.<p style="text-align: left">&nbsp;<p>
<div class="przyk" style="width: 779; height: 330">
   <TABLE frame="void" rules="none" width="741" height="302">
         <TR>
            <TD width="59" height="16">K_ty{</TD>
            <TD width="396" height="16">&nbsp; </TD>
             
            <TD width="41" height="16"></TD>
             
            <TD width="778" height="16"> </TD>
             
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;</strong>j := 1;</TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16"></TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;while&nbsp; </strong>(j
            <span lang="en"><font face="Symbol">&pound;</font></span> k) <strong>do </strong> </TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16">//e[1]&gt;...&gt;e[j-1], e[j-1]= max{e[j-1],...,e[n]}</TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>x := j;&nbsp;&nbsp;i := j +1;&nbsp; </TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16">//x ma byæ pozycj± elementu najwiêkszego 
            w¶ród e[j],...,e[n]</TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            while </strong>(i&lt;n+1)<strong> do </strong></TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16">// szukamy maksimum w¶ród elementów na 
            pozycjach &gt;j</TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong><b>if</b> e[i]&gt; e[x] <b>then</b> x := i <b>fi</b>;</TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16"></TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            i := i+1;</TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16"></TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            od;</strong></TD> 
            <TD width="41" height="16"></TD> 
            <TD width="778" height="16">e[x]&nbsp; = max {e[j],...,e[n]}</TD> 
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            swap(e[j],e[x]);<STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
             </TD>
            <TD width="41" height="16">   </TD>
            <TD width="778" height="16">   e[1]&gt;...&gt;e[j-1]&gt;e[j], e[j] = max{e[j],...,e[n]}</TD>
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j 
            := j + 1;</TD>
            <TD width="41" height="16">   </TD>
            <TD width="778" height="16">   e[1]&gt;...&gt;e[j-1],   e[j-1] = max{e[j-1],...,e[n]} </TD>
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16">   &nbsp;<STRONG>od;</STRONG></TD>
            <TD width="41" height="16">   </TD>
            <TD width="778" height="16">   //&nbsp;&nbsp; j = k+1</TD>
         </TR>
         <TR>
            <TD width="59" height="16"></TD>
            <TD width="396" height="16">      result := e[k]&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="41" height="16">      </TD>
             
            <TD width="778" height="16">      //e[1]&gt;...&gt;e[k],   e[k] = max{e[k],...,e[n]}      </TD>
             
         </TR>
         <TR>
            <TD width="59" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="396" height="16"></TD>
            <TD width="41" height="16"></TD>
            <TD width="778" height="16"> </TD>
         </TR>
   </TABLE>
</div>

<p style="text-align: left">Nie bêdziemy tu dok³adniej analizowaæ poprawno¶ci 
tego algorytmu.&nbsp; Komentarze umieszczone obok instrukcji, pozwalaj± 
uzasadniæ niezmiennik pêtli, który mówi, ¿e e[j-1] jest (j-1)szym co do 
wielko¶ci elementem rozwa¿anego ci±gu.</P>

<p style="text-align: left">Koszt tego algorytmu, mierzony liczb± wykonanych 
porównañ elementów, to suma kosztów zwi±zanych z k krotnym wyszukiwaniem 
maksimum w coraz krótszych ci±gach:</P>

<p style="text-align: center">(n-1) + (n-2)+ (n-3) +... + (n-k) = k*n - 
k(k+1)/2.</P>

<p style="text-align: left">Je¶li k jest&nbsp; ma³± sta³±, to koszt tego algorytmu jest 
liniowy. Je¶li natomiast k= <font face="Symbol">Q</font>(n), to sk³adnik k*n 
spowoduje, ¿e funkcja kosztu algorytmu bêdzie ros³a ze wzrostem n, tak jak 
funkcja kwadratowa.</P>

<p style="text-align: left">Czy mo¿na rozwi±zaæ problem k-tego co do wielko¶ci 
elementu taniej, wykonuj±c mniejsz± liczbê porównañ? C.A.R.Hoare zaproponowa³ algorytm wykorzystuj±cy 
zasadê &quot;dziel i zwyciê¿aj&quot;.</P>

<p style="text-align: left"><b>Idea algorytmu Hoare: </b></P>

<blockquote>
  <ol>
    <li>

<p style="text-align: left">Rozdzieliæ elementy ci±gu na mniejsze i wiêksze 
wzglêdem pewnego elementu m, np. wzglêdem pierwszego lub ostatniego elementu ci±gu. Niech x 
bêdzie liczb± elementów wiêkszych od m.</P>

    </li>
    <li>

<p style="text-align: left">Je¿eli&nbsp; x &gt; k-1, to&nbsp; elementu k-tego 
szukamy w¶ród elementów wiêkszych od m, stosuj±c to samo postêpowanie.</P>

    </li>
    <li>

<p style="text-align: left">Je¿eli&nbsp; x = k-1, to m jest szukanym, k-tym co do 
wielko¶ci elementem ci±gu.</P>

    </li>
    <li>

<p style="text-align: left">Je¿eli&nbsp; x&nbsp; &lt; k-1, to w¶ród elementów 
mniejszych od m szukamy (t± sam± metod±) elementu (k-x-1)tego co do wielko¶ci.</P>

    </li>
  </ol>
</blockquote>

<p style="text-align: left"><b>Przyk³ad 6.2</b></P>

<p style="text-align: left">Niech bêdzie ci±g e = (6, 4, 1, 8, 7, 3, 2, 5, 9, 0). 
Przypu¶æmy, ¿e szukamy w nim 6 co do wielko¶ci elementu. Niech elementem 
rozdzielaj±cym bêdzie pierwszy element ci±gu. Tylko 9,7,8 s± wiêksze, 
a elementy 4, 1, 3, 2, 5, 0 s± mniejsze od 6. </P>

<p style="text-align: center"><font face="Verdana">4, 1, 3, 2, 5, 0,</font> <b>6</b>, 8, 7, 9.</P>

<p style="text-align: left">Wyró¿nili¶my pozycjê liczby 6, aby zaznaczyæ miejsce 
jakie liczba 6 powinna zaj±æ po uporz±dkowaniu w porz±dku rosn±cym ci±gu e.&nbsp; Zgodnie z punktem 4 
algorytmu, szukamy teraz elementu drugiego 
co do wielko¶ci (6-3-1=2) w ci±gu elementów mniejszych, czyli w ci±gu&nbsp;&nbsp; 4, 1, 3, 2, 
5, 0. Po rozdzieleniu tego ci±gu wzglêdem 4 otrzymamy 1, 2, 3, 0,&nbsp;<b>4,&nbsp; </b>5, bo tylko jeden element jest wiêkszy od 4. Na mocy punktu 3 
algorytmu Hoare, 4 jest szukanym, szóstym co do wielko¶ci elementem danego ci±gu e.</P>

<p style="text-align: left">Zupe³nie inaczej bêdzie wygl±da³ przebieg 
wyszukiwania, je¿eli jako element rozdzielaj±cy we¼miemy ostatni element ci±gu, 
w tym przypadku 0. Wszystkie elementy s± wiêksze od 0, zatem po pierwszym 
rozdzieleniu mamy</P>

<p style="text-align: center"><b>0</b>, 4, 1, 8, 7, 3, 2, 5, 9, 6</P>

<p style="text-align: left">Zgodnie z ide± algorytmu Hoare, nadal szukamy 
elementu szóstego co do wielko¶ci w ci±gu elementów wiêkszych, tzn. 4, 1, 8, 7, 
3, 2, 5, 9, 6. Po ponownym rozdzieleniu wzglêdem elementu ostatniego mamy</P>

<p style="text-align: center">4, 1, 3, 2, 5,<b> 6</b>, 8, 7, 9</P>

<p style="text-align: left">Poniewa¿ s± trzy elementy wiêksze od 6, zatem nale¿y 
teraz szukaæ elementu (6-3-1=2) drugiego co do wielko¶ci w¶ród elementów 
mniejszych od 6. Po kolejnym rozdzieleniu ci±gu 4, 1, 3, 2, 5,wzglêdem 
ostatniego elementu, otrzymamy 4, 1, 3, 2, <b>5. </b>&nbsp;A¿ cztery elementy s± 
mniejsze od 5, zatem musimy jeszcze raz powtórzyæ rozdzielanie. Tym razem 
rozdzielamy ci±g 4, 1, 3, 2, w poszukiwaniu elementu najwiêkszego.<font face="Wingdings">J</font></P>

<p style="text-align: left">Jedyna trudno¶æ w implementacji algorytmu Hoare, to 
wykonanie punktu 1 z mo¿liwie najmniejsz± liczb± porównañ i w taki sposób, by 
zarówno elementy wiêksze jak i mniejsze od elementu rozdzielaj±cego m stanowi³y zwarty segment ci±gu. 
Chcemy przecie¿ zastosowaæ do nich ten sam algorytm. Rozdzielanie mo¿na 
zrealizowaæ przepisuj±c 
wszystkie elementy do tablic pomocniczych, ale nie jest to konieczne. Znane s± 
ró¿ne sposoby realizacji zadania rozdzielania. Przyk³ad 6.2 pokazuje jak wiele 
zale¿y od wyboru elementu rozdzielaj±cego i sposobu rozdzielania ci±gu.</P>

<p style="text-align: left">Przedstawimy poni¿ej algorytm rozdzielania 
dzia³aj±cy w miejscu, tzn. nie wykorzystuj±cy, poza danym ci±giem, ¿adnej 
dodatkowej pamiêci i u¿ywaj±cy elementu ostatniego jako elementu 
rozdzielaj±cego. Algorytm ten zapiszemy w postaci funkcji Partition z dwoma 
parametrami l, p, wskazuj±cymi lewy i prawy koniec rozwa¿anego fragmentu ci±gu, 
l&lt;p. Wynikiem tej funkcji jest pozycja, któr± zajmie w ci±gu element 
rozdzielaj±cy, w taki sposób, ¿e na pozycjach starszych znajduj± siê elementy 
wiêksze od elementu rozdzielaj±cego, a na pozycjach m³odszych, elementy mniejsze 
lub równe od rozdzielaj±cego. Wynik algorytmu, jak zwykle, zapiszemy na zmiennej 
result.</P>

<p style="text-align: left">Niech specyfikacj± algorytmu&nbsp; Patrition 
bêd± warunki:</P>

<p style="text-align: center">wp = {l<font face="Symbol">
<span lang="en">&pound;</span> </font>p },&nbsp; wk = {e[l] <font face="Symbol">
<span lang="en">&pound;</span>...<span lang="en">&pound;</span></font>e[x-1]<font face="Symbol">
<span lang="en">&pound;</span></font>e[x] <font face="Symbol"><span lang="en">&pound;</span>
</font>e[x+1] <font face="Symbol"><span lang="en">&pound;</span>...<span lang="en">&pound;</span></font>e[p], 
result = x}.</P>

<p style="text-align: left">Warunek pocz±tkowy zapewnia tylko, ¿e ci±g ma co 
najmniej jeden element. Natomiast warunek koñcowy ma zapewniæ, ¿e dokonali¶my 
podzia³u ci±gu w po¿±dany sposób.</P>

<p style="text-align: left">&nbsp;<p>
<div class="przyk" style="width: 824; height: 330">
   <TABLE frame="void" rules="none" width="718" height="302" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="147" height="16">int&nbsp; Partition</TD>
            <TD width="413" height="16">&nbsp; (l, p: int)<b>{</b></TD>
             
            <TD width="56" height="16"></TD>
             
            <TD width="920" height="16"> </TD>
             
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><strong>&nbsp;</strong>x := e[p]; i := l 
            - 1; j := l;</TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">//x jest elementem rozdzielaj±cym</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><b>while&nbsp; </b>(j &lt; p) <b>do</b> </TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">//e[k] <font face="Symbol">
            <span lang="en">&pound;</span> </font>x dla k=l,... ,i , oraz x
            <font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla 
            k=i+1,...,j-1</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</b><strong>&nbsp;&nbsp;
            </strong> e[j]<font face="Symbol"><b> </b><span lang="en">&pound;</span></font> 
            x &nbsp;<b>then</b> </TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            </strong>swap(e[i+1], e[j]);</TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">&nbsp;//e[k] <font face="Symbol">
            <span lang="en">&pound;</span> </font>x dla k=l,... ,i, i+1 oraz x
            <font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla 
            k=i+2,...,j</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i := i+1; </TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">//e[k] <font face="Symbol">
            <span lang="en">&pound;</span> </font>x dla k=l,... ,i , oraz x
            <font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla 
            k=i+1,...,j</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>fi;</b></TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16"></TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><b>&nbsp;&nbsp; </b>&nbsp;&nbsp; j := j+1;</TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">//e[k] <font face="Symbol">
            <span lang="en">&pound;</span> </font>x dla k=l,... ,i , oraz x
            <font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla 
            k=i+1,...,j-1</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16"><strong>od ;&nbsp;&nbsp; </strong></TD> 
            <TD width="56" height="16"></TD> 
            <TD width="920" height="16">//&nbsp;j=p</TD> 
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16">   swap(e[i+1],e[p]);&nbsp;
             </TD>
            <TD width="56" height="16">   </TD>
            <TD width="920" height="16">   &nbsp;//e[k] <font face="Symbol">
            <span lang="en">&pound;</span> </font>x dla k=l,... ,i , oraz x
            <font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla 
            k=i+1,...,p</TD>
         </TR>
         <TR>
            <TD width="147" height="16"></TD>
            <TD width="413" height="16">   result := i+1;   <STRONG>return&nbsp; </STRONG>
             result</TD>
            <TD width="56" height="16">   </TD>
            <TD width="920" height="16">   </TD>
         </TR>
         <TR>
            <TD width="147" height="16"><strong>&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="413" height="16">   &nbsp;</TD>
            <TD width="56" height="16">   </TD>
            <TD width="920" height="16">   &nbsp;</TD>
         </TR>
         </TABLE>
</div>

<p style="text-align: left">Rola wska¼ników i, j w algorytmie Partition jest 
nastêpuj±ca: wszystkie elementy na pozycjach od l do i s± mniejsze lub równe&nbsp; 
x, na pozycjach od&nbsp; i+1 do j-1, s± wiêksze od x. Pozosta³ych miejsc jeszcze 
nie zbadali¶my.</P>

<p style="text-align: left"><b>Przyk³ad 6.3</b></P>

<p style="text-align: left">Przyjrzyjmy siê kolejnym stanom tablicy, do której 
zastosowano algorytm Partition. Element rozdzielaj±cy zosta³ zaznaczony kolorem 
czerwonym. Elementy mniejsze maj± kolor ¿ó³ty, a elementy wiêksze kolor 
fioletowy. W osobnych kolumnach zapisali¶my warto¶ci zmiennych i, j. </P>
<center>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="58%" id="AutoNumber1">
  <tr>
    <td width="8%" align="center" bgcolor="#C0C0C0">1</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">2</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">3</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">4</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">5</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">6</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">7</td>
    <td width="8%" align="center" bgcolor="#C0C0C0">8</td>
    <td width="9%" align="center" bgcolor="#C0C0C0">9</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp;&nbsp;&nbsp; i</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp;&nbsp;&nbsp; j</td>
  </tr>
  <tr>
    <td width="8%" align="center">3</td>
    <td width="8%" align="center">2</td>
    <td width="8%" align="center">6</td>
    <td width="8%" align="center">9</td>
    <td width="8%" align="center">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center">4</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 0</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 1</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center">2</td>
    <td width="8%" align="center">6</td>
    <td width="8%" align="center">9</td>
    <td width="8%" align="center">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 1</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 2</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center">6</td>
    <td width="8%" align="center">9</td>
    <td width="8%" align="center">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 2</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 3</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center">9</td>
    <td width="8%" align="center">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 2</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 4</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="8%" align="center">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 2</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 5</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">5</td>
    <td width="8%" align="center">1</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 2</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 6</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#FFFF00">1</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">5</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 3</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 7</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#FFFF00">1</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">5</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">8</td>
    <td width="8%" align="center">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 3</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 8</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#FFFF00">1</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">5</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">8</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">7</td>
    <td width="9%" align="center"><font face="Verdana" color="#FF0000">4</font></td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; i = 3</td>
    <td width="12%" align="center" bgcolor="#CCCCFF">&nbsp;&nbsp; j = 9</td>
  </tr>
  <tr>
    <td width="8%" align="center" bgcolor="#FFFF00">3</td>
    <td width="8%" align="center" bgcolor="#FFFF00">2</td>
    <td width="8%" align="center" bgcolor="#FFFF00">1</td>
    <td width="8%" align="center">4</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">5</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">6</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">8</td>
    <td width="8%" align="center" bgcolor="#DDA0DD">7</td>
    <td width="9%" align="center" bgcolor="#DDA0DD">9</td>
    <td width="24%" align="center" bgcolor="#CCCCFF" colspan="2" rowspan="2">
    result = 4</td>
  </tr>
  <tr>
    <td width="73%" align="center" colspan="9">&nbsp;</td>
  </tr>
</table>
</center>

<p>Ka¿dy wiersz tabeli zawiera stan ci±gu po wykonaniu kolejnej iteracji pêtli. 
Gdy j=9 opuszczamy pêtlê &quot;while&quot; i wykonujemy zamianê pozycji 4tej i 9tej, 
umieszczaj±c tym samym element rozdzielaj±cy 4&nbsp; na pozycji czwartej. Na 
pozycjach mniejszych ni¿ 4 znalaz³ siê elementy mniejsze od rozdzielaj±cego, a 
na pozycjach wiêkszych ni¿ 4 znalaz³y siê elementy wiêksze.<font face="Wingdings">J</font></P>

<p style="text-align: left"><b>Poprawno¶æ algorytmu Partition</b>: Za³ó¿my, ¿e 
po wej¶ciu do pêtli &quot;while&quot; (tzn. j&lt;p) spe³niony jest warunek&nbsp;
<font face="Symbol">g</font>(i,j) postaci:</P>

<p style="text-align: center">e[k] <font face="Symbol"><span lang="en">&pound;</span>
</font>x dla k= l,... ,i&nbsp;&nbsp;&nbsp; oraz&nbsp;&nbsp; x
<font face="Symbol"><span lang="en">&pound;</span></font> e[k] dla k=i+1,...,j-1</P>

<p style="text-align: left">Odpowiada to nastêpuj±cej sytuacji:</P>

<p style="text-align: left">
<img border="0" src="Rysunki/Rysunek3_4.gif" width="698" height="165"></P>

<p style="text-align: left">Je¿eli element na pozycji j-tej (ten o najmniejszym 
indeksie, którego jeszcze nie zbadali¶my) jest mniejszy lub równy elementowi 
rozdzielaj±cemu x, to musimy go umie¶ciæ w segmencie elementów
<font face="Symbol"><span lang="en">&pound;</span> </font>x. Wykonuj±c operacjê 
swap(e[i+1],e[j]), powiêkszymy segment elementów <font face="Symbol">
<span lang="en">&pound;</span> </font>x. Musimy wiêc uaktualniæ wska¼nik i, co 
robimy wykonuj±c instrukcjê i:=i+1. Lista 
elementów wiêkszych koñczy siê teraz na pozycji jtej. Jednak po wykonaniu&nbsp; 
instrukcji j:= j+1 nadal spe³nione jest <font face="Symbol">g</font>(i,j).&nbsp; </P>

<p style="text-align: left">Je¿eli element na pozycji j-tej jest wiêkszy od 
elementu rozdzielaj±cego, to powinien on powiêkszyæ segment elementów &gt; x. 
Wystarczy wiêc przesun±æ wska¼nik j o jedno miejsce w prawo. Oczywi¶cie, znów 
spe³niona jest formu³a <font face="Symbol">g</font>(i,j). </P>

<p style="text-align: left">Wniosek: formu³a </P>

<p style="text-align: center">e[k] <font face="Symbol"><span lang="en">&pound;</span>
</font>x dla k=l,... ,i&nbsp;&nbsp;&nbsp; oraz&nbsp;&nbsp; x <font face="Symbol">
<span lang="en">&pound;</span></font> e[k] dla k=i+1,...,j-1</P>

<p style="text-align: left">jest niezmiennikiem pêtli w algorytmie Partition. 
Innym niezmiennikiem (uzasadnienie pozostawiamy Czytelnikowi) jest formu³a j
<font face="Symbol"><span lang="en">&pound;</span></font> p. Zatem po wykonaniu pêtli 
warto¶ci± j jest p oraz spe³niony jest warunek koñcowy specyfikacji tego 
algorytmu.&nbsp; </P>

<p></P>

<div class="twier">
<p>Twierdzenie 6.1&nbsp; Dla dowolnego niepustego ci±gu o elementach z dowolnej struktury 
danych, która ma okre¶lony liniowy porz±dek, algorytm Partition zatrzymuje siê, a otrzymany wynik spe³nia warunek koñcowy </P>
<p style="text-align: center">e[l] <font face="Symbol">
<span lang="en">&pound;</span> ... <span lang="en">&pound;</span> </font>e[result-1]<font face="Symbol">
<span lang="en">&pound;</span> </font>e[result] <font face="Symbol"><span lang="en">&pound;</span>
</font>e[result+1] <font face="Symbol"><span lang="en">&pound;</span> ... <span lang="en">&pound;</span></font> e[p].</P>
</div>

<p style="text-align: left"><b>Koszt algorytmu Partition:</b> Liczba porównañ 
wykonanych w procesie rozdzielania zale¿y od liczby elementów znajduj±cych siê w 
rozwa¿anej czê¶ci ci±gu. W ka¿dej iteracji pêtli &quot;while&quot; wykonujemy tylko jedno 
porównanie. Pêtla &quot;while&quot; jest wykonywana dok³adnie p - l razy. Zatem dla ci±gu 
n elementowego&nbsp; koszt algorytmu wynosi: T(Partition,n) =
<font face="Symbol">Q</font>(n).</P>

<p style="text-align: left">Algorytm Hoare zapiszemy jako algorytm rekurencyjny 
Hoare(e, l, p,k), którego parametrami s± ci±g elementów typu <i>elem</i>, l, p&nbsp; 
to indeksy lewego i prawego koñca&nbsp; fragmentu ci±gu, w którym bêdziemy 
kontynuowaæ poszukiwania oraz k- numer poszukiwanego elementu. Wynikiem 
algorytmu jest obiekt typu <i>elem, </i>k-ty najwiêkszy element ci±gu<i>.</i></P>

<p style="text-align: left">&nbsp;<p>
<div class="przyk" style="width: 846; height: 330">
   <TABLE frame="void" rules="none" width="819" height="302">
         <TR>
            <TD width="48" height="16">elem </TD>
            <TD width="558" height="16">&nbsp;Hoare (e: ci±g, l, p, k: int)</TD>
             
            <TD width="25" height="16"></TD>
             
            <TD width="721" height="16"> </TD>
             
         </TR>
         <TR>
            <TD width="48" height="16"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;
            </b></TD>
            <TD width="558" height="16"><strong>&nbsp;</strong>j := Partition(l,p);</TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">//j jest pozycj± elementu rozdzielaj±cego: na prawo 
            elementy niemniejsze, na lewo elementy mniejsze.</TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16"><b>if </b>(p-j = k-1) <b>then</b> result 
            := e[j]<b> </b>&nbsp;</TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">//e[j] jest mniejsze od dok³adnie k-1 
            elementów</TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16"><b>else</b><strong>&nbsp;&nbsp;&nbsp;
            </strong> </TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            if </strong>(p-j&gt;k-1)<strong> then
            </strong></TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">&nbsp;//jest co najmniej k elementów 
            wiêkszych od e[j]</TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            result:=Hoare(e, j+1, p, k);<strong>&nbsp; </strong></TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">//e[result] jest k-tym co do wielko¶ci 
            elementem ci±gu e[j+1],...,e[p] </TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <b>else </b>&nbsp; </TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16"></TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16"><strong>&nbsp;&nbsp;&nbsp; </strong><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </b>result <b>:= </b>Hoare(e, l, j-1, k-(p-j+1);<b> </b><strong>&nbsp;&nbsp; </strong></TD> 
            <TD width="25" height="16"></TD> 
            <TD width="721" height="16">&nbsp;//e[result] jest k-(p-j+1)-tym co 
            do wielko¶ci elementem ci±gu e[l],e[l+1],...e[j-1]</TD> 
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16">   <STRONG>&nbsp; </STRONG>
             <b>fi</b><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi&nbsp; </STRONG>
             </TD>
            <TD width="25" height="16">   </TD>
            <TD width="721" height="16">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="48" height="16"></TD>
            <TD width="558" height="16">   <strong>return </strong>&nbsp;e[result]</TD>
            <TD width="25" height="16">   </TD>
            <TD width="721" height="16">   //e[result] jest k-tym co do 
            wielko¶ci elementem ci±gu e</TD>
         </TR>
         <TR>
            <TD width="48" height="16"><strong>&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="558" height="16">   &nbsp;</TD>
            <TD width="25" height="16">   </TD>
            <TD width="721" height="16">   &nbsp;</TD>
         </TR>
         </TABLE>
</div>

<p><b>Koszt algorytmu Hoare.</b> Algorytm Hoare w najgorszym przypadku mo¿e 
dzia³aæ tak ¼le, jak algorytm naiwny. Je¿eli dany ci±g jest uporz±dkowany 
rosn±co, to w ka¿dym rekurencyjnym wywo³aniu funkcji Partition, liczba elementów 
mniejszych od rozdzielaj±cego jest zbiorem pustym. Zatem, o ile trzeba 
kontynuowaæ poszukiwania k-tego co do wielko¶ci elementu, kontynuuje siê je w 
ci±gu elementów o jeden krótszym. Bior±c pod uwagê koszt Partition, otrzymujemy 
(n-1) + (n-2) + ...+(n-k) = kn - k(k+1)/2 porównañ w przypadku pesymistycznym. 
Na szczê¶cie koszt ¶redni algorytmu Hoare jest zdumiewaj±co dobry. Udowodniono, 
¿e ¶redni koszt algorytmu Hoare jest liniowy O(n).<p><b>Poprawno¶æ:</b> Dok³adny 
dowód poprawno¶ci algorytmu Hoare mo¿na przeprowadziæ przez indukcjê ze wzglêdu 
na pewien porz±dek trójek (l,p,k). My zauwa¿ymy tylko, ¿e w wyniku dzia³ania 
Partition spe³niony mamy warunek:<p style="text-align: center">e[l] <font face="Symbol">
<span lang="en">&pound;</span>...<span lang="en">&pound;</span></font>e[j-1]<font face="Symbol">
<span lang="en">&pound;</span></font>e[j] <font face="Symbol"><span lang="en">&pound;</span>
</font>e[j+1] <font face="Symbol"><span lang="en">&pound;</span>...<span lang="en">&pound;</span></font>e[p],<p style="text-align: left">
Element e[j] jest szukanym k-tym co do wielko¶ci elementem, gdy&nbsp; p- j +1 = 
k. Rzeczywi¶cie, jedyne wiêksze od e[j] elementy znajduj± siê na pozycjach 
j+1,...,p i jest ich wtedy dok³adnie k-1. Je¿eli elementów wiêkszych od e[j] 
jest co najmniej k (tzn. p-j&gt;k-1), to szukanie k-tego elementu musimy 
kontynuowaæ w³a¶nie w¶ród tych elementów, a elementy mniejsze od e[j] mo¿emy 
pomin±æ. Je¿eli elementów wiêkszych od e[j] jest niewiele (tzn. p-j &lt;k), to nie 
ma w¶ród nich k-tego najwiêkszego. Co wiêcej te wiêksze elementy oraz element 
e[j] mo¿emy pomin±æ w dalszych rozwa¿aniach i poszukiwaæ w¶ród elementów 
mniejszych od e[j], elementu k-(p-j+1)-tego co do wielko¶ci. Je¿eli wywo³ania 
rekurencyjne Hoare(e, j+1, p, k) oraz<b>&nbsp;&nbsp;&nbsp;
            </b>Hoare(e, l, j-1, k-(p-j+1)) daj± poprawne wyniki, to warto¶æ 
zwracana jako wynik wywo³ania Hoare(e,l,p,k) jest te¿ ustalona poprawnie.<p><b>
Pytanie 8: </B>Jaki jest koszt algorytmu Hoare wyszukiwania elementu k-tego co 
do wielko¶ci w ci±gu uporz±dkowanym rosn±co? &nbsp;  <br>

<FORM>
<INPUT class="GUZIK" TYPE='button' VALUE='------Zobacz odpowied¼------' NAME='Klik0' 
onClick="napis(this.form,'n-1 +n-2 +... n-k = nk -k(k+1)/2');">
</form>

<p><br clear="all">
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p5.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr>
</table>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>