<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 4"></A><br clear="all"><div class="tytulpunktu">
  4.  Optymalny algorytm min_max. </div>

<p>Algorytmy, o których mówili¶my do tej pory dzia³a³y &quot;w miejscu&quot;, tzn. poza 
kilkoma zmiennymi pomocniczymi nie wykorzystywa³y ¿adnych dodatkowych struktur. 
Algorytm, który zamierzamy teraz omówiæ, u¿ywa dwóch dodatkowych tablic, o 
³±cznej d³ugo¶ci równej rozmiarowi danych. </P>
<p><b>Metoda</b></P>
<p>Porównujemy parami elementy ci±gu. Element mniejszy z ka¿dej pary 
zapamiêtujemy w tablicy MNIEJSZE, a element wiêkszy z ka¿dej pary zapamiêtujemy 
w tablicy 
WIÊKSZE. Nastêpnie w tablicy MNIEJSZE znajdujemy element minimalny, a w tablicy 
WIÊKSZE znajdujemy element maksymalny. Je¶li liczba elementów w ci±gu nie jest 
parzysta, to element ostatni musi jeszcze byæ porównany ze znalezionym elementem 
minimalnym i, o ile nie jest od niego mniejszy, ze znalezionym elementem 
maksymalnym.</P>
<p>W przedstawionej realizacji tej metody u¿yjemy zmiennej result dla 
zapamiêtania elementów najmniejszego i najwiêkszego i dla uproszczenia za³o¿ymy, 
¿e liczba elementów w ci±gu e jest parzysta.</P>

<p></P>

<div class="def" style="width: 778; height: 324">
   <TABLE frame="void" rules="none" width="746">
         <TR>
            <TD width="33"> <p>min_max4{</TD>
            <TD width="758">&nbsp;</TD>
             
            <TD width="29">&nbsp;</TD>
             
            <TD width="734">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">&nbsp;i := 1; k := 1;</TD>
             
            <TD width="29">&nbsp;</TD>
             
            <TD width="734">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758"><STRONG>while </STRONG>
            (i<FONT FACE="Symbol"> +1 <span lang="en">&pound;</span> </FONT>n)  <STRONG>do </STRONG></TD> 
            <TD width="29">&nbsp;</TD> 
            <TD width="734">&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; </STRONG>
             (e[i] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[i+1])   <STRONG>then </STRONG></TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   //(<font face="Symbol">&quot;</font>j&lt;k)(<font face="Symbol">$</font>j<sub><font face="Verdana">0</font></sub>&lt;k) MNIEJSZE[j]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            WIÊKSZE[j<sub><font face="Verdana">0</font></sub>]</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="758">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            MNIEJSZE[k] := e[i]; WIÊKSZE[k] := e[i+1];</TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="758">   &nbsp;&nbsp;&nbsp;&nbsp; <b>else</b></TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="758">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            MNIEJSZE[k] := e[i+1]; WIÊKSZE[k] := e[i];</TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="758">   &nbsp;&nbsp;&nbsp;&nbsp; <b>fi;</b></TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   //(<font face="Symbol">&quot;</font>j<font face="Symbol"><span lang="en">&pound;</span></font>k)(<font face="Symbol">$</font>j<sub><font face="Verdana">0</font></sub><font face="Symbol"><span lang="en">&pound;</span></font>k) 
            MNIEJSZE[j]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            WIÊKSZE[j<sub><font face="Verdana">0</font></sub>]</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">      &nbsp;&nbsp;&nbsp;&nbsp;      i := i+2; &nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="29">      &nbsp;</TD>
             
            <TD width="734">      &nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="758">      &nbsp;&nbsp;&nbsp;&nbsp; k := k+1;</TD>
             
            <TD width="29">      &nbsp;</TD>
             
            <TD width="734">      //(<font face="Symbol">&quot;</font>j<font face="Symbol">&lt;</font>k)(<font face="Symbol">$</font>j<sub><font face="Verdana">0</font></sub><font face="Symbol">&lt;</font>k) 
            MNIEJSZE[j]<font face="Symbol"> <span lang="en">&pound;</span> </font>
            WIÊKSZE[j<sub><font face="Verdana">0</font></sub>]</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">   <STRONG>&nbsp;od ;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG></TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">      result.min := min(MNIEJSZE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD> 
            <TD width="29">      &nbsp;</TD> 
            <TD width="734">      &nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="758">   result.max := max(WIÊKSZE);&nbsp;&nbsp;&nbsp; </TD>
            <TD width="29">   &nbsp;</TD>
            <TD width="734">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="758"></TD>
            <TD width="29">&nbsp;</TD>
            <TD width="734">&nbsp;</TD>
         </TR>
   </TABLE>
 </div>
 
<p>

 <b>Poprawno¶æ algorytmu min_max4</b><p>

 Niezmiennikiem pêtli w tym algorytmie jest formu³a <font face="Symbol">g</font> 
 postaci:<p style="text-align: center">

 (<font face="Symbol">&quot;</font>j&lt;k)(<font face="Symbol">$</font>j<sub><font face="Verdana">0</font></sub>&lt;k) MNIEJSZE[j]<font face="Symbol">
 <span lang="en">&pound;</span> </font>WIÊKSZE[j<sub><font face="Verdana">0</font></sub>] oraz (<font face="Symbol">&quot;</font>j&lt;k)(<font face="Symbol">$</font>j<sub><font face="Verdana">0</font></sub>&lt;k) MNIEJSZE[j<sub><font face="Verdana">0</font></sub>]<font face="Symbol">
 <span lang="en">&pound;</span> </font>WIÊKSZE[j].<p>

 Formu³a ta mówi, ¿e dla ka¿dego elementu w³o¿onego do tablicy MNIEJSZE znajdzie 
 siê element w tablicy WIEKSZE, który jest od niego wiêkszy, i odwrotnie.

 Ponadto, ka¿dy element ci±gu e, jest albo elementem tablicy MNIEJSZE, albo 
 elementem tablicy WIÊKSZE. Je¶li szukamy elementu najmniejszego, to nie mo¿e 
 siê on znajdowaæ w tablicy WIÊKSZE, bo zgodnie z formu³± <font face="Symbol">g</font> 
 po wykonaniu pêtli, ka¿dy element z tablicy WIÊKSZE ma od siebie mniejszy lub 
 równy element w tablicy&nbsp; MNIEJSZE. Podobnie, nie mo¿emy szukaæ elementu 
 najwiêkszego w¶ród elementów MNIEJSZE, bo ka¿dy element z tablicy MNIEJSZE ma 
 od siebie wiêkszy lub równy element w tablicy WIÊKSZE. Wynika st±d, ¿e element 
 najmniejszy ci±gu e znajduje siê w tablicy MNIEJSZE, a element najwiêkszy - w 
 tablicy WIÊKSZE.<p>

 Z rozwa¿añ w poprzednim wyk³adzie wiemy, ¿e funkcja minimum zastosowana do 
 dowolnego niepustego ci±gu zwraca element najmniejszy w tym ci±gu. Na mocy 
 za³o¿enia n<font face="Verdana"> &#8805; 2</font>, z czego wynika, ¿e tablice MNIEJSZE i WIÊKSZE s± 
 niepuste. Zatem po wykonaniu&nbsp; instrukcji {result.min := min(MNIEJSZE);} mamy<p style="text-align: center">

 &nbsp;result.min = MNIEJSZE[i] dla pewnego i<font face="Symbol"> 
 =</font> 1,..., n div 2,&nbsp;&nbsp;&nbsp; result.min <font face="Symbol">
 <span lang="en">&pound;</span> </font>MNIEJSZE[k] dla&nbsp; k=1,..., n div 2 <p>

 oraz&nbsp; po wykonaniu instrukcji {result.max := max(WIÊKSZE);} mamy<p style="text-align: center">

 result.max = WIÊKSZE[i] dla pewnego i,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WIÊKSZE[k]&nbsp; <font face="Symbol">
 <span lang="en">&pound;</span> </font>result<font face="Symbol">.</font>max dla&nbsp; k=1,..., n div 2 .<p>

 Ostatecznie po wykonaniu programu, warto¶ci± zmiennej resunlt.min jest najmniejszy 
 element ci±gu e, a warto¶ci± zmiennej result.max jest najwiêkszy element ci±gu e.<p>

 &nbsp;<p></P>

<div class="twier">
<p>Twierdzenie 4.1&nbsp; Algorytm min_max4 jest ca³kowicie poprawnym rozwi±zaniem problemu min-max ze 
wzglêdu na warunek pocz±tkowy&nbsp; (n&gt;0 <span lang="en"><font face="Symbol">&Ugrave;</font></span> 
(n mod 2 = 0))<font face="Symbol"> </font>i warunek koñcowy  </P>
<p style="text-align: center">(<font face="Symbol">&quot;</font>i<font face="Symbol"><span lang="en">&pound;</span>
</font>n)(e[i] <font face="Symbol"><span lang="en">&pound;</span> </font>result.max
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>result.min <font face="Symbol">
<span lang="en">&pound;</span></font> e[i])</P>
<p>&nbsp;w ka¿dej strukturze danych STR, w 
której&nbsp; okre¶lony jest liniowy porz±dek elementów. </P>
  </div>
  
<p><b>Koszt algorytmu min_max4</b></P>
  
<p>Koszt tego algorytmu ³atwo oszacowaæ, bo w ka¿dym kroku pêtli wykonujemy 
(niezale¿nie od konkretnych warto¶ci elementów ci±gu)&nbsp; dok³adnie jedno 
porównanie, co ³±cznie daje n div 2 porównañ. Z analizy algorytmów minimum i 
maksimum&nbsp; wiemy (obie tablice pomocnicze maj± d³ugo¶æ [n/2]), ¿e wykonuj± 
one dok³adnie (n div 2 -1) porównañ, co daje ostatecznie 3n/2 - 2 porównañ, </P>
  
<p style="text-align: center">T(min_max4,n) = 3n/2 - 2.</P>
<p>

 Przygl±daj±c siê bli¿ej podanej metodzie, dojdziemy z pewno¶ci± do wniosku, ¿e 
 tablice pomocnicze nie s± nam potrzebne. Mo¿emy przecie¿ na 
 bie¿±co modyfikowaæ zarówno warto¶æ result.min jak warto¶æ result.max, tak jak to siê dzieje 
 w algorytmach minimum i maksimum.<p>

 Idea tego nowego algorytmu bêdzie bardzo podobna do przedstawionej w min_max4. 
 Rozwa¿amy kolejne pary elementów. Z ka¿dej pary wybieramy element mniejszy i 
 porównujemy z aktualnie znalezionym elementem najmniejszym. Podobnie wiêkszy 
 element z ka¿dej pary porównujemy z aktualnie znalezionym elementem 
 najwiêkszym. Po przejrzeniu wszystkich par znajdziemy równocze¶nie element 
 najmniejszy i element najwiêkszy. Podobnie jak w poprzednim algorytmie, 
 za³o¿ymy dla wygody, ¿e liczba elementów w ci±gu e jest parzysta i wiêksza od 
 1.<p>

 &nbsp;<p></P>

<div class="def" style="width: 803; height: 390">
   <TABLE frame="void" rules="none" width="783">
         <TR>
            <TD width="33"> <p>min_max5{</TD>
            <TD width="776"><A NAME="EDU.wyklad.punkt 5"></A></TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   <STRONG>&nbsp;if&nbsp; </STRONG>
             (e[1] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[2])   <STRONG>then </STRONG></TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">&nbsp;&nbsp;&nbsp;&nbsp; result.min := e[1]; result.max := e[2];</TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776"> <b>else</b></TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">&nbsp;&nbsp;&nbsp;&nbsp; result.min := e[2]; result.max := e[1];</TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776"> <b>fi;</b></TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">// (<font face="Symbol">&quot;</font>j<font face="Symbol">
            <span lang="en">&pound;</span> </font>2) (result.min<font face="Symbol">
            <span lang="en">&pound;</span></font> e[j]<font face="Symbol">
            <span lang="en">&pound;</span> </font>result.max)</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="776">&nbsp;i := 3; </TD>
             
            <TD width="50">&nbsp;</TD>
             
            <TD width="732">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="776"><STRONG>while </STRONG>
            (i<FONT FACE="Symbol"> +1 <span lang="en">&pound;</span> </FONT>n)  <STRONG>
            do </STRONG></TD> 
            <TD width="50">&nbsp;</TD> 
            <TD width="732">// (<font face="Symbol">&quot;</font>j<font face="Symbol">
            <span lang="en">&pound;</span> </font>i-1) (result.min<font face="Symbol">
            <span lang="en">&pound;</span></font> e[j]<font face="Symbol">
            <span lang="en">&pound;</span> </font>result.max)&nbsp; </TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="776">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; </STRONG>
             (e[i] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[i+1])   <STRONG>then&nbsp; </STRONG></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            x := e[i]; y :=e[i+1]   <STRONG>&nbsp;</STRONG></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   //&nbsp; x = min(e[i],e[i+1]), y = max(e[i],e[i+1])</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</STRONG></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong> x :=e[i+1];   <strong>&nbsp;</strong>y := e[i]</TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   &nbsp; </TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi;</STRONG></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   &nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>&nbsp; not (result.min <FONT FACE="Symbol"> <span lang="en">
            &pound;</span> </FONT>
            x) <b>then</b> result.min := x<b> fi</b>; </TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   // (<font face="Symbol">&quot;</font>j<font face="Symbol">
            <span lang="en">&pound;</span> </font>i+1) (result.min<font face="Symbol">
            <span lang="en">&pound;</span></font> e[j]<font face="Symbol"> </font>)</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="776">   &nbsp;&nbsp;&nbsp; <b>&nbsp;if</b> not (y <FONT FACE="Symbol"> <span lang="en">
            &pound;</span> </FONT>
            result.max) <b>then</b> result.max := y <b>fi;</b></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   // ((<font face="Symbol">&quot;</font>j<font face="Symbol">
            <span lang="en">&pound;</span> </font>i+1) (e[j]<font face="Symbol">
            <span lang="en">&pound;</span> </font>result.max)</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="776">      &nbsp;&nbsp;&nbsp;&nbsp;      i := i + 2; &nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="50">      &nbsp;</TD>
             
            <TD width="732">      // (<font face="Symbol">&quot;</font>j<font face="Symbol">
            <span lang="en">&pound;</span> </font>i-1) (result.min<font face="Symbol">
            <span lang="en">&pound;</span></font> e[j]<font face="Symbol">
            <span lang="en">&pound;</span> </font>result.max)</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="776">   <STRONG>&nbsp;od ;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG></TD>
            <TD width="50">   &nbsp;</TD>
            <TD width="732">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="776"></TD>
            <TD width="50">&nbsp;</TD>
            <TD width="732">&nbsp;</TD>
         </TR>
   </TABLE>
 </div>
 
<p>

 <b>Poprawno¶æ algorytmu min_max5</b><p>

 Niezmiennikiem w tym algorytmie (porównaj komentarze) jest formu³a<p style="text-align: center">

 (<font face="Symbol">&quot;</font>j<font face="Symbol"> <span lang="en">&pound;</span>
 </font>i-1) (result.min<font face="Symbol"> <span lang="en">&pound;</span></font> e[j]<font face="Symbol">
 <span lang="en">&pound;</span> </font>result.max).<p>

 Rzeczywi¶cie, je¶li przy pewnej warto¶ci i wchodzimy do pêtli i spe³niona jest 
 formu³a (<font face="Symbol">&quot;</font>j<font face="Symbol"> <span lang="en">&pound;</span>
 </font>i-1) (result.min<font face="Symbol"> <span lang="en">&pound;</span></font> e[j]<font face="Symbol">
 <span lang="en">&pound;</span> </font>result.max), która mówi, ¿e warto¶ci± 
 result.min jest element 
 najmniejszy, a warto¶ci± result.max jest element najwiêkszy ze wszystkich&nbsp; 
 elementów o indeksach mniejszych ni¿ i, to porównuj±c result.min z mniejszym elementem 
 nastêpnej pary (e[i],e[i+1]), a result.max z wiêkszym elementem tej pary, 
 znajdziemy element najmniejszy ze wszystkich elementów a¿ do (i+1)-go. Podobnie porównuj±c 
 result.max z wiêkszym elementem tej pary, znajdziemy element najwiêkszy ze wszystkich 
 elementów a¿ do (i+1)-go. Poniewa¿ przed wej¶ciem do pêtli niezmiennik jest 
 prawdziwy, to po wyj¶ciu z pêtli jest równie¿ prawdziwy. Ponadto, po wyj¶ciu z 
 pêtli warto¶ci± 
 zmiennej i jest n+1. Dowodzi to poprawno¶ci algorytmu min_max5 ze wzglêdu na 
 warunek pocz±tkowy (n&gt;1 <font face="Symbol"><span lang="en">&Ugrave;</span> </font>n 
 mod 2 = 0) i warunek koñcowy (<font face="Symbol">&quot;</font>j<font face="Symbol">
 <span lang="en">&pound;</span> </font>n) (result.min<font face="Symbol"> <span lang="en">&pound;</span></font> 
 e[j]<font face="Symbol"> <span lang="en">&pound;</span> </font>result.max). <p><b>Koszt 
algorytmu min_max5</b></P>
<p>Koszt algorytmu min_max5, tak jak wszystkich poprzednich, mierzymy liczb± 
wykonanych porównañ elementów danego ci±gu. Przyjmijmy n=2k. Przed wej¶ciem do 
pêtli wykonujemy 1 porównanie. W pêtli warto¶ci zmiennej i, kontroluj±cej pêtlê, 
zmieniaj± siê co 2. Zatem pêtla wykona (n-2)/2 iteracji. W ka¿dej iteracji 
wykonujemy 3 porównania, co daje ³±czny koszt</P>
<p style="text-align: center">T(min_max5) = 3 (n-2)/2 +1 = 3n/2-2. </P>
<p>Koszt tego algorytmu jest wiêc taki sam, jak koszt dwóch poprzednich 
algorytmów. Nie wykorzystuje on rekursji i nie korzysta z dodatkowych miejsc 
pamiêci, poza trzema zmiennymi pomocniczymi. Ponadto algorytm ten nie modyfikuje  stanu ci±gu 
wej¶ciowego, co czasami jest istotne dla dalszej obróbki tych danych.</P>
<p>Na zakoñczenie tego punktu zanotujmy jeszcze, ¿e omawiany algorytm jest 
optymalny w klasie algorytmów rozwi±zuj±cych problem min-max w modelu drzew 
decyzyjnych, tzn. przez porównywanie elementów. Oznacza to, ¿e ka¿dy algorytm 
tej klasy dla danych rozmiaru&nbsp; n musi w przypadku pesymistycznym wykonaæ co 
najmniej 3n/2 -2 porównañ.</P>
<p></P>

<div class="twier">
<p>Twierdzenie 4.2&nbsp; Algorytm min_max5 (a tak¿e min_max3) jest optymalnym rozwi±zaniem problemu równoczesnego 
wyszukiwania minimum i maksimum przez porównywanie elementów. </P>
  </div>
  
<p>Dowód optymalno¶ci pomijamy. Dociekliwych Czytelników odsy³amy do ksi±¿ki <i>
Elementy analizy algorytmów</i>, L. Banachowski, A. Kreczmar, WNT, 1982. </P>
  
<p></P>
<p></P>

<p><b>Pytanie 5</B>: Jaki jest koszt pamiêciowy algorytmu min_max4? </P>

<!-- <p>Odpowied¼: 2n.</P> -->

<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'2n')">
</p>
</form>
<p><br clear="all"></p>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>