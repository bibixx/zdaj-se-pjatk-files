<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">1.&nbsp; Problem min-max. Algorytm naiwny.</div> 

<p>Problem, który rozwa¿ymy w 
tym punkcie, to znalezienie elementu najmniejszego i najwiêkszego w danym 
skoñczonym  zbiorze, reprezentowanym przez tablicê e o elementach e[1], ..., e[n]. 
Dla uproszczenia nazywaæ bêdziemy ten problem min-max. Zaczniemy od prostego 
rozwi±zania, tzw. algorytmu 
naiwnego, który w nastêpnych punktach tego wyk³adu nieco poprawimy. Przyjmiemy, 
¿e poszukiwany algorytm bêdzie u¿ywa³ zmiennej result, reprezentuj±cej obiekt o 
dwóch atrybutach : min i max, na 
których zostan± zapamiêtane wyniki.</P>

<p>Algorytm rozwi±zuj±cy problem&nbsp; min-max, interpretowany w strukturze, w 
której uniwersum jest zbiorem liniowo uporz±dkowanym,&nbsp; powinien byæ poprawny ze wzglêdu na 
nastêpuj±c± specyfikacjê:</P>

<p style="text-align: center">&nbsp;wp = {n&gt;0},&nbsp;&nbsp; </P>

<p style="text-align: center">wk = {(<font face="Symbol">$</font> i<sub><font face="Verdana">0</font></sub>,i<sub><font face="Verdana">1</font></sub><font face="Symbol"> <span lang="en">&pound;</span> </font>
n) (e[i<sub><font face="Verdana">0</font></sub>]=result.min <span lang="en">
<font face="Symbol">&Ugrave;</font></span> 
e[i<sub><font face="Verdana">1</font></sub>] = result.max), (<font face="Symbol">&quot;</font>j<font face="Symbol"><span lang="en">&pound;</span> </font>
n)(e[i] <span lang="en"> <font face="Symbol">&pound;</font></span> result.min
<span lang="en"><font face="Symbol">&Ugrave;</font></span> result.max <font face="Symbol"><span lang="en">&pound;</span> </font>e[i])}.</P>

<p style="text-align: left"><b>Metoda</b></P>

<p style="text-align: left">Najprostszym rozwi±zaniem problemu min-max jest 
znalezienie najpierw elementu najwiêkszego, a potem elementu najmniejszego przez 
dwukrotne przegl±danie ci±gu. Je¿eli kolejny element jest wiêkszy od 
najwiêkszego znalezionego do tej pory, to bêdzie on teraz elementem najwiêkszym. 
Podobnie przy wyszukiwaniu elementu najmniejszego: porównujemy kolejne elementy 
ci±gu ze znalezionym elementem najmniejszym i ewentualnie poprawiamy jego 
warto¶æ, tak by warto¶ci± zmiennej result.min by³ element najmniejszy ze wszystkich 
przejrzanych do tej pory elementów.&nbsp; Algorytm mo¿e byæ zapisany 
nastêpuj±co:</P>


<p><div class="przyk" style="width: 750; height: 324">
   <TABLE frame="void" rules="none" width="718">
         <TR>
            <TD width="33"> <p>min_max1</TD>
            <TD width="392">{</TD>
             
            <TD width="615">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">result.max := e[1]; i := 2; </TD>
             
            <TD width="615">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392"><STRONG>while </STRONG>
            (i<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>n)  <STRONG>do </STRONG></TD> 
            <TD width="615">&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; </STRONG>
             not (e[i] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            result.max)   <STRONG>then </STRONG></TD>
            <TD width="615">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="392">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            result.max := e[i]<STRONG> fi;</STRONG></TD>
            <TD width="615">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">      &nbsp;&nbsp;&nbsp;&nbsp;      i := i+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="615">      &nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">   <STRONG>&nbsp; od ;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG></TD>
            <TD width="615">   // (<font face="Symbol">&quot;</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) e[i] <font face="Symbol"><span lang="en">&pound;</span></font>result.<font face="Symbol"> </font>max
<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>(<font face="Symbol">$</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) result.max = e[i]</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">      result.min :=e[1]; i := 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD> 
            <TD width="615">      &nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">   <STRONG>&nbsp;while </STRONG>(i<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>n)  <STRONG>do&nbsp;&nbsp;&nbsp; </STRONG></TD>
            <TD width="615">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="392">&nbsp;&nbsp;&nbsp;&nbsp;   <STRONG>&nbsp;if&nbsp; </STRONG>
             not (result.min<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[i])   <STRONG>then </STRONG>&nbsp;</TD>
            <TD width="615">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="392">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            result.min := e[i]<STRONG> fi;</STRONG></TD>
            <TD width="615">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="392">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      i := i+1</TD>
            <TD width="615">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="392"><strong>od;</strong></TD>
            <TD width="615">//(<font face="Symbol">&quot;</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) result.min <font face="Symbol"><span lang="en">&pound;</span> </font>e[i]&nbsp;
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>(<font face="Symbol">$</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) result.min = e[i]</TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="392"></TD>
            <TD width="615">&nbsp;</TD>
         </TR>
   </TABLE>
</div>

<p style="text-align: left">Pe³n± analizê poprawno¶ci tego algorytmu 
pozostawiamy Czytelnikowi (por. wyk³ad 01). Stwierdzimy teraz tylko, ¿e 
niezale¿nie od typu elementów ci±gu, je¿eli tylko relacja <FONT FACE="Symbol"> <span lang="en">&pound;</span></FONT> jest liniowym 
porz±dkiem, to po wykonaniu algorytmu prawdziwa bêdzie formu³a&nbsp;</P>

<p style="text-align: center">&nbsp;(<font face="Symbol">&quot; </font>i<font face="Symbol"><span lang="en">&pound;</span>
</font>n) (e[i] <font face="Symbol"><span lang="en">&pound;</span> </font>
result.max
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>result<font face="Symbol">.</font>min <font face="Symbol">
<span lang="en">&pound;</span></font> e[i]). </P>

<p style="text-align: left">Co wiêcej, warto¶ciami zmiennych&nbsp; result.min i 
result.max s± elementy rozwa¿anego ci±gu. Zatem</P>

<p></P>

<div class="twier">
<p>Twierdzenie 2.1</P>
<p>Algorytm min_max1 jest ca³kowicie poprawny w ka¿dej 
strukturze danych Str, w której okre¶lony jest z liniowy porz±dek <FONT FACE="Symbol"> <span lang="en">&pound;</span></FONT>, ze wzglêdu na warunek pocz±tkowy n&gt;0 i 
warunek koñcowy  </P>

<p style="text-align: center">(<font face="Symbol">&quot;</font>i<font face="Symbol"><span lang="en">&pound;</span>
</font>n)(e[i] <font face="Symbol"><span lang="en">&pound;</span> </font>result<font face="Symbol">.</font>max
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>result.min <font face="Symbol">
<span lang="en">&pound;</span></font> e[i])<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>
(<font face="Symbol">$</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) result.max = e[i]<font face="Symbol"><span lang="en">&Ugrave;</span> </font>(<font face="Symbol">$</font>i<font face="Symbol"> <span lang="en">&pound;</span>
</font>n) result.min = e[i].</P>

</div>

<p style="text-align: left">Zauwa¿my, ¿e liczba wykonywanych operacji nie zale¿y 
od kolejno¶ci elementów w ci±gu. Przyjmuj±c n jako rozmiar danych i porównywanie 
jako operacjê dominuj±c±, z ³atwo¶ci± oszacujemy czasowy koszt algorytmu 
min_max1: T(n) = 2n - 2. </P>

<p style="text-align: left">Ten prosty algorytm nie jest jednak najlepszy. Po 
pierwsze, zamiast dwukrotnie przegl±daæ wszystkie elementy, raz w poszukiwaniu 
elementu najwiêkszego i drugi raz w poszukiwaniu elementu najmniejszego, mo¿na 
wykonaæ tylko jedn±&nbsp; pêtlê. </P>

   <TABLE frame="void" rules="none" width="489">
         <TR>
            <TD width="33"> {</TD>
            <TD width="446"></TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="446">result.max :=e[1];&nbsp; result.min :=e[1]; i := 2;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="446"><STRONG>while </STRONG>
            (i<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>n)  <STRONG>do </STRONG></TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="446">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; </STRONG>
             not (e[i] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            result.max)   <STRONG>then </STRONG>result.max := e[i]<STRONG> fi;</STRONG></TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="446">&nbsp;&nbsp;&nbsp;&nbsp;   <STRONG>&nbsp;if&nbsp; </STRONG>
             not (result.min<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[i])   <STRONG>then </STRONG>&nbsp;result.min := e[i]<STRONG> fi;</STRONG></TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="446">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      i := i+1</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="446"><strong>od</strong></TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="446"></TD>
         </TR>
   </TABLE>

<p style="text-align: left">Taki zabieg upro¶ci³ nieco strukturê algorytmu, ale 
nadal wykonujemy 2(n-1) porównañ. Teraz jednak ³atwo zauwa¿ymy, ¿e je¶li jaki¶ 
element e[i] jest wiêkszy od aktualnego maksimum, to przecie¿ ten element nie 
mo¿e byæ jednocze¶nie elementem mniejszym od aktualnego minimum i nie musimy 
wykonywaæ drugiego porównania. Zatem algorytm mo¿e przyj±æ postaæ:</P>


<p><div class="przyk">
   <TABLE frame="void" rules="none" width="788">
         <TR>
            <TD width="33"> <p>min_max2{</TD>
            <TD width="593">&nbsp;</TD>
             
            <TD width="27">&nbsp;</TD>
             
            <TD width="668">&nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="593">result.max :=e[1]; result.min := e[1]; i := 2; </TD>
             
            <TD width="27">&nbsp;</TD>
             
            <TD width="668">// result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
            e[j], e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
            result.max dla j=1,...,(i-1)</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="593"><STRONG>while </STRONG>
            (i<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>n)  <STRONG>
            do </STRONG></TD> 
            <TD width="27">&nbsp;</TD> 
            <TD width="668">&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="593">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; </STRONG>
             not (e[i] <FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            result.max)   <STRONG>then&nbsp; </STRONG></TD>
            <TD width="27">   &nbsp;</TD>
            <TD width="668">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="593">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            result.max := e[i]</TD>
            <TD width="27">   &nbsp;</TD>
            <TD width="668">   // e[j]<FONT FACE="Symbol"><span lang="en">&pound;</span></FONT>result.max, 
            dla j=1,...,i</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="593">      &nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="27">      &nbsp;</TD>
             
            <TD width="668">      &nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="593">&nbsp;&nbsp;&nbsp;&nbsp;   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            &nbsp;if&nbsp; </STRONG>
             not (result.min<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>
            e[i])   <STRONG>then </STRONG></TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="593">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            result.min := e[i]<STRONG> fi</STRONG></TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">// result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
            e[j], dla j=1,...,i</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="593">&nbsp;&nbsp;&nbsp;&nbsp; <b>fi;</b></TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="593">&nbsp;&nbsp;&nbsp;&nbsp; i := i+1;</TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">// result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
            e[j], e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
            result.max dla j=1,...,(i-1)</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="593"><strong>od</strong></TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">&nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="593"></TD>
            <TD width="27">&nbsp;</TD>
            <TD width="668">&nbsp;</TD>
         </TR>
   </TABLE>
</div>

<p style="text-align: left">Teraz jednak ³atwo zauwa¿yæ, ¿e koszt algorytmu 
zale¿y od tego, jakie s± wzajemne zale¿no¶ci miêdzy elementami ci±gu, czyli 
zale¿y od kolejno¶ci w jakiej zapisane s± elementy w ci±gu. W najgorszym razie 
algorytm wykona 2n-2 porównania. Stanie siê tak np. dla dowolnego ci±gu 
uporz±dkowanego malej±co. Dyskusjê 
kosztu ¶redniego algorytmu przedstawimy w nastêpnym punkcie tego wyk³adu. Teraz 
zajmiemy siê przeanalizowaniem jego poprawno¶ci.</P>

<p style="text-align: left">Za³ó¿my, ¿e wykonujemy algorytm min-max2 w 
strukturze danych STR, w której okre¶lona jest relacja porz±dku liniowego <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span>, a 
elementy tablicy e[1:n] nale¿± do uniwersum tej struktury. Po wykonaniu 
pierwszych trzech instrukcji przypisania, oba atrybuty zmiennej result&nbsp; s± równe e[1], 
a i=2. Zatem&nbsp; prawdziwa jest w³asno¶æ</P>

<p style="text-align: center">(<font face="Symbol">&quot;</font>j<font face="Symbol">&lt;
</font>i)(e[j] <font face="Symbol"><span lang="en">&pound;</span> </font>result.max
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>result.min <font face="Symbol">
<span lang="en">&pound;</span></font> e[j]).</P>

<p style="text-align: left">Za³ó¿my teraz, ¿e po pewnej liczbie iteracji pêtli &quot;while&quot; 
spe³niona jest formu³a <font face="Symbol">g</font>(i) postaci&nbsp; result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
e[j], e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> result.max dla 
j=1,...,(i-1). Prze¶led¼my co siê stanie w nastêpnej iteracji. Je¿eli 
rozwa¿any element e[i] jest wiêkszy od warto¶ci zmiennej max, to, po wykonaniu 
przypisania result.max := e[i]<strong style="font-weight: 400">, warto¶ci± 
zmiennej </strong>result.<strong style="font-weight: 400">max jest najwiêkszy 
spotkany do tej pory element. </strong>Je¿eli natomiast element 
e[i] nie jest wiêkszy od result.max, to&nbsp; stara warto¶æ zmiennej max wskazuje 
element najwiêkszy.&nbsp; Wykonane instrukcje nie zmieni³y warto¶ci zmiennej 
result.min, zatem po wykonaniu pierwszego porównania mamy</P>

<p style="text-align: center">e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
result.max dla j=1,...,(i-1),i,&nbsp; oraz result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
e[j] dla j=1,...,(i-1).</P>

<p style="text-align: left">Drugie porównanie (to po &quot;else&quot;) wykonujemy tylko 
wtedy, gdy rozwa¿any element e[i] by³ niewiêkszy od aktualnego maksimum. Je¶li 
e[i] jest mniejsze od warto¶ci aktualnego minimum, wykonujemy instrukcjê 
przypisania result.min := e[i]<strong>.</strong> Oczywi¶cie, ani sprawdzenie testu w &quot;if&quot;, 
ani wykonanie tej instrukcji przypisania, nie zmieniaj± warto¶ci result.max. Po 
wykonaniu pierwszej instrukcji pêtli spe³niona jest zatem w³asno¶æ&nbsp;
<font face="Symbol">g(</font>i<font face="Symbol">+1) </font>postaci</P>

<p style="text-align: center">e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
result.max dla j=1,...,(i-1),i oraz result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
e[j] dla j=1,...,(i-1),i.</P>

<p style="text-align: left">Wewn±trz pêtli pozosta³a do wykonania instrukcja 
przypisania i := i+1; Mamy zatem star± warto¶æ zmiennej i zast±piæ warto¶ci± 
wiêksz± o 1. Zastêpuj±c w formule <font face="Symbol">g(</font>i<font face="Symbol">+1),
</font>wyra¿enie (i+1) przez i, otrzymujemy&nbsp; formu³ê&nbsp;
<font face="Symbol">g</font>(i):</P>

<p style="text-align: center">result.min <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
e[j],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e[j] <span lang="en"> <FONT FACE="Symbol"> &pound;</FONT></span> 
result.max dla 
j=1,...,(i-1).</P>

<p style="text-align: left">Udowodnili¶my wiêc, ¿e je¶li na pocz±tku kolejnej 
iteracji <font face="Symbol">g</font>(i) jest spe³nione, to jest te¿ spe³nione 
po wykonaniu tej iteracji. Formu³a <font face="Symbol">g</font>(i) jest 
niezmiennikiem pêtli w tym algorytmie. Zatem po wyj¶ciu z pêtli, co jest mo¿liwe dopiero 
wtedy, gdy i= n+1, równie¿ spe³niona jest formu³a&nbsp; <font face="Symbol">g</font>(i). 
Na wyj¶ciu prawdziwa jest wiêc formu³a postaci:</P>

<p style="text-align: center">(result.min <font face="Symbol">
<span lang="en">&pound;</span></font>e[1] <font face="Symbol"><span lang="en">&pound;</span> </font>
result.max)
<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>(result.min <font face="Symbol">
<span lang="en">&pound;</span></font> e[2] <font face="Symbol"><span lang="en">&pound;</span> </font>
result.max ) <span lang="en">
<font face="Symbol">&Ugrave;</font></span> ...
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>(result.min <font face="Symbol">
<span lang="en">&pound;</span></font>e[i-1] <font face="Symbol"><span lang="en">&pound;</span> </font>
result.max )&nbsp;<font face="Symbol"><span lang="en">&Ugrave;</span> </font>(i = n+1),</P>

<p style="text-align: left">a poniewa¿ warto¶ciami zmiennych result.min, 
result.max s± elementy danego ci±gu, to prawdziwy jest warunek koñcowy 
przyjêtej specyfikacji algorytmu.</P>

<p style="text-align: left">Jest oczywiste, ¿e algorytm min_max2 zatrzymuje siê dok³adnie 
po n-1 iteracjach, poniewa¿ n jest liczb± naturaln±, a warto¶ciami zmiennej i, 
kontroluj±cej pêtlê, s± kolejne liczby naturalne zaczynaj±c od 2. Ostatecznie</P>

<p></P>

<div class="twier">
<p>Twierdzenie 2.2&nbsp; W ka¿dej strukturze danych STR, w której okre¶lony jest z liniowy porz±dek <FONT FACE="Symbol"> <span lang="en">&pound;</span></FONT>, 
algorytm min_max2&nbsp; zatrzymuje siê dla dowolnego niepustego ci±gu, a 
warto¶ci± zmiennej result jest para z³o¿ona z elementu najwiêkszego i&nbsp; 
najmniejszego tego ci±gu, tzn. algorytm min_max2 jest, ze wzglêdu na przyjêt± 
specyfikacjê, ca³kowicie poprawnym rozwi±zaniem problemu min-max.&nbsp;&nbsp; </P>

</div>

<p><b>Pytanie 2</B>: Czy algorytm min_max2 dzia³a poprawnie i jaki bêdzie wynik 
algorytmu, je¶li n=0?&nbsp;  <BR><BR>
 

<!-- <p>Odpowied¼: Warto¶æ n=0 odpowiada pustemu 
ci±gowi e. Dla n=0 algorytm nie dzia³a poprawnie, gdy¿ zmiennym min i max 
zostanie przypisana nieokre¶lona warto¶æ e[1], lub zostanie zg³oszony b³±d 
wykonania.</P> -->

 <a class="ODP" href="javascript:okno('odpowiedzi/odp3_1.html')">Zobacz odpowied¼</a></p>

<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>