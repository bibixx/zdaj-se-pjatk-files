<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->

    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
   <td align="left"><A HREF="main03_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
   <td align="right">&nbsp;<A HREF="main03_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>


<br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><br clear="all"><div class="tytulpunktu">
  5. Drugi co do wielko¶ci element ci±gu</div>

<p>Byæ mo¿e, ogl±daj±c pucharowe rozgrywki sportowe, zastanawiacie siê Pañstwo, 
jak to jest, ¿e miejsce drugie zajmuj± czêsto dru¿yny, które wcale nie s± 
najlepsze. Dosz³y do fina³u i przegra³y z mistrzem, ale tak naprawdê 
reprezentuj± du¿o gorszy poziom od zwyciêzcy i&nbsp; inne dru¿yny wydaj± siê byæ 
du¿o lepsze. To nie wydaje siê wrêcz sprawiedliwe! Jak znale¼æ dru¿ynê, która jest 
obiektywnie najlepsza ze wszystkich, po pominiêciu zwyciêzcy?</P>

<p>Sformalizujemy problem w nastêpuj±cy sposób: dany jest ci±g n elementów 
e[1],..., e[n] pewnej liniowo uporz±dkowanej struktury danych. Znale¼æ drugi co do wielko¶ci 
element tego ci±gu, tzn.&nbsp; znale¼æ element najwiêkszy w zbiorze {e[1],...,e[n]}\max{e[1], ..., e[n]}.&nbsp; 
Za³o¿ymy, ¿e elementy w ci±gu nie powtarzaj± siê, i ¿e ci±g posiada co najmniej 
dwa elementy. Jak zwykle wynik algorytmu zapiszemy na zmiennej result. Przyjmijmy nastêpuj±c± specyfikacjê: </P>

<p style="text-align: center">wp = {e[i]<font face="Symbol"> <span lang="en">&sup1;</span></font> 
e[j] dla i<span lang="en"><font face="Symbol">&sup1;</font></span>j, n&gt;0},&nbsp; </P>

<p style="text-align: center">wk = { result= e[i] dla pewnego i &lt; n+1,&nbsp; e[j] &lt;  result &lt; e[i<sub><font face="Verdana">0</font></sub>] 
dla pewnego i<sub><font face="Verdana">0</font></sub> i dla wszystkich j
<font face="Symbol"><span lang="en">&sup1;</span> </font>i<sub><font face="Verdana">0</font></sub>}.</P>

<p style="text-align: left">Pierwsza czê¶æ warunku koñcowego, mówi, ¿e warto¶æ 
zmiennej result jest elementem danego ci±gu, a druga czê¶æ, ¿e tylko jeden 
element ci±gu jest od result wiêkszy. Algorytm naiwny, wynikaj±cy z samego 
sformu³owania zadania jest nastêpuj±cy:</P>
<blockquote>
  <ul>
    <li>

<p style="text-align: left">1. Znajd¼ element najwiêkszy stosuj±c algorytm max.</P>
    </li>
    <li>

<p style="text-align: left">2. Pomiñ w dalszych rozwa¿aniach element najwiêkszy.</P>
    </li>
    <li>

<p style="text-align: left">3. W¶ród pozosta³ych elementów, znajd¼ element 
najwiêkszy stosuj±c ponownie algorytm max.</P>
    </li>
  </ul>
</blockquote>
<p>Algorytm znajduj±cy maksimum, max, jest, jak wiadomo, algorytmem optymalnym i wykonuje n-1 porównañ 
dla znalezienia elementu najwiêkszego (por. wyk³ad I, p.4). Usuniêcie elementu maksymalnego mo¿e 
polegaæ na zamianie pozycji pierwszego i maksymalnego elementu. Koszt tej 
operacji jest sta³y. Punkt trzeci algorytmu, mo¿na zrealizowaæ szukaj±c elementu 
najwiêkszego w ci±gu e[2],...,e[n], co wymaga n-2 porównañ. Razem koszt 
algorytmu naiwnego wynosi 2n-3.</p>
<p>Zastanówmy siê jednak, czy to drugie wyszukiwanie elementu najwiêkszego 
nie mog³oby byæ zast±pione czym¶ innym. Czy przegl±daj±c ci±g w poszukiwaniu 
elementu najwiêkszego, nie mogliby¶my wykonaæ czê¶ci pracy potrzebnej do 
znalezienia elementu drugiego najwiêkszego?</p>
<p>Przypatrzmy siê jeszcze raz turniejowi rozgrywanemu przez, powiedzmy, n dru¿yn 
systemem pucharowym.&nbsp; W ka¿dym etapie turnieju dru¿yny graj± parami.&nbsp; 
Dobór w pary mo¿e byæ losowy. Do nastêpnego etapu przechodz± tylko te dru¿yny, 
które wygrywaj± pojedynki. Oczywi¶cie, po skoñczonej liczbie rund turniej koñczy 
siê wybraniem najlepszej dru¿yny. </p>


<p><b>Pytanie 6</B>: Ile rund trzeba wykonaæ, aby wybraæ najlepsz± dru¿ynê, 
je¿eli na pocz±tku startowa³y 32 dru¿yny? 
<FORM><p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'5 rund');">
</p></form>

<p></P><!-- <p>Odpowied¼: 5 rund</P> --><p></P>

<p>Ogólnie, je¿eli startowa³o 2<sup><font face="Verdana">n</font></sup> dru¿yn, 
to&nbsp; liczba rund wynosi n. A ile dok³adnie meczów musia³o zostaæ w tym 
przypadku rozegranych?&nbsp; </P>
<FORM><p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'2^n - 1');">
</p></FORM>

<p>Wróæmy jednak do problemu bardziej abstrakcyjnego, sformu³owanego w 
specyfikacji powy¿ej. Ka¿dej dru¿ynie odpowiada teraz jeden element ci±gu, a 
si³a dru¿yny jest wyra¿ona przez warto¶æ przypisan± temu elementowi. &quot;Mecz&quot; 
polega na porównaniu dwóch elementów zgodnie z pewn±, obwi±zuj±c± w przyjêtej 
strukturze danych, relacj± porz±dku liniowego <span lang="en">
<font face="Symbol">&pound;</font></span>. &quot;Zwyciê¿a&quot; i przechodzi do nastêpnej rundy 
element o wiêkszej warto¶ci. Oczywi¶cie element, który wygra³ w ostatniej 
rundzie nie przegra³ ani jednego &quot;meczu&quot; - jest to rzeczywi¶cie element 
najwiêkszy.</p>
<p><b>Przyk³ad 5.1</b> Niech elementami ci±gu bêd± liczby naturalne 6, 4 ,9, 8, 
5, 7, 3, 1. Przedstawmy w postaci grafu kolejne etapy wyszukiwania elementu 
najwiêkszego opisan± metod±, por. Rysunek 3.2.</p>
<p style="text-align: center">
<img border="0" src="Rysunki/Rysunek3_2.gif" width="300" height="250"></p>
<p>Wêz³ami w drzewie turnieju s± warto¶ci elementów ci±gu. Kolejne rundy 
turnieju odpowiadaj± poziomom w tym drzewie. W korzeniu drzewa znajduje siê 
element najwiêkszy. A gdzie znajduje siê element drugi co co wielko¶ci? Nie jest 
to bynajmniej wierzcho³ek na na poziomie 1, bo porównywali¶my tu dziewi±tkê z 
siódemk±, a przecie¿ 8 jest wiêksze ni¿ 7. £atwo zauwa¿yæ, ¿e musia³ byæ taki 
moment, ¿e element najwiêkszy by³ porównywany z elementem drugim co do 
wielko¶ci. W rozwa¿anym przyk³adzie sta³o siê tak ju¿ na pocz±tku turnieju, ale 
mog³o siê tak staæ w dowolnej z rund. Zatem, gdzie szukaæ drugiego co do 
wielko¶ci elementu? W¶ród elementów, które przegra³y z elementem najwiêkszym.</P>
<p>Obserwacja z przyk³adu 5.1 jest dostatecznie ogólna, by¶my mogli 
zaprojektowaæ algorytm rozwi±zywania naszego problemu. Zapiszemy go 
nieformalnie, implementacjê przedstawionej tu metody omówimy pó¼niej w wyk³adzie 
szóstym.</P>
<p></P>

<div class="def" style="width: 704; height: 112">
<p>Algorytm turniej (szkic):</P>
<ol>
  <li>Zbuduj drzewo turnieju znajduj±c element najwiêkszy ci±gu. </li>
  <li>W¶ród elementów, które &quot;przegra³y&quot; z elementem najwiêkszym, znajd¼ element 
  najwiêkszy.</li>
</ol>
</div>

<p></P>
<p>Zauwa¿my najpierw, ¿e koszt tego algorytmu jest du¿o mniejszy ni¿ algorytmu 
naiwnego. Znalezienie elementu najwiêkszego wi±¿e siê z wykonaniem n-1 porównañ 
niezale¿nie od tego, czy liczba n jest, czy nie jest potêg± dwójki. Elementy, 
które nie mia³y pary, przechodz± do nastêpnego etapu, bez wykonywania porównañ. 
Liczba rund turnieju wynosi <span lang="en"><font face="Symbol">é</font></span>lg 
n<font face="Symbol"><span lang="en">&ugrave;</span>, </font>bo jest to wysoko¶æ drzewa 
binarnego o n li¶ciach, por. wyk³ad II, p.5. Zatem ci±g, który musimy ponownie 
przeszukaæ sk³ada siê z <span lang="en"><font face="Symbol">é</font></span>lg n<font face="Symbol"><span lang="en">&ugrave;</span></font>&nbsp; 
elementów. Ostatecznie liczba wykonanych porównañ wynosi n-1 + <span lang="en">
<font face="Symbol">é</font></span>lg n<font face="Symbol"><span lang="en">&ugrave;</span>-1,</font></P>
<p style="text-align: center">T(Turniej, n) = n + <span lang="en">
<font face="Symbol">é</font></span>lg n<font face="Symbol"><span lang="en">&ugrave;</span>-</font>2 
.</P>
<p>Ca³a trudno¶æ w implementacji tego algorytmu polega za sposobie znalezienia 
elementów, które przegra³y ze zwyciêzc±, tak by nie wykonywaæ ¿adnych 
dodatkowych porównañ 
elementów. Poniewa¿ buduj±c drzewo turnieju nie wiemy, który element zwyciê¿y, 
zatem dla ka¿dego wygrywaj±cego trzeba pamiêtaæ listê elementów, które z nim 
przegra³y. Implementacjê wykorzystuj±c± strukturê list i strukturê stosów 
omówimy w rozdziale szóstym.</P>
<p></P>

<p><b>Pytanie 7</B>: Ile dok³adnie porównañ wykona algorytm Turniej dla ci±gu 
dziewiêcioelementowego, je¿eli za³o¿ymy, ¿e element, który nie ma pary 
automatycznie przechodzi do nastêpnej rundy?&nbsp; </P>

<!-- <p>11 porównañ.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'11 porównañ.')">
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main03_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main03_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>