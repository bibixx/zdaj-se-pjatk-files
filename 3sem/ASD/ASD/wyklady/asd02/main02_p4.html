<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<p><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    </p>
    <div class="tytulpunktu">4.&nbsp; Algorytm binarnych poszukiwañ</div> 

<p> W tym punkcie omówimy algorytm rozwi±zywania problemu wyszukiwania, który 
wykorzystuje&nbsp; w sposób bardzo istotny, za³o¿enie o uporz±dkowaniu danego 
ci±gu. Dla uproszczenia za³o¿ymy, ¿e x nale¿y do przedzia³u [e[1], e[n]]. 
Przyjmijmy specyfikacjê algorytmu </p>
<p style="text-align: center"> wp = {n &gt; 1, e[1]&lt; e[2]&lt; ... &lt; e[n], 
e[1]<font face="Symbol"> <span lang="en">&pound;</span></font> x <font face="Symbol">&lt;
</font>e[n]},</p>
<p style="text-align: center"> wk = {<font face="Symbol"> </font>result<font face="Symbol">
<span lang="en">&pound;</span> </font>n, e[result]<font face="Symbol"> <span lang="en">
&pound;</span> </font>x <font face="Symbol">&lt; </font>e[result+1]}.</p>
<p> Metoda zastosowana w tym algorytmie nosi nazwê &quot;dziel i zwyciê¿aj&quot;.&nbsp; W tym przypadku 
polega ona na znalezieniu zadania o mniejszym rozmiarze, 
którego rozwi±zanie jest równocze¶nie rozwi±zaniem zadania pocz±tkowego.&nbsp; <BR/> </p>
<div class="przyk" style="width: 595; height: 307">
   <TABLE frame="void" rules="none" width="586" height="279">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="58" height="15"> BinSearch<b>{</b></TD>
            <TD width="254" height="15"></TD>
             
            <TD width="7" height="15">&nbsp; </TD>
             
            <TD width="249" height="15"></TD>
             
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   i := 1; j := n;   <STRONG>&nbsp;</STRONG> </TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   </TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">      <b>&nbsp;</b><STRONG>while&nbsp; </STRONG>(i+1 
            &lt; j)   <STRONG>do </STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="7" height="16">      </TD>
             
            <TD width="249" height="16">      //e[i] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[j]&nbsp; oraz i&lt;j</TD>
             
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>m := (i + j) 
            div 2;</TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; i <font face="Symbol">&lt;&nbsp; </font>m &lt; 
            j</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
            <b>if</b> e(m) <span lang="en"><font face="Symbol">&pound;</font></span> x
            <b>then</b> </TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; e[m] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[j]</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>i := m</TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; e[i] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[j] oraz i&lt;j</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            else</strong></TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; e[i] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[m]</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>j := m</TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; e[i] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[j] oraz i&lt;j</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi</strong></TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   </TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   <strong>od;</strong></TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp;i&lt;j,&nbsp; e[i] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[j] oraz i+1=j</TD>
         </TR>
         <TR>
            <TD width="58" height="16"></TD>
            <TD width="254" height="16">   result := i</TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   //&nbsp; e[result] <span lang="en">
            <font face="Symbol">&pound;</font></span><font face="Symbol"> </font>x &lt; 
            e[result+1]</TD>
         </TR>
         <TR>
            <TD width="58" height="16"><strong>}</strong></TD>
            <TD width="254" height="16">   </TD>
            <TD width="7" height="16">   </TD>
            <TD width="249" height="16">   </TD>
         </TR>
      </TBODY>
   </TABLE>
</div>
<p> Formu³y zapisane obok instrukcji informuj± o w³asno¶ciach prawdziwych w
  trakcie realizacji algorytmu. Wynika z nich, ¿e niezmiennikiem pêtli w tym 
algorytmie, jest formu³a&nbsp; (e[i]<font face="Symbol">
<span lang="en">&pound;</span></font> x <font face="Symbol">&lt; </font>e[j]
<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>i &lt; j). </p>
<p> Rzeczywi¶cie, je¿eli formu³a (e[i]<font face="Symbol">
<span lang="en">&pound;</span></font> x <font face="Symbol">&lt; </font>e[j]&nbsp;<font face="Symbol"><span lang="en">&Ugrave;</span> </font>i &lt; j) 
jest spe³niona na pocz±tku kolejnej iteracji oraz spe³niony jest warunek pêtli, 
to&nbsp; po sprawdzeniu, po której stronie elementu ¶rodkowego e[m] znajduje siê 
x&nbsp; oraz przesuniêciu odpowiedniego koñca przedzia³u znów mamy prawdziw± 
formu³ê (e[i]<font face="Symbol">
<span lang="en">&pound;</span> </font>x<font face="Symbol"> &lt; </font>e[j]). 
Poniewa¿ i+1&lt;j, to (i+j)/2&lt;j, oraz i &lt;(i+j)/2, czyli w obu przypadkach po 
wykonaniu przypisania i :=m lub j :=m, mamy i&lt;j. Na mocy twierdzenia I.4.1 (o 
niezmiennikach), po wyj¶ciu z pêtli mamy i+1<font face="Symbol"> <span lang="en">&sup3;</span></font> 
j oraz prawdziwy jest niezmiennik.&nbsp; Zatem&nbsp; (e[i]<font face="Symbol">
<span lang="en">&pound;</span></font> x <font face="Symbol">&lt; </font>e[j]
<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>i &lt; j 
<font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; </font>i+1=j), czyli 
algorytm ustala warto¶æ zmiennej result zgodnie z wymaganiami specyfikacji. 
Udowodnili¶my w ten sposób, ¿e dla wszystkich danych spe³niaj±cych warunek 
pocz±tkowy, je¿eli algorytm daje wynik, to spe³nia on warunek koñcowy w dowolnej 
strukturze danych z okre¶lonym liniowym porz±dkiem.</p>

<p></P>

<div class="twier">
<p>Twierdzenie 4.1</P>
<p>W ka¿dej strukturze danych STR, w której okre¶lony jest z liniowy porz±dek <FONT FACE="Symbol"> <span lang="en">&pound;</span></FONT>, 
algorytm BinSearch jest ca³kowicie poprawny ze wzglêdu na specyfikacjê&nbsp; </P>

<p style="text-align: center">wp = {n &gt; 1, e[1]&lt; e[2]&lt; ... &lt; e[n], 
e[1]<font face="Symbol"> <span lang="en">&pound;</span></font> x <font face="Symbol">&lt;
</font>e[n]}, wk = {<font face="Symbol"> </font>result<font face="Symbol">
<span lang="en">&pound;</span> </font>n, e[result]<font face="Symbol"> <span lang="en">
&pound;</span> </font>x <font face="Symbol">&lt; </font>e[result+1]}.</P>

</div>

<p> Dla dowodu twierdzenia 4.1 trzeba jeszcze pokazaæ, ¿e algorytm BinSearch 
zatrzymuje siê dla dowolnych danych spe³niaj±cych warunek pocz±tkowy. </p>
<p> Zauwa¿my, ¿e je¿eli ró¿nica j - i&nbsp; pewnej iteracji wynosi c, to w 
nastêpnej iteracji jest mniejsza od c, bo</p>
<p style="text-align: center"> j - [(i+j)/2] &lt; j - i&nbsp;&nbsp; oraz&nbsp;&nbsp; 
[(i+j)/2] - i &lt; j - i.</p>
<p> Zatem ci±g ró¿nic j - i warto¶ci zmiennych i, j w kolejnych iteracjach pêtli 
&quot;While&quot;, jest ci±giem malej±cym liczb naturalnych. Poniewa¿ nie mo¿na zbudowaæ 
nieskoñczonego ci±gu malej±cego liczb naturalnych, zatem po skoñczonej liczbie 
kroków warunek j - i &gt;1 nie bêdzie spe³niony. Algorytm zakoñczy wtedy 
obliczenie. Wynika st±d, ¿e algorytm BinSearch zatrzymuje siê dla dowolnych 
danych, co koñczy dowód twierdzenia 4.1.</p>
<p> <b>Analiza kosztu</b>: </p>
<p> Zastanówmy siê najpierw czym bêdziemy mierzyæ koszt czasowy tego algorytmu.
  Poza operacjami przypisania i operacjami arytmetycznymi, wykonuje siê porównywanie
  elementów. Zauwa¿my, ¿e dla tego algorytmu, nie jest istotne czym s± elementy 
ci±gu i jakie maj± warto¶ci. Wa¿ne s± tylko relacje miêdzy x, a elementami 
ci±gu. Wydaje siê wiêc naturalnym wybranie porównywania, jako operacji dominuj±cej, 
przy pomocy której bêdziemy mierzyli koszt czasowy algorytmu. Zauwa¿my jeszcze,
  ¿e niezale¿nie od warto¶ci elementów, algorytm zawsze postêpuje podobnie: w
  ka¿dym kroku patrzymy, w której po³owie rozwa¿anego fragmentu ci±gu, znajduje
  siê x.</p>
<p> Pytanie o liczb± wykonanych operacji dominuj±cych sprowadza siê do pytania: 
ile iteracji wykona pêtla &quot;while&quot;. Poniewa¿ w ka¿dej iteracji, segment, w którym 
mie¶ci siê x, jest dwa razy krótszy od rozwa¿anego w poprzedniej iteracji, zatem pytanie sprowadza siê  do tego, ile razy ci±g o d³ugo¶ci n
  mo¿na podzieliæ na 2  czê¶ci. Poniewa¿ algorytm zatrzymuje siê, gdy indeksy i, 
j s± s±siednimi liczbami naturalnymi, zatem w najgorszym razie wykona&nbsp; <span lang="en">
<font face="Symbol">é</font></span>lg n<font face="Symbol"><span lang="en">&ugrave;</span> </font>
porównañ.</p>
<p style="text-align: left"> Koszt czasowy algorytmu BinSearch jest 
logarytmiczny w stosunku do liczby elementów ci±gu, T(BinSearch, n) =
<font face="Symbol">Q</font>(lg n). Jest to wiêc istotna poprawa w porównaniu z 
algorytmami wyszukiwania przedstawionymi w poprzednich punktach tego wyk³adu.</p>


<p><b>Pytanie 4</B>: Który z algorytmów wykona mniejsz± liczbê porównañ w przypadku 
najgorszym: algorytm Skoki z d³ugo¶ci± skoku równ±&nbsp; <span lang="en">
<font face="Symbol">é</font></span><font face="Symbol"><span lang="en">Ö</span>(</font>n-1)
<span lang="en"><font face="Symbol">&ugrave;</font></span>, czy algorytm poszukiwañ binarnych? 


<!--Odpowied¼ Algorytm BinSearch wykona <span lang="en">
<font face="Symbol">é</font></span>lg n<span lang="en"><font face="Symbol">&ugrave;</font></span> 
porównañ, a algorytm Skoki wykona w najgorszym razie <font face="Symbol">(</font><span lang="en"><font face="Symbol">é</font></span><font face="Symbol"><span lang="en">Ö</span>(</font>n-1)<span lang="en"><font face="Symbol">&ugrave;</font></span> 
+ <span lang="en">
<font face="Symbol">é</font></span><font face="Symbol"><span lang="en">Ö</span>(</font>n-1)<span lang="en"><font face="Symbol">&ugrave;</font></span> 
- 1) porównañ. Poniewa¿ lg n &lt; 2 <span lang="en"><font face="Symbol">Ö</font></span>n 
dla wszystkich n&gt;1. Mniejszy koszt ma algorytm poszukiwañ binarnych, bo funkcja 
logarytm ro¶nie do nieskoñczono¶ci du¿o wolniej ni¿ funkcja pierwiastek. </p>

-->

<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' 
onClick="napis(this.form,'Mniejszy koszt ma algorytm poszukiwañ binarnych, bo logarytm ro¶nie du¿o wolniej ni¿ pierwiastek.')">
</p>
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>