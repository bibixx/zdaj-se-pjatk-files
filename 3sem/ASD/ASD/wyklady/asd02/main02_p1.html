<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main02_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main02_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a>
</td></tr></table><br clear="all"><a NAME="EDU.wyklad.punkt 1"></a><br clear="all">
   

 <div class="tytulpunktu">1. Problem wyszukiwania</div> 

    <p>

Niech E bêdzie dowolnym, niepustym zbiorem, 
a X jego dowolnym podzbiorem. Problem wyszukiwania polega na ustaleniu, czy dany element x nale¿y do zbioru X.&nbsp;Rozwi±zaniem 
problemu bêdzie algorytm, który dla dowolnego ci±gu i dowolnego elementu x 
daje w wyniku warto¶æ prawda wtedy i tylko wtedy, gdy c jest jednym z elementów ci±gu.
         Zak³adamy, ¿e elementy zbioru X s± umieszczone w tablicy e jako e[1], e[2], ..., e[n] i, ¿e odpowied¼ zostanie zapamiêtana na zmiennej booleowskiej 
result.
          
<p>
Specyfikacja poszukiwanego algorytmu sk³ada siê z dwóch warunków: 
warunku pocz±tkowego wp okre¶laj±cego dane wej¶ciowe i warunku koñcowego&nbsp; 
wk okre¶laj±cego oczekiwane w³asno¶ci wyniku:<blockquote>
  <p>wp = { n &gt; 0   }
     <br>
  wk = { result = true&nbsp;&nbsp; wttw istnieje takie i, ¿e x = e[i] oraz i <FONT FACE="Symbol">&#163</FONT>n}</p>
</blockquote>
</p>
<H2 class="subsection"><font face="Verdana" size="2">Rozwi±zanie </font></H2>
      <P>
         Metoda: Bêdziemy porównywali x z kolejnymi elementami ci±gu poczynaj±c od 
         pierwszego. Je¶li badany element ci±gu jest ró¿ny od x, to kontynuujemy 
         przeszukiwanie, a je¶li jest równy x, to koñczymy postêpowanie. 
         Algorytm odpowiadaj±cy tej metodzie, nazywany algorytmem poszukiwañ 
         sekwencyjnych, jest przedstawiony poni¿ej. Dla 
         uproszczenia rozwa¿añ zwi±zanych z uzasadnieniem poprawno¶ci, szukany element jest umieszczony 
         dodatkowo na pozycji (n+1)-szej danego ci±gu, e[n+1]=x. Po takiej 
         modyfikacji ci±gu e, mamy pewno¶æ, 
         ¿e przegl±daj±c kolejne pozycje zmodyfikowanego ci±gu, trafimy na 
         element x.</P>

<H4 class="paragraph"><font size="2">ALGORYTM&nbsp; poszukiwañ sekwencyjnych</font><BR/><BR/> </H4>
<div class="przyk" style="width: 839; height: 264">
   <TABLE frame="void" rules="none" width="816">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="35"> Member</TD>
            <TD width="195">{</TD>
             
            <TD width="14">&nbsp; </TD>
             
            <TD width="554">&nbsp;</TD>
             
         </TR>
         <tr>
            <TD width="35"></TD>
         </tr>
         <TR>
            <TD width="35"></TD>
            <TD width="195">e[n+1] := x; i := 1; </TD>
             
            <TD width="14">&nbsp;</TD>
             
            <TD width="554">//przed wykonaniem pêtli x <font face="Symbol">
            <span lang="en">&Iuml;</span>{</font>e[1],...,e[i-1]<font face="Symbol">}
            <br>
&nbsp;</font></TD>
             
         </TR>
         <TR>
            <TD width="35">&nbsp; </TD>
            <TD width="195"><STRONG>while </STRONG>
            (not 
             x = e[i])  <STRONG>do </STRONG></TD> 
            <TD width="14">&nbsp;</TD> 
            <TD width="554">//Po sprawdzeniu i-tego elementu, x
            <font face="Symbol"><span lang="en">&Iuml;</span>{</font>e[1],...,e[i-1]<font face="Symbol"> 
            } </font>oraz x<font face="Symbol"> </font><span lang="en">
            <font face="Symbol">&sup1;</font></span>e[i]<font face="Symbol"><br>
&nbsp;</font></TD> 
         </TR>
         <TR>
            <TD width="35">&nbsp;</TD>
            <TD width="195">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
             &nbsp; i := i+1 </TD>
            <TD width="14">   &nbsp;</TD>
            <TD width="554">   //Po zmianie warto¶ci i, x <font face="Symbol">
            <span lang="en">&Iuml;</span>{</font>e[1],...,e[i-1]<font face="Symbol">}</font></TD>
         </TR>
         <TR>
            <TD width="35">&nbsp;</TD>
            <TD width="195">      <STRONG>od</STRONG> ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="14">      &nbsp;</TD>
             
            <TD width="554">      &nbsp;</TD>
             
         </TR>
         <TR>
            <TD width="35"></TD>
            <TD width="195">   <STRONG>if&nbsp; </STRONG>(i<FONT FACE="Symbol"> <span lang="en">&pound;</span> </FONT>n)<STRONG> 
            then </STRONG>result := true<STRONG> </STRONG></TD>
            <TD width="14">   &nbsp;</TD>
            <TD width="554">   //Je¶li pêtla zatrzyma³a siê na indeksie 
            mniejszym od n+1, to x<font face="Symbol"><span lang="en">Î</span>{</font>e[1],...,e[n]<font face="Symbol">}</font></TD>
         </TR>
         <TR>
            <TD width="35"></TD>
            <TD width="195">   <STRONG>&nbsp;&nbsp;else &nbsp;</STRONG></TD>
            <TD width="14">   &nbsp;</TD>
            <TD width="554">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="35">&nbsp;</TD>
            <TD width="195">   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong>result :=<strong> false</strong></TD>
            <TD width="14">   &nbsp;</TD>
            <TD width="554">   //Je¶li pêtla zatrzyma³a siê na indeksie równym 
            n+1, to x <font face="Symbol">
            <span lang="en">&Iuml;</span>{</font>e[1],...,e[n]<font face="Symbol">} </font></TD>
         </TR>
         <TR>
            <TD width="35">&nbsp;</TD>
            <TD width="195">   <strong>fi</strong></TD>
            <TD width="14">   &nbsp;</TD>
            <TD width="554">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="35"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="195"></TD>
            <TD width="14">&nbsp;</TD>
            <TD width="554">&nbsp;</TD>
         </TR>
      </TBODY>
   </TABLE>
</P>
</div>
<P>
   Zauwa¿my, ¿e typ elementów ci±gu nie ma tu ¿adnego znaczenia. Jest tylko 
   konieczne, aby struktura, w której dzia³a algorytm, mia³a zdefiniowan± relacjê 
   równo¶ci dla obiektów ze zbioru E.</P>
<P>
   Algorytm przegl±da kolejne pozycje zmodyfikowanego ci±gu i zatrzymuje siê na 
   pozycji, któr± zajmuje element x. W przypadku, gdy jest to pozycja ostatnia 
   (n+1)-sza mamy pewno¶æ, ¿e x nie wystêpowa³ w danym ci±gu. Przeanalizujmy 
   dok³adniej zachowanie tego programu, stosuj±c metodê niezmienników.
</P>
<P>
   £atwo zauwa¿yæ, ¿e formu³a <font face="Symbol">a</font> = (x<span lang="en"><font face="Symbol">&sup1;</font></span>e[1]<font face="Symbol">
   <span lang="en">&Ugrave;</span> </font>... <font face="Symbol"><span lang="en">&Ugrave;</span>
   </font>x<span lang="en"><font face="Symbol">&sup1;</font></span>e[i-1]<font face="Symbol">)
   </font>jest niezmiennikiem pêtli &quot;while&quot; w tym algorytmie. Przed wykonaniem 
   pêtli, gdy jeszcze nie sprawdzili¶my ¿adnego elementu, a&nbsp; i=1, formu³a
   <font face="Symbol">a</font> jest spe³niona trywialnie. Je¶li po i-tej 
   kolejnej iteracji stwierdzili¶my, ¿e x <span lang="en"><font face="Symbol">&sup1;</font></span> 
   e[i], to wiemy, ¿e na ¿adnej z pozycji e[1],...,e[i] nie ma elementu x. W 
   takiej sytuacji zwiêkszamy warto¶æ indeksu i, zatem informacja jak± posiadamy 
   o elementach ci±gu e ma postaæ: (x<span lang="en"><font face="Symbol">&sup1;</font></span>e[1]<font face="Symbol">
   <span lang="en">&Ugrave;</span> </font>... <font face="Symbol"><span lang="en">&Ugrave;</span>
   </font>x<span lang="en"><font face="Symbol">&sup1;</font></span>e[i-1]). Je¶li 
   natomiast po i-tej iteracji stwierdzamy, ¿e e[i] = x, to algorytm opuszcza 
   pêtlê. Jedyna instrukcja jak± pozosta³o wykonaæ, to instrukcja warunkowa, 
   ustalaj±ca warto¶æ wyniku.&nbsp; Je¶li znale¼li¶my x na pozycji od 1 do n, to 
   znaczy, ¿e x jest elementem danego ci±gu. Je¶li wyszli¶my z pêtli z warto¶ci± 
   i = n+1, to znaczy, ¿e nie znale¼li¶my x w danym ci±gu.&nbsp; Z powy¿szych 
   rozwa¿añ wynika nastêpuj±ce twierdzenie.</P>

<p><div class="lemat">
   Twierdzenie 
   <p>Algorytm Member jest poprawnym rozwi±zaniem problemu wyszukiwania, 
   tzn. w dowolnej strukturze danych algorytm zatrzymuje siê, a po jego 
   wykonaniu prawdziwe jest zdanie<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   result = true&nbsp;&nbsp; wttw&nbsp;&nbsp; x <FONT FACE="Symbol">&#206 </FONT>&nbsp;{e[1],...,e[n]}.</p>
   </P>

</div></p>

<p><b><font face="Verdana">
   <SPAN class="large1">Analiza kosztu</SPAN> </font></b></p>
      <P>
         Operacj±, która (oprócz operacji arytmetycznych) powtarza siê w tym 
         algorytmie, jest porównywanie elementów.
         Koszt czasowy bêdziemy&nbsp; wiêc mierzyli liczb± wykonanych porównañ 
         elementów ci±gu.
      </P>
      <P>
         Oczywi¶cie, mo¿e siê zdarzyæ, ¿e element x znajduje siê na pierwszej 
         pozycji, ale mo¿e siê te¿ zdarzyæ, ¿e nie ma go w naszym ci±gu. Zatem:</P>
<ul>
  <li>w najlepszym przypadku wykonamy 1 porównanie. </li>
  <li>w najgorszym przypadku wykonamy n+1&nbsp; porównañ. </li>
</ul>
<P>
   Ustalmy (dowolnie) strukturê danych, z której pochodz± elementy ci±gu 
   e[1],...,e[n].
   Koszt ¶redni policzymy ze wzoru:
</P>
<P style="text-align: center">
   A(n) =&nbsp; <font face="Symbol" size="4">S</font><sub>d<FONT FACE="Symbol">&#206</FONT>D</sub><font face="Symbol"> 
   (</font>P(d) <font face="Symbol"><span lang="en">´</span></font> t(d),</P>
<P>
   gdzie&nbsp; D
   jest zbiorem wszystkich danych rozmiaru n, P(d) jest
   prawdopodobieñstwem wyst±pienia danych d, a t(d) jest liczb±
   porównañ wykonanych w czasie realizacji algorytmu 1 dla danych d.
</P>
<P>
   Wszystkie mo¿liwe dane rozmiaru n mo¿na podzieliæ na dwie grupy: wszystkie te 
   ci±gi, do których x nale¿y i wszystkie te ci±gi, do których x nie nale¿y. Co 
   wiêcej, wszystkie ci±gi rozmiaru n, w których x wystêpuje,&nbsp; mo¿na poklasyfikowaæ
   nastêpuj±co (s± to klasy abstrakcji pewnej relacji
   równowa¿no¶ci na zbiorze ci±gów d³ugo¶ci n):
</P>
<ul>
  <li>wszystkie takie ci±gi, w których <span class="inline-math-graphics">x 
  znajduje siê na pozycji pierwszej,</span> </li>
  <li>wszystkie takie ci±gi, w których <span class="inline-math-graphics">x 
  znajduje siê na pozycji drugiej,</span></li>
  <li>itd....</li>
  <li>wszystkie takie ci±gi,&nbsp; w których <span class="inline-math-graphics">
  x znajduje siê na pozycji </span>n-tej,</li>
</ul>
<P>
   Zatem zdarzenie x <FONT FACE="Symbol">&#206 </FONT>{e[1],...,e[n]} rozbija 
   siê na sumê zdarzeñ x = e[i] dla i=1,2,..., n. Zauwa¿my jeszcze, ¿e dla 
   wszystkich danych z tej samej klasy zachowanie algorytmu jest takie samo, tzn. 
   liczba wykonanych porównañ bêdzie taka sama.</P>
<P>
   Przyjmijmy nastêpuj±ce uproszczenia.
   Niech p bêdzie prawdopodobieñstwem zdarzenia x <FONT FACE="Symbol">&#206 </FONT>{e[1],...,e[n]} i
   niech prawdopodobieñstwo tego, ¿e x = e(i) bêdzie dla
   ka¿dego i = 1,...,n takie samo. Mamy wiêc
</P>
<P style="text-align: center">
   P(x = e[i]) = p/n.</P>
<P>
   Ostatecznie, ¶redni koszt rozwa¿anego algorytmu wyra¿a siê wzorem : <br>
&nbsp;&nbsp;&nbsp; A(n) = P(x = e[1]) <font face="Symbol"><span lang="en">´</span></font>1 + ...+ P(x = e[i]) 
   <font face="Symbol"><span lang="en">´</span> </font>i + ... + P(x = e[n])<font face="Symbol">
   <span lang="en">´</span></font> 
   n + (1-p)<font face="Symbol"><span lang="en">´</span></font>(n+1).</P>
<P>
   St±d, po podstawieniu P(x=e[i]) = p/n,&nbsp; otrzymujemy&nbsp; A(n) = 
   p<font face="Symbol"><span lang="en">´</span></font>(n+1)/2 +(1-p)(n+1) = n+1 - p<font face="Symbol"><span lang="en">´</span></font>(n+1)/2.<BR/><BR/>Je¶li wiemy, ¿e
   <span class="inline-math-graphics">x nale¿y do danego ci±gu, </span>tzn. p=1,
   wtedy koszt ¶redni wyra¿a siê funkcj±:
   <SPAN CLASS="inline-math-graphics">A(n) = (n+1)/2.</SPAN></P>
<P>
   <BR/>Koszt pamiêciowy  mierzymy liczb±
         miejsc pamiêci komputera, koniecznych do przechowania danych i wyników wykonania algorytmu. W tym
         przypadku wynosi on n+3 (dany ci±g + zmienne pomocnicze). Koszt 
   pamiêciowy algorytmu Member jest liniowy ze wzglêdu na rozmiar danych.</P>
<P>
   Uwaga:
         W³a¶ciwie nale¿a³oby traktowaæ inaczej zmienne
         pomocnicze arytmetyczne i zmienne s³u¿±ce go przechowywania obiektów 
   zbioru E. Typu
         elementów zbioru E nie znamy, a przecie¿ mog± to byæ skomplikowane 
   obiekty zajmuj±ce du¿o wiêcej miejsca, ni¿ prosta zmienna typu integer.</P>
<p><b>Pytanie 1</B>: Jaka jest d³ugo¶æ ci±gu, je¿eli ca³kowity 
czas wykonania algorytmu Member dla tego ci±gu i pewnego x, wyniós³ 1s, a ka¿de&nbsp; 
porównanie elementów tego ci±gu zajmuje 10<sup><font face="Verdana">-6</font></sup>s 
(koszt zwi±zany z wszystkimi innymi operacjami wykonywanymi przez algorytm 
zaniedbujemy)?&nbsp; </p>

<!-- Odpowied¼: Odpowied¼: Algorytm 1 wykona liczbê porównañ odpowiadaj±c± 
pozycji elementu szukanego w ci±gu. Mamy x * 10<sup><font face="Verdana">-6</font></sup> s. = 1s, czyli&nbsp; x= 1 000 
000. Ci±g musi mieæ co najmniej 1000000 elementów.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0'
 onClick="napis(this.form,'Ci±g musi mieæ co najmniej 1000000 elementów.')">
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>