<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a>
</td></tr></table>

<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">5.&nbsp;  <b>Optymalno¶æ algorytmu binarnych 
      poszukiwañ</b></div> 

<p> Algorytm binarnych poszukiwañ wykonuje zadanie wyszukiwania w ci±gu 
uporz±dkowanym najlepiej z przedstawionych do tej pory algorytmów. Zastanówmy 
siê, czy jest mo¿liwe dalsze poprawienie kosztu. </p>

<p> Rozwa¿my klasê wszystkich algorytmów, które rozwi±zuj± problem wyszukiwania 
w ci±gu uporz±dkowanym przez porównywanie elementów. Dla ustalenia uwagi, niech 
ka¿dy algorytm w rozwa¿anej klasie, bêdzie ca³kowicie poprawny ze wzglêdu na 
specyfikacjê:</p>
<p style="text-align: center"> wp = {n &gt; 1, e[1]&lt; e[2]&lt; ... &lt; e[n], 
e[1]<font face="Symbol"> <span lang="en">&pound;</span></font> x <font face="Symbol">&lt;
</font>e[n]},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wk = {<font face="Symbol"> </font>result<font face="Symbol">
<span lang="en">&pound;</span> </font>n, e[result]<font face="Symbol"> <span lang="en">
&pound;</span> </font>x <font face="Symbol"><span lang="en">&pound;</span> </font>
e[result+1]}.</p>
<p>Drzewem decyzyjnym dla danego algorytmu wyszukiwania nazywaæ bêdziemy drzewo 
binarne, którego wierzcho³ki wewnêtrzne s± etykietowane parami porównywanych 
elementów, li¶cie zawieraj± warto¶ci zmiennej result. Ka¿dy wierzcho³ek 
wewnêtrzny ma dwa nastêpniki odpowiadaj±ce akcjom, które trzeba wykonaæ, gdy&nbsp; 
porównanie w tym wierzcho³ku da³o odpowied¼ tak i&nbsp; gdy da³o odpowied¼ nie. 
Ka¿da ¶cie¿ka odpowiada&nbsp; wiêc ci±gowi porównañ wykonanych przez algorytm 
dla konkretnych danych. Warto¶æ znajduj±ca siê w li¶ciu (na tej ¶cie¿ce) jest 
uzyskanym wynikiem algorytmu. Oznaczmy przez D(Alg,n) drzewo decyzyjne dla 
algorytmu Alg i danych o rozmiarze n.<Br>

<p>Przyk³ad 5.1</p>
<p>Niech rozwa¿anym 
algorytmem bêdzie algorytm poszukiwañ sekwencyjnych Search. Wtedy drzewo 
decyzyjne dla dowolnego ci±gu e[1], e[2], e[3], e[4],&nbsp; zosta³o 
przedstawione na rysunku 2_1.<p style="text-align: center">
<BR><img border="0" src="Rysunki/Rysunek2_1.gif" width="333" height="252"></p>
<br>
Przyk³ad 5.2<p style="text-align: left">Niech rozwa¿anym algorytmem bêdzie 
algorytm Skoki. Drzewo decyzyjne dla danych e[1], e[2],...,e[16] zosta³o 
przedstawione na rysunku 2_2.</p>

<p style="text-align: center"><img border="0" src="Rysunki/Rysunek2_3.gif" width="500" height="500"></p>

<p><b>Pytanie 5: </b>Ile maksymalnie pytañ TAK/NIE trzeba zadaæ, aby odgadn±æ 
dowoln± liczbê z przedzia³u [0,10<sup><font face="Verdana">6</font></sup>]? 
</p>
<!-- Odp. 6 lg 10.-->
<form><p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'6 lg 10.')">
</p></form>

<p>NA mocy za³o¿enia wszystkie algorytmy rozwa¿anej 
klasy zawsze daj± poprawne wyniki, zatem wszystkie mo¿liwe wyniki musz± siê 
znale¼æ jako etykiety li¶ci w ka¿dym z drzew decyzyjnych odpowiadaj±cych 
konkretnemu algorytmowi. Dla danych rozmiaru n, zmienna result, zgodnie ze 
specyfikacj± przyjmowaæ mo¿e tylko n-1 ró¿nych warto¶ci. Zatem liczba li¶ci 
dowolnego drzewa decyzyjnego D(Alg,n) musi byæ co najmniej równa n-1. 
Oczywi¶cie, liczba li¶ci mo¿e byæ du¿o wiêksza ni¿ n-1. Algorytm mo¿e wykonywaæ 
niepotrzebne porównania i wielokrotnie dochodziæ do tego samego wyniku.</p>
<p>Liczba wykonanych porównañ w konkretnym obliczeniu jest równa d³ugo¶ci 
¶cie¿ki od korzenia do li¶cia, zatem policzmy jak d³ugie musz± byæ ¶cie¿ki. 
Zanotujmy najpierw prosty fakt dotycz±cy drzew binarnych.</p>

<p><div class="lemat">
  <p>Lemat 5.1</p>
  <p>Je¿eli l jest liczb± li¶ci w drzewie binarnym, a h jego wysoko¶ci±, to l <font face="Symbol"> <span lang="en">&pound;</span> </font>
  2 <sup><font face="Verdana">h</font></sup>.</p>
</div>
<p></p>

<p>Dowód lematu 5.1 mo¿na przeprowadziæ przez proste rozumowanie indukcyjne ze 
wzglêdu na h.
</p>
<p>Wróæmy do problemu d³ugo¶ci ¶cie¿ek w drzewie decyzyjnym. Gdyby w jakim¶ 
drzewie decyzyjnym D(Alg,n) wszystkie ¶cie¿ki mia³y d³ugo¶æ mniejsz± ni¿ 
lg(n-1), to wysoko¶æ tego drzewa by³aby mniejsza ni¿ lg(n-1). Wtedy, na mocy 
lematu 5.1, liczba li¶ci w tym drzewie by³aby mniejsza ni¿ 2 <sup>
<font face="Verdana">lg(n-1)</font></sup>, czyli mniejsza od (n-1). Zmienna 
result w algorytmie Alg nie przyjmowa³aby jednej z mo¿liwych warto¶ci. To jednak 
jest niemo¿liwe, bo za³o¿yli¶my, ¿e wszystkie algorytmy rozwa¿anej klasy zawsze 
daj± poprawne wyniki. Wynika st±d, ¿e w ka¿dym drzewie decyzyjnym musi istnieæ 
jaka¶ ¶cie¿ka o d³ugo¶ci co najmniej lg(n-1). Oznacza to, ¿e w przypadku 
najgorszym liczba wykonanych porównañ musi byæ co najmniej równa lg(n-1). 
Poniewa¿ musi to byæ liczba ca³kowita, zatem liczba wykonanych porównañ w 
przypadku pesymistycznym wynosi co najmniej <span lang="en"><font face="Symbol">
é</font></span>lg(n-1)<font face="Symbol"><span lang="en">&ugrave;</span>.</font></p>
<p>Uzyskany wynik mówi, ¿e dla dowolnego algorytmu rozwi±zuj±cego problem 
wyszukiwania przez porównywanie elementów, zawsze znajd± siê takie dane, dla 
których algorytm wykona co najmniej <font face="Symbol">Q</font>(lg n) porównañ.</p>
<p>Poniewa¿ algorytm BinSearch wykonuje w najgorszym przypadku <span lang="en">
<font face="Symbol">é</font></span>lg n<font face="Symbol"><span lang="en">&ugrave;</span></font> 
porównañ, zatem:</p>

<p><div class="lemat">
  <p>Lemat 5.2</p>
  <p>Algorytm binarnych poszukiwañ BinSearch jest optymalnym, ze wzglêdu na 
  pesymistyczny koszt czasowy, rozwi±zaniem problemu wyszukiwania elementu w 
  danym ci±gu uporz±dkowanym.</p>
</div>
<p></p>

<p><b>Pytanie 6</b>: Który z algorytmów wyszukiwania w ci±gu uporz±dkowanym 
zosta³ zastosowany, je¿eli wykonano kolejno porównania z elementami&nbsp; ci±gu 
o nastêpuj±cych indeksach&nbsp; 64, 95, 111, 103, 99, 97, 96? Ile elementów mia³ 
ten ci±g?  .</p>

<!-- Odpowied¼: Algorytm binarnych&nbsp; poszukiwañ zastosowany do ci±gu o 127 
elementach</P> -->

<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' 
onClick="napis(this.form,'Algorytm binarnych&nbsp; poszukiwañ zastosowany do ci±gu o 127 elementach')">
</p>
</form>
<p><br clear="all">
</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_cw.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>