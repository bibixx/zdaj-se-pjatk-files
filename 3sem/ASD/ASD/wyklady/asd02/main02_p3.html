<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main02_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<p><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    </p>
    <div class="tytulpunktu">3.&nbsp; Skoki </div> 

<p class="MsoNormal" style="text-align:justify">Algorytm, który omówimy w tym 
punkcie jest tylko nieznaczn± modyfikacj± omawianej poprzednio metody 
sekwencyjnego poszukiwania w ci±gu uporz±dkowanym.</p>
<p class="MsoNormal" style="text-align:justify">Zastanówmy siê, jak wygl±daj± 
nasze poszukiwania w ksi±¿ce telefonicznej. Oczywi¶cie zak³adamy, ¿e wszystkie 
zawarte w niej informacje s± uporz±dkowane ze wzglêdu na porz±dek alfabetyczny. 
Je¶li zupe³nie nie wiemy, w której czê¶ci ksi±¿ki znajduje siê szukana przez nas 
pozycja, a ksi±¿ka jest gruba, to zwykle zniechêcamy siê przewracaniem kolejno 
kartki po kartce i przyspieszamy proces poszukiwania przerzucaj±c po kilka, lub 
kilkana¶cie kartek na raz i sprawdzaj±c za ka¿dym razem, czy ju¿ minêli¶my 
szukane has³o, czy te¿ jeszcze trzeba szukaæ dalej. Je¶li ju¿ przeskoczyli¶my 
kartkê z szukanym has³em, to postêpujemy teraz ostro¿niej np. cofaj±c siê kartka 
po kartce a¿ do znalezienia szukanej pozycji. Czy nie tak wygl±daj± Pañstwa 
poszukiwania w ksi±¿ce telefonicznej, czy w s³owniku?</p>
<p class="MsoNormal" style="text-align:justify">Spróbujmy teraz sformalizowaæ 
opisan± wy¿ej metodê. Zak³adamy, tak jak poprzednio, ¿e elementy przeszukiwanego 
zbioru s± umieszczone w tablicy na pozycjach e[1],...,e[n] w porz±dku rosn±cych 
warto¶ci. Dodatkowo przyjmiemy, ¿e poszukiwany element x mie¶ci siê w przedziale 
wyznaczonym przez pierwszy i ostatni element ci±gu. Zadanie niech polega na 
ustaleniu najmniejszego przedzia³u utworzonego przez elementy ci±gu, w którym 
mie¶ci siê x. Specyfikacja szukanego algorytmu bêdzie tym razem nastêpuj±ca: </p>
<p class="MsoNormal" style="text-align:center">wp = {n&gt;0, e[1] &lt; e[2] &lt;... &lt; e[n],&nbsp; e[1] 
<span style="font-family: Symbol">&pound;</span> x &lt; e[n]},&nbsp;&nbsp; wk =&nbsp; {e[result]
<span style="font-family: Symbol">&pound;</span> x <span style="font-family: Symbol">&pound;</span> e[result+1],&nbsp; 
1 <span style="font-family: Symbol">&pound;</span> result <span style="font-family: Symbol">&pound;</span> n}.</p>
<p class="MsoNormal" style="text-align:justify"><b>Metoda</b>: 
&nbsp;Porównujemy element x z co czwartym elementem danego ci±gu tak d³ugo a¿ 
znajdziemy element wiêkszy od x. Wtedy przeszukujemy  sekwencyjnie (co najwy¿ej) 
cztery elementy poprzedzaj±ce.&nbsp;&nbsp; </p>
<p class="MsoNormal" style="text-align:justify">W przedstawionym poni¿ej 
algorytmie u¿yli¶my&nbsp; instrukcji exit, która umo¿liwia natychmiastowe 
opuszczenie pêtli i przej¶cie do wykonywania nastêpuj±cych po niej instrukcji. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR/> </p>
<div class="przyk" style="width: 842; height: 228">
   <TABLE frame="void" rules="none" width="816" height="306">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="33" height="16"> Skoki </TD>
            <TD width="263" height="16">{</TD>
             
            <TD width="8" height="16">&nbsp; </TD>
             
            <TD width="494" height="16"></TD>
             
         </TR>
         <tr>
            <TD width="33" height="1"></TD>
         </tr>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">&nbsp;i := 4;<b>&nbsp; </b>&nbsp;</TD>
             
            <TD width="8" height="16"></TD>
             
            <TD width="494" height="16"></TD>
             
         </TR>
         <TR>
            <TD width="33" height="16">&nbsp; </TD>
            <TD width="263" height="16">&nbsp;<STRONG>while </STRONG>
            &nbsp;( i <font face="Symbol">&lt;</font> n )&nbsp;  <STRONG>do</STRONG>&nbsp;&nbsp;</TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16">// e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
            i-4&nbsp; oraz i <font face="Symbol">&lt;</font> n+4&nbsp; i dodatkowo 
            i <font face="Symbol">&lt;</font> n</TD> 
         </TR>
         <TR>
            <TD width="33" height="16"> </TD>
            <TD width="263" height="16">&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>
            (x &lt; e[i])&nbsp; <b>then</b></TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16"></TD> 
         </TR>
         <TR>
            <TD width="33" height="18"> </TD>
            <TD width="263" height="18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit </TD> 
            <TD width="8" height="18"></TD> 
            <TD width="494" height="18">// e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
            i-4&nbsp; oraz x &lt; e[i]<font face="Symbol"> </font>&nbsp;</TD> 
         </TR>
         <TR>
            <TD width="33" height="16"> </TD>
            <TD width="263" height="16">&nbsp;&nbsp;&nbsp;&nbsp; <b>else</b></TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16"></TD> 
         </TR>
         <TR>
            <TD width="33" height="16"> </TD>
            <TD width="263" height="16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            i := i + 4 </TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16">// e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
            i-4&nbsp; oraz i <font face="Symbol">&lt;</font> n+4 </TD> 
         </TR>
         <TR>
            <TD width="33" height="16"> </TD>
            <TD width="263" height="16">&nbsp;&nbsp;&nbsp;&nbsp; <b>fi;</b></TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16"></TD> 
         </TR>
         <TR>
            <TD width="33" height="16"> </TD>
            <TD width="263" height="16">   <STRONG>od</STRONG>
             ;</TD> 
            <TD width="8" height="16"></TD> 
            <TD width="494" height="16"> </TD> 
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">   <STRONG>&nbsp;&nbsp; </STRONG>&nbsp;&nbsp; </TD>
            <TD width="8" height="16">   </TD>
            <TD width="494" height="16">   //&nbsp; i<font face="Symbol"> &lt; </font>n 
            oraz&nbsp; e[i-4]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp;&lt; e[i]&nbsp;&nbsp; albo&nbsp; i-4<font face="Symbol"> &lt;</font> 
            n,&nbsp;n<font face="Symbol"> <span lang="en">&pound;</span></font> 
            i oraz e[i-4]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x &lt; e[n]</TD>
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">      <b>&nbsp;</b><STRONG>&nbsp;if </STRONG>
            (i&gt;n) <STRONG>then </STRONG>
            k := n<STRONG>-</STRONG>1<STRONG> else</STRONG>
            k := i-1<STRONG>&nbsp; fi;</STRONG></TD>
             
            <TD width="8" height="16">      </TD>
             
            <TD width="494" height="16">      //  i<font face="Symbol">-4 &lt;
            </font>k <font face="Symbol">&lt; </font>n oraz&nbsp; e[i-4]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp;&lt; e[k+1] </TD>
             
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">   &nbsp;<b>while </b>&nbsp;(k
            <span lang="en"><font face="Symbol">&sup1;</font></span> i-4
            and x &lt; e[k]<font face="Symbol"> </font>
            )&nbsp;
            <b>do</b> </TD>
            <TD width="8" height="16">   </TD>
            <TD width="494" height="16">   // x&lt; e[k+1] oraz&nbsp; x &lt; e[k] oraz&nbsp; 
            i-4&lt; k</TD>
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
            k := k-1  </TD>
            <TD width="8" height="16">   </TD>
            <TD width="494" height="16">   // x &lt; e[k+1] </TD>
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">   <strong>&nbsp;</strong><b>od</b>;&nbsp;&nbsp; &nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong></TD>
            <TD width="8" height="16">   </TD>
            <TD width="494" height="16">   // x&lt; e[k+1]&nbsp; oraz&nbsp; (e[k]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; lub&nbsp; k= i-4)</TD>
         </TR>
         <TR>
            <TD width="33" height="16"></TD>
            <TD width="263" height="16">   &nbsp;result := k;</TD>
            <TD width="8" height="16">   </TD>
            <TD width="494" height="16">   </TD>
         </TR>
         <TR>
            <TD width="33" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="263" height="16"></TD>
            <TD width="8" height="16"></TD>
            <TD width="494" height="16"></TD>
         </TR>
      </TBODY>
   </TABLE>
</div>
<p class="MsoNormal"><b>Poprawno¶æ</b>: Zauwa¿my najpierw, ¿e je¶li rozwa¿any 
ci±g ma mniej ni¿ 5 elementów, to nie wejdziemy do pierwszej pêtli. Druga za¶ jest 
znanym nam przeszukiwaniem sekwencyjnym, z tym, ¿e cofamy siê zaczynaj±c od 
przedostatniego elementu ci±gu (elementu ostatniego nie warto sprawdzaæ, bo z 
za³o¿enia&nbsp; x&lt; e[n]).  </p>
<p class="MsoNormal">Spróbujmy teraz przeanalizowaæ dzia³anie algorytmu w celu 
ustalenia niezmiennika pierwszej pêtli. Za³ó¿my, ¿e jeste¶my wewn±trz pêtli, tu¿ 
po sprawdzeniu testu (i <font face="Symbol">&lt;</font> n ), oraz&nbsp; e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
i-4, tzn. x nie jest mniejsze od wszystkich elementów ci±gu o numerach co 
najmniej o 4 mniejszych od aktualnej warto¶ci i. Po sprawdzeniu warunku
            (x &lt; e[i]) albo wyjdziemy z pêtli, wiedz±c, ¿e x mie¶ci siê 
miêdzy e[i-4] a e[i], albo stwierdzimy, ¿e x nie jest mniejsze od wszystkich 
elementów ci±gu a¿ do pozycji i. Teraz jednak, zgodnie z tre¶ci± pêtli, 
zwiêkszymy warto¶æ zmiennej i&nbsp; o 4. W konsekwencji znów wiemy, ¿e x 
nie jest mniejsze od wszystkich elementów ci±gu o numerach co najmniej o 4 
mniejszych od obecnej warto¶ci i, e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
            x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
i-4. Ponadto, je¿eli wchodzimy do pêtli z warto¶ci± i spe³niaj±c±&nbsp; i-4 &lt; n, 
to warunek pêtli gwarantuje, ¿e równie¿ i&lt;n. Zatem, nawet je¶li zwiêkszymy w tej 
iteracji warto¶æ i o 4, znów spe³niona bêdzie w³asno¶æ&nbsp; i-4 &lt; n.</p>
<p class="MsoNormal">Niezmiennikiem pierwszej pêtli jest wiêc formu³a&nbsp;&nbsp;&nbsp; 
i-4 &lt; n oraz&nbsp;&nbsp; e[j]<font face="Symbol"> <span lang="en">&pound;</span></font> 
x&nbsp; dla 0&lt; j<font face="Symbol">&nbsp; <span lang="en">&pound;</span></font> 
i-4.</p>
<p class="MsoNormal">Je¿eli opuszczamy pêtlê&nbsp; wykonuj±c instrukcjê exit, to 
oczywi¶cie zale¿no¶ci, które by³y w tym momencie prawdziwe (np. niezmiennik), 
nadal zachodz±. Wiemy jednak dodatkowo, ¿e x&lt;e[i]. Je¿eli opuszczamy pêtlê, 
poniewa¿ i&gt;n, to znów niezmiennik jest spe³niony. Ostatecznie do wyj¶ciu z 
pierwszej pêtli prawdziwa jest formu³a</p>
<p class="MsoNormal" style="text-align: center">(e[i-4]<font face="Symbol"> <span lang="en">&pound;</span></font> 
x <span lang="en"><font face="Symbol">&Ugrave;</font></span> (i-4)&lt;n <span lang="en">
<font face="Symbol">&Ugrave;</font></span> x&lt;e[i] <span lang="en"><font face="Symbol">&Ugrave;</font></span> 
i&lt; n)<font face="Verdana">&nbsp;
</font> <font face="Symbol"> <span lang="en">Ú</span> </font>(n <font face="Symbol"> <span lang="en">&pound;</span> </font>
i <span lang="en">
<font face="Symbol">&Ugrave;</font></span> e[i-4]<font face="Symbol"> <span lang="en">&pound;</span></font> 
x <span lang="en"><font face="Symbol">&Ugrave;</font></span> (i-4)&lt;n <span lang="en">
<font face="Symbol">&Ugrave;</font></span> x&lt;e[n])</p>
<p class="MsoNormal">W drugim cz³onie tej alternatywy dopisali¶my zale¿no¶æ 
x&lt;e[n], która wynika z przyjêtego warunku pocz±tkowego. </p>
<p class="MsoNormal">Pozosta³o jeszcze sprawdziæ co dzieje siê w drugiej pêtli. 
Przed wej¶ciem do drugiej pêtli x&lt;e[k+1]. Je¿eli po &quot;do&quot; spe³niony jest warunek 
x&lt;e[k+1], to poniewa¿ musieli¶my przej¶æ przez test, wiemy dodatkowo, ¿e x&lt;e[k] 
oraz k&gt; i-4. Zatem po wykonaniu instrukcji k := k-1, znów x&lt;e[k+1]. Ponadto ca³y 
czas prawdziwa jest formu³a i-4<font face="Symbol">&nbsp; <span lang="en">&pound;</span> </font>
k. Je¿eli i=4, to w drugiej pêtli, k mo¿emy zmniejszyæ tylko do 1, bo na mocy 
warunku pocz±tkowego e[1]<font face="Symbol"><span lang="en">&pound;</span></font> x. 
Wynika st±d, ¿e niezmiennikiem drugiej pêtli jest formu³a ( x&lt;e[k+1] <font face="Symbol"> <span lang="en">&Ugrave;</span> </font>&nbsp;i-4<font face="Symbol"> 
&lt;</font>
k). Wyj¶cie z drugiej pêtli nast±pi albo, gdy k= i-4, albo,&nbsp; gdy e[k]<font face="Symbol"> <span lang="en">&pound;</span></font> 
x. Zatem po wyj¶ciu z drugiej pêtli mamy </p>
<p class="MsoNormal" style="text-align: center">albo k= i-4 <font face="Symbol"> <span lang="en">&Ugrave;</span>&nbsp; </font>
x &lt; e[k+1]&nbsp; albo i-4 <font face="Symbol">&lt;</font> k<font face="Symbol">&nbsp; <span lang="en">&Ugrave;</span>&nbsp; </font>
e[k]<font face="Symbol"> <span lang="en">&pound;</span></font> x<font face="Symbol">&nbsp; <span lang="en">&Ugrave;</span> </font>&nbsp;x 
&lt; e[k+1].</p>
<p class="MsoNormal">Bior±c pod uwagê, ¿e przy wej¶ciu do drugiej pêtli 
spe³niony by³ warunek e[i-4] <font face="Symbol"> <span lang="en">&pound;</span></font> 
x dla i &gt;4 lub&nbsp; e[1]<font face="Symbol"><span lang="en">&pound;</span></font> x&nbsp; 
dla i=4, otrzymujemy ostatecznie&nbsp; e[k] <font face="Symbol"> <span lang="en">&pound;</span></font> 
x &lt; e[k+1], i ta w³a¶nie warto¶æ k jest przypisana zmiennej result.</p>

<p><div class="lemat">
   Twierdzenie 3.1<p>W 
   dowolnej strukturze danych z porz±dkiem liniowym
   <span lang="en"> <font face="Symbol">
   &pound;</font></span>, algorytm Skoki jest ca³kowicie poprawny ze wzglêdu na 
   specyfikacjê&nbsp; </p>
   <p style="text-align: center">wp =&nbsp; {n &gt; 0, e[1]&lt; e[2]&lt; ... &lt; e[n]},&nbsp; wk 
   = { (result = i<font face="Symbol">&nbsp; <span lang="en">&Ugrave;</span></font> i<font face="Symbol"> &lt; </font>n
   <font face="Symbol"><span lang="en">&Ugrave;</span></font><font face="Verdana"> </font>e[i]<font face="Symbol">
   <span lang="en">&pound;</span> </font>x <font face="Symbol">&lt;</font><font face="Verdana"> </font>e[i+1])}.</p>

</div>
<p></p>

<p><b>Pytanie 3:</B> Ile porównañ wykona algorytm wyszukiwania Skoki, 
je¿eli ci±g sk³ada siê ze stu elementów oraz wiadomo, ¿e szukany element spe³nia 
warunek e[1] <font face="Symbol">
   <span lang="en">&pound;</span> </font>x &lt;e[2]? </P>

<!-- <p>Odpowied¼: 3 porównania.  </P> -->
 
<FORM>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'Trzy porównania');">
</p>
</form>

<p class="MsoNormal"><b>Koszt algorytmu</b>: W najgorszym razie przejdziemy krokami 
&quot;co 4&quot; ca³y ci±g nie znajduj±c odpowiedzi (nie porównujemy x z 
elementem&nbsp; ostatnim nawet, gdy n jest podzielne przez 4, bo warunkiem pêtli 
jest i&lt;n). Musimy siê wtedy cofn±æ i przejrzeæ 
osobno pominiête&nbsp; 3 elementy. Pesymistyczny<b> </b>algorytmu, mierzony 
liczb± wykonanych porównañ, wynosi<b> : </b>W(n)=<b> </b>[(n-1)/4]+3.</p>
<p class="MsoNormal">Na koniec, zauwa¿my, ¿e nic nie stoi na przeszkodzie, aby 
wykonywaæ wiêksze &quot;skoki&quot;. Pozostawiamy Czytelnikowi zadanie, przekszta³cenia 
algorytmu skoki do postaci procedury&nbsp; SKOKI(k), której parametr k 
okre¶la³by d³ugo¶æ wykonywanego &quot;skoku&quot;. Oczywista modyfikacja polegaæ bêdzie na 
zamianie liczby 4 na k. Jasne jest te¿, ¿e tak zmodyfikowany algorytm wykona w 
najgorszym razie [(n-1)/k] + k-1 porównañ.</p>


<p class="MsoNormal"><b>Pytanie 4:  </b>Dla jakich warto¶ci k algorytm&nbsp; 
SKOKI(k) ma najmniejszy 
koszt pesymistyczny?</p>
<p></P>
<p><a class="ODP" href="javascript:okno('odpowiedzi/odp2_4.html')">Zobacz odpowied¼</a><br clear="all"></p>

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main02_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>