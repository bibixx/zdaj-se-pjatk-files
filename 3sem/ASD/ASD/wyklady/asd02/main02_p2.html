<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main02_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main02_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
<div class="tytulpunktu">2. Wyszukiwanie w ci±gu uporz±dkowanym.</div> 

<p> W tym punkcie rozwa¿ymy problem wyszukiwania przy za³o¿eniu, ¿e 
przeszukiwany ci±g jest podzbiorem pewnego liniowo uporz±dkowanego zbioru i sam 
jest uporz±dkowany.</p>

<p> <b>Problem:</b> Dany jest element x oraz  ci±g n elementowy uporz±dkowany
  rosn±co. Zadanie polega na znalezieniu takiego przedzia³u, wyznaczonego przez 
kolejne elementy ci±gu, do którego x nale¿y, lub stwierdzenie, ¿e x do tego 
ci±gu nie nale¿y.</p>

<p> Za³ó¿my tak jak poprzednio, ¿e elementy ci±gu s± zapisane w tablicy e&nbsp; 
na pozycjach e[1], e[2], ..., e[n] i niech specyfikacja poszukiwanego algorytmu 
bêdzie nastêpuj±ca:</p>
<p style="text-align: center"> wp = {n &gt; 0, e[1]&lt; e[2]&lt; ... &lt; e[n]},</p>
<p style="text-align: center"> wk = {(x &lt; e[1] <font face="Symbol">
<span lang="en">&Ugrave;</span></font> result = 0) <font face="Symbol"><span lang="en">
Ú</span></font> ( e[n]<font face="Symbol"> <span lang="en">&pound;</span> </font>x
<font face="Symbol"><span lang="en">&Ugrave;</span> </font>result = n)
<font face="Symbol"><span lang="en">Ú</span></font>&nbsp; (result = i<font face="Symbol">&nbsp;
<span lang="en">&Ugrave;</span></font> i<font face="Symbol"> 
&lt; </font>n <font face="Symbol"><span lang="en">&Ugrave;</span> </font>e[i]<font face="Symbol">
<span lang="en">&pound;</span> </font>x <font face="Symbol">&lt; </font>e[i+1])}.</p>
<p> Przyjêli¶my wiêc, ¿e wynikiem algorytmu ma byæ liczba 0, gdy x&nbsp; jest 
liczb± mniejsz± od wszystkich elementów ci±gu (x&lt;e[1]), liczba n, gdy x jest 
niemniejsze od 
wszystkich elementów ci±gu, lub liczba i, 1<font face="Symbol"> <span lang="en">
&pound;</span> </font>i<font face="Symbol"> <span lang="en">&pound;</span> </font>n, gdy e[i]<font face="Symbol">
<span lang="en">&pound;</span></font> x &lt; e[i+1].</p>
<p> <b>Metoda:</b> Pierwsze najprostsze rozwi±zanie, to sekwencyjne przeszukanie ci±gu. 
Najpierw rozwa¿ymy przypadek, gdy szukany element x nie mie¶ci siê w ¿adnym 
przedziale wyznaczonym przez elementy danego ci±gu.&nbsp; Je¶li obie sytuacje x 
&lt; e[1] i e[n]<font face="Symbol"> <span lang="en">&pound;</span></font> x s± ju¿ 
wykluczone, to wiemy na pewno, ¿e&nbsp; e[i]<font face="Symbol"> <span lang="en">
&pound;</span></font> x &lt; e[n]. Aby ustaliæ w³a¶ciw± odpowied¼, wystarczy teraz 
porównywaæ x z kolejnymi elementami ci±gu.</p>

<H4 class="paragraph"><font size="2">ALGORYTM </font><BR/> </H4>
<div class="przyk" style="width: 842; height: 228">
   <TABLE frame="void" rules="none" width="816">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="33"> Search </TD>
            <TD width="274">{</TD>
             
            <TD width="34">&nbsp; </TD>
             
            <TD width="457">&nbsp;</TD>
             
         </TR>
         <tr>
            <TD width="33"></TD>
         </tr>
         <TR>
            <TD width="33"></TD>
            <TD width="274"><b>if</b> x&lt; e[1] <b>then</b> i := 0 <b>else </b> </TD>
             
            <TD width="34">&nbsp;</TD>
             
            <TD width="457">// i=0, gdy x jest mniejsze od wszystkich elementów 
            ci±gu</TD>
             
         </TR>
         <TR>
            <TD width="33">&nbsp; </TD>
            <TD width="274">&nbsp;&nbsp;&nbsp; <b>if</b> e[n]<font face="Symbol">
            <span lang="en">&pound;</span> </font>x <b>then</b> i := n <b>else</b>&nbsp;&nbsp; </TD> 
            <TD width="34">&nbsp;</TD> 
            <TD width="457">// i=n, gdy x jest równy lub wiêkszy od e[n]</TD> 
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="274">   <STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             &nbsp;&nbsp;&nbsp; i := 1;</TD>
            <TD width="34">   &nbsp;</TD>
            <TD width="457">   // e[1]<font face="Symbol"> <span lang="en">&pound;</span></font> x &lt; e[n]</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="274">      &nbsp;<STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while </STRONG>
            (not x &lt; e[i+1])  <STRONG>do </STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="34">      &nbsp;</TD>
             
            <TD width="457">      // e[i]<font face="Symbol"> <span lang="en">&pound;</span></font> x 
            oraz e[i+1]<font face="Symbol"> <span lang="en">&pound;</span></font> x </TD>
             
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="274">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            i := i+1 </TD>
            <TD width="34">   &nbsp;</TD>
            <TD width="457">   // e[i]<font face="Symbol"> <span lang="en">&pound;</span></font> x</TD>
         </TR>
         <TR>
            <TD width="33"></TD>
            <TD width="274">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; od</STRONG> 
            ;</TD>
            <TD width="34">   &nbsp;</TD>
            <TD width="457">   // e[i]<font face="Symbol"> <span lang="en">&pound;</span></font> x&nbsp; 
            oraz x &lt; e[i+1]</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="274">   <strong>&nbsp;&nbsp;fi fi</strong>&nbsp;;&nbsp;&nbsp; &nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong></TD>
            <TD width="34">   &nbsp;</TD>
            <TD width="457">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33">&nbsp;</TD>
            <TD width="274">   &nbsp;result := i;</TD>
            <TD width="34">   &nbsp;</TD>
            <TD width="457">   &nbsp;</TD>
         </TR>
         <TR>
            <TD width="33"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></TD>
            <TD width="274"></TD>
            <TD width="34">&nbsp;</TD>
            <TD width="457">&nbsp;</TD>
         </TR>
      </TBODY>
   </TABLE>
</div>
<P>
   Niezmiennikiem pêtli w tym algorytmie jest formu³a&nbsp; e[i]<font face="Symbol">
   <span lang="en">&pound;</span></font> x. Rzeczywi¶cie, je¿eli spe³niony jest 
   warunek pêtli (not x &lt; e[i+1]) oraz e[i]<font face="Symbol"> <span lang="en">
   &pound;</span></font> x&nbsp; dla pewnej warto¶ci i, to wiemy równie¿, ¿e&nbsp; 
   e[i+1]<font face="Symbol"> <span lang="en">&pound;</span></font> x. Po wykonaniu 
   jedynej instrukcji&nbsp; pêtli i := i+1, x spe³nia zale¿no¶æ e[i]<font face="Symbol"><span lang="en">&pound;</span></font> x. 
   Poniewa¿ formu³a&nbsp; e[i]<font face="Symbol"> <span lang="en">&pound;</span></font> x 
   jest spe³niona przed pierwszym wej¶ciem do pêtli (i jest wtedy równe 1), oraz 
   jest jej niezmiennikiem, zatem na mocy twierdzenia o niezmienniku (por. 
   wyk³ad 1.4), po wyj¶ciu z pêtli te¿ bêdzie spe³niona. Skoro wyszli¶my z 
   pêtli, to sta³o siê tak dlatego, ¿e warunek (not x &lt; e[i+1]) nie by³ 
   spe³niony. Mamy wiêc e[i] <font face="Symbol"> <span lang="en">&pound;</span></font> x&nbsp; 
   oraz x &lt; e[i+1], a zmienna result przyjmie w³a¶nie warto¶æ i.</P>
<P>
   Zastanówmy siê jeszcze nad problemem zatrzymywania siê tego algorytmu. Je¿eli 
   nie zachodzi ¿aden z dwóch pierwszych warunków (x&lt; e[1], e[n]<font face="Symbol">
   <span lang="en">&pound;</span> </font>x ), to wiemy na pewno, ¿e e[1] <font face="Symbol">
   <span lang="en">&pound;</span></font> x &lt; e[n]. Wynika to z za³o¿enia, ¿e 
   relacja <font face="Symbol"><span lang="en">&pound;</span> </font>jest liniowym 
   porz±dkiem, a ci±g jest rosn±cy. W konsekwencji zmienna i nie mo¿e przyj±æ 
   warto¶ci wiêkszej od n. Pêtla zatrzyma siê po co najwy¿ej n-1 krokach dla 
   wszystkich danych spe³niaj±cych warunek pocz±tkowy. Mo¿emy 
   wiêc sformu³owaæ twierdzenie:</P>

<p><div class="lemat">
   Twierdzenie 2.1<p>Algorytm Search jest ca³kowicie poprawny ze wzglêdu na warunek 
   pocz±tkowy&nbsp; wp =&nbsp; {n &gt; 0, e[1]&lt; e[2]&lt; ... &lt; e[n]} i 
   warunek koñcowy wk = {(x &lt; e[1] <font face="Symbol"><span lang="en">&Ugrave;</span></font> 
   result = 0) <font face="Symbol"><span lang="en">Ú</span></font> ( e[n]<font face="Symbol">
   <span lang="en">&pound;</span></font> x <font face="Symbol"><span lang="en">&Ugrave;</span></font><font face="Verdana">
   </font>result = n) <font face="Symbol"><span lang="en">Ú</span></font>&nbsp; 
   (result = i<font face="Symbol">&nbsp; <span lang="en">&Ugrave;</span></font> i<font face="Symbol"> &lt; </font>n
   <font face="Symbol"><span lang="en">&Ugrave;</span></font><font face="Verdana"> </font>e[i]<font face="Symbol">
   <span lang="en">&pound;</span> </font>x <font face="Symbol">&lt;</font><font face="Verdana"> </font>e[i+1])} w 
   dowolnej strukturze danych z porz±dkiem liniowym <font face="Symbol">
   <span lang="en">&pound;</span></font>.</p>
   <p>

</div>
<p></p>

<p>Analiza kosztu omawianego tu algorytmu jest bardzo podobna do analizy 
przedstawionej w punkcie 1. Jako operacjê dominuj±c± wybierzmy porównywanie 
elementów ci±gu.&nbsp; W najgorszym razie algorytm wykona 2 + (n-1) porównañ 
przegl±daj±c wszystkie elementy ci±gu, gdy¿ przypadek najgorszy dla naszego algorytmu, 
to&nbsp; e[n-1] <font face="Symbol"><span lang="en">&pound;</span> </font>x &lt; e[n].</p>

<p>Aby oszacowaæ koszt ¶redni przyjmijmy pewne uproszczenia. Po pierwsze 
za³o¿ymy, ¿e struktur± danych dla naszego algorytmu jest zbiór liczb 
rzeczywistych oraz, ¿e zarówno x jak i elementy ci±gu mieszcz± siê w przedziale [a, b] 
wyznaczonym przez pewne liczby rzeczywiste a, b, a&lt;b. Niech dla uproszczenia notacji 
e[0]=a oraz e[n+1]=b. W ten sposób obszar naszych poszukiwañ sk³ada siê z n+1 
przedzia³ów: e[0]-e[1], e[1]-e[2], itd. e[n-1]-e[n], e[n]-e[n+1]. Za³o¿ymy 
ponadto, ¿e prawdopodobieñstwo tego, ¿e x przyjmuje dowoln± warto¶æ c z 
przedzia³u [a, b] jest dla wszystkich c taka sama. Prawdopodobieñstwo tego, ¿e x 
znajduje siê w jakim¶ ustalonym przedziale mo¿na zmierzyæ stosunkiem d³ugo¶ci 
rozwa¿anego przedzia³u do d³ugo¶ci ca³ego obszaru:</p>

<p style="text-align: center">&nbsp;P(x <span lang="en"><font face="Symbol">Î</font></span> 
[e[i],e[i+1]]) = |[e[i],e[i+1]]|/|[a,b]| = (e[i+1]-e[i])/(b-a).</p>

<p>Zauwa¿my, ¿e niezale¿nie od tego jaka jest konkretna warto¶æ zmiennej x, je¿eli&nbsp; x
<span lang="en"><font face="Symbol">Î</font></span> [e[0],e[1]], to algorytm Search wykona jedno porównanie, je¿eli 
x
<span lang="en"><font face="Symbol">Î</font></span> [e[n],e[n+1]], wykona 2 porównania, 
a gdy x
<span lang="en"><font face="Symbol">Î</font></span> [e[i],e[i+1]], gdzie 0&lt;i&lt;n, 
wykona (2 + i)&nbsp; porównañ. Oczekiwan± liczbê porównañ wykonan± przez 
algorytm Search policzymy ze wzoru:</p>

<p style="text-align: center">A(Search,n) = P(x <span lang="en">
<font face="Symbol">Î</font></span> [e[0],e[1]])<font face="Symbol">
<span lang="en">´</span></font> 1 + P(x <span lang="en"><font face="Symbol">Î</font></span> 
[e[n],e[n+1]]) <font face="Symbol"><span lang="en">´</span></font> 2 +
<font face="Symbol">S</font><sub><font face="Verdana">0&lt;i&lt;n</font></sub> P(x <font face="Symbol">Î</font> [e[i],e[i+1]]) (2+i).</p>

<p>Wynika st±d, ¿e  </p>

<p style="text-align: center">A(Search, n) = ((e[1]-a) +2(b-e[n]) + <font face="Symbol">S</font><sub><font face="Verdana">0&lt;i&lt;n</font></sub> 
(e[i+1]-e[i])(2+i))/(b-a) = <P><center>
((b-a) +(b-e[1])+ <font face="Symbol">S</font><sub><font face="Verdana">0&lt;i&lt;n</font></sub> 
(e[n]-e[i]))/(b-a).</center></p> </p>
<P>
   Oczywi¶cie, tê ostatni± sumê mo¿na oszacowaæ z góry przez 2+(n-1), co nie 
   jest wynikiem specjalnie interesuj±cym. Je¿eli natomiast dodatkowo za³o¿ymy, 
   ¿e d³ugo¶ci przedzia³ów [e[i+1],e[i]] wyznaczonych przez kolejne elementy 
   ci±gu s± takie same, to  P(x <font face="Symbol">Î</font> [e[i],e[i+1]]) = 1/(n+1).
</P>
Wtedy
<P style="text-align: center">
   A(Search, n) =&nbsp; 1*1/(n+1) + 2*1/(n+1) + <font face="Symbol">S</font><sub><font face="Verdana">0&lt;i&lt;n</font></sub>(2+i)*1/(n+1)  = n/2 + 1.</P>
<p>Uwaga. Je¿eli wiemy, ¿e szukany element znajduje siê w przedziale wyznaczonym przez pierwszy i ostatni element ci±gu, to  w algorytmie Search mo¿emy pomin±æ dwa pierwsze porównania.</p>
<p><b>Pytanie 2:&nbsp;  </b>Jaka jest oczekiwana liczba porównañ 
wykonanych przez algorytm Search (zmodyfikowanym tak jak w powy¿ej Uwadze), je¶li zosta³ on zastosowany do ci±gu 
0,4,8,16,32, a rozwa¿an± struktur± danych s± liczby naturalne i wiemy, ¿e 
szukany element x jest liczb± naturaln± spe³niaj±c± warunek 0&lt;x&lt;33? </p>
<!-- Odp. 25/8  = 4*1/32 + 4*2/32 + 8*3/32 + 16*4/32-->
<FORM>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'25/8');">
</p>
</form>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main02_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main02_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>