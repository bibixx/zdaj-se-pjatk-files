<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td-->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
<td align="left"><A HREF="main05_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main05_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
    </tr>
</table>

<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">1. Z³o¿ono¶æ problemu sortowania, koszt 
      pesymistyczny</div> 

    <p>W poprzednim wyk³adzie poznali¶my kilka podstawowych algorytmów sortowania. Ich 
    wspóln± cech± by³o wykonywanie porównañ elementów w celu ustalenia 
    ostatecznej ich kolejno¶ci. Inn± wspóln± cech± tych algorytmów by³a ich 
    uniwersalno¶æ: mog³y byæ stosowane do obiektów dowolnych typów, byle tylko 
    by³ na nich okre¶lony liniowy porz±dek. Z³o¿ono¶æ 
    tych algorytmów waha³a siê od kwadratowej do liniowo-logarytmicznej wzglêdem 
    d³ugo¶ci sortowanego ci±gu. Teraz zastanowimy siê nad z³o¿ono¶ci± samego 
    problemu sortowania, tzn. zbadamy, jak kosztowne musz± byæ 
    algorytmy rozwi±zywania tego problemu.</p>
  


<p></P>

<div class="def">
<p>Definicja 1.1&nbsp;&nbsp; Drzewo binarne nazwiemy lokalnie pe³nym wtedy i 
tylko wtedy, gdy ka¿dy wierzcho³ek tego drzewa jest albo li¶ciem (czyli 
nie ma nastêpników), albo ma dok³adnie dwa nastêpniki.</P>

</div>

<p></P>



<p>Niech Sort bêdzie dowolnym algorytmem rozwi±zuj±cym problem sortowania przez 
porównywanie elementów.</P><p></P>

<div class="def">
<p>Definicja 1.2&nbsp; Drzewem decyzyjnym dla algorytmu sortowania Sort zastosowanym do dowolnego n 
elementowego ci±gu, nazywamy etykietowane drzewo binarne, lokalnie pe³ne, takie ¿e <br>
(1)&nbsp; etykietami wierzcho³ków wewnêtrznych s± elementy porównywane w kolejnych&nbsp; 
krokach algorytmu Sort, <br>
(2)&nbsp; krawêdzie &quot;w lewo&quot; odpowiadaj± odpowiedzi TAK na postawione w 
wierzcho³ku pytanie, a krawêdzie &quot;w prawo&quot; odpowiadaj±&nbsp; odpowiedzi NIE,<br>
(3)&nbsp; etykietami li¶ci s± uporz±dkowane niemalej±co permutacje elementów 
danego ci±gu.</P>

</div>

<p></P>

    <p><b>Przyk³ad 1.1</b></p>
  


    <p>Na rysunku 5.1 przedstawiono drzewo decyzyjne algorytmu SelectionSort, 
    zastosowanego do ci±gu trzyelementowego e[1], e[2], e[3].</p>
  


    <p><center><img border="0" src="Rysunki/Rysunek5_1.gif" width="400" height="250"></center></p>
  


    <p>Ka¿de wykonanie algorytmu SelectionSort dla ci±gu z³o¿onego z trzech 
    elementów, ma odpowiadaj±c± mu ¶cie¿kê 
    w tym drzewie. Liczby i : j zapisane w wierzcho³kach drzewa mówi±, ¿e 
    porównywane s± elementy&nbsp; i-ty i j-ty sortowanego ci±gu. Je¶li e[i]
    <span lang="en"><font face="Symbol">&pound;</font></span> e[j], to idziemy w lewo, 
    a w przeciwnym przypadku idziemy w prawo. Li¶cie drzewa zawieraj± kolejno¶æ 
    w jakiej elementy sortowanego ci±gu powinny wystêpowaæ w uporz±dkowaniu 
    niemalej±cym. Je¿eli sortowane elementy to e[1] = 3, e[2] = 2, e[3] = 5, to 
    wykonaniu algorytmu SelectionSort dla tego ci±gu, odpowiada przej¶cie po 
    ¶cie¿ce od korzenia do li¶cia (2,1,3). <font face="Wingdings">J</font></p>
  


    <p><b>Przyk³ad 1.2</b></p>
  


    <p>Na rysunku 5.2 przedstawiono drzewo decyzyjne algorytmu InsertionSort, 
    zastosowanego do ci±gu trzyelementowego e[1], e[2], e[3].</p>
  


    <p><center><img border="0" src="Rysunki/Rysunek5_2.gif" width="400" height="250"></center></p>
  


    <p>Je¿eli sortujemy ci±g e[1] = 2, e[2] = 7, e[3] = 5, to wykonaniu 
    algorytmu InsertionSort odpowiada ¶cie¿ka od korzenia do li¶cia (1,3,2). 
    Zauwa¿my, ¿e ¶cie¿ka odpowiadaj±ca wykonaniu algorytmu InsetionSort dla 
    ci±gu e[1] = 3, e[2] = 2, e[3] = 5, jest krótsza ni¿ w przypadku algorytmu 
    SelectionSort.<font face="Wingdings"> J</font></p>
  


<p><b>Pytanie 1</B>: Ile wierzcho³ków maksymalnie mo¿e siê znajdowaæ na poziomie&nbsp; 
k drzewa decyzyjnego (Korzeñ jest na poziomie 0, synowie korzenia - na poziomie 
1 itd)? </p>

<!-- Odpowied¼: Co najwy¿ej 2^k.</P> -->

<form>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' 
onClick="napis(this.form,'Co najwy¿ej 2^k.')"> </p>
</form>
  


<p></P>

<div class="lemat">
<p>Lemat 1.1&nbsp;&nbsp; Je¿eli n jest liczb± li¶ci w drzewie binarnym, a h jego 
wysoko¶ci±, to&nbsp; </P>
<p style="text-align: center">(a) n <font face="Symbol"><span lang="en">&pound;</span> </font>2 <sup>
    <font face="Verdana">h</font></sup>,<font face="Verdana"><sup>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sup></font>(b)&nbsp; h <span lang="en"><font face="Symbol">&sup3;</span> <span lang="en">é</span></font>lg 
n<font face="Symbol"><span lang="en">&ugrave;</span>.</font></P>
 </div>
 
<p></P>
<p>Dowód Lematu 1.1 (a) przeprowadzimy przez indukcjê ze wzglêdu na h. 
Oczywi¶cie nierówno¶æ (a) jest prawdziwa dla h=0, bo wtedy drzewo sk³ada siê 
tylko z jednego wierzcho³ka. Za³ó¿my, ¿e nierówno¶æ (a) jest prawdziwa dla 
wszystkich drzew o wysoko¶ci h.&nbsp; 
 
</P>

<p><center>
<img border="0" src="Rysunki/Rysunek5_3.gif" width="300" height="250" align="left"></center></P>

<p>Rozwa¿my drzewo o wysoko¶ci h+1, por. Rysunek 5.3. </P>

<p>Niech y bêdzie liczb± wierzcho³ków wewnêtrznych na przedostatnim poziomie 
tego drzewa. Na mocy za³o¿enia indukcyjnego liczbê li¶ci w drzewie do wysoko¶ci h mo¿emy 
oszacowaæ przez 2<sup><font face="Verdana">h</font></sup>-y. Zatem wszystkich 
li¶ci w drzewie o wysoko¶ci h+1 jest co najwy¿ej 2y + (2<sup><font face="Verdana">h</font></sup>-y). Mamy 
:</P>

<p style="text-align: center">n <font face="Symbol"><span lang="en">&pound;</span></font> 
2y + (2<sup><font face="Verdana">h</font></sup>-y) = y + 2<sup><font face="Verdana">h</font></sup> <font face="Symbol"><span lang="en">&pound;</span>&nbsp; 
2</font><sup><font face="Verdana">h</font></sup><font face="Symbol"> + 2</font><sup><font face="Verdana">h</font></sup><font face="Symbol"> 
= 2<sup> </sup> </font><sup>h</sup><font face="Symbol"><sup>+1</sup>.</font></P>



    <p>Na mocy zasady indukcji matematycznej, nierówno¶æ (a) jest prawdziwa dla 
    wszystkich h. </p>
  


    <p>&nbsp;</p>
  


    <p>&nbsp;</p>
  


    <p>W³asno¶æ (b) otrzymujemy przez zlogarytmowanie nierówno¶ci (a) oraz 
    uwzglêdnienie faktu, ¿e h jest liczb± naturaln±.<font face="Wingdings"> J</font></p>
  


    <p>Drzewo decyzyjne dla dowolnego algorytmu sortuj±cego ci±g n elementowy 
    musi zawieraæ ¶cie¿ki prowadz±ce do wszystkich mo¿liwych odpowiedzi, tzn. 
    wszystkich mo¿liwych permutacji ci±gu n elementowego. Wynika st±d, ¿e liczba 
    li¶ci w tym drzewie musi byæ co najmniej równa n!. Na mocy Lematu 1.1 
    wysoko¶æ h drzewa decyzyjnego dla algorytmu sortuj±cego ci±g n elementowy 
    musi spe³niaæ nierówno¶æ h<font face="Symbol"> <span lang="en">&sup3;</span> <span lang="en">é</span></font>lg 
    n!<font face="Symbol"><span lang="en">&ugrave;</span>. </font></p>
  


<p></P>

<div class="lemat">
<p>Lemat 1.2&nbsp;&nbsp; Ka¿de drzewo decyzyjne dla dowolnego algorytmu 
sortuj±cego ci±g n elementowy przez porównywanie elementów, ma co najmniej 
wysoko¶æ <font face="Symbol"> <span lang="en">é</span></font>lg n!<font face="Symbol"><span lang="en">&ugrave;</span></font>.</P>
 </div>
 
<p></P>
  


    <p>Wysoko¶æ drzewa&nbsp; decyzyjnego wyznacza ograniczenie górne na 
    liczbê wykonanych porównañ, na dowolnej ¶cie¿ce w drzewie decyzyjnym, a co za 
    tym idzie, determinuje ograniczenie liczby porównañ wykonanych przez algorytm 
    sortuj±cy. Wynika st±d nastêpuj±ce twierdzenie:<br>
&nbsp;</p>
  


<p><div class="lemat">
  <p>Twierdzenie 1.3&nbsp; Ka¿dy algorytm Alg sortuj±cy ci±g n elementowy przez 
  porównania musi wykonaæ co najmniej <font face="Symbol"> <span lang="en">é</span></font>lg 
  n!<font face="Symbol"><span lang="en">&ugrave;</span> </font>porównañ w 
  najgorszym przypadku, tzn.</p>
  


    <p style="text-align: center">W(Alg, n)<font face="Symbol"> <span lang="en">&sup3;</span></font> <font face="Symbol"> <span lang="en">é</span></font>lg 
    n!<font face="Symbol"><span lang="en">&ugrave;</span></font>.</p>
  


</div>
<p></p>



    <p>Przypomnijmy, ¿e lg n! <span lang="en"><font face="Symbol">&sup3;</font></span> 
    n<span lang="en"><font face="Symbol">´</font></span>lgn - n<span lang="en"><font face="Symbol">´</font></span>lg e.&nbsp;Twierdzenie to mówi, ¿e dla ka¿dego algorytmu sortuj±cego ci±g n 
    elementowy przez porównywanie elementów, zawsze znajd± siê takie dane, dla 
    których algorytm musi wykonaæ co najmniej <font face="Symbol">Q</font>(n<span lang="en"><font face="Symbol">´</font></span>lgn) 
    porównañ.</p>
  


    <p><b>Uwaga.</b> Algorytm MergeSort wykonuje dla dowolnego n elementowego 
    ci±gu <font face="Symbol">O</font>(n<span lang="en"><font face="Symbol">´</font></span>lgn) 
    porównañ. Jest wiêc optymalnym algorytmem sortowania, bo górne ograniczenie 
    czasu dzia³ania algorytmu jest zgodne z pesymistyczn± doln± granic± 
    z³o¿ono¶ci problemu.</p>
  


<p><b>Pytanie 2</B>: Dla jakich danych algorytm SelectionSort zastosowany do 
ci±gu n elementowego wykonuje co najmniej&nbsp; <font face="Symbol"> <span lang="en">é</span></font>lg 
  n!<font face="Symbol"><span lang="en">&ugrave;</span></font> porównañ?&nbsp;&nbsp; 
</p>

<!-- Odpowied¼: Dla wszystkich danych.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' 
onClick="napis(this.form,'Dla wszystkich danych.')">
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main05_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main05_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>