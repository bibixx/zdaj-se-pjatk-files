<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
<td align="left"><A HREF="main14_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td><td align="right">&nbsp;
<A HREF="main14_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
    </tr>
</table>

<br clear="all"><A NAME="EDU.wyklad.punkt 2"></A><br clear="all">
    <div class="tytulpunktu">1.&nbsp; Na czym to polega?</div> 

  


<p>  
W wielu omawianych w tym wyk³adzie algorytmach by³a stosowana zasada &quot;dziel i 
zwyciê¿aj&quot;, która polega na podzieleniu&nbsp; rozwi±zywanego problemu na dwa 
podproblemy, rozwi±zaniu ich i po³±czeniu wyników, tak by uzyskaæ rozwi±zanie 
ca³ego problemu. Metoda programowania dynamicznego jest w³a¶ciwie rozwiniêciem 
tej idei. Podzielmy dany problem na mniejsze podproblemy, a z ich wyników 
spróbujmy wywnioskowaæ rozwi±zanie koñcowe. Nie zawsze jednak wiadomo, jakie to 
mniejsze podproblemy s± nam potrzebne. W metodzie zwanej &quot;programowaniem 
dynamicznym&quot; proponuje siê rozwa¿enie wszystkich mniejszych podproblemów. Z 
pozoru takie podej¶cie mo¿e siê wydawaæ nierozs±dne ze wzglêdu na nak³ad 
potrzebnej pracy. Tymczasem jest odwrotnie. Wykonuj±c pewn± dodatkow± pracê, 
postawiony problem mo¿emy rozwi±zaæ z kosztem mniejszym, ni¿ gdyby¶my ten 
problem atakowali bezpo¶rednio. Oczywi¶cie nie ka¿dy problem mo¿na rozwi±zaæ t± 
metod±, tak jak to by³o w przypadku techniki zach³annej, metody dziel i 
zwyciê¿aj, czy metody rekurencyjnej. Jednak klasa problemów, dla których metoda 
programowania dynamicznego daje dobre rezultaty jest na tyle du¿a, ¿e warto 
poznaæ bli¿ej tê technikê rozwi±zywania problemów.</P>

<p>  
Matematyczne podstawy tej metody zawdziêczamy R. Belmanowi, który rozpocz±³ 
badania nad t± metod± w 1955 r. S³owo &quot;programowanie&quot; u¿yte w nazwie tej metody 
nie odnosi siê do programowania, w sensie zapisywania pewnej metody postêpowania 
w jêzyku zrozumia³ym dla komputera, ale do techniki tablicowania wyników 
po¶rednich w celu ich pó¼niejszego u¿ycia do znalezienia optymalnego rozwi±zania 
danego problemu.</P>

<p>  
Metodê programowania dynamicznego zwykle stosuje siê w przypadku problemów 
optymalizacyjnych, dla których proste rozwi±zania rekurencyjne prowadz± do 
algorytmów wyk³adniczych. Aby mo¿na by³o zastosowaæ metodê programowania 
dynamicznego, problem powinien mieæ dwie podstawowe cechy: optymaln± 
podstrukturê oraz wspólne podproblemy. 


</P>

<p>  
Powiemy, ¿e problem ma optymaln± podstrukturê, je¿eli optymalne rozwi±zanie 
problemu zawiera w sobie optymalne rozwi±zania jego podproblemów. Wyznaczenie optymalnego 
rozwi±zania problemu polega na wybraniu tych podproblemów, które sk³adaj± siê na 
rozwi±zanie ca³ego problemu.</P>



<p>  
Paradygmat programowania dynamicznego sk³ada siê z trzech prostych zasad:</P>

<ol>
  <li>Scharakteryzowaæ strukturê rozwi±zania optymalnego.</li>
  <li>Zdefiniowaæ rekurencyjnie warto¶æ rozwi±zania optymalnego, jako funkcjê 
  rozwi±zañ optymalnych dla podproblemów.</li>
  <li>Skonstruowaæ optymalne rozwi±zanie problemu na bazie wyliczonych wcze¶niej 
  wielko¶ci.</li>
</ol>

  


    <p style="text-align: left">U¿ycie tych zasad wyja¶nimy na przyk³adach, 
    które s± tre¶ci± pozosta³ych punktów tego wyk³adu.</p>
  


    
    <p>Na zakoñczenie tego punktu zauwa¿my, ¿e metoda zach³anna, o której 
    mówili¶my w wyk³adzie XI te¿ wymaga by problem posiada³ w³asno¶æ optymalnej 
    podstruktury. Istotna ró¿nica polega na sposobie wykorzystania tej 
    w³asno¶ci. Stosuj±c technikê zach³ann±, najpierw dokonujemy wyboru 
    podproblemu, który w danym momencie rokuje najlepsze rozwi±zanie zadania, a 
    nastêpnie rozwi±zujemy ten podproblem. W programowaniu dynamicznym najpierw 
    znajdujemy optymalne rozwi±zania podproblemów, a potem wybieramy te 
    w³a¶ciwe, które pozwol± nam znale¼æ optymalne rozwi±zanie problemu.</p>
  


    
    <p><b>Pytanie 1</B>: Niech problem polega na znalezieniu najkrótszej ¶cie¿ki 
    w grafie zorientowanym, w którym ka¿da krawêd¼ ma taki sam koszt. Czy 
    problem najkrótszej ¶cie¿ki ma w³asno¶æ optymalnej podstruktury?

    <br>
  
<!-- Odpowied¼: Tak.Podzielmy najkrótsz± ¶cie¿kê od u do v na dwie czê¶ci: ¶cie¿kê od u 
    do w i&nbsp; od w do v.&nbsp; Obie te ¶cie¿ki&nbsp; musz± byæ optymalne, bo 
    w przeciwnym wypadku mo¿na by skonstruowaæ inn± krótsz± ¶cie¿kê od u do v.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Sprawd¼ odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'Tak. ')">
</form>
</p>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="left"><A HREF="main14_p0.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main14_p2.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>