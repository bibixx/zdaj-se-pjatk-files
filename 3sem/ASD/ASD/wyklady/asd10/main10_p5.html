<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main10_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main10_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><br clear="all"><div class="tytulpunktu">
5. Przyk³ady funkcji mieszaj±cych</div>


 &nbsp;<BR>

Funkcja haszuj±ca zosta³a zdefiniowana jako odwzorowanie przypisuj±ce kluczom 
adresy, tzn. pozycje w tablicy haszuj±cej. Je¶li liczba elementów, które chcemy 
zapamiêtaæ w tablicy haszuj±cej, wynosi n, a liczba mo¿liwych adresów wynosi m, 
to liczba funkcji mieszaj±cych wynosi m<sup><font face="Verdana">n</font></sup>. 
Liczba funkcji ze zbioru n elementowego w zbiór m elementowy jest, jak widaæ, 
bardzo du¿a. Nie wszystkie jednak z tych funkcji nadaj± siê do naszych celów. 
Nawet je¶li ograniczymy siê do tzw. funkcji doskona³ych, tzn. 
ró¿nowarto¶ciowych,&nbsp; to wiêkszo¶æ z nich nie jest przydatna. Funkcja haszuj±ca, 
której warto¶æ wylicza siê bardzo czêsto, musi mieæ prost± 
defincjê a jej wyliczanie powinno byæ szybkie. Co wiêcej, zale¿y nam na tym, by 
równomiernie rozrzuca³a elementy danego zbioru kluczy w tablicy. <p>Zwykle 
bêdziemy zak³adaæ, ¿e klucze s± liczbami naturalnymi identyfikuj±cymi w pewien 
sposób elementy rozwa¿anych przez nas zbiorów.&nbsp; Wybór funkcji haszuj±cej 
zale¿y od zbioru kluczy, z którymi pracujemy. Kilka, ogólnie znanych i czêsto 
stosowanych, przyk³adów funkcji mieszaj±cych jest tre¶ci± tego punktu.</p>
<p><b>Dzielenie</b></p>
<p>Najprostszym przyk³adem funkcji mieszaj±cej jest funkcja postaci </p>
<p style="text-align: center">h(x) = x mod m, </p>
<p>o ile uniwersum kluczy sk³ada siê z liczb naturalnych, a m jest rozmiarem 
tablicy haszuj±cej. Jest to ³atwa i szybka funkcj± haszuj±ca. Je¶li elementami 
uniwersum s± s³owa, to mo¿emy równie¿ u¿yæ funkcji mieszaj±cej zdefiniowanej 
przez dzielenie, poniewa¿ s³owa s± reprezentowane przez ci±gi bitów, a te z 
kolei mo¿emy potraktowaæ jako binarn± reprezentacjê pewnej liczby, któr± u¿yjemy 
jako klucza.</p>
<p>Je¶li litera A jest reprezentowana przez ci±g binarny 00001, B przez 
00010,..., L przez 01100,.. to s³owo ALA jest reprezentowane przez&nbsp; 
000010110000001 (konkatenacja reprezentacji liter). Liczb± odpowiadaj±c± temu 
ci±gowi bitów jest 1409. Zak³adaj±c, ¿e tablica haszuj±ca ma 13 elementów, s³owo 
ALA powinno siê znale¼æ na pozycji pi±tej, bo 1409 mod 13 = 5.</p>
<p>Przy takiej funkcji mieszaj±cej trzeba unikaæ pewnych warto¶ci m. Na 
przyk³ad, gdyby m = 2<sup><font face="Verdana">p</font></sup>, to warto¶æ h(k) 
zale¿a³aby tylko od p ostatnich bitów rozwiniêcia dwójkowego liczby k. Na 
przyk³ad, gdyby¶my przyjêli m=16, to wszystkie s³owa reprezentowane przez liczby 
parzyste, znajdowa³yby siê na pozycjach parzystych, a pozycja s³owa zale¿a³aby 
tylko od czterech ostatnich bitów. Dobra 
liczba m powinna, w przypadku funkcji mieszaj±cej za pomoc± operacji modulo, byæ liczb± pierwsz±, niezbyt blisk± potêdze 
dwójki.</p>
<p>Je¶li nic szczególnego nie wiemy o kluczach, to zwykle stosujemy tê w³a¶nie 
metodê.</p>
<p><b>Mno¿enie</b></p>
<p>Dla danego parametru <font face="Symbol">q</font>, 0&lt;<font face="Symbol">q</font>&lt;1 
niech funkcja mieszaj±ca ma postaæ:</p>
<p style="text-align: center">h(x) = <span lang="en"><font face="Symbol">ë</font></span>(( <font face="Symbol">q <span lang="en">´</span> </font>x) 
mod 1) m<span lang="en"><font face="Symbol">&ucirc;</font></span>.</p>
<p>Warto¶ci± funkcji h jest tym razem czê¶æ dziesiêtna iloczynu x i 
<font face="Symbol">q</font>, wynik 
mno¿ymy przez m, i ostatecznie czê¶æ ca³kowita wyniku bêdzie adresem klucza x.</p>
<p>Na przyk³ad, je¶li&nbsp; <font face="Symbol">q </font>= 0.511 oraz m = 13, to s³owo ALA, reprezentowane 
przez ci±g bitów 000010110000001, </p>
<p style="text-align: center">h(ALA) =&nbsp; <span lang="en">
<font face="Symbol">ë</font></span>(1409<font face="Symbol"><span lang="en">´</span> 
q) </font>mod 1 <font face="Symbol">)<span lang="en">´</span> </font>m<span lang="en"><font face="Symbol">&ucirc;</font></span>&nbsp; 
=&nbsp; <span lang="en"><font face="Symbol">ë</font></span>(719,999 mod 1) <font face="Symbol"><span lang="en">´</span> </font>m<span lang="en"><font face="Symbol">&ucirc;</font></span> 
=&nbsp; <span lang="en"><font face="Symbol">ë</font></span>0,999 <font face="Symbol"><span lang="en">´</span> </font>m
<span lang="en"><font face="Symbol">&ucirc;</font></span>= 12</p>
<p>zostanie umieszczone na pozycji 12. </p>
<p>Przy takiej funkcji haszuj±cej warto¶æ m nie ma wielkiego znaczenia. Istotna 
jest natomiast warto¶æ parametru q, która na podstawie teoretycznych badañ nie 
powinna byæ ani bliska zeru, ani bliska jedno¶ci, powinna byæ natomiast oddalona 
od nich o&nbsp; (<span lang="en"><font face="Symbol">Ö</font></span>5 -1)/2.</p>
<p><b>Wycinanie</b></p>
<p>W tej metodzie do obliczenia adresu wykorzystuje siê tylko czê¶æ klucza. Mo¿e 
to byæ np. fragment ¶rodkowy, albo ostatnie cztery pozycje, albo konkretnie 
wskazane pozycje.&nbsp; Na ogó³ pomijamy te fragmenty klucza, które nie 
rozró¿niaj± dostatecznie dobrze elementów. </p>
<p>Na przyk³ad, gdyby¶my chcieli zapamiêtaæ telefony naszych znajomych z 
Warszawy, to nie ma sensu braæ pod uwagê prefiksu 22, gdy¿ jest on identyczny 
dla wszystkich telefonów warszawskich. Je¶li&nbsp; nasz zbiór sk³ada siê z imion 
dziewcz±t (Polek), to przy wyliczaniu adresu elementu, nie bêdziemy brali pod 
uwagê ostatniej litery, gdy¿ na ogó³ jest to litera 'a'.</p>
<p><b>Kompresja</b></p>
<p>Za³ó¿my, ¿e elementy rozwa¿anego uniwersum s± reprezentowane przez ci±gi 
bitów. W tej metodzie rozrzucania u¿ywamy wszystkich bitów. Dzielimy natomiast 
ca³y ci±g na odcinki równej d³ugo¶ci i wykonujemy operacjê XOR na 
odpowiadaj±cych bitach. </p>
<p>Na przyk³ad, je¶li elementami interesuj±cego nas uniwersum s± s³owa i 
przypisali¶my literom liczby, np. tak jak w przyk³adzie 4.1, to adresem s³owa 
mo¿e byæ suma binarnych reprezentacji liter w sensie operacji XOR traktowana 
jako liczba z przedzia³u 0-31. Mamy wtedy</p>
<p style="text-align: center">h(antek) = 00001 XOR 01111 XOR 10100 XOR 00101 XOR 
01011 = 10100 = (20)<sub><font face="Verdana">10</font></sub></p>
<p style="text-align: center">h(piotr) = 10001 XOR 01001 XOR 10000 XOR 10100 XOR 
10010 = 01110 = (14)<sub><font face="Verdana">10</font></sub>.</p>
<p>Zwróæmy uwagê, ¿e operacja XOR jest ³±czna i przemienna. Wynika st±d, ¿e 
wszystkie s³owa o takich samych literach otrzymaj± ten sam adres.&nbsp; </p>
<p>Nie bêdziemy siê tu zajmowaæ g³êbiej funkcjami mieszaj±cymi. Wiele innych 
przyk³adów mo¿na znale¼æ w literaturze. Zauwa¿my tylko na zakoñczenie tego 
punktu, ¿e niezale¿ne od tego, jak zdefiniujemy funkcjê mieszaj±c±, zawsze mo¿e 
siê zdarzyæ, ¿e wyst±pi kolizja: ró¿ne elementy otrzymaj± ten sam adres.</p>
<p><b>Pytanie 5</B>: Jaki jest koszt wyszukania s³owa w zbiorze reprezentowanym 
przez tablicê z haszowaniem stosuj±c± mieszanie opisane w ostatnim przyk³adzie 
(kompresja), a jakie gdyby¶my te same elementy umie¶cili po prostu na kolejnych 
pozycjach w zwyk³ej tablicy (zak³adamy, ¿e nie wyst±pi³ problem kolizji)?&nbsp; 
</P>

<!-- <p>Odpowied¼: W zwyk³ej tablicy musieliby¶my wykonaæ w najgorszym przypadku 31 porównañ s³ów, -->
<!-- a w przypadku tablicy haszuj±cej jedno wyliczenie adresu s³owa.</P> -->

<form>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'W zwyk³ej tablicy, w najgorszym przypadku 31 porównañ s³ów,a w haszuj±cej jedno wyliczenie adresu s³owa.')">
</form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main10_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main10_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>