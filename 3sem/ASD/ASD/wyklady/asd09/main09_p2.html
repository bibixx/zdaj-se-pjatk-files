<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>

<td align="left"><A HREF="main09_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main09_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><br clear="all">
<A NAME="EDU.wyklad.punkt 2"></A>
<br clear="all">

<div class="tytulpunktu">2. Operacja wstawiania.</div> 

    <p>Niech Heap oznacza zbiór kopców etykietowanych elementami zbioru Et. Operacja wstawiania&nbsp; insert ma nastêpuj±c± sygnaturê:</p>





    <p style="text-align: center">insert : Et <font face="Symbol">
    <span lang="en">´</span> </font>&nbsp;Heap<font face="Symbol"> <span lang="en">
    &reg;</span> </font>Heap.</p>





<p>Tak, jak w przypadku struktur drzewiastych BST I AVL, wymagamy, aby operacja 
insert&nbsp; spe³nia³a dla dowolnych e<span lang="en"><font face="Symbol">Î</font></span>Et 
i H<span lang="en"><font face="Symbol">Î</font></span>Heap, specyfikacjê:<p style="text-align: center">
insert(e,H) <font face="Symbol"><span lang="en">Î</span> </font>Heap<p style="text-align: center">
(member(e,H) <font face="Symbol"><span lang="en">&reg;</span> </font>&nbsp;H = 
insert(e,H)) <span lang="en"><font face="Symbol">&Ugrave;</font></span> (<font face="Symbol"><span lang="en">&Oslash;</span>
</font>member(e,H) <font face="Symbol"><span lang="en">&reg;</span> </font>&nbsp;member(e,insert(e,H))),<p>
gdzie member jest relacj± zachodz±c± miêdzy elementem i kopcem odpowiadaj±c± na 
pytanie, czy element nale¿y, czy nie nale¿y do kopca.<p>
Idea algorytmu wstawiania elementu e do kopca H polega na tym, by zachowaæ 
strukturê drzewa doskona³ego kosztem uporz±dkowania. Odtworzenie tej 
struktury jest du¿o trudniejsze, gdy¿ dotyczy ca³ego drzewa, ni¿ poprawienie etykietowania, 
które dotyczy tylko jednej ¶cie¿ki. Je¶li zapomnimy na chwilê o uporz±dkowaniu drzewa, to naturalnym 
miejscem, do którego mo¿emy dowi±zaæ nowy wierzcho³ek jest pierwszy niekompletny 
wêze³ na przedostatnim poziomie drzewa, o ile taki istnieje, i pierwszy z lewej 
li¶æ, w przeciwnym przypadku (por. rysunek 9.1(a)).<p><b>Metoda</b>.<ol>
  <li>Dowi±¿ nowy wierzcho³ek x do pierwszego z lewej wierzcho³ka, którego rz±d 
  jest &lt;2 na przedostatnim poziomie, gdy drzewo D nie jest&nbsp; pe³ne,&nbsp; i, 
  na ostatnim poziomie, gdy jest pe³ne (por. rysunek 9.3).</li>
  <li>Nadaj nowemu wierzcho³kowi etykietê e.</li>
  <li>Je¿eli tak otrzymane drzewo nie jest kopcem, to przesuwaj±c siê wzd³u¿ 
  drogi od li¶cia x do korzenia drzewa, zamieniaj etykiety ojca i syna, o ile 
  nie spe³niaj± warunku czê¶ciowego uporz±dkowania kopca.&nbsp;





  </li>
  </ol>


<p>
<center>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="37%" id="AutoNumber3">
  <tr>
    <td width="100%">
    <p align="center" style="text-align: center">
    <img border="0" src="RYSUNKI/Rysunek9_3.gif" width="250" height="250"></td>
  </tr>
</table>

</center>
</p>


<p><b>Przyk³ad 2.1</b><p>Na rysunku 9.3(a) przedstawiono przyk³ad kopca o 
wysoko¶ci 3. Chcemy do³±czyæ do tego kopca etykietê 0. Pierwszy krok polega na 
dowi±zaniu nowego wierzcho³ka z etykiet± 0 jako prawego syna wierzcho³ka z 
etykiet± 6. Jest to w³a¶nie pierwszy z lewej wierzcho³ek na przedostatnim 
poziomie, który nie ma kompletu synów. W wyniku otrzymali¶my drzewo doskona³e 
(por. rysunek 9.3(b), ale bez w³asno¶ci czê¶ciowego uporz±dkowania. 





<p>&nbsp;<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="60%" id="AutoNumber1">
    <tr>
      <td width="50%">
      <img border="0" src="RYSUNKI/Rysunek9_3a.gif" width="250" height="250"></td>
      <td width="50%">
      <img border="0" src="RYSUNKI/Rysunek9_3b.gif" width="250" height="250"></td>
    </tr>
  </table>





<p>Stwierdzamy to porównuj±c nowowstawiony element z etykietê jego ojca. Poniewa¿ 6&gt;0, wiêc zamieniamy 
miejscami te etykiety. Jedna zamiana jednak nie 
wystarczy i musimy jeszcze zamieniæ 0 z 3 i 0 z 1, jak pokazano na rysunku 
9.3(c).&nbsp; Ostatecznie otrzymamy 
 
kopiec przedstawiony na rysunku 9.3 (d).<font face="Wingdings"> J</font><p>&nbsp;<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="60%" id="AutoNumber2">
    <tr>
      <td width="50%">
      <img border="0" src="RYSUNKI/Rysunek9_3c.gif" width="250" height="250"></td>
      <td width="50%">
      <img border="0" src="RYSUNKI/Rysunek9_3d.gif" width="250" height="250"></td>
    </tr>
  </table>





<p><b>Koszt operacji wstawiania</B><p>Zgodnie z opisanym algorytmem, kroki 1-2 
maj± koszt sta³y. Poprawienie uporz±dkowania dotyczy tylko jednej ¶cie¿ki od 
nowowstawionego wierzcho³ka do korzenia (w najgorszym razie). Wynika st±d, ¿e 
koszt operacji wstawiania mo¿na oszacowaæ z góry przez wysoko¶æ drzewa. Zgodnie 
z lematem 1.2, jest on wiêc równy&nbsp; T(n) = O(lg n), dla drzewa o n 
wierzcho³kach.<p><b>Uwaga</b>. Implementacja przedstawionego algorytmu na 
drzewie sprawia trochê k³opotów. Po pierwsze, musimy w ka¿dym wê¼le pamiêtaæ 
referencjê do wierzcho³ka ojca. Po drugie, musimy znale¼æ wierzcho³ek, do którego 
nale¿y dowi±zaæ nowy element. Pamiêtanie jednej referencji do tego 
wierzcho³ka nie wystarczy, bo po kolejnych wstawieniach trzeba j± uaktualniæ. 
Natomiast pamiêtanie w ka¿dym wê¼le referencji do najbli¿szego &quot;nastêpnika&quot; z 
prawej wymaga sporo dodatkowej pamiêci.&nbsp; O implementacji algorytmu 
wstawiania bêdzie mowa w dalszej czê¶ci wyk³adu.

<p><b>Pytanie 2</B>: Czy dla dowolnego kopca, ci±g etykiet&nbsp;wierzcho³ków wypisanych w porz±dku &quot;wszerz&quot; jest uporz±dkowany rosn±co?  

<BR>
<FORM>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'NIE. Czê¶ciowe uporz±dkowanie kopca dotyczy tylko ¶cie¿ek od korzenia do li¶ci.');">
</p>
</form>
</p>


<p><br clear="all">
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main09_p1.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main09_p3.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>