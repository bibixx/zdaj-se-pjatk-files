<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main09_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main09_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<br clear="all">
<A NAME="EDU.wyklad.punkt 3"></A><br clear="all"><div class="tytulpunktu">
3. Usuwanie minimum.</div>





<p>Element minimalny, ze wzglêdu na porz±dek w zbiorze etykiet, znajduje siê w korzeniu kopca. 
Znalezienie elementu minimalnego nie przedstawia wiêc ¿adnego problemu. Je¶li 
kopiec jest reprezentowany przez korzeñ drzewa binarnego root typu node (por. 
wyk³ad VI p4.), to aby poznaæ warto¶æ elementu minimalnego kopca,&nbsp; 
wystarczy sprawdziæ warto¶æ atrybutu&nbsp; root.val.<p style="text-align: center">
Et min(root : node){ return root.val;}.<p>Uzasadnienie, ¿e operacja min zwraca 
najmniejsz± z etykiet przechowywanych w kopcu pozostawiamy Czytelnikowi.<p>
Operacj±, której po¶wiêcimy wiêcej uwagi w tym punkcie, bêdzie operacja usuwania 
minimum, delmin,<p style="text-align: center">
delmin : Heap <font face="Symbol"><span lang="en">&reg;</span> </font>Heap,<p>polegaj±ca na 
usuniêciu z kopca elementu najmniejszego. &nbsp; Ma ona nastêpuj±c± specyfikacjê: 
dla dowolnego H<font face="Symbol"> <span lang="en">Î</span> </font>Heap i 
dowolnego e <font face="Symbol"><span lang="en">Î</span> </font>Et,<p style="text-align: center">
min(H) = e <font face="Symbol"><span lang="en">&reg;</span> (</font>min (delmin(H)) 
&gt; e <font face="Symbol"><span lang="en">&Ugrave;</span>&nbsp; <span lang="en">&Oslash;</span></font> member(e, 
delmin(H))).<p>Oczywi¶cie, po wykonaniu tej operacji, powinni¶my otrzymaæ 
równie¿ kopiec. Usuniêcie elementu minimalnego chcemy wykonaæ tak, by w jak 
najmniejszym stopniu modyfikowaæ strukturê drzewa doskona³ego. Nie mo¿emy wiêc 
po prostu usun±æ wierzcho³ka znajduj±cego siê w korzeniu drzewa. <p><b>Metoda</b><p>Niech x bêdzie li¶ciem znajduj±cym siê 
najbardziej na prawo na ostatnim poziomie kopca H, tak jak zaznaczono na rysunku 
9.4. Postêpowanie sk³ada siê z trzech kroków:<ol>
  <li>Zast±p etykietê korzenia drzewa H, etykiet± wierzcho³ka x.</li>
  <li>Usuñ wierzcho³ek x z drzewa H.</li>
  <li>Je¿eli tak otrzymane drzewo nie jest kopcem, to zaczynaj±c od korzenia, 
  zamieniaj etykietê wierzcho³ka z etykiet± tego z jego synów, którego etykieta 
  jest mniejsza, tak d³ugo, a¿ otrzymane drzewo bêdzie kopcem.</li>
  </ol>

<p><center>
  <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="40%" id="AutoNumber3">
    <tr>
      <td width="100%">
      <p align="center" style="text-align: center">
      <img border="0" src="RYSUNKI/Rysunek9_4.gif" width="250" height="250"></td>
    </tr>
</table>
</center>
</p>

  <p><b>Przyk³ad 3.1</b><p>Rozwa¿my drzewo z rysunku 9.2(a). Prze¶led¼my proces 
  usuwania etykiety korzenia tego drzewa. Kolejne fazy algorytmu s± zilustrowane 
  na rysunkach 9.4(a), (b), (c). W pierwszym kroku zapamiêtamy etykietê li¶cia 
  (na rysunku 9.4(a) zaznaczony wierzcho³ek z etykiet± 12) znajduj±cego siê na 
  ostatnim poziomie drzewa, najbardziej na prawo, i umie¶cimy j± w korzeniu 
  drzewa (usuwaj±c w ten sposób etykietê 1). Otrzymane drzewo jest doskona³e, nie jest 
  jednak czê¶ciowo uporz±dkowane. Uporz±dkowanie poprawimy, zamieniaj±c etykietê 
  wierzcho³ka z mniejszym z jego synów, tak jak zaznaczono na rysunku 9.4(b), i 
  kontynuuj±c ten proces w górê drzewa tak d³ugo, a¿ otrzymamy drzewo czê¶ciowo uporz±dkowane. 
  Wynik przedstawiono na rysunku 9.4(c).<p>&nbsp;<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="80%" id="AutoNumber2">
    <tr>
      <td width="33%">
      <img border="0" src="RYSUNKI/Rysunek9_4a.gif" width="250" height="250"></td>
      <td width="33%">
      <img border="0" src="RYSUNKI/Rysunek9_4b.gif" width="250" height="250"></td>
      <td width="34%">
      <img border="0" src="RYSUNKI/Rysunek9_4c.gif" width="250" height="250"></td>
    </tr>
  </table>
  <p><b>Koszt algorytmu delmin</b><p>Kroki 1 i 2 algorytmu maj± sta³y koszt. W ka¿dym 
  kroku pêtli 3, algorytm wykonuje co najwy¿ej dwa porównania (wybór najmniejszego z 
  trzech elementów). Liczba iteracji jest równa d³ugo¶ci przebytej ¶cie¿ki, a ta 
w 
  najgorszym przypadku jest równa wysoko¶ci drzewa. Koszt ca³kowity wykonania 
operacji delmin mo¿emy wiêc 
  szacowaæ z góry przez O(lg n).<p><b>Uwaga</b>. Podobnie, jak w przypadku 
wstawiania, usuwanie minimum z drzewa-kopca sprawia trochê problemów. Chodzi o 
znalezienie ostatniego li¶cia, tego, którego etykieta wêdruje na miejsce 
usuwanego minimum. Znów, jak w przypadku wstawiania, jedna referencja nie 
wystarczy, bo po usuniêciu jednego elementu, trzeba bêdzie j± uaktualniæ (umieæ 
znów znale¼æ ostatni li¶æ). Zatem, by³oby najlepiej&nbsp; mieæ referencje&nbsp; 
do &quot;s±siada&quot; z lewej w ka¿dym wierzcho³ku. Ponadto potrzebne s± 
referencje do wierzcho³ka-ojca. Wszystko to wymaga dodatkowej pamiêci 
rzêdu liczby przechowywanych elementów. Inn±, bardziej oszczêdn±,&nbsp; implementacjê tego algorytmu 
poznamy w punkcie czwartym wyk³adu.</p>
<p><b>Pytanie 3</B>:&nbsp; Czy koszt algorytmu delmin, zastosowanego do kopca o 
2<sup><font face="Verdana">k</font></sup> wierzcho³kach, mo¿na oszacowaæ z góry przez 2*k 
? 
<!-- <p>Odpowied¼: TAK.</P> -->


<p>&nbsp;<FORM>
<p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' 
onClick="napis(this.form,'Tak, bo wysoko¶æ kopca zale¿y logarytmicznie od liczby elementów.');">
</p>
</form>

<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main09_p2.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main09_p4.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>