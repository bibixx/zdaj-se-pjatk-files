<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td-->
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="left"><A HREF="main01_p4.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main01_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
</tr></table><br clear="all"><A NAME="EDU.wyklad.punkt 5"></A><br clear="all"><div class="tytulpunktu">
5. Koszt algorytmu&nbsp; </div>


<p>Podstawowymi miarami kosztu algorytmu s±: czas i pamiêæ.</p>
<p> Jak mierzyæ czas? Oczywi¶cie chcemy by miara by³a niezale¿na od komputera, 
na którym realizowany bêdzie algorytm. Jest oczywiste, ¿e realizacja tego samego 
algorytmu&nbsp; na ró¿nych komputerach dla tych samych danych, nie musi zaj±æ 
tyle samo czasu. Zatem informacja, ile jednostek czasu
  wymaga wykonanie algorytmu dla konkretnych danych, na konkretnym komputerze, niewiele mówili
  o samym algorytmie. Miara kosztu algorytmu powinna zale¿eæ od typu problemu
  i rodzaju rozwi±zania, a nie od komputera, na którym realizujemy obliczenia.
  Naturaln± miar± czasu mo¿e byæ:</p>
<p> * liczba instrukcji,<br>
  * liczba operacji arytmetycznych,<br>
  * liczba porównañ wykonanych, w trakcie realizacji algorytmu,<br>
  * liczba wywo³añ rekurencyjnych procedur, itd.</p>
<p>W ka¿dym algorytmie mo¿na wyró¿niæ pewn± operacjê istotn± dla rozwi±zywanego zadania. 
Tak± operacjê nazwiemy dominuj±c±. Mówimy, ¿e koszt czasowy algorytmów mierzymy
  liczb± operacji
  dominuj±cych. Wybór operacji dominuj±cej zale¿y od problemu i wybranego rozwi±zania. W problemie mno¿enia macierzy za operacje dominuj±ce&nbsp; mo¿na uznaæ 
operacje arytmetyczne +, *. W problemie wyszukiwania elementu w zbiorze, operacj± dominuj±c± jest 
równo¶æ. W problemie sortowania operacj± dominuj±c± jest najczê¶ciej porównywanie
  elementów, ale mo¿na te¿ przyj±æ operacjê przestawiania elementów.</p>
<p>Maj±c dany algorytm Alg i&nbsp; ¶rodowisko, w którym&nbsp;
  bêdzie on pracowa³, 
  mo¿emy policzyæ liczbê operacji dominuj±cych, wykonanych przez algorytm w 
czasie jego realizacji dla konkretnych danych d. Liczbê tê oznaczamy przez t(Alg,d). 
Je¶li z kontekstu wynika o jaki algorytm 
chodzi, bêdziemy po prostu pisali t(d).</p>
<p>Rozwa¿my poznane przyk³ady algorytmów. W algorytmie&nbsp; max, rozwi±zuj±cym 
problem wyszukiwania elementu najwiêkszego, dane to d³ugo¶æ ci±gu i jego 
elementy. Wybierzmy jako operacjê dominuj±c± porównywanie elementów, a rozmiar 
danych to liczba elementów ci±gu. Dla danych d1 = &lt;5, (1,7,4,2,8)&gt; mamy t(max,d1) 
= 4, a dla danych&nbsp; d2 = &lt;6, (2,4,7,8,1,3)&gt;,&nbsp; t(max,d2)=5. </p>
<p>W algorytmie znajdowania pierwiastka kwadratowego z danej liczby naturalnej, 
rozmiarem danym mo¿e byæ liczba bitów potrzebnych do zapamiêtania tej liczby n, 
a operacj± dominuj±c± operacje arytmetyczne. W ka¿dym kroku algorytmu wykonujemy 
3 operacje dodawania i jedno&nbsp; badanie równo¶ci. Je¶li n=16, to t(sqrt, n) = 
4<font face="Symbol"> <span lang="en">´</span> </font>4 =16, je¶li n=25, to t(sqrt, n) = 4
<font face="Symbol"><span lang="en">´</span> </font>5 = 20. Wiedz±c jaka jest liczba 
wykonanych operacji dominuj±cych, mo¿emy dok³adnie powiedzieæ, ile czasu zajmie 
nam wykonanie algorytmu. Czy jednak jest to dla nas interesuj±ce? Czy mo¿emy z 
tych informacji wyci±gn±æ wniosek, ile czasu potrzeba dla wykonania algorytmu 
dla danych o rozmiarze 100000? Nie.&nbsp; </p>
<p>Zupe³nie inaczej wygl±da sprawa, je¶li zauwa¿ymy, ¿e np. algorytm max 
wykonuje zawsze n-1 porównañ dla dowolnego n elementowego ci±gu, a algorytm sqrt,&nbsp; 
obliczaj±c pierwiastek z liczby n, wykonuje zawsze 4<span lang="en"><font face="Symbol">Ö</font></span>n 
operacji arytmetycznych. Dlatego te¿ ocenê kosztów algorytmu chcemy uniezale¿niæ od szybko¶ci komputera, konkretnej 
implementacji, jêzyka programowania oraz konkretnego zestawu danych.&nbsp; 
Natomiast chcemy j± uzale¿niæ od rozmiaru danych. </p>
<p>To, jak mierzymy wielko¶æ danych zale¿y od rozwi±zywanego problemu. Na przyk³ad, je¿eli naszym
  problemem jest mno¿enie macierzy, to przez rozmiar danych rozumie siê zwykle wymiar mno¿onych macierzy; je¿eli problem polega na sortowaniu, to oczywistym 
rozmiarem danych jest d³ugo¶æ sortowanego ci±gu. Dla problemu wyszukiwania 
najkrótszych ¶cie¿ek w grafie, rozmiarem danych bêdzie liczba wierzcho³ków grafu.&nbsp; 
Maj±c ustalon± operacjê dominuj±c± oraz pojêcie wymiaru danych dla rozwa¿anego 
algorytmu, bêdziemy siê starali okre¶liæ zale¿no¶æ miêdzy rozmiarem danych, a 
liczb± wykonanych&nbsp; przez niego operacji dominuj±cych, zwan± z³o¿ono¶ci± 
czasow± algorytmu.<BR>
</p>
<p><div class="def">Definicja 5.1<p>Z³o¿ono¶æ czasowa algorytmu, to liczba 
  operacji dominuj±cych wykonywanych przez algorytm w czasie jego realizacji, 
  wyra¿ona jako funkcja rozmiaru danych. 
</div>

<p> Faktyczny czas wykonania algorytmu jest proporcjonalny do jego z³o¿ono¶ci 
czasowej. Znaj±c rozmiar danych oraz z³o¿ono¶æ algorytmu mo¿emy wyliczyæ liczbê 
operacji dominuj±cych wykonywanych przez algorytm, a wiedz±c na jakim komputerze 
algorytm zostanie wykonywany, mo¿emy obliczyæ czas potrzebny do jego wykonania.</p>

<p> Zdarzaj± siê jednak algorytmy, których dzia³anie zale¿y nie tylko od 
rozmiaru danych, ale tak¿e od ich warto¶ci. W takich przypadkach, bêdziemy 
analizowaæ przypadki najgorszych i ¶rednich zachowañ algorytmu.</p>
<p><div class="def">Definicja 5.2<p></p>
<p> Niech D(n) bêdzie zbiorem danych rozmiaru n dla pewnego problemu P oraz
  Alg niech bêdzie algorytmem rozwi±zuj±cym ten problem. Pesymistyczn± z³o¿ono¶æ 
czasow± oznaczamy przez W(Alg,n), a ¶redni± (oczekiwan±) z³o¿ono¶æ czasow± przez&nbsp; 
A(Alg,n). Wielko¶ci te s± zdefiniowane nastêpuj±co:</p>
<p style="text-align: center"> &nbsp;W(Alg,n) = max{t(Alg,d): d<span lang="en"><font face="Symbol">Î</font></span>D(n)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(Alg,n) =<font face="Symbol"> <span lang="en">&aring;</span></font>{p(d)<span lang="en"><font face="Symbol">´</font></span>t(Alg,d): d<span lang="en"><font face="Symbol">Î</font></span>D(n)} </p>
<p> gdzie p(d) jest prawdopodobieñstwem wyst±pienia danych d, t(Alg,d) liczb± 
operacji dominuj±cych, wykonanych przez algorytm Alg dla danych d.</p>
<p> Je¿eli warto¶æ t(Alg,d) jest taka sama dla wszystkich danych d z klasy D(n), to mówimy po 
prostu o z³o¿ono¶ci
  czasowej algorytmu i wielko¶æ tê oznaczamy przez T(Alg, n).</p> 
</div>

<p><BR>Inn± interesuj±c± miar± z³o¿ono¶ci algorytmu jest z³o¿ono¶æ pamiêciowa. 
Podobnie jak poprzednio i to pojêcie chcemy uniezale¿niæ od komputera i jêzyka programowania, natomiast chcemy by zale¿a³o
  od wymiaru danych. Miar± danych tego typu z³o¿ono¶ci mo¿e byæ liczba zmiennych u¿ytych 
w algorytmie lub liczba miejsc potrzebnych do zapamiêtania danych. Pamiêtajmy 
jednak, ¿e zmienne mog± byæ bardzo ró¿nych typów i w zwi±zku z tym ilo¶æ s³ów 
pamiêci potrzebnych do przechowywania ich warto¶ci ró¿niæ siê mo¿e bardzo 
istotnie. Rozs±dniej wiêc bêdzie mierzyæ z³o¿ono¶æ pamiêciow± ilo¶ci± s³ów 
maszynowych potrzebnych do przechowania danych i realizacji algorytmu.</p>
<p style="text-align: left"> Z³o¿ono¶æ pamiêciow± wyra¿amy jako funkcjê rozmiaru danych&nbsp; i oznaczamy&nbsp; 
przez S(Alg,n),
  gdzie Alg jest algorytmem, a n rozmiarem danych dla tego algorytmu. Podobnie jak w przypadku z³o¿ono¶ci czasowej, ilo¶æ s³ów pamiêci&nbsp; potrzebnej
  do wykonania algorytmu zale¿y czêsto od rodzaju danych. Rozwa¿a siê wiêc koszt 
pamiêciowy pesymistyczny, oraz koszt pamiêciowy ¶redni. </p>
<p style="text-align: left"> W nastêpnych wyk³adach tego kursu, Czytelnik pozna 
wiele przyk³adów analizy z³o¿ono¶ci. Skupimy siê jednak bardziej na analizie 
czasowej z³o¿ono¶ci, ni¿ z³o¿ono¶ci pamiêciowej przedstawianych algorytmów.</p>
<p></P>

<p><b>Pytanie 5</B> Niech Alg = {if&nbsp; g then&nbsp; A1 else A2 fi}, oraz 
tt(g) oznacza liczbê operacji dominuj±cych wykonywanych przy badaniu testu g, a  
tt(A<sub><font face="Verdana">i</font></sub>) - maksymaln± liczbê operacji 
dominuj±cych, które mo¿e wykonaæ algorytm A<sub><font face="Verdana">i</font></sub> 
dla i=1,2. Jak mo¿na oszacowaæ liczbê operacji dominuj±cych dla algorytmu Alg? </P>

<FORM><p>
<INPUT class="GUZIK" TYPE='button' VALUE='------Zobacz odpowied¼------' NAME='Klik0' 
onClick="napis(this.form,'tt(if g then A1 else A2 fi)<= tt(g) + max(tt(A1),tt(A2)).');">
</p></form>



 <table width="100%" border="0" cellspacing="0" cellpadding="0"><tr>
<td align="left"><A HREF="main01_p4.html" TARGET="main"  class="NAWIGACJA">
&laquo;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main01_p6.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>