<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title></title>
<meta name="Keywords" content="s³owa kluczowe">
<meta name="Description" content="">
<LINK REL="stylesheet" TYPE="text/css" HREF="../main.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../style.html">
<script language="JavaScript" src="../skrypty.js" type="text/javascript"></script>
</head>
<body bgcolor="whitesmoke" leftmargin="8" topmargin="8" marginwidth="8" marginheight="8">
<!--body bgcolor="whitesmoke" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"-->
<!--table width="100%" cellspacing="4" cellpadding="4" border="0"-->
<!--tr-->
    <!--td--><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main01_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main01_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td></tr></table>
<br clear="all"><A NAME="EDU.wyklad.punkt 4"></A>

<br clear="all">
<div class="tytulpunktu">4. Poprawno¶æ algorytmu</div>

<p><BR>Co to znaczy, ¿e algorytm dzia³a poprawnie? 
Intuicja podpowiada nam, ¿e chodzi tu o to, by dla dowolnych danych&nbsp;uzasadniæ zgodno¶æ 
uzyskanych wyników z zamierzeniami.
 Aby jednak tak± zgodno¶æ ustaliæ ponad wszelk± w±tpliwo¶æ,
    musimy jasno sformu³owaæ intencje, podaæ tzw. specyfikacjê algorytmu. </p>
<p>Specyfikacj±
    algorytmu nazywaæ bêdziemy parê w³asno¶ci: &lt;wp, wk&gt;, gdzie wp jest warunkiem
  pocz±tkowym, a wk warunkiem koñcowym. Intuicyjnie, warunek pocz±tkowy to ten, 
który maj± spe³niaæ dane pocz±tkowe, a warunek koñcowy to ten, który ma byæ 
spe³niony po wykonaniu algorytmu. Ogólnie, oba warunki powinny opisywaæ 
zale¿no¶ci miêdzy zmiennymi przed i po wykonaniu algorytmu. </p>
  <p><b>Przyk³ad 4.1&nbsp; </b></p>
  <p>Rozwa¿my problem znalezienia elementu najwiêkszego w danym ci±gu liczb naturalnych 
  x<sub>1</sub>,..., x<sub>n</sub>. Naturalnym warunkiem pocz±tkowym bêdzie za³o¿enie&nbsp; niepusto¶ci ci±gu: 
  nie mo¿na znale¼æ elementu najwiêkszego w zbiorze pustym. Mo¿emy go zapisaæ w postaci: 
  wp 
  = {n&gt;0}. 
   Warunek koñcowy, natomiast, powinien charakteryzowaæ oczekiwany wynik i mo¿e mieæ postaæ: 
  wk = {result = x<sub>i </sub>dla pewnego i<FONT FACE="Symbol"> &#163; </FONT>n 
 oraz dla wszystkich i, x<sub>i</sub> <FONT FACE="Symbol"> &#163; </FONT> result}.&nbsp;Algorytm rozwi±zuj±cy ten problem mo¿emy zapisaæ w 
  postaci:</p>

<p> <div class="przyk" style="width: 510; height: 178">
   <TABLE frame="void" rules="none" width="464" height="143" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
         <TR>
            <TD width="50" height="12"> max<b>{</b></TD>
            <TD width="403" height="12">&nbsp; </TD>           
         </TR>
         <TR>
            <TD width="50" height="16">  </TD>
            <TD width="403" height="16">   <STRONG>&nbsp;</STRONG>result := x<sub>1</sub>; i := 2;&nbsp;</TD>
         </TR>
         <TR>
            <TD width="50" height="16">  </TD>
            <TD width="403" height="16"> &nbsp;<b>while</b> i <FONT FACE="Symbol"> &#163; </FONT>n <b>do </b></TD>            
         </TR>
         <TR>
            <TD width="50" height="16">  </TD>
            <TD width="403" height="16"> <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</b> not (x<sub>i</sub> <FONT FACE="Symbol"> &#163;</FONT> result) 
<b>then </b> result := x<sub>i</sub> <b>fi</b>; </TD>
         </TR>
         <TR>
            <TD width="50" height="16">  </TD>
            <TD width="403" height="16">   <STRONG> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>i := i+1</TD>
         </TR>
         <TR>
            <TD width="50" height="16">  </TD>
            <TD width="403" height="16">   <strong> od </strong></TD>
         </TR>
         <TR>
            <TD width="50" height="16"> <strong> } </strong> </TD>
            <TD width="403" height="16">   </TD>
         </TR>
         
   </TABLE>
   </div>

<p>

£atwo zauwa¿yæ, ¿e po wykonaniu tego algorytmu w strukturze liczb 
naturalnych, warto¶ci± zmiennej result jest rzeczywi¶cie element najwiêkszy 
ci±gu, czyli po wykonaniu algorytmu spe³niony jest warunek koñcowy wk.
Warunek wk, podany w przyk³adzie 4.1., wydaje siê byæ rozs±dnym z punktu widzenia 
badanego problemu.
 Jest jednak jasne, ¿e dla jednego algorytmu mo¿na zaproponowaæ wiele ró¿nych 
par postaci &lt;wp, wk&gt;, nie ka¿da jest jednak dla nas interesuj±ca, np.: 
para formu³</p>
<p style="text-align: center"> <n></n>
wp = {n&gt;0},&nbsp; wk = {i =(n+1)}, </p>
<p>chocia¿ opisuje w³asno¶ci zmiennych wystêpuj±cych w algorytmie max, nie daje 
nam dostatecznej informacji o tym, czego mamy siê spodziewaæ po wynikach i co 
w³a¶ciwie robi ten algorytm.&nbsp; Specyfikacja ma precyzowaæ problem, ma 
umo¿liwiæ&nbsp; odpowied¼ na pytanie, czy algorytm rozwi±zuje 
postawiony problem, czy nie. Specyfikacja ma opisaæ co ma robiæ algorytm, jednak 
bez wskazywania, jak ma to robiæ.<BR>

</p>

<div class="def">
<p><A NAME="EDU.skorowidz.termin poprawno¶æ_algorytmu 1_3"></A> 
Definicja 4.1 Ca³kowita poprawno¶æ algorytmu.</P>
<p>Powiemy, ¿e algorytm Alg dzia³aj±cy w pewnej strukturze danych Str jest ca³kowicie poprawny
 ze wzglêdu na warunek pocz±tkowy wp i warunek  koñcowy  wk
 wtedy i tylko wtedy, gdy dla wszystkich danych spe³niaj±cych warunek pocz±tkowy
  wp w strukturze Str, algorytm koñczy obliczenie i  jego wyniki spe³niaj± warunek koñcowy 
wk. </div>
<p style="text-align: left"><font face="Verdana">Podkre¶lmy jeszcze raz, ¿e 
je¶li</font> algorytm Alg jest ca³kowicie poprawny ze wzglêdu na specyfikacjê <b>
&lt;</b>wp, wk<b>&gt;</b>, to warunek pocz±tkowy daje gwarancjê, ¿e algorytm zakoñczy 
obliczenie. Tak w³a¶nie jest w przyk³adzie 4.1: algorytm max zatrzymuje siê dla 
dowolnych danych w strukturze liczb naturalnych. Rzeczywi¶cie, zmienna i, 
kontroluj±ca pêtlê, przyjmuje jako swoje warto¶ci kolejne liczby naturalne, a 
parametr n te¿ jest liczb± naturaln±. Zatem po skoñczonej liczbie kroków zmienna 
i przyjmie warto¶æ n. </p>

<p style="text-align: left">Co wiêcej, po wykonaniu algorytmu spe³niony jest 
warunek 
  (<font face="Symbol">&quot;</font>i)(x<sub>i</sub> <FONT FACE="Symbol"> &#163; </FONT> 
  result):&nbsp; W pêtli &quot;while&quot; ka¿dy element
  ci±gu jest porównywany z elementem result. Je¶li po przejrzeniu i-pierwszych elementów
  ci±gu, result ma warto¶æ najwiêkszego z nich, to w nastêpnym kroku, result przyjmie
  warto¶æ najwiêkszego elementu w¶ród pierwszych (i+1) elementów: max{max{x<sub>1</sub>,...,
  x<sub>i</sub>}, x<sub>i+1</sub>}
  = max{x<sub>1</sub>,..., x<sub>i+1</sub>}. Poniewa¿, dla ci±gu o d³ugo¶ci 1,
  warto¶ci± zmiennej result jest element najwiêkszy (ten jedyny element ci±gu),
  to, na mocy zasady indukcji matematycznej, dla ci±gu dowolnej d³ugo¶ci
  n, po zakoñczeniu pêtli &quot;while&quot;, warto¶ci± result bêdzie element najwiêkszy 
ci±gu x<sub>1</sub>,...,x<sub>n</sub>.</p>

<p style="text-align: left">£atwo zauwa¿yæ, ¿e nie s± tu istotne warto¶ci 
elementów ci±gu, ani ich typy. To samo rozumowanie mo¿emy powtórzyæ dla ci±gów o 
elementach z dowolnej liniowo uporz±dkowanej przestrzeni, byle tylko n by³o 
liczb± naturaln±. Prawdziwe jest wiêc ogólniejsze twierdzenie sformu³owane jako 
lemat 4.1.</p>

<p><div class="lemat">
  <p>Lemat 4.1</p>
  <p>Algorytm max jest ca³kowicie poprawny ze wzglêdu na specyfikacjê <b>&lt;</b> 
  (n&gt;0<font face="Symbol"> <span lang="en">&Ugrave;</span></font> n<span lang="en"><font face="Symbol">Î</font></span>N),<wp,wk></wp,wk> 
  (<font face="Symbol">&quot;</font>i)(x<sub>i</sub> <FONT FACE="Symbol"> &#163; </FONT> 
  result) <font face="Symbol"><span lang="en">&Ugrave;</span> </font>(<font face="Symbol">$</font>i)(x<sub>i</sub>
  <font face="Symbol">= </font>result) <b>&gt; </b>w ka¿dej strukturze danych, w 
  której relacja porównywania elementów&nbsp; <FONT FACE="Symbol"> &#163;</FONT> 
  jest relacj± liniowego porz±dku.</p>
</div>
<p></p>

<p>Nie zawsze mo¿na znale¼æ dostatecznie silny warunek pocz±tkowy, który 
gwarantowa³by zatrzymywanie siê programu. Nie zawsze te¿ zale¿y nam na tym. W 
takich przypadkach zadowolimy siê czê¶ciow± poprawno¶ci± algorytmu.<BR>

</p>

<div class="def">
<p><A NAME="EDU.skorowidz.termin poprawno¶æ_algorytmu 1_3"></A> 
Definicja 4.2 Czê¶ciowa poprawno¶æ algorytmu.</P>
<p>

Powiemy ¿e algorytm Alg jest czê¶ciowo poprawny
  ze wzglêdu na warunek pocz±tkowy wp i warunek koñcowy wk w strukturze Str wtedy i tylko wtedy,
  gdy dla wszystkich danych spe³niaj±cych warunek pocz±tkowy wp w strukturze Str, je¿eli algorytm
  zakoñczy obliczenie, to wyniki spe³niaj± warunek koñcowy wk.</div>
<p></p>

<p>Wprost z przyjêtych definicji wynika, ¿e ca³kowita poprawno¶æ algorytmu 
implikuje jego czê¶ciow±&nbsp; poprawno¶æ ze wzglêdu na tê sam± specyfikacjê. Nie jest 
jednak odwrotnie, jak pokazuje nastêpuj±cy przyk³ad.</p>

<p><b>Przyk³ad 4.2</b></p>

<p>Rozwa¿my nastêpuj±cy algorytm sqrt_1, którego zadaniem ma byæ obliczenie 
pierwiastka kwadratowego z liczby x. Bêdziemy go rozwa¿aæ w strukturze liczb 
rzeczywistych, to znaczy, ¿e operacje u¿yte w tym algorytmie s± operacjami w 
zbiorze liczb rzeczywistych, a zmienne przyjmuj± wy³±cznie warto¶ci rzeczywiste. 
Niech specyfikacja algorytmu ma postaæ:</p>

<p style="text-align: center">wp = {x&gt;0},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
wk = {result = <span lang="en"><font face="Symbol">Ö</font></span>x}.<BR/> </p>

<div class="przyk" style="width: 721; height: 219">
   <TABLE frame="void" rules="none" width="685" height="183">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="43" height="3"> sqrt</TD>
            <TD width="268" height="3"><b>{&nbsp; </b> </TD>
             
            <TD width="10" height="3">&nbsp; </TD>
             
            <TD width="346" height="3"></TD>
             
         </TR>
         <tr>
            <TD width="43" height="1"></TD>
         </tr>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">i := 1; k := 0; reszta := x;</TD>
             
            <TD width="10" height="16"></TD>
             
            <TD width="346" height="16"></TD>
             
         </TR>
         <TR>
            <TD width="43" height="16">&nbsp; </TD>
            <TD width="268" height="16"><b>while</b> not (reszta = 0) <b>do</b></TD> 
            <TD width="10" height="16"></TD> 
            <TD width="346" height="16">// i = 2k+1, reszta = x - k<sup><font face="Verdana">2</font></sup></TD> 
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">   <STRONG>&nbsp;&nbsp;&nbsp; </STRONG>
             &nbsp;&nbsp;&nbsp; k := k + 1;</TD>
            <TD width="10" height="16">   </TD>
            <TD width="346" height="16">   // i = 2k-1, reszta = x - (k-1)<font face="Symbol"><sup>2</sup></font></TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">      <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>&nbsp;  
            reszta := reszta - i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="10" height="16">      </TD>
             
            <TD width="346" height="16">      // i = 2k-1, reszta = x - k<font face="Symbol"><sup>2</sup></font></TD>
             
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            i := i + 2;</TD>
            <TD width="10" height="16">   </TD>
            <TD width="346" height="16">   // i = 2k+1, reszta = x - k<font face="Symbol"><sup>2</sup></font></TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">   <STRONG>&nbsp;od;&nbsp;</STRONG></TD>
            <TD width="10" height="16">   </TD>
            <TD width="346" height="16">   </TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="268" height="16">   <strong>&nbsp;</strong>result := k   <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong></TD>
            <TD width="10" height="16">   </TD>
            <TD width="346" height="16">   // reszta = 0, reszta = x - k<sup><font face="Symbol">2</font></sup>, 
            result = k</TD>
         </TR>
         <TR>
            <TD width="43" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></TD>
            <TD width="268" height="16"><strong>}</strong></TD>
            <TD width="10" height="16"></TD>
            <TD width="346" height="16"></TD>
         </TR>
      </TBODY>
   </TABLE>
</div>
<p>Proste eksperymenty z tym algorytmem poka¿±, ¿e dla x=4 wynikiem jest 2, dla 
x=16 wynikiem jest 4. itd. Mo¿na udowodniæ, ¿e dla dowolnego x postaci n<sup><font face="Verdana">2</font></sup>, 
wynikiem programu jest n. W strukturze liczb rzeczywistych, ten algorytm nie 
zawsze siê jednak zatrzymuje. Wystarczy przyj±æ jak±kolwiek liczbê ca³kowit± 
postaci n<sup><font face="Verdana">2</font></sup> + 1. Po ¿adnej liczbie kroków 
nie otrzymamy warunku reszta=0. Wynika st±d, ¿e algorytm sqrt jest czê¶ciowo poprawny ze wzglêdu na podan± 
specyfikacjê w strukturze liczb rzeczywistych, ale nie jest ca³kowicie poprawny.</p>

<p><b>Uwaga</b> Gdyby¶my nieco zmodyfikowali algorytm, wstawiaj±c w pêtli 
warunek not(reszta &gt; i) zamiast obecnego testu, to otrzymany algorytm by³by 
ca³kowicie poprawny w strukturze liczb rzeczywistych ze wzglêdu na specyfikacjê
<b>&lt;</b> x&gt;0, result = [<span lang="en"><font face="Symbol">Ö</font></span>x]}<b>&gt;</b>.</p>

<p>Analiza czê¶ciowej&nbsp; i ca³kowitej poprawno¶ci&nbsp; programu nie jest 
rzecz± banaln±. Samo zrozumienie jak &quot;dzia³a&quot; instrukcja przypisania czêsto 
nastrêcza du¿o k³opotów.</p>

<p><b>Przyk³ad 4.3</b></p>

<p>Instrukcja {x:= 5;} ma oczywiste konsekwencje: po jej wykonaniu warto¶ci± x 
jest 5, a warto¶æ ¿adnej innej zmiennej nie ulega zmianie. Je¿eli instrukcja 
przypisania ma postaæ {x := x+ 5;}, to po wykonaniu tej instrukcji warto¶æ 
zmiennej x zwiêkszy³a siê o 5 w stosunku do starej warto¶ci x. Skomplikujmy 
teraz nieco sytuacjê&nbsp;&nbsp; zak³adaj±c, ¿e x &gt; y (warto¶æ zmiennej x jest 
wiêksza od warto¶ci pewnej zmiennej y) tu¿ przed wykonaniem instrukcji {x := 
x+5;}. Jaka zale¿no¶æ miêdzy x i y jest spe³niona po wykonaniu tej instrukcji? 
Warto siê samodzielnie zastanowiæ nad tym pytaniem i dlatego odpowied¼ jest 
ukryta pod przyciskiem. </p>
<form>
<INPUT class="GUZIK" TYPE='button' VALUE='-----Zobacz odpowied¼-----' NAME='Klik0' onClick="napis(this.form,'x-5 > y')">
</form>

<p>Dowodzenie poprawno¶ci z³o¿onego algorytmu jest bardziej skomplikowane. 
Bêdziemy postêpowali zgodnie z ide± Floyda opisów programów. Skorzystamy przy 
tym ze strukturalnej budowy algorytmu. Aby udowodniæ poprawno¶æ algorytmu 
postaci {P1;P2;} ze wzglêdu na specyfikacjê &lt;wp, wk&gt;, bêdziemy siê starali 
znale¼æ tak± w³asno¶æ po¶redni± <font face="Symbol">a</font>, ¿e algorytm 
{P1} jest poprawny ze wzglêdu na specyfikacjê &lt;wp, <font face="Symbol">a</font>&gt;, 
a algorytm {P2} jest poprawny ze wzglêdu na specyfikacjê &lt;<font face="Symbol">a</font>, 
wk&gt;.</p>

<p>Jeszcze gorzej jest w przypadku, gdy program zawiera pêtle.&nbsp; Jedn± z 
metod analizy algorytmów stosowanych w tym wyk³adzie, jest metoda 
niezmienników Hoare. Przypomnijmy najpierw definicjê niezmiennika.<BR>

</p>

<div class="def">
<p><A NAME="EDU.skorowidz.termin poprawno¶æ_algorytmu 1_3"></A> 
Definicja 4.3 Niezmiennik</P>
<p>

Powiemy ¿e formu³a <font face="Symbol">a</font> jest niezmiennikiem pêtli&nbsp; 
{while <font face="Symbol">g</font> do P od} w strukturze Str, je¿eli z tego ¿e formu³a (<font face="Symbol">g
<span lang="en">&Ugrave;</span> a</font>) jest spe³niona&nbsp; przed wykonaniem 
programu P (tzn. tre¶ci pêtli} wynika, ¿e formu³a <font face="Symbol">a</font> jest spe³niona po wykonaniu 
programu P w strukturze Str. </div>
<p></p>

<p><b>Przyk³ad 4.4 </b>  </p>

<p>Problem: Znale¼æ najwiêkszy wspólny dzielnik dwóch danych liczb naturalnych x, y. 
Niech specyfikacja poszukiwanego algorytmu ma postaæ:</p>
<p style="text-align: center">wp ={x+y &gt; 0},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
wk = {result<FONT FACE="Symbol"> | </FONT>x <font face="Symbol"> <span lang="en">&Ugrave;</span></font> 
result<FONT FACE="Symbol"> 
| </FONT>y <font face="Symbol"> <span lang="en">&Ugrave;</span> </font>(<FONT FACE="Symbol"> &quot; </FONT>z)(z<FONT FACE="Symbol">&#189;</FONT>x i z<FONT FACE="Symbol">&#189;</FONT>y<FONT FACE="Symbol">
<span lang="en">&reg;</span> </FONT> 
 z<FONT FACE="Symbol"> &#163; </FONT>result)}.</p>
<p>Warunek pocz±tkowy gwarantuje, ¿e x i y nie s± równocze¶nie równe 0, w 
warunek koñcowy, ¿e uzyskany wynik (warto¶æ zmiennej result) jest dzielnikiem 
zarówno x jak i y, oraz ka¿dy inny wspólny dzielnik x i y ma mniejsz± od niego 
warto¶æ. Znany wszystkim algorytm Euklidesa rozwi±zuje postawiony w tym 
przyk³adzie problem.&nbsp; <BR/> </p>

<div class="przyk">
   <TABLE frame="void" rules="none" width="777" height="188">
      <COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left"><COL align="left">
      <TBODY>
         <TR>
            <TD width="43" height="3"> &nbsp;nwd(</TD>
            <TD width="260" height="3"><b>{&nbsp; </b> </TD>
             
            <TD width="35" height="3">&nbsp; </TD>
             
            <TD width="421" height="3"></TD>
             
         </TR>
         <tr>
            <TD width="43" height="1"></TD>
         </tr>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16"><b>if</b> x*y = 0 <b>then</b>   result := x+y
            <b>else</b>  <STRONG>&nbsp;</STRONG></TD>
             
            <TD width="35" height="16"></TD>
             
            <TD width="421" height="16">// je¿eli jedna z liczb x, y jest równa 
            zeru, to najwiêkszy wspólny dzielnik tych liczb jest równy drugiej z 
            nich</TD>
             
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16"><strong>while </strong>not(x = y) <b>do</b></TD>
             
            <TD width="35" height="16"></TD>
             
            <TD width="421" height="16">//nwd(x,y) = k</TD>
             
         </TR>
         <TR>
            <TD width="43" height="16">&nbsp; </TD>
            <TD width="260" height="16"><b>&nbsp;&nbsp;&nbsp;&nbsp; if</b> x &gt; y
            <b>then </b> </TD> 
            <TD width="35" height="16"></TD> 
            <TD width="421" height="16"> </TD> 
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">   <STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </STRONG>
             &nbsp;&nbsp;&nbsp; x := x - y</TD>
            <TD width="35" height="16">   </TD>
            <TD width="421" height="16">   // nwd(x,y) = k</TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">      <strong>&nbsp;&nbsp;&nbsp;&nbsp; else</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TD>
             
            <TD width="35" height="16">      </TD>
             
            <TD width="421" height="16">      </TD>
             
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            y := y - x</TD>
            <TD width="35" height="16">   </TD>
            <TD width="421" height="16">   // nwd(x,y) = k</TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">   <STRONG>&nbsp;&nbsp;&nbsp; fi&nbsp;</STRONG></TD>
            <TD width="35" height="16">   </TD>
            <TD width="421" height="16">   </TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">   <strong>&nbsp;od&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </strong></TD>
            <TD width="35" height="16">   </TD>
            <TD width="421" height="16">   // je¿eli liczby s± równe, to ich 
            najwiêkszy wspólny dzielnik jest równy ich wspólnej warto¶ci</TD>
         </TR>
         <TR>
            <TD width="43" height="16"></TD>
            <TD width="260" height="16">   result := y</TD>
            <TD width="35" height="16">   </TD>
            <TD width="421" height="16">   </TD>
         </TR>
         <TR>
            <TD width="43" height="16"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></TD>
            <TD width="260" height="16"><strong>}</strong></TD>
            <TD width="35" height="16"></TD>
            <TD width="421" height="16"></TD>
         </TR>
      </TBODY>
   </TABLE>
</div>
<p>Niezmiennikiem pêtli w tym algorytmie jest formu³a&nbsp; nwd(x,y) = k. Uzasadnienie: nwd(x,y) = nwd(x-y,y), gdy x&gt;y 
oraz nwd(x,y) = nwd(y-x,x), gdy y&gt;x. Zatem niezale¿nie od tego, któr± czê¶æ 
instrukcji warunkowej wykonamy, najwiêkszy wspólny dzielnik nowych warto¶ci 
zmiennych x i y jest taki sam, jak liczb przypisanych tym zmiennym przed 
wykonaniem programu.</p>
<p>Nie na wiele przyda nam siê niezmiennik, je¿eli nie jest on prawdziwy 
przed wykonaniem programu. Je¿eli jednak jest prawdziwy przed wej¶ciem do pêtli 
i pozostaje prawdziwy po ka¿dej iteracji, to, o ile algorytm siê zatrzyma, 
uzyskane warto¶ci zmiennych równie¿ go spe³niaj±. Pozwala nam to czêsto 
zrozumieæ co robi program i uzasadniæ jego czê¶ciow± poprawno¶æ.</p>
<p>
<div class="lemat">
  <p>Twierdzenie 4.1 O niezmiennikach.</p>
  <p>Je¿eli formu³a <font face="Symbol">a </font>&nbsp;jest niezmiennikiem pêtli 
  {while <font face="Symbol">g</font> do P od} oraz jest prawdziwa przed jej 
  wykonaniem w pewnej strukturze Str, to po wykonaniu pêtli, formu³a&nbsp;
  <font face="Symbol" size="2">a</font><font face="Symbol" size="3"> </font>&nbsp;bêdzie 
  równie¿ prawdziwa.&nbsp; </p>
</div>
<p></p>
<p>Wróæmy na chwilê do przyk³adu poprzedniego. Niech k bêdzie najwiêkszym 
wspólnym dzielnikiem danych liczb naturalnych x i y.&nbsp; Je¿eli x*y = 0, to 
jedna z liczb x lub y musi byæ zerem, ale wtedy k jest równe sumie tych liczb. 
Je¿eli obie liczby x i y s± ró¿ne od zera i&nbsp; przed wykonaniem pêtli mamy 
nwd(x,y) = k, to w³asno¶æ ta nie zmienia siê w kolejnych iteracjach pêtli. W 
momencie, wyj¶cia z pêtli&nbsp; mamy (nwd(x,y) = k <span lang="en">
<font face="Symbol">&Ugrave;</font></span> x=y), z czego wynika, ¿e zmienna result ma 
warto¶æ k, a wiêc warto¶æ najwiêkszego wspólnego dzielnika danych liczb.&nbsp; 
Pozostaje jeszcze pytanie, czy ten algorytm zatrzymuje siê dla wszystkich danych 
spe³niaj±cych warunek pocz±tkowy. Zauwa¿my, ¿e suma&nbsp; (x + y) jest w tym 
algorytmie zawsze liczb± naturaln± ró¿n± od zera. Co wiêcej, warto¶æ tej sumy 
jest w ka¿dym nastêpnym kroku równa wiêkszej z warto¶ci x i y w kroku 
poprzednim. Zatem ci±g warto¶ci sum (x + y) jest ¶ci¶le malej±cy, a wiêc nie 
mo¿e byæ nieskoñczony. To dowodzi, ¿e po skoñczonej liczbie kroków algorytm 
Euklidesa zatrzyma siê. <BR>

</p>

<div class="def">
<p><A NAME="EDU.skorowidz.termin poprawno¶æ_algorytmu 1_3"></A> 
Definicja 4.4 W³asno¶æ stopu.</P>
<p>

Algorytm Alg ma w³asno¶æ stopu w strukturze danych Str, je¿eli dla dowolnych 
danych pocz±tkowych obliczenie algorytmu w tej strukturze jest skoñczone.&nbsp; </div>
<p></p>

<p>Przyk³adem niech bêdzie algorytm {x:=0; while&nbsp; not (x=y) do x := x+1 
od}. W strukturze liczb naturalnych ten algorytm zawsze siê zatrzymuje,&nbsp; bo 
ka¿d± liczbê naturaln± mo¿na otrzymaæ z zera przez dodawanie jedynki. Ten 
algorytm ma wiêc w³asno¶æ stopu w strukturze liczb naturalnych.</p>

<p>
&nbsp;<b>Pytanie 4&nbsp; </b>Czy w³asno¶æ&nbsp; (Warto¶ci± zmiennej result&nbsp; 
jest najwiêksza z liczb {x<sub><font face="Verdana">1</font></sub>,...,x<sub><font face="Verdana">i-1</font></sub>}&nbsp; 
oraz&nbsp; i <FONT FACE="Symbol"> &#163; </FONT>n ) jest niezmiennikiem pêtli w 
algorytmie max?  
<BR>
<FORM><p>
<INPUT class="GUZIK" TYPE='button' VALUE='Zobacz odpowied¼' NAME='Klik0' onClick="napis(this.form,'Nie, bo po wykonaniu ostatniego kroku i = n+1.');">
</p></form>

<FORM><p>
<INPUT class="GUZIK" TYPE='button' VALUE='Uwaga!' NAME='Klik0' 
onClick="napis(this.form,'Gdy zmienimy drugi warunek na i<n+2, to odpowiedzi± jest TAK.');">
</p></form>
<p><br clear="all"><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td align="left">
<A HREF="main01_p3.html" TARGET="main"  class="NAWIGACJA">&#171;&nbsp;poprzedni punkt</a>&nbsp;</td>
<td align="right">&nbsp;<A HREF="main01_p5.html" TARGET="main" class="NAWIGACJA">nastêpny punkt&nbsp;&#187;</a></td>
</tr></table><!--/td-->
<!--/tr-->
<!--/table-->
</body>
</html>