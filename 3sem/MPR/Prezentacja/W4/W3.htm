<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN">
<html><head rel="stylesheet" type="text/css" href="../style/common.css">
 <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
 <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]"><title>W7</title>
 <link rel="stylesheet" type="text/css" href="../style/common.css">
 <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script></head><body bgcolor="#efefef">
<div align="center"><a name="W7"></a><h1>7. Java i bazy danych (JDBC)</h1></div>
<hr>
<p>Java jest doskona≥ym úrodowiskiem programowania dostÍpu do baz danych.
Przyjrzymy siÍ wiÍc mechanizmom umoøliwiajπcym pisanie takich programÛw.<br></p>
<hr>

<a name="W7.1"></a><h2>7.1. Przyk≥adowa baza danych</h2>
<br>
Schemat przyk≥adowej bazy danych ksiπøek (moøe czÍúÊ BD ksiÍgarni internetowej) przedstawia poniøszy rysunek.<br>
<br>
<img src="images/bd1.jpg" alt="r" border="1" height="207" width="630">
<br>
<br>
Baza sk≥ada siÍ z trzech powiπzanych tabel (AUTOR, POZYCJE, WYDAWCA). Pola
ID (identyfikatory) sπ kluczami g≥Ûwnymi w tabelach AUTOR i WYDAWCA,
w tabeli POZYCJE odnoszπ sie do nich klucze zewnÍtrzne (obce) AUTID i WYDID. Pole
ISBN jest kluczem g≥ownym tabeli POZYCJE. Podobnej bazy bÍdziemy uøywac
w przyk≥adowych programach tego rozdzia≥u.<br>
<br>
Poniøej przedstawiono plik wsadowy z instrukcjami dla MySQL, ktÛre tworzπ
przyk≥πdowπ bazÍ. Na tej podstawie moøna siÍ zorientowaÊ jak ta baza wyglπda.<br>
<br>
<pre>create database if not exists ksidb;
use ksidb;
drop table if exists AUTOR; 
drop table if exists WYDAWCA; 
drop table if exists POZYCJE;

create table AUTOR (
        AUTID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(AUTID)
        ) ENGINE=INNODB;

create table WYDAWCA (
        WYDID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(WYDID)
        ) ENGINE=INNODB;



load data infile '../BazySql/ksidb/AUTOR.TXT' replace into table AUTOR;
load data infile '../BazySql/ksidb/WYDAWCA.TXT' replace into table WYDAWCA;

create table POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK integer not null,
        CENA real,
        PRIMARY KEY(ISBN),

        INDEX(AUTID),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(AUTID),

        INDEX(WYDID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(WYDID)


        ) ENGINE=INNODB;

load data infile '../BazySql/ksidb/POZYCJE.TXT' replace into table POZYCJE;
</pre>
<br>Podobny skrypt dla Derby w trybie Embedded ( uruchamianu przez <span style="font-weight: bold; font-style: italic;">ij &nbsp;nazwa_skryptu</span>)<br><br><pre>connect 'jdbc:derby:ksidb;create=true';

drop table POZYCJE;
drop table AUTOR;
drop table WYDAWCA;


create table AUTOR (
        AUTID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(AUTID)
        );

create table WYDAWCA (
        WYDID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(WYDID)
        );


CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'AUTOR','AUTOR.TXT',null,null,null,0);
CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'WYDAWCA','WYDAWCA.TXT',null,null,null,0);

create table POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK integer not null,
        CENA real,
        PRIMARY KEY(ISBN),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(AUTID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(WYDID)
        );

CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'POZYCJE','POZYCJE.TXT',null,null,null,0);
</pre>
<br>
<a name="W7.2"></a><h2>7.2. Dlaczego Java?</h2>
<br>
Zazwyczaj "powaøne" RDBMS nie dostarczajπ gotowych (zadowalajπcych) rozwiπzaÒ&nbsp;
w zakresie graficznych interfejsÛw dostÍpu do&nbsp; baz danych lub nieco bardziej
zaawansowanych úrodkÛw przetwarzania danych na styku klient ñ serwer bazodanowy.<br>
<br>
Zamiast tego udostÍpniane sπ programistyczne interfejsy (API), dziÍki ktÛrym moøna takie problemy rozwiπzywaÊ.<br>
Kaødy RDBMS ma zdefiniowane dla rÛønych jÍzykÛw programowania odpowiednie
interfejsy programistyczne dostÍpu do BD (C, C++, Cobol, PL/I etc; nie wspomnÍ
juø o Visual Basicu czy jÍzykach specyficznych dla danego RDBMS).<br>
<br>
Sπ to jednak biblioteki dynamiczne, skompilowane (i zlinkowane) dla konkretnych
platform sprzÍtowych i systemowych. Kaøde takie API rÛøni siÍ w teø w zaleønoúci
od RDBMS.<br>
<br>
<b>Programistyczny interfejs dostÍpu do baz danych z poziomu Javy <br>
JDBC (Java Database Connectivity API):<br>
</b>
<ul>
  <li>jest niezaleøny od maszyny bazodanowej (RDBMS)</li>
  <li>jest niezaleøny od platformy sprzÍtowej</li>
  <li>jest niezaleøny od systemu operacyjnego</li>
</ul>
Jest zatem jednolity i uniwersalny, a do tego ≥atwy w uøyciu i aktualny (np.
umoøliwia dzia≥ania, wykorzystujπce nowe konstrukcje SQL ñ przewijalne tabele
wynikowe czy typy danych SQL3 ñ oraz programowanie z uwzglÍdnieniem wymagaÒ
úrodowisk rozproszonych).<br>
<br>
<div class="notec">Wszystko co chcielibyúmy robiÊ z dowolnymi relacyjnymi bazami danych z
poziomu programÛw uøytkowych ñ moøemy zrobiÊ w Javie, w jej duchu i konwencji,
majπc jednoczeúnie do dyspozycji przebogate úrodowisko Javy.<br>
<br>
Znajπc JavÍ moøemy szybko i ≥atwo tworzyÊ aplikacje bazodanowe, ktÛre wykraczajπ
poza samπ interakcjÍ z RDBMS i mogπ w≥πczaÊ wszystko co Java ma do zaoferowania
(programowanie sieciowe, rozproszone, multimedialne itp.) </div><br>
<br>
<a name="W7.3"></a><h2>7.3. JDBC</h2>
JDBC&nbsp; jest zestawem klas i interfejsÛw, umoøliwiajπcych:<br>
<ol>
  <li>Po≥πczenie z bazπ danych</li>
  <li>Wykonywanie instrukcji SQL na bazie danych</li>
  <li>Otrzymywanie i przetwarzanie wynikÛw instrukcji SQL (np. tabel wynikowych)</li>
</ol>
&nbsp;<br>
Wersja JDBC 1.0 dostarcza podstawowych úrodkÛw dzia≥ania na BD.<br>
Wersje JDBC 2.0 i - aktualna JDBC 4.0 dajπ dodatkowe moøliwoúci&nbsp; np. <br>
<ul>
  <li>przewijalne i modyfikowalne tabele wynikowe, </li>
  <li>bezpoúrednie modyfikowanie tabel wynikowych za pomoc metod klasy Statement</li>
  <li>wsadowe przetwarzanie instrukcji SQL</li>
  <li>obs≥ugÍ typÛw danych SQL3</li>
  <li>wspomaganie&nbsp; JNDI (Java Naming and Directory Services) ñ czyli moøliwoúÊ
katalogowania i prowadzenia nazw ürÛde≥ danych na poziomie logicznym (podobnie
jak to jest w hierarchicznym systemie plikowym)&nbsp; </li>
  <li>pooling po≥πczeÒ (przechowywanie puli po≥πczeÒ w pamiÍci w celu ew. ponownego uøycia i przyspieszenia transakcji)</li>
  <li>transakcje rozproszone (przesy≥anie danych w sieci do takich klientÛw jak np. przeglπdarki lub laptopy)</li>
  <li>dostÍp do praktycznie kaødej formy tabularyzowanych danych (w tym arkuszy kalkulacyjnych i zwyk≥ych plikÛw),</li><li>obs≥ugÍ typu XML.</li>
</ul>
JDBC pozwala na dzia≥anie w architekturze dwu- i trzy-warstwowej.<br>
<br>
Architektura dwuwarstwowa<br>
<br>
<img src="images/arch1.jpg" alt="r" border="1" height="239" width="526">
<br>
<br>
èrÛd≥o: JDBC User's Guide. Javasoft<br>
<br>
Architektura trzywarstwowa<br>
<br>
<img src="images/arch2.jpg" alt="r" border="1" height="387" width="607">
<br>
<br>
èrÛd≥o: JDBC User's Guide. Javasoft<br>
<br>
<div class="important">Zalety warstwy poúredniej: efektywnoúÊ, kontrola, bezpieczeÒstwo, u≥atwienie
utrzymywania i rozwoju systemu, moøliwoúci integracji z innymi podsystemami
(middleware).</div><br>
<br>
<br>
<a name="W7.4"></a><h2>7.4. Sterowniki JDBC</h2>
Aby po≥πczyÊ siÍ z bazπ danych i mÛc wykonywaÊ na niej operacje naleøy skorzystaÊ
ze specjalnego sterownika, ktÛry t≥umaczy odwo≥ania z poziomu Javy na odwo≥ania
w≥aúciwe dla danego RDBMS.<br>
<br>
Istniejπ 4 typy sterownikÛw.<br>
<br>
<p style="margin-bottom: 0cm;"><br></p>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="553">
<col width="181"><col width="196"><col width="167"><tbody><tr valign="top"><td width="181"><p style="page-break-after: avoid;"><font size="3">Typ sterownika</font></p></td><td width="196"><p><font face="Times New Roman CE, serif"><font size="3">Wyjaúnienia</font></font></p></td><td width="167"><p><font size="3">Zastosowanie</font></p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;"><font size="3">1 <i>- </i><b><font size="3"><span lang="pl-PL"><i>JDBC-ODBC
			bridge </i></span></font></b></font></p><p style="margin-bottom: 0cm;"><b><font size="3"><font size="3"><span lang="pl-PL"><i>+
			sterownik ODBC </i></span></font></font></b></p><p style="margin-bottom: 0cm;"><br></p><p><br></p></td><td width="196"><p style="margin-bottom: 0cm;"><font face="Times New Roman CE, serif"><font size="3">DostÍp
			do BD przez ODBC.</font></font></p><p style="margin-bottom: 0cm;"><font face="Times New Roman CE, serif"><font size="3">JDBC-ODBC
			bridge komunikuje siÍ ze sterownikiem ODBC a ten z bazπ danych.</font></font></p><p><font face="Times New Roman CE, serif"><font size="3">Natywny kod
			ODBC musi byÊ za≥adowany po stronie klienta.</font></font></p></td><td width="167"><p style="margin-bottom: 0cm;"><font size="3">Wszelkie BD <font face="Times New Roman CE, serif">spe≥niajπce
			protokÛ≥ ODBC.</font></font></p><p><font face="Times New Roman CE, serif"><font size="3">Kiedy nie
			ma problemÛw z ≥adowaniem natywnego kodu po stronie klienta
			</font></font></p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;"><b><font size="3">2 -<font size="3"><span lang="pl-PL"><i>
			Native-API</i></span></font></font></b></p><p style="margin-bottom: 0cm;"><b><font size="3"><font size="3"><span lang="pl-PL"><i>
			    partly-Java driver</i></span></font></font></b></p><p><br></p></td><td width="196"><p><font face="Times New Roman CE, serif"><font size="3">Sterownik
			JDBC t≥umaczy odwo≥ania na natywny kod konkretnego API klienta
			danego RDBMS.</font></font></p></td><td width="167"><p><font size="2"><font size="3"><font face="Times New Roman CE, serif">Sterowniki
			sπ specyficzne dla </font>RDBMS dostarczane przez firmy  np.
			Oracle, Sybase, IBM DB2 (UDB) etc. </font></font></p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;"><b><font size="2"><font size="3">3 - </font><font size="3"><span lang="pl-PL"><i><font size="3">JDBC-Net </font></i></span></font></font></b></p><p style="margin-bottom: 0cm;"><b><font size="3"><font size="3"><span lang="pl-PL"><i>
			     pure Java driver</i></span></font></font></b></p><p><br></p></td><td width="196"><p><font size="2"><font size="3"><font face="Times New Roman CE, serif">Tylko
			kod javowy. Odwo≥ania t≥umaczone sπ na uniwersalny, niezaleøny od
			RDBMS, protokÛ≥ sieciowy, a nastÍpnie przez serwer na kody
			specyficzne dl</font>a RDBMS . </font></font></p></td><td width="167"><p><font face="Times New Roman CE, serif"><font size="3">Najbardziej
			elastyczne rozwiπzanie, ale  w przypadku uøycia w Internecie
			wymaga, by sterownik/serwer zapewnia≥y odpowiedni poziom
			bezpieczeÒstwa </font></font></p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;"><b><font size="3">4 - <font size="3"><span lang="pl-PL"><i>Native-protocol
			</i></span></font></font></b></p><p style="margin-bottom: 0cm;"><b><font size="3"><font size="3"><span lang="pl-PL"><i>
			    pure Java driver</i></span></font></font></b></p><p><br></p></td><td width="196"><p style="margin-bottom: 0cm;"><font size="3">Tylko kod javowy.</font></p><p><font face="Times New Roman CE, serif"><font size="3">Sterownik
			t≥umaczy odwo≥ania na specyficzny dla danego RDBMS protokÛ≥
			sieciowy</font></font></p></td><td width="167"><p style="margin-bottom: 0cm;"><font face="Times New Roman CE, serif"><font size="3">Pozwala
			na b. efektywnπ, bo bezpoúredniπ komunikacjÍ klient-serwer
			bazodanowy. Doskona≥e w intranecie.</font></font></p><p style="margin-bottom: 0cm;"><font size="3"><font face="Times New Roman CE, serif">G≥Ûwnym
			ürÛd≥em sπ producenci RDBMS np. Oracle, Sybase, Informix,
			IBM DB2, Inprise InterBase, Microsoft SQL Se</font>rver</font></p><p><br></p></td></tr></tbody>
</table>
<br>
<br>
<a name="W7.5"></a><h2>7.5. £πczenie z bazπ danych</h2>
<br>
Po≥πczenie z bazπ danych wymaga dwÛch krokÛw:<br>
<ul>
  <li>za≥adowania sterownika JDBC,</li>
  <li>zaøπdania od sterownika&nbsp; po≥πczenia i ew. uzyskania go w postaci obiektu typu Connection.</li>
</ul>
Za≥adowanie sterownika odbywa siÍ za pomocπ wywo≥ania statycznej metody klasy
Class o nazwie forName i z argumentem ñ nazwa klasy (sterownika). OgÛlnie
metoda ta zwraca obiekt-klasÍ o podanej nazwie. Jeúli klasa ta nie jest za≥adowana
do JVM, nastÍpuje jej za≥adowanie. Klasy-sterowniki sπ tak napisane, øe przy
ich ≥adowaniu rejestrujπ siÍ jako obiekty typu Driver. <br>
Zwykle obiekt ten (klasa) nie interesuje nas (dlatego w wywo≥aniu pomijamy zwracany rezultat).&nbsp; <br>
<br>
Przyk≥ady:<br>
<br>
&nbsp; Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");<br>
&nbsp; Class.forName("postgresql.Driver"); <br>
&nbsp; Class.forName("oracle.jdbc.driver.OracleDriver");<br>
&nbsp; Class.forName("com.mysql.jdbc.Driver");<br>
<br>
<br>
Nad za≥adowanymi sterownikami kontrolÍ sprawuje DriverManager (nazwa klasy).<br>
Prowadzi on listÍ zarejestrowanych sterownikÛw.<br>
Statyczna metoda <b>getConnection</b> z klasy DriverManager pozwala na uzyskanie po≥πczenia z bazπ, ktÛrej URL podajemy jako argument metody.<br>
DriverManager przeglπda listÍ zarejestrowanych sterownikÛw i wybiera ten, ktÛry moøe po≥πczyÊ siÍ z podanπ bazπ.<br>
Po po≥πczeniu z bazπ&nbsp; zwracany jest obiekt typu Connection, ktÛry reprezentuje po≥πczenie.<br>
<br>
<div class="syntax"><br>
<b>Connection con = DriverManager.getConnection(dbUrl, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
userID, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
password);</b><br>
<br>
lub (jeúli dopuszczalne jest "domyúlne" po≥πczenie ñ bez podania nazwy uøytkownika i has≥a)<br>
<br>
<b>Connection con = DriverManager.getConnection(dbUrl);</b><br>
<br>
Wszystkie argumenty metody getConnection sπ typu String.<br>
<br>
Forma lokatorÛw (urli) zaleøna jest od sterownika i konkretnej bazy danych np.<br>
<br>
// ürÛd≥o danych ODBC o nazwie ksidb<br>
String dbUrl = "jdbc:odbc:ksidb" <br>
<br>
// ≥πczenie z Oraclem z dodatkowymi specyfikacjami<br>
String dbUrl = "jdbc:oracle:thin:user/password@( description=(address_list=(
address=(protocol=tcp) (host=dbmachine)(port=1521)))(source_route=yes) (connect_data=(sid=ksidb)))";<br>
<br>
// MySQL:<br>
<b>String dbUrl = "jdbc:mysql://localhost/ksidb";</b><br>
</div><br>
<br>
<br>
Uwaga: klasa sterownika powinna byÊ dostÍpna dla odwolaÒ z naszego programu.
Odpowiedni JAR moøna np. umieúciÊ w katalogu jre/lib/ext.<br>
<br>
<br>
W trakcie ≥adowania klasy sterownika i przy prÛbie po≥πczenia mogπ powstaÊ wyjπtki, ktÛre musimy obs≥uøyÊ. <br>
<br>
<pre>....
 String driverName = <b>"com.mysql.jdbc.Driver"</b>;
 String url = "<b>jdbc:mysql://localhost/ksidb</b>";
 String uid = "jakis";
 String pwd = "haslo";
 Connection con;

 try {
     Class.forName(driverName);
     con = DriverManager.getConnection(url, uid, pwd);
    } catch (ClassNotFoundException  exc)  {  // brak klasy sterownika
        System.out.println("Brak klasy sterownika");
        System.out.println(exc);
        System.exit(1);
    } catch(SQLException exc) {  // nieudane po≥πczenie
       System.out.println("Nieudane po≥πczenie z " + url);
       System.out.println(exc);
       System.exit(1);
}

.....

</pre>
<br>
Moøemy teø przechwyciÊ oba wyjπtki w jednej klauzuli catch(Exception exc) ...<br>
<br>
Innym sposobem uzyskania po≥aczenie jest wykorzystaie serwisÛw JNDI oraz
tzw. ürÛde≥ danych - zapoznamy sie z nim w rozdziale "Aplikacje WEB".<br><br><br>Sterowniki
spe≥niajπce specyfikacjÍ JDBC 4.0 (jeúli odpowiednie JARy spe≥niajπ
protokÛl Service Provider) mogπ byÊ odnajdywane bez jawnego za≥adowania
klasy.<br>Np. jeúli nasza aplikacja ma dostÍp do pliku derby.jar (jest
na úcieøce dostÍpu klas), to uzyskaÊ po≥aczenie moøemy &nbsp;proúciej:<br><br><pre>Connection con = DriverManager.getConnection("jdbc:derby:ksidb"); </pre>
Dzieje siÍ tak dlatego, øe w&nbsp;derby.jar w katalogu
META-INF/services znajduje siÍ plik java.sql.Driver, zawierajπcy nazwÍ
klasy sterowanika.<br><br>Przy tej okazji - parÍ s≥Ûw o Derby.<br>Derby jest &nbsp;niewielkim i wygodnym w uøyciu SZBD, ca≥kowicie napisanym w Javie, dostarczanym w dystrybucji Javy 6.<br>Moøe dzia≥aÊ w dwÛch trybach:<br><ul><li>embedded - SZBD dzia≥a w tej samej maszynie wirtualnej co nasza aplikacja i nie wymaga dzia≥ania serwera,</li><li>klient-serwer (wymaga startu serwera Derby)</li></ul><br>Bardzo waønπ kwestiπ jest ustalenie systemowej w≥aúciwoúci Javy <span style="font-weight: bold; font-style: italic;">derby.system.home</span>,
wskazujπcej na katalog, w ktÛrym zajdujπ siÍ bazy danych. Jesli tej
w≥aúciwoúci nie ustalimy, to zostanie przyjÍty bieøπcy katalog lub
katalog podany bezpoúrednio przy specyfikacji URLa bazy danych.<br>W≥aúciwoúÊ derby.system.home moøemy okreúliÊ&nbsp; podajπc opcjÍ <span style="font-weight: bold;">-Dderby.system.home=<span style="font-style: italic;">nazwa_katalogu</span></span> przy starcie JVM (czy to nazej aplikacji, czy serwera Derby czy teø CLI, ktÛry w Derby nazywa siÍ <span style="font-weight: bold;">ij</span>.<br><br>Za≥Ûømy, øe:<br>JAVA_HOME wskazuje na katalog instalacyjny Javy i katalog %JAVA_HOME%/bin jest naúcieøce PATH<br>DERBY_HOME - katalog instalacyjny Derby,<br>DERBY_JARS
- zawiera nazwy niezbÍdnych bibliotek JAR z
katalogu&nbsp;%DERBY_HOME%/lib, w szczegÛlnoúci: (rozdzielone
srednikami):<br>&nbsp;%DERBY_HOME%/lib/derby.jar<br>%DERBY_HOME%/lib/derbynet.jar<br>;%DERBY_HOME%/lib/derbyclient.jar<br>%DERBY_HOME%/lib/derbytools.jar <br><br><br>Start CLI w trybie embedded &nbsp;ze skryptem tworzπcym bazÍ danych ksidb w katalogu D:\DerbyDbs<br><pre>java -Dderby.system.home=D:/DerbyDbs -cp "%DERBY_JARS" -Dij.protocol=jdbc:derby: 
org.apache.derby.tools.ij <span style="font-style: italic;">nazwa_skryptu</span></pre><br>Start aplikacji App w trybie embedded &nbsp;Derby (dostÍp do bd ksidb umieszczonej w katalogu D:\DerbyDbs):<br><pre>java -Dderby.system.home=D:/DerbyDbs -cp %DERBY_HOME%/derby.jar App

// dostÍp do ksidb w programie:
Connection con = DriverManager.getConnection("jdbc:derby:ksidb");</pre><br>Start serwera Derby (z ustaleniem derby.system.home):<br><pre>java -Dderby.system.home=D:/DerbyDbs -cp "%DERBY_JARS" org.apache.derby.drda.NetworkServerControl start</pre><br>DostÍp do bazy danych za pomocπ protoko≥u sieciowego (po starcie serwera):<br><pre>  String driverName = "org.apache.derby.jdbc.ClientDriver";
  String url = "jdbc:derby://localhost/ksidb";
  try {
      Class.forName(driverName).newInstance();
      Connection con = DriverManager.getConnection(url);
      // ...
  }

lub jeúli dostÍpnym JARem jest tylko derbyclient.jar:

try {&nbsp;
     Connection con = DriverManager.getConnection(jdbc:derby://localhost/ksidb);
// ...
}</pre>DostÍp
w trybie embedded do bazy danych&nbsp; umieszczonej w katalogu
D:\DerbyDbs (niezaleønie od tego czy w≥aúciwoúÊ derby.system.home
zosta≥a ustalona &nbsp;czy nie):<br><pre>Connection con = DriverManager.getConnection(jdbc:derby:D:/DerbyDbs/ksidb);</pre><br>Po uzyskaniu po≥πczenia otrzymany obiekt Connection wykorzystujemy do operacji
na bazie danych za poúrednictwem innych obiektÛw, ktÛry uzyskamy od obiektu
Connection.<br>
Pokazuje to poniøszy rysunek.<br>
<br>
<img src="images/schemat1.jpg" alt="r" border="1" height="311" width="553">
<br>
<br>
<p style="margin-bottom: 0cm; line-height: 150%;">Po zakoÒczeniu operacji
na bazie danych warto zwolniÊ uzyskane zasoby (takie jak Statement) oraz&nbsp;
po≥πczenie, wywo≥ujπc odpowiednie&nbsp; metody close() na rzecz obiektÛw reprezentujπcych
zasoby/ po≥πczenie.<br>
Nie zawsze jest to obowiπzkowe, bo zwykle zasoby sπ zwalniane automatycznie
przy zakoÒczeniu programu, ale naleøy do dobrej praktyki programistycznej,
mogπ siÍ bowiem zdarzyÊ takie sytuacje, kiedy zasoby nie zostanπ automatycznie
zwolnione.</p>
<p style="margin-bottom: 0cm; line-height: 150%;"></p>
<p style="margin-bottom: 0cm;"></p>
<br>
<a name="W7.6"></a><h2>7.6. Uzyskiwanie metainformacji o bazie danych (przyk≥ad)</h2>
<br>
<pre> Connection con;
<b> DatabaseMetaData md;  // metadane</b>

 // ... uzyskane po≥πczenie
// reprezentuje obiekt con

// uzyskanie metadanych
<b> md = con.getMetaData();  </b>

 // odpytywanie metadanych o rÛøne
 // informacje
 md.getDatabaseProductName();
 md.getDatabaseProductVersion();
 md.getDriverName();
 md.getURL();
 md.getUserName();
 md.supportsAlterTableWithAddColumn();
 md.supportsAlterTableWithDropColumn();
 md.supportsANSI92FullSQL();
 md.supportsBatchUpdates();
 md.supportsMixedCaseIdentifiers();
 md.supportsMultipleTransactions();
 md.supportsPositionedDelete();
 md.supportsPositionedUpdate();
 md.supportsSchemasInDataManipulation();
 md.supportsTransactions();
 md.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
 md.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE);
 md.insertsAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE);
 md.updatesAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE);

</pre>
Przyk≥adowe wyniki:<br>
<div class="listing100"><br>
DatabaseProductName: ACCESS<br>
DatabaseProductVersion: 3.5 Jet<br>
DriverName: JDBC-ODBC Bridge (ODBCJT32.DLL)<br>
URL: jdbc:odbc:ksidb<br>
UserName: admin<br>
supportsAlterTableWithAddColumn: true<br>
supportsAlterTableWithDropColumn: true<br>
supportsANSI92FullSQL: false<br>
supportsBatchUpdates: true<br>
supportsMixedCaseIdentifiers: true<br>
supportsMultipleTransactions: true<br>
supportsPositionedDelete: false<br>
supportsPositionedUpdate: false<br>
supportsSchemasInDataManipulation: false<br>
supportsTransactions: true<br>
ResultSet&nbsp; TYPE_SCROLL_INSENSITIVE :true<br>
ResultSet&nbsp; TYPE_SCROLL_SENSITIVE :false<br>
insertsAreDetected :false<br>
updatesAreDetected :false<br>
<br>
DatabaseProductName: MySQL<br>
DatabaseProductVersion: 3.23.33-debug<br>
DriverName: Mark Matthews' MySQL Driver<br>
URL: jdbc:mysql:///test<br>
UserName: Admin<br>
supportsAlterTableWithAddColumn: true<br>
supportsAlterTableWithDropColumn: true<br>
supportsANSI92FullSQL: false<br>
supportsBatchUpdates: false<br>
supportsMixedCaseIdentifiers: false<br>
supportsMultipleTransactions: true<br>
supportsPositionedDelete: false<br>
supportsPositionedUpdate: false<br>
supportsSchemasInDataManipulation: false<br>
supportsTransactions: false<br>
ResultSet&nbsp; TYPE_SCROLL_INSENSITIVE :true<br>
ResultSet&nbsp; TYPE_SCROLL_SENSITIVE :false<br>
insertsAreDetected :false<br>
updatesAreDetected :false<br>
</div><br>
<br>
<br>
Interfejs DatabaseMetaData zawiera rÛwnieø metody umoøliwiajπce uzyskanie informacji o:<br>
<ul>
  <li>podtrzymywanych przez RDBMS typach danych</li>
  <li>zestawie tabel w bazie danych.</li>
</ul>
<br>
<br>
<a name="W7.7"></a><h2>7.7. Wykonywanie instrukcji SQL</h2>
<br>
Do wykonywanie instrukcji SQL s≥uøy obiekt typu: <br>
<br>
&nbsp;&nbsp;&nbsp; <b>Statement&nbsp;&nbsp; (oznacza instrukcje SQL)</b><br>
<br>
a takøe obiekty typu interfejsÛw pochodnych: <br>
<br>
&nbsp;&nbsp;&nbsp; <b>PreparedStatement (prekompilowane instrukcje SQL)<br>
<br>
&nbsp;&nbsp;&nbsp; CallableStatement (przechowywane procedury)</b><br>
<br>
Uzyskujemy je od obiektu typu Connection za pomocπ odwo≥aÒ&nbsp; (odpowiednio):
createStatement(...), prepareStatement(...) i prepareCall(...)<br>
<br>
Poniøszy schemat obrazuje sposÛb pos≥ugiwania siÍ tymi interfejsami.<br>
<br>
<img src="images/statemet.jpg" alt="r" border="1" height="457" width="682">
<br>
<br>
RÛønice pomiÍdzy w/w metodami sπ nastÍpujπce.<br>
<br>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="614">
<tbody><tr valign="top"><td width="202"><p style="margin-bottom: 0cm;"><font size="4"><b>          Argumenty
			metod</b></font></p><p style="margin-bottom: 0cm;"><br></p><p style="margin-bottom: 0cm;"><br></p><p><font size="4"><b>Metody</b></font></p></td><td width="203"><p style="page-break-after: avoid;" align="center"><font size="4"><b>SELECT...</b></font></p></td><td width="202"><p style="margin-bottom: 0cm;"><font size="4"><b>CREATE TABLE...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>DROP TABLE...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>INSERT...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>UPDATE...</b></font></p><p><font size="4"><b>DELETE...</b></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>executeQuery(...)</b></font></p></td><td width="203"><p><font face="Times New Roman CE, serif"><font size="4"><b>zwraca tabelÍ wynikowπ</b></font></font></p></td><td width="202"><p><font size="4"><b>-</b></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>executeUpdate(...)</b></font></p></td><td width="203"><p><font size="4"><b>-</b></font></p></td><td width="202"><p><font face="Times New Roman CE, serif"><font size="4"><b>zwraca
			liczbÍ zmodyfikowanych rekordÛw lub ñ1 (np. dla
			CREATE...)</b></font></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>execute(...)</b></font></p></td><td colspan="2" width="406"><p><font size="2"><b><font size="4"><font face="Times New Roman CE, serif">wykonuje
			dowolnπ instrukcjÍ SQL i zwraca wartoúÊ boolean (true ñ
			jeúli powsta≥a tabela wynikowa, false ñ jeúli nie;
			prawdziwy wynik ñ tabelÍ wynikowπ lub liczbÍ
			zmodyfikowanych rekordÛw uzyskujemy za pomocπ dodatkowego
			odwo≥ania do obiektu S</font>tatement )</font></b></font></p></td></tr></tbody>
</table>
<p style="margin-bottom: 0cm;"><br></p>
Ten sam obiekt typu Statement moøe byÊ wielokrotnie uøywany do wykonania rÛønych instrukcji SQL np.<br>
<br>
<pre>Statement stmt;
...
String[] creTab = { "CREATE TABLE  A (ID INTEGER, NAME CHAR(30))",
                                "CREATE TABLE  B (ID INTEGER, ADR CHAR(30))",
                             };
...
for (int i = 0; i &lt;&nbsp;creTab.length; i++) {
      stmt.executeUpdate(creTab[i]);
}
stmt.executeUpdate("INSERT INTO A VALUES(1, 'Pies')");
stmt.executeUpdate("INSERT INTO B VALUES(1, 'Buda')");
....

</pre>
<br>
<a name="W7.8"></a><h2>7.8. Obs≥uga wyjπtkÛw SQLException</h2>
<br>
ZarÛwno createStatement() jak i metody executeUpdate(...), executeQuery(...)
i execute(...) mogπ generowaÊ wyjπtki typu SQLException.<br>
Wyjπtki te sygnalizujπ b≥Ídy, wykrywane albo przez sam sterownik (np. brak
jakiegoú trybu dzia≥ania) , albo przez RDBMS (np. b≥Ídy sk≥adniowe w SQL
lub prÛba naruszenia ograniczeÒ ñ jednoznacznoúci, spÛjnoúci referencyjnej
itp.).<br>
<br>
<b>Wyjπtki te musimy obs≥ugiwaÊ.</b><br>
A&nbsp;w trakcie obs≥ugi moøemy uzyskaÊ wiele cennych informacji o przyczynie b≥Ídu.<br>
<br>
Na przyk≥ad:<br>
<pre>Connection con;
Statement stmt;
try {
     Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
     con = DriverManager.getConnection("jdbc:odbc:ksidb");
     stmt = con.createStatement();
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }

   String crestmt = "CREATE TABLE WYDAWCA ( " +
                    "    ID  INTEGER,      " +
                    "    NAME VARCHAR(120), " +
                    "    CONSTRAINT WYDPK PRIMARY KEY(ID) )";
   try  {
     stmt.executeUpdate(crestmt);
     System.out.println("Table created.");
   } catch (SQLException exc)  {
<b>     // rÛøne informacje, ktÛre moøna uzyskaÊ o wyjπtku SQLException</b>
     System.out.println("SQL except.: " + exc.getMessage());  // komunikat
     System.out.println("SQL state  : " + exc.getSQLState()); // kod standardowy
     System.out.println("Vendor errc: " + exc.getErrorCode()); //&nbsp;kod zaleøny od RDBMS
     System.exit(1);
   } finally {       // klauzula finally wykona siÍ zawsze
      try {          // wykorzystujemy to do prawid≥owego zwolnienia zasobÛw
        stmt.close();
        con.close();
      } catch(SQLException exc) {
        System.out.println(exc);
        System.exit(1);
      }
   }

</pre>
<br>
<br>
<a name="W7.9"></a><h2>7.9. Instrukcja SQL SELECT, tabele wynikowe, ResultSet i kursory</h2>
W wyniku wykonania instrukcji SELECT powstaje tabela wynikowa. <br>
Jest ona w Javie dostÍpna poprzez obiekt typu ResultSet.<br>
<br>
<img src="images/ResultSet.jpg" alt="r" border="1" height="424" width="643">
<br>
<br>
<br>
Przy czym:<br>
<ul>
  <li>ResultSet moøemy przeglπdaÊ za pomocπ kursora,</li>
  <li>kursor inicjalnie jest ustawiony przed pierwszym rekordem tabeli wynikowej,</li>
  <li>w zaleønoúci od typu ResultSet moøemy przemieszczaÊ kursor tylko w
kierunku od poczπtku tabeli wynikowej do koÒca (typ: ResultSet.TYPE_FORWAD_ONLY)
lub&nbsp; w obu kierunkach (typy ResultSet.TYPE_SCROLL_INSENSITIVE lub ResultSet.TYPE_SCROLL_SENSITIVE).</li>
  <li>interfejs ResultSet zawiera metody przemieszczajπce kursor, z ktÛrych korzystamy przy przeglπdaniu tabeli wynikowej. </li>
  <li>metody przemieszczajπce kursor zwracajπ wartoúÊ logicznπ false, gdy
øπdane przemieszczenie kursora nie jest moøliwe np. polecenie przejúcia do
nastÍpnego rekordu wyprowadza nas poza tabelÍ,</li>
  <li>jeúli kursor ustawiony jest na jakimú rekordzie tabeli wynikowej,
to moøemy pobraÊ wartoúci jego pÛl za pomocπ odpowiednich metod interfejsu
ResultSet; metody te zapewniajπ automatyczne przekszta≥cenie typÛw SQL do
odpowiadajπcych im typÛw Javy</li>
</ul>
<a name="W7.10"></a><h2>7.10. Przemieszczanie kursora</h2>
W kontekúcie:<br>
<br>
<b>ResultSet rs = stmt.executeQuery(query);</b><br>
<br>
<p style="margin-bottom: 0cm;"><br></p>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="614">
<col width="125"><col width="215"><col width="130"><col width="134"><tbody><tr valign="top"><td width="125"><p style="page-break-after: avoid;" align="center"><font size="4"><font face="Times New Roman CE, serif">Odwo≥ani</font>e</font></p></td><td width="215"><p><font size="4">Ustawia kursor</font></p></td><td colspan="2" width="266"><p style="page-break-after: avoid;" align="center"><font size="4">Typ
			ResultSet</font></p></td></tr><tr valign="top"><td width="125"><br>
</td><td width="215"><p><br></p></td><td width="130"><p><font size="4">nieprzewijalny</font></p></td><td width="134"><p><font size="4">przewijalny</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.beforeFirst();</font></p></td><td width="215"><p><font size="4">Przed pierwszym rekordem</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.first();</font></p></td><td width="215"><p><font size="4">Na pierwszym rekordzie</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.next();</font></p></td><td width="215"><p><font face="Times New Roman CE, serif"><font size="4">Na
			nastÍpnym rekordzie</font></font></p></td><td width="130"><p><font size="4">TAK</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.previous();</font></p></td><td width="215"><p><font size="4">Na poprzednim rekordzie</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.last();</font></p></td><td width="215"><p><font size="4">Na ostatnim rekordzie</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.afterLast();</font></p></td><td width="215"><p><font size="4">Za ostatnim rekordem</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.absolute(n);</font></p></td><td width="215"><p><font size="4">Na n-tym rekordzie</font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr><tr valign="top"><td width="125"><p><font size="4">rs.relative(n);</font></p></td><td width="215"><p><font face="Times New Roman CE, serif"><font size="4">Na
			rekordzie oddalonym o n miejsc od bieøπcego (jeúli n &lt; 0 ñ

			to do poczπtku)</font></font></p></td><td width="130"><p><font size="4">NIE</font></p></td><td width="134"><p><font size="4">TAK</font></p></td></tr></tbody>
</table>
<p style="margin-bottom: 0cm;"><br></p>
Przyk≥ad:<br>
ile rekordÛw zawiera tabela wynikowa?<br>
<br>
<pre>int count = 0;
while (rs.next()) count++;</pre>
<br>
lub:<br>
<br>
<pre>rs.last();
int count = rs.getRow() // numer bieøπcego rekordu</pre>
<br>
Uwaga: dzia≥anie na ResultSet nie oznacza, øe wszystkie rekordy tabeli wynikowej
sπ "úciπgane" z RDBMS. Jest zwykle úciπgana jakaú rozsπdna porcja, gdy kursor
zbliøa siÍ do pozycji od ktÛrej te rekordy mogπ byÊ potrzebne.<br>
Dlatego drugi sposÛb (dostÍpny tylko dla przewijalnych&nbsp; tabel wynikowych) jest bardziej efektywny od pierwszego<br>
<br>
Oczywiúcie, ResultSet przeglπdamy zwykle po to by pobieraÊ wartoúci pÛl poszczegÛlnych
rekordÛw i wykonywaÊ na nich jakieú operacje (choÊby raportowania).<br>
<br>
<a name="W7.11"></a><h2>7.11. OdpowiednioúÊ typÛw danych SQL i Javy. Pobieranie wartoúci pÛl</h2>
Typy danych zapisane w BD rÛøniπ siÍ od typÛw danych Javy.<br>
Aby sprawnie dzia≥aÊ na wartoúciach pÛl poszczegÛlnych rekordÛw trzeba wiedzieÊ
w jaki sposÛb typy SQL sπ odzwierciedlane w typy Javy.<br>
<br>
<table border="1" cellspacing="1" width="526">
<tbody><tr><td valign="middle" width="29%"><p align="center">Standardowy typ SQL </p></td><td valign="top" width="35%"><p align="center">Podstawowy typ Javy </p></td><td valign="top" width="35%"><p align="center">Obiektowy typ Javy</p></td></tr><tr><td valign="middle" width="29%"><code></code><p>CHAR </p></td><td valign="top" width="35%"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>VARCHAR </p></td><td w="" idth="35%" valign="top"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>LONGVARCHAR </p></td><td valign="top" width="35%"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>NUMERIC </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td><td valign="top" width="35%"><code></code><p>j
ava.math.BigDecimal </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DECIMAL </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BIT </p></td><td valign="top" width="35%"><code></code><p>boolean </p></td><td valign="top" width="35%"><code></code><p>Boolean </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TINYINT
</p></td><td valign="top" width="35%"><code></code><p>byte </p></td><td valign="top" width="35%"><code></code><p>Integer </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>SMALLINT </p></td><td valign="top" width="35%"><code></code><p>short </p></td><td valign="top" width="35%"><code></code><p>Integer </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>INTEGER </p></td><td valign="top" width="35%"><code></code><p>int </p></td><td valign="top" width="35%"><code></code><p>Integer
</p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BIGINT </p></td><td valign="top" width="35%"><code></code><p>long </p></td><td valign="top" width="35%"><code></code><p>Long </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>REAL </p></td><td valign="top" width="35%"><code></code><p>float </p></td><td valign="top" width="35%"><code></code><p>Float </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>FLOAT </p></td><td valign="top" width="35%"><code></code><p>doub
le </p></td><td valign="top" width="35%"><code></code><p>Double </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DOUBLE </p></td><td valign="top" width="35%"><code></code><p>double </p></td><td valign="top" width="35%"><code></code><p>Double </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code><!--
code--></code><p>VARBINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>LONGVARBINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DATE </p></td><td valign="top" width="35%"><code></code><p>java.sql.Date </p></td><td valign="top" width="35%"><code></code><p>java.sql.Date </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TIME </p></td><td valign="top" width="35%"><code></code><p>java.sql.Time </p></td><td valign="top" width="35%"><code></code><p>java.sql.Time </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TIMESTAMP </p></td><td valign="top" width="35%"><code></code><p>java.sql.Timestamp </p></td><td valign="top" width="35%"><code></code><p>java.sql.Timestamp </p></td></tr><tr><td valign="Midd
le" width="29%"><p>CLOB </p></td><td valign="top" width="35%"><code></code><p>java.sql.Clob </p></td><td valign="top" width="35%"><code></code><p>java.sql.Clob </p></td></tr><tr><td valign="middle" width="29%"><p>BLOB </p></td><td valign="top" width="35%"><code></code><p>java.sql.Blob </p></td><td valign="top" width="35%"><code></code><p>java.sql.Blob </p></td></tr><tr><td valign="middle" width="29%"><p>ARRAY </p></td><td valign="top" width="35%"><code></code><p>java.sql.Array </p></td><td valign="top" width="35%"><cod e=""></cod><p>java.sql.Array </p></td></tr><tr><td valign="middle" width="29%"><p>STRUCT </p></td><td valign="top" width="35%"><code></code><p>java.sql.Struct </p></td><td valign="top" width="35%"><code></code><p>java.sql.Struct </p></td></tr><tr><td valign="middle" width="29%"><p>REF </p></td><td valign="top" width="35%"><code></code><p>java.sql.Ref </p></td><td valign="top" width="35%"><code></code><p>java.sql.Ref </p></td></tr></tbody>
</table>
<br>
<br>
Ta informacja jest waøna, jeúli chcemy tworzyÊ nieco bardziej elastyczne
aplikacje (np. uniwersalne edytory tabel bazodanowych).<br>
<br>
&nbsp;Do pobierania wartoúci kolumn tabeli wynikowej s≥uøπ metody getTTT(...)
interfejsu ResultSet, ktÛre dokonujπ automatycznej konwersji&nbsp; pomiÍdzy SQL-owym
typem pola, a typem Javy TTT (TTT ñ oznacza tu jakiú typ np. int lub String).<br>
<br>
Najprostszy szablon:<br>
<br>
<img src="images/rsGet.jpg" alt="r" border="1" height="145" width="554">
<br>
<br>
Moøliwoúci uøycie metod getTTT(...) wobec okreúlonych typÛw SQL wyjaúnia nastÍpujπca rysunek.<br>
<br>
<img src="images/types.jpg" alt="r" border="1" height="642" width="765">
<br>
<br>
Przyk≥ad:<br>
<br>
<pre>String sel = "select tytul, cena from pozycje where cena &gt; 40";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      while (rs.next())  {                     //  moøna teø uøyÊ:
         String tytul = rs.getString(3);       //   rs.getString("tytul");
         float cena  = rs.getFloat(6);         //   rs.getFloat("cena");
         float usd = cena/4;
         System.out.println("Tytul: " + tytul);
         System.out.println("Cena : " + cena + " PLN");
         System.out.println("USD  : " + usd + " USD");
         System.out.println("-----------------");
      }
      rs.close();
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
Uwaga: naleøy zamykaÊ ResultSet po wykorzystaniu (rs.close()), aby na pewno zwolniÊ zasoby.<br>
ResultSet jest zamykany automatycznie, gdy zamykamy Statement (stmt.close())
lub gdy ten sam obiekt typu Statment&nbsp; wykorzystywany jest ponownie do wykonania
innej instrukcji SQL (ew. powstaje wtedy nowy ResultSet).<br>
<br>
<img src="images/rsTyp.jpg" alt="r1" border="1" height="409" width="646">
<br>
<br>
<br>
<a name="W7.12"></a><h2>7.12. Modyfikowalny ResultSet</h2>
Jeøeli sterownik JDBC dopuszcza modyfikowalny ResultSet (typ: ResultSet.TYPE_CONCUR_UPDATABLE),
to moøemy uøyÊ wobec obiektu typu ResultSet metod updateTTT(...), updateRow(),
insertRow()&nbsp; i deleteRow(...).<br>
Pozwalajπ one na: dodawanie, modyfikowanie i usuwanie rekordÛw bez bezpoúredniego
uøycia instrukcji SQL, operujπc na obiekcie typu ResultSet.<br>
<br>
Przed wywo≥aniem tych metod naleøy ustawiÊ kursor, tak by wskazywa≥ odpowiedni rekord. <br>
<pre>// Np. usuwanie rekordu 5
ResultSet rs;
...
rs.absolute(5);
rs.deleteRow();

</pre>
Metoda updateRow() s≥uøy zarÛwno do wpisywania jak i modyfikowania rekordÛw.&nbsp;
Przy wpisywaniu ustawiamy kursor na specjalnym "rekordzie" ñ nowym wierszu,
za pomocπ metody moveToInsertRow().<br>
Ustalenie wartoúci pÛl (w nowym lub modyfikowanym) rekordzie odbywa siÍ za
pomocπ metod updateTTT(...) (gdzie TTT ñ javowy typ pola) z dwoma argumentami:
oznaczenie kolumny (indeks lub nazwa) i wpisywana wartoúÊ.<br>
<br>
<img src="images/rsMod.jpg" alt="r" border="1" height="467" width="644">
<br>
<br>
<br>
<a name="W7.13"></a><h2>7.13. Metainformacje o tabeli wynikowej</h2>
Specjalny obiekt typu <b>ResultSetMetaData</b> dostarcza informacji o kolumnach tabeli wynikowej. Obiekt ten uzyskujemy od obiektu ResultSet za pomocπ metody getMetaData():<br>
<br>
<div class="syntax"><br>
&nbsp;&nbsp;&nbsp; ResultSet rs ... <br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; ResultSetMetaData rsmd =&nbsp; rs.getMetaData();<br>
</div><br>
<br>
a nastÍpnie uøywamy metod interfejsu ResultSetMetaData by otrzymaÊ konkretne informacje.<br>
Przyk≥ad <br>
( mamy otwarte po≥aczenie Connection con i uøywamy dodatkowej metody <br>
&nbsp; void say(String s)&nbsp; { System.out.print(s); }&nbsp; )<br>
<br>
<pre> String sel ="SELECT AUTOR.ID, AUTOR.AUTOR, POZYCJE.TYTUL,"
                   "WYDAWCA.NAME AS WYDAWCA " +
                   "FROM POZYCJE,AUTOR, WYDAWCA " +
                   "WHERE WYDAWCA.ID = POZYCJE.WYDID " +
                   "AND AUTOR.ID = POZYCJE.AUTID " +
                   "ORDER BY AUTOR ASC;";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      ResultSetMetaData rsmd = rs.getMetaData();
      int cc = rsmd.getColumnCount();               // liczba kolumn
     for (int i = 1; i &lt;= cc; i++)  {               // i-ta kolumna:
        say('\n'+ rsmd.getColumnName(i));           // - nazwa
        say(" " + rsmd.getColumnDisplaySize(i));    // - szerokoúÊ
        say(" " + rsmd.getColumnClassName(i));      // - klasa Javy
        say(" " + rsmd.getColumnType(i));           // - typ SQL
        say(" " + rsmd.getColumnTypeName(i));       // - typ RDBMS
      }
      stmt.close();
      con.close();

   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
Uwaga:<br>
typ SQL ñ sta≥a int z java.sql.Types<br>

klasa Javy ñ jakiej klasy obiekt zwrÛci&nbsp; getObject() uøyty wobec tej kolumny ResultSet<br>
<br>
Moøliwy wynik:<br>
<div class="listing100"><br>
ID 11 java.lang.Integer 4 LONG<br>
AUTOR 255 java.lang.String 12 TEXT<br>
TYTUL 255 java.lang.String 12 TEXT<br>
WYDAWCA 120 java.lang.String 12 TEXT<br>
</div><br>
<br>
<br>
<a name="W7.14"></a><h2>7.14. Instrukcje prekompilowane</h2>
Prekompilowane instrukcje SQL sπ przed wykonaniem wysy≥ane do RDBMS i podlegajπ
tam prekompilacji, swoistemu przygotowaniu, ktÛre nastÍpnie przyspiesza ich
wielokrotne uøycie (wykonanie).<br>
Oczywiúcie nie ma sensu wykonywaÊ tej samej instrukcji wielokrotnie. Dlatego
w instrukcjach prekompilowanych uøywane sπ znaki ? jako symbole parametrÛw.
Przy kaødym wykonaniu w miejsce znakÛw ? podstawia siÍ odpowiednie wartoúci.<br>
Instrukcje prekompilowane w Javie reprezentowane sπ jako obiekty typu PreparedStatement. <br>
Tworzymy instrukcjÍ prekompilowanπ za pomocπ metody prepareStatement (zamiast
createStatement), podajπc jako argument odpowiedniπ instrukcjÍ SQL (z parametrami
?). Zwykle instrukcje takie wykonujemy w pÍtli ustalajπc wartoúci parametrÛw
za pomocπ metod set... interfejsu PrepareStatement .<br>
<br>
Jeúli TTT i XXX oznaczajπ (rÛøny) typ Javy (np. int, String, float, etc)
to (przyk≥adowe) wykonanie instrukcji prekompilowanej moøna przedstawiÊ schematycznie
w nastÍpujπcy sposÛb:<br>
<br>
<img src="images/prep.jpg" alt="r" border="1" height="329" width="606">
<br>
<br>
<br>
Przyk≥ad:<br>
<pre>Connection con;
PreparedStatement stmt;
...
  String[] wyd =  { "PWN", "PWE", "Czytelnik", "Amber", "HELION",
                            "MIKOM" };
  int beginKey = 10,
  try  {
     stmt = con.prepareStatement("INSERT INTO WYDAWCA VALUES(?,?)");
     for (int i=0; i &lt; wyd.length; i++)   {
       stmt.setInt(1, beginKey + i);
       stmt.setString(2, wyd[i]);
       stmt.executeUpdate();     //         Uwaga: inna forma executeUpdate()
 }
     con.close();
   } catch(SQLException exc)  {
      System.out.println(exc);
   }

</pre>
<br>
<a name="W7.15"></a><h2>7.15. Obs≥uga transakcji</h2>
<b>Transakcja</b> to grupa instrukcji, traktowanych jako ca≥oúÊ: jeøeli ktÛraú
z nich nie zostanie wykonana ñ nie mogπ byÊ wykonane inne; np. przelew z
konta na konto)<br>
<br>
Sterowniki JDBC zwykle uøywajπ domyúlnie trybu autoCommit (wykonanie kaødej
instrukcji INSERT, DELETE, UPDATE powoduje zmiany w bazie danych; transakcjπ
jest jedna instrukcja).<br>
<br>
<img src="images/commit.jpg" alt="r" border="1" height="306" width="631">
<br>
<br>
<br>
<a name="W7.16"></a><h2>7.16. Zastosowanie architektury "Model-View-Controller" przy tworzeniu graficznych interfejsÛw BD za pomocπ komponentÛw Swingu</h2>
<br>
Java wyjπtkowo dobrze nadaje siÍ do tworzenia graficznych interfejsÛw uøytkownika
dostÍpu do baz danych. SzczegÛlnπ rolÍ odgrywajπ tu komponenty Swingu ze
wzglÍdu na ich elastycznoúÊ, atrakcyjnoúÊ graficznπ, niezaleøny od platformy
i konfigurowalny wyglπd oraz realizacjÍ koncepcji MVC.<br>
SzczegÛlnie atrakcyjnym (w kontekúcie interakcji z bazπ danych) komponentem Swingu jest tabela (klasa JTable).<br>
<br> Zobaczymy teraz przyk≥ad realizacji modelu danych tabeli dla przedstawienia
tabeli wynikowej instrukcji SELECT (i nie tylko ñ praktycznie kaødego ResultSetu).<br>
KomÛrki tabeli bÍdπ edytowalne, a ich edycja ma powodowaÊ zmiany w tabelach BD.<br>
<br>
<pre>// Model danych dla&nbsp;tabeli pokazujπcej dowolny ResultSet

import java.util.*;
import java.sql.*;
import javax.swing.*;
import javax.swing.table.*;
import javax.swing.event.*;

public class DbTable extends AbstractTableModel  {
    private Connection con;
    private ResultSet rs;
    private String[]  columnNames;
    private int[]  columnTypes;
    private boolean[] readOnly;
    private String tableName = "";
    private List  rows;
    private ResultSetMetaData   md;
    private boolean editable = false;

public DbTable(Connection conn, String query, ResultSet resultSet, boolean ed)  {
   rs = resultSet;
   editable = ed;
   con = conn;
   tableName = getTableName(query);
   try {
     md = rs.getMetaData();
     int cc =  md.getColumnCount();
     columnNames = new String[cc];
     columnTypes = new int[cc];
     readOnly = new boolean[cc];
     for(int col = 0; col &lt; cc; col++) {
       columnNames[col] = md.getColumnName(col+1);
       columnTypes[col] = md.getColumnType(col+1);
       readOnly[col] = md.isReadOnly(col+1);
     }

     rows = new ArrayList();
     while (rs.next()) {
        List row = new ArrayList();
        for (int i = 1; i &lt;= getColumnCount(); i++) {
          row.add(rs.getObject(i));
        }
        rows.add(row);
     }
     rs.close();
     fireTableChanged(null); // Nowa tabela
   } catch (SQLException ex) {
            System.out.println(ex.getMessage());
     }
}

// Niedoskonala wersja
private String getTableName(String q)  {
   if (q == null || q.equals("")) return "";
   StringTokenizer st = new StringTokenizer(q);
   while (st.hasMoreTokens())  {
     String w = st.nextToken();
     w = w.toUpperCase();
     if (w.equals("FROM")) {
         String t = st.nextToken();
         if (t.indexOf(',') == -1) return t;
         break;
     }
   }
   return "";
}

// Obowiπzkowe metody interfejsu TableModel
public String getColumnName(int column) {
    if (columnNames[column] != null) return columnNames[column];
     else return "";
}

public Class getColumnClass(int column) {
   String type;
   Class c = null;
   try {
     type = md.getColumnClassName(column+1);
     c = Class.forName(type);
     }
     catch (Exception e) {
       return super.getColumnClass(column);
   }
   return c;
}

public boolean isCellEditable(int row, int column) {
    if (!editable) return false;
    if (tableName.equals("")) return false;
    return !readOnly[column];
}

public int getColumnCount() {
   return columnNames.length;
}

public int getRowCount() {
   return rows.size();
}

public Object getValueAt(int r, int c) {
    List row = (List)rows.get(r);
    return row.get(c);
}

 public String dbValue(int col, Object value) {
    int type;
    if (value == null) return "null";
    type = columnTypes[col];

    switch(type) {
        case Types.CHAR:
        case Types.VARCHAR:
        case Types.LONGVARCHAR:
             return "\'"+value.toString()+"\'";
        case Types.BIT:
            return ((Boolean)value).booleanValue() ? "1" : "0";
        default:
            return value.toString();
        }
}


 public void setValueAt(Object value, int r, int c) {
    List row = (List) rows.get(r);
    String oldval = row.get(c).toString();
    if (oldval.equals(value.toString())) return;
    String colName = getColumnName(c);
    String query = " update " + tableName +
                   " set " + colName + " = " + dbValue(c, value) +
                   " where ";
    for(int j = 0; j &lt; getColumnCount(); j++) {
      colName = getColumnName(j);
      if (colName.equals("")) continue;
      if (j != 0)  query += " and ";
      query += colName +" = "+  dbValue(j, getValueAt(r, j));
    }
    query +=  ";";
    try {
       Statement s = con.createStatement();
       int updCount = s.executeUpdate(query);
       row.set(c, value);
       System.out.println("Zmieniono rekordÛw: " + updCount);
    } catch (SQLException e) {
        System.out.println(query);
        System.out.println(e.getMessage());
   }
 }


}

</pre>
Srworzymy rÛwnieø prosty garficzny interfejs do wydawania zleceÒ SQL oraz oglπdania wynikÛw w postaci tabeli.<br>
Przyk≥adowe okno tego programiku wyglπda tak:<br>
<br>
<img src="images/ksidb1.jpg" alt="r" border="1" height="478" width="608">
<br>
<br>
a&nbsp; jego kod &nbsp;pokazano poniøej:<br>
<br>
<pre>// Testowy interfejs SQL

import java.sql.*;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;

public class TestSQL extends JFrame implements ActionListener {

   private Connection con = null;
   private Statement stmt;
   private ResultSet rs = null;
   private String query;
   private JTable table = new JTable();
   private JTextArea ta = new JTextArea(3,40);
   private DefaultListModel history = new DefaultListModel();
   private JList hlis = new JList(history);
   private JWindow wh = new JWindow();


   public TestSQL(String URL, String driver, String user,
                         String passwd) {
        super("Baza danych ksiπøki");
        setDefaultCloseOperation(3);

        try {
           Class.forName(driver);
           con = DriverManager.getConnection(URL);
           stmt = con.createStatement();
        } catch (Exception exc)  {
           System.out.println(exc.getMessage());
           System.exit(1);
        }

        JScrollPane scrollpane = new JScrollPane(table);
        scrollpane.setPreferredSize(new Dimension(600, 400));
        JPanel p = new JPanel();
        p.setLayout(new BorderLayout());
        ta.setLineWrap(true);

        JScrollPane tsp = new JScrollPane(ta);
        p.add(tsp, "Center");
        JButton b = new JButton("Execute");
        b.setMnemonic('E');
        b.addActionListener(this);

        p.add(b, "East");
        p.setBorder(BorderFactory.createLineBorder(Color.blue));
        getContentPane().add(scrollpane, "Center");
        getContentPane().add(p, "South");

        createHistoryList();

        pack();
        setVisible(true);
    }

   public void actionPerformed(ActionEvent e)  {
      String new_query = ta.getText();
      if (new_query.equals(query)) return;
      query = new_query;
      if (!history.contains(query)) history.addElement(query);
      execute(query);
   }

   void execute(String query)  {
      try  {
        rs = stmt.executeQuery(query);
        DbTable dbt = new DbTable(con, query, rs, true);
        table.setModel(dbt);
      } catch(SQLException exc)  {
         System.out.println(exc.getMessage());
      }
   }

  void createHistoryList()  {

    ta.addMouseListener(new MouseAdapter()  {
        public void mouseReleased(MouseEvent e)  {
          if (e.isPopupTrigger())  {
             wh.pack();
             wh.show();
          }
        }
    });

    hlis.addMouseListener(new MouseAdapter()  {
        public void mouseClicked(MouseEvent e)  {
          if (e.getClickCount() == 2)   {
             String s = (String) hlis.getSelectedValue();
             if (s != null) ta.setText(s);
             wh.setVisible(false);
          }
        }
    });

    JScrollPane hsp = new JScrollPane(hlis);
    hsp.setPreferredSize(new Dimension(200, 300));
    JPanel hp = new JPanel(new BorderLayout());
    hp.setBorder(BorderFactory.createLoweredBevelBorder());
    hp.add(hsp, "Center");
    JPanel bhp = new JPanel();

    ActionListener hlHandler = new ActionListener()  {
      public void actionPerformed(ActionEvent e)  {
          String cmd = e.getActionCommand();
          if (cmd.equals("Cancel")) wh.setVisible(false);
          else if (cmd.equals("Clear all")) history.clear();
          else  {
            int index = hlis.getSelectedIndex();
            if (index == -1) return;
            if (cmd.equals("Clear")) history.remove(index);
            else if (cmd.equals("Execute"))  {
              String new_query = (String) hlis.getSelectedValue();
              if (new_query.equals(query)) return;
              query = new_query;
              wh.setVisible(false);
              execute(query);
              ta.setText(query);
            }
          }
      }
    };

    JButton  b = new JButton("Cancel");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Clear");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Clear all");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Execute");
    b.addActionListener(hlHandler);
    bhp.add(b);
    hp.add(bhp, "South");

    wh.getContentPane().add(hp);
    ta.addMouseListener(new MouseAdapter()  {
       public void mouseReleased(MouseEvent e)  {
          if (e.isPopupTrigger())  {
            wh.setLocation( getX()+10, getY()+50);
            wh.pack();
            wh.show();
          }
       }
     });
  }


  public static void main(String[] args) {
    String driverName = "com.mysql.jdbc.Driver";
    String url = "jdbc:mysql:///ksidb";
    String uid = "pies";
    String pwd = "kuba";
    new TestSQL(url, driverName, uid, pwd);
  }
}
</pre>
<br>
<a name="W7.17"></a><h2>7.17 Zadania i Êwiczenia</h2>
Ze wzglÍdu na wagÍ problematyki programowania dostÍpu do baz danych&nbsp; Êwiczenia
bÍdπ doúÊ obszerne, ale za to proste i stopniowo wprowadzajπce w temat.<br>
Uøywana w Êwiczeniach przyk≥adowa baza danych ksiπøek zrealizowana jest w MySQL.<br>
Po instalacji MySQL i sterownika Connector/J (jego plik jar moøna umieúciÊ
w katalogu jre/lib/ext) naleøy stworzyÊ bazÍ danych uruchamiajπc plik wsadowy
o nastÍpujπcej postaci:<br>
<br>
<pre>create database if not exists ksidb;
use ksidb;
drop table if exists AUTOR, WYDAWCA, POZYCJE;

create table if not exists AUTOR (
        ID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(ID)
        );
load data infile 'AUTOR.TXT' replace into table AUTOR;


create table if not exists WYDAWCA (
        ID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(ID)
        );
load data infile 'WYDAWCA.TXT' replace into table WYDAWCA;


create table if not exists POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK int not null,
        CENA real,
        PRIMARY KEY(ISBN),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(ID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(ID),
        );
load data infile 'POZYCJE.TXT' replace into table POZYCJE;

</pre>
Przyk≥adowe pliki z danymi do≥aczone sπ na CD.<br>
<br>
<b>CZ å∆ 1. DBLETY</b><br>
<br>
Proponowane "deblety" sπ krÛtkimi programikami Êwiczeniowymi pokazujπcymi
podstawowe dzia≥ania z bazami danych z poziomu Javy. Tutaj pokazane sa czÍúciowymi
programy, ktÛre naleøy uzpe≥niÊ, tak by w≥aúciwie dzia≥a≥y.<br>
<br>
<u>Zad. 1 (£πczenie z bazπ danych i uzyskiwanie metainformacji o bazie danych)</u><br>
<br>
<div class="notel">Program pokazuje, øe do po≥πczenia z BD potrzebne sπ dwa kroki:<br>
- za≥adowanie odpowiedniej klasy sterownika<br>
- uzyskanie po≥πczenie poprzez uzyskanie obiektu typu Connection<br>
Od obiektu Connection moøemy otrzymaÊ metainformacje zwiπzane ze sterownikiem,
systemem zarzπdzania BD i samπ BD poprzez&nbsp; uzyskanie obiektu typu DatabaseMetaData,
ktÛry moøemy odpytywaÊ za pomocπ wielu&nbsp; metod interfejsu DatabaseMetaData.</div>
Naleøy napisaÊ program, ≥πczπcy siÍ z bazπ danych ksiπøek i uzyskujπcy niektÛre
informacje o bazie danych.<br>
<br>
CzÍúciowy gotowy program (bez czÍúci odpowiedzialnej za po≥πczenie z bazπ
i uzyskanie metainformacji jest pokazany poniøej. Nalezy go uzupe≥niÊ o brakujπce
fragmenty kodu.<br>
<br>
<pre>import java.sql.*;
import java.lang.reflect.*;


public class Con1  {


 // .... tu czegoú brakuje

 public Con1()  {
   // ... i tu rownieø
 }

// Metoda raportujπca informacje zebrane w DatabaseMetaData
// w wywo≥aniach metody info podano jako argumenty nazwy metod tego interfejsu
// a w metodzie info korszystamy z metod refleksji;
// ten sposÛb oprogramowania jest zaawansowany, ale wygodny, bo duøo mniej pisania
// i kod jest bardziej klarowny
// klauzula throws SQLException mÛwi o tym, øe w trakcie dzia≥ania reportInfo moøe powstaÊ wyjπtek
// SQLException, ale nie bÍdziemy go tu obs≥ugiwaÊ, obs≥ugÍ przekaøemy do miejsca wywo≥ania
// czyli bloku try w konstruktorze

void reportInfo() throws SQLException {

   info("getDatabaseProductName");
   info("getDatabaseProductVersion");
   info("getDriverName");
   info("getURL");
   info("getUserName");

   info("supportsAlterTableWithAddColumn");
   info("supportsAlterTableWithDropColumn");
   info("supportsANSI92FullSQL");
   info("supportsBatchUpdates");
   info("supportsMixedCaseIdentifiers");
   info("supportsMultipleTransactions");
   info("supportsPositionedDelete");
   info("supportsPositionedUpdate");
   info("supportsSchemasInDataManipulation");
   info("supportsTransactions");

   System.out.println("ResultSet  TYPE_SCROLL_INSENSITIVE :" +
       md.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));
   System.out.println("ResultSet  TYPE_SCROLL_SENSITIVE :" +
       md.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));
   System.out.println("insertsAreDetected :" +
       md.insertsAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE));
   System.out.println("updatesAreDetected :" +
       md.updatesAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE));
 }

// Metoda info korzysta z metod refleksji do wywo≥ania metod podanych "przez" nazwy.
 void info(String metName) {
   Class mdc  = DatabaseMetaData.class;
   Class[] paramTypes =  { };
   Object[] params =  { };
   String infoTyp;
   if (metName.startsWith("get"))
     infoTyp = metName.substring(3,metName.length());
   else infoTyp = metName;
   try  {
     Method m = mdc.getDeclaredMethod(metName, paramTypes);
     System.out.println(infoTyp + ": " + m.invoke(md, params));  // dynamiczne wywo≥anie metody
   } catch(Exception exc)  {   // Moøliwe powody wyjπtkÛw: nie ma takiej metody, niew≥aúciwe wywo≥anie
     System.out.println(exc);
   }
 }

  public static void main(String[] args)  {
   new Con1();
 }

</pre>
<br>
<br>
<u>Zadanie 2 (tworzenie tabeli)</u><br>
Uwaga: Przed wykonaniem tego zadania naleøy zrobiÊ kopiÍ bazy.<br>
<br>
<div class="notel">Przyk≥ad pokazuje nastÍpujπce waøne kwestie:<br>
<ul>
  <li>polecenia DDL lub SQL sπ wykonywane za poúrednictwem obiektu typu Statement</li>
  <li>obiekt Statement uzyskujemy od obiektu Connection za pomocπ zlecenia createStatement()</li>
  <li>wszelkie zmiany w bazie danych ( w tym usuwanie i tworzenie tabel)
wykonujemy za pomocπ metody executeUpdate aktywowanej na rzecz obiektu Statement</li>
  <li>&nbsp;"na tym samym" obiekcie Statement moøemy wykonaÊ dowolnie wiele poleceÒ SQL/DDL</li>
  <li>od obiektu typu SQLException (wyjπtku SQL) moøemy siÍ dowiedzieÊ wielu
rzeczy np. o standardowy "SQL State" lub zaleøny od dostawcy RDBMS kod b≥Ídu.</li>
</ul>
</div>Zadanie: utworzyÊ tabelÍ WYDAWCA z kolumnami: <br>
ID (ca≥kowitoliczbowy klucz pierwotny)<br>
NAME (≥aÒcuch znakowy zmiennej d≥ugoúci o maks. 255 znakach) ñ nazwa wydawcy.<br>
<br>
NapisaÊ program w taki sposÛb, by zawsze (niezaleønie od tego czy juø w bazie
istnieje tabela WYDAWCA) by≥a tworzona nowa tabela.<br>
Uwaga: tabela WYDAWCA jest tabelπ macierzystπ dla tabeli POZYCJE (klucz
zewnÍtrzny tabeli POZYCJE odnosi siÍ do klucza pierwotnego tabeli WYDAWCA;
relacja ta wymusza spÛjnoúÊ referencyjnej).<br>
<br>
<pre>import java.sql.*;

public class Cre1 {

  static public void main(String[] args) {
    new Cre1();
  }

Statement stmt;&nbsp;

Cre1()  {
   Connection con = null;
   try {
      // ≥πczenie z bazπ i utworzenie obiektu typu Statement
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }

   // metoda dropTable jest naszπ w≥asnπ metodπ napisanπ dla skrÛcenia programu
   // usuwa ona tabelÍ podanπ jako argument
   // Aby w kaødych okolicznoúciach stworzyÊ nowπ tabelÍ WYDAWCA
   // musimy usunπÊ ew.  juø istniejπcπ tabelÍ WYDAWCA
   dropTable("POZYCJE"); // usuniÍcie&nbsp;tabeli pochodnej, bÍdπcej w relacji z tabelπ WYDAWCA
   dropTable("WYDAWCA"); // usiniÍcie&nbsp;tabeli WYDAWCA

   String crestmt = ...

   try  {
     ....                 &nbsp;// wykonanie polecenia zapisanego w crestmt

   } catch (SQLException exc)  {                      // przechwycenie wyjπtku:
      System.out.println("SQL except.: " + exc.getMessage());
      System.out.println("SQL state  : " + exc.getSQLState());
      System.out.println("Vendor errc: " + exc.getErrorCode());
      System.exit(1);
   } finally {
      try {
        stmt.close();
        con.close();
      } catch(SQLException exc) {
        System.out.println(exc);
        System.exit(1);
      }
   }
}

private void dropTable(String tname  )  {
   // ....

}

</pre>
<br>
<br>
∆wiczenie dodatkowe:<br>
<ol>
  <li>przywrÛciÊ bazÍ danych do postaci wyjúciowej</li>
  <li>skompilowaÊ i wykonaÊ program bez odwo≥ania dropTable("POZYCJE") </li>
  <li>obejrzeÊ dok≥adnie komunikaty o wyjπtkach</li>
</ol>
<br>
<u>Zad. 3 (wpisywanie rekordÛw do tabeli)</u><br>
<br>
DodaÊ do tabeli WYDAWCA trzy rekordy reprezentujπce jakichú wydawcÛw.<br>
<br>
<div class="notec">Przyk≥ad ilustruje nastÍpujπce kwestie:<br>
<ul>
  <li>&nbsp;instrukcja SQL do wpisywania ma postaÊ INSERT...&nbsp; (w kilka rÛønych formach)</li>
  <li>&nbsp;przy wpisywaniu rekordÛw uøywamy executeUpdate(...)</li>
  <li>&nbsp;przy wpisywaniu i modyfikowaniu metoda ta zwraca liczbÍ wpisanych/zmodyfikowanych rekordÛw,</li>
  <li>dane typu znakowego (CHAR, VARCHAR, LONGVARCHAR) sπ podawane w SQL w apostrofach</li>
</ul>
</div><br>
<pre>import java.sql.*;

public class Ins1 {

  static public void main(String[] args) {
    new Ins1();
  }

Statement stmt;

Ins1()  {
   Connection con = null;
   try {
     //...
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }

   String[] ins =  { "INSERT INTO WYDAWCA VALUES (1, \'Wyd 1\')",
                             "INSERT INTO WYDAWCA VALUES (2, \'Wyd 2\')",
                             "INSERT INTO WYDAWCA VALUES (3, \'Wyd 3\')",
                   };
   int insCount = 0;   // ile rekordÛw wpisano
   try  {
     for (int i=0; i &lt; ins.length; i++) // wpisywanie rekordÛw
     // ...
   }
//...
}
}&nbsp;
</pre>
Dodatkowe Êwiczenie:<br>
wykonaÊ program ponownie i<br>
zobaczyÊ jak naruszone jest ograniczenie jednoznacznoúci klucza pierwotnego<br>
<br>
Modyfikacja: uøyÊ prekompilowanych instrukcji.<br>
<div class="notec">Ta modyfikacja&nbsp; ilustruje uøycie instrukcji prekompilowanych:<br>
<ul>
  <li>&nbsp;ins. prekompilowana przygotowywana i wykonywana jest za pomocπ obiektu typu PreparedStatement</li>
  <li>obiekt ten jest tworzony poprzez (inne!) odwo≥anie do obiektu Connection: prepareStatement(...)</li>
  <li>argumentem prepareStatement jest String, w ktÛrym wystÍpujπ znaki zapytania
ñ miejsca na "parametry" podstawiane przy kolejnych wykonaniach polecenia
prekompilowanego</li>
  <li>&nbsp;metody set...&nbsp; interfejsu PreparedStatement&nbsp; pozwalajπ podstawiaÊ za parametry-znaki zapytania kolejne wartoúci</li>
  <li>&nbsp;trzeba wiedzieÊ jaki jest typ wartoúci (pola) i uøyÊ odpowiedniej metody set...</li>
</ul>
</div><br>
<br>
<pre>   // ...
   String[] wyd =  { "PWN", "PWE", "Czytelnik", "Amber", "HELION", "MIKOM" };
   int beginKey = 10,
       insCount =  0;
   try  {
     // przygotowanie instrukcji prekompilowanej
     stmt = con.prepareStatement("INSERT INTO WYDAWCA VALUES(?,?)");
     for (int i=0; i &lt; wyd.length; i++)   {
       // ... ?
     }
     con.close();
   } catch(SQLException exc)  {
      System.out.println(exc);
   }

   // ...
</pre>
<br>
<u>Zadanie 4 (SELECT i ResultSet)</u><br>
<br>
Uwaga: aby wykonaÊ to zadanie naleøy przywrÛciÊ wyjúciowπ wersjÍ bazy <br>
<br>
WyprowadziÊ z tabeli POZYCJE wszystkie rekordy, spe≥niajπce warunek CENA
&gt; 30 z≥ i pokazaÊ dla kaødego z nich tytu≥ i cenÍ w PLN i (obliczonπ)
cenÍ w USD.<br>
<br>
&nbsp;<div class="notec">Program ma ilustrowaÊ nastÍpujπce kwestie:<br>
<ul>
  <li>instrukcja SELECT wykonywana jest za pomocπ executeQuery(..)</li>
  <li>executeQuery zwraca obiekt typy ResultSet (tzw. tabela wynikowa)</li>
  <li>z ResultSet zwiπzany jest tzw. kursor, ktÛry wskazuje bieøπcy rekord w tabeli wynikowej</li>
  <li>inicjalnie kursor ustawiony jest przed pierwszym rekordem tabeli wynikowej</li>
  <li>kursor moøemy przesuwaÊ (tylko w stronÍ koÒca tabeli, o ile nie wymagaliúmy
tego, by ResultSet mÛg≥ byÊ "skrolowany") za pomocπ metody next() interfejsu
ResultSet</li>
  <li>wartoúci poszczegÛlnych kolumn z bieøπcego rekordu moøemy pobraÊ za pomocπ metod get... </li>
</ul>
</div><br>
<br>
<pre>
   String sel = "SELECT AUTOR, TYTUL, CENA FROM POZYCJE WHERE CENA &gt; 40";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      while (rs.next())  {
         String tytul = // ... ?
         float cena  = //&nbsp; ... ?
         float usd = cena/4;
         System.out.println("Tytul: " + tytul);
         System.out.println("Cena : " + cena + " PLN");
         System.out.println("USD  : " + usd + " USD");
         System.out.println("-----------------");
      }
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
<br>
Dodatkowe zadanie: wyprowadziÊ wszystkie rekordy tabeli wynikowej powsta≥ej
na skutek wykonania instrukcji SELECT od koÒca tabeli; a nastÍpnie wyprowadziÊ
rekordy 3, 7 i 9.<br>
<br>
<div class="notec">To zadanie winno zilustrowaÊ:<br>
<ul>
  <li>przewijalny ResultSet (typ deklarujemy w createStatement)</li>
  <li>absolutne pozycjonowanie w ramach tabeli wynikowej</li>
  <li>uøycie metainformacji o kolumnach tabeli wynikowej (obiekt typu ResultSetMetaData
moøemy uzyskaÊ za pomocπ zlecenia wobec ResultSet ñ getMetaData(), nastÍpnie
moøemy go "odpytaÊ" o rÛøne informacje za pomocπ metod interfejsu ResultSetMetaData)</li>
  <li>uniwersalnoúÊ metody getString: jeúli potrzebna nam tylko znakowa reprezentacja
informacji zawartej w kolumnach tabeli, getString (uøyte wobec bieøπcego
rekordu ResultSet) dokona w≥aúciwej konwersji dla kaødego typu danych w BD
(oprÛcz typÛw definiowanych i SQL3</li>
</ul>
</div><br>
<br>
<br>
<pre>  String sel = // ... ?
   try  {
      Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                           ResultSet.CONCUR_READ_ONLY);
      ResultSet rs = stmt.executeQuery(sel);
      ResultSetMetaData rsmd = rs.getMetaData();
      int cc = rsmd.getColumnCount();
      for (int i = 1; i &lt;= cc; i++)
        System.out.print(rsmd.getColumnLabel(i) + "     ");

      System.out.println("\n------------------------------ przewijanie do gÛry");

      // ... ?
&nbsp;
      System.out.println("\n----------------------------- pozycjonowanie abs.");
      int[] poz =  { 3, 7, 9  };
      for (int p = 0; p &lt; poz.length; p++)  {
         System.out.print("[ " + poz[p] + " ] ");
         // ... ?
         for (int i = 1; i &lt;= cc; i++) System.out.print(rs.getString(i) + ", ");
         System.out.println("");
      }
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
<br>
<b>CZ å∆ 2. Java jako jÍzyk tworzenia interfejsÛw bazodanowych</b><br>
<br>
Druga czÍúÊ ÊwiczeÒ polega na przedstawieniu Javy jako wygodnego jÍzyka do
tworzenia graficznych interfejsÛw uøytkownika dostÍpu do baz danych.<br>
Prezentowany wczesniej (w p. 16) program korzysta z uniwersalnego modelu
danych tabeli Swing, odzwierciedlajπcego&nbsp; tabelÍ wynikowπ zapytania SQL
lub jakikolwiek inny ResultSet.<br>
<br>
Program sk≥ada siÍ z dwÛch plikÛw ürÛd≥owych, definiujπcych dwie klasy o tych samych nazwach co pliki:<br>
<ul>
  <li>DbTable.java ñ odzwierciedla dowolny&nbsp; ResultSet w modelu danych tabeli Swingowej (JTable),</li>
  <li>TestSQL.java ñ jest graficznym interfejsem, umoøliwiajπcym uzyskiwanie
wynikÛw zapytaÒ SELECT w postaci tabeli JTable, dla ktÛrej modelem jest klasa
DbTable.</li>
</ul>
SkompilowaÊ obie klasy i uruchomiÊ program.<br>
<br>
Po uruchomieniu TestSQL jako g≥Ûwnej klasy uzyskujemy moøliwoúÊ wpisywania
poleceÒ SQL w wielowierszowym polu edycyjnym u do≥u okna. KlikniÍcie w przycisk
Execute lub naciúniÍcie alt-e (mnemonika) powoduje wykonanie instrukcji SELECT
(nie tylko!) i przedstawienie jej wynikÛw w tabeli w centrum okna. Tabela
pozwala na bezpoúrednie edytowanie pÛl w bazie danych (dbl-click na polu
tabeli) ñ jeúli jest to moøliwe na podstawie danego ResultSet. <br>
Wydane polecenia SQL gromadzone sπ w postaci "listy historii"/<br>
Moøemy do niej siÍgaÊ poprzez prawy klik na polu edycyjnym.<br>
PodwÛjne klikniÍcie na elemencie historii ( zapamiÍtanym poleceniu&nbsp; ) powoduje jego przepisanie do pola edycyjnego.<br>
U do≥u okna listy historii znajdujπ siÍ przyciski o nastÍpujπcym znaczeniu:<br>
"Cancel"&nbsp; - zamknij listÍ<br>
"Clear" ñ usuÒ zaznaczony element<br>
"Clear all" ñ usuÒ wszystki elementy historii<br>
"Execute" ñ wykonaj zaznaczonπ na liúcie historii instrukcjÍ SQL<br>
<br>
Komentarze:<br>
<ol>
  <li>Model danych tabeli (plik DbTable.java) jest doúÊ uniwersalny ñ pozwala przedstawiÊ dowolny ResultSet w postaci tabeli Swingowej</li>
  <li>&nbsp;Konkretne GUI ( TestSQL) moøe byÊ dowolnie zmieniane bez ingerencji w zwiπzki DB ñ Swing table model</li>
  <li>&nbsp;Realizacja&nbsp; tego GUI zajÍ≥a ma≥o czasu: okazuje siÍ, øe program w
Javie o zaawansowanych moøliwoúciach&nbsp; moøe liczyÊ mniej niø 200 wierszy (tzn.
niezwykle krÛtki). Nb. wiÍkszoúÊ kodu tego programu zajmuje siÍ obs≥ugπ listy
historii. </li>
</ol>
<br>
StworzyÊ bardziej interesujπce GUI. ZastanowiÊ siÍ w jaki sposÛb moøna by
by≥o uzyskiwac w klasie DBTable dostÍp do ResultSet i prezentacjÍ go w modlu
bez przepisywania rekordÛw do wewnÍtrznych struktur danych,<br>
<br>



</body></html>