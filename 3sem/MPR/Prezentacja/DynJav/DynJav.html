<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Podstawy programowania (Java)">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2008">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Dynamiczna Java</title></head>

<body>
<div align="center">
<a name="DynJav"></a><h1>Dynamiczna Java</h1>
</div>
<hr>
<i>Dynamiczne programowanie pozwala na&nbsp;tworzenie bardzo elastycznych i uniwersalnych aplikacji. W Javie ma ono wiele aspektów.<br></i><span style="font-style: italic;">Java jest jêzykiem interpretowanym. Kompilator tworzy kod bajtowy, ten zaœ podlega interpretacji przez wirtualn¹ maszynê Javy. </span><span style="font-style: italic;">Daje to podstawy do dynamicznego, w fazie wykonania, kszta³towaniu mechanizmów
dzia³ania programu. Osi¹gamy to dziêki tzw. refleksji.</span><br style="font-style: italic;"><span style="font-style: italic;">
Refleksja stanowi równie¿ podstawowy, niskopoziomowy mechanizm,
wykorzystywany
przy programowaniu komponentowym (JavaBeans).&nbsp;Termin JavaBeans
wi¹¿e siê&nbsp; z koncepcj¹ budowania
programów z gotowych, ³atwo dostosowywanych do konkretnych potrzeb,
komponentów
programowych. Idea to niezwykle kusz¹ca, ale jednoczeœnie – z
niewiadomych
powodów – owiana nimbem "wy¿szego wtajemniczenia".&nbsp; W bardzo
krótkim wprowadzeniu
do JavaBeans zobaczymy, ¿e nie ma tu nic tajemniczego ani trudnego, a
korzyœci wi¹¿¹ siê nie tylko z ponownym uzyciem gotowych komponentów,
ale równie¿ z mo¿liwoœci¹ tworzeniu uniwersalnych kodów dziêki
machanizmowi nas³uchu zmian w³aœciwoœci.<br>Kolejny
dynamiczny aspekt Javy - to adnotacje. Pozwalaj¹ one na swoistym
metapoziomie kszta³towaæ semantykê aplikacji i&nbsp;znacz¹co
upraszczaj¹ wykorzystanie ró¿nych technologii programistycznych.<br>Ostatni
temat w tym wyk³adzie dotyczy integracji Javy z&nbsp; jêzykami
skryptowymi. Tu dynamiczne programowanie w Javie przekracza bariery
jednej platformy i otwiera przebogate mo¿liwoœci w tworzeniu
ró¿norodnych aplikacji.&nbsp; </span> 
<hr>
<a name="DynJav.1"></a><h2>1. Refleksja</h2><a name="DynJav.2"></a><h2>1.1. Dynamiczne ³adowanie klas</h2>W klasie Object zdefiniowano metodê getClass. Zastosowana wobec dowolnego obiektu
zwraca odnoœnik do jego klasy, do obiektu klasy java.lang.Class. <br><br>
<div class="important">Obiekty klasy Class s¹ klasami (to wa¿ne: tu same klasy s¹ obiektami) </div><br>
<br>
Mo¿emy wobec takich obiektów stosowaæ ró¿ne metody klasy Class z pakietu java.lang, np. <br>
<br>
<ul><li>
getSuperClass() - zwracaj¹c¹ obiekt klasy Class oznaczaj¹cy klasê bazow¹ danej klasy, </li><li>
getInterfaces() - zawracaj¹c¹ tablicê obiektów, zawieraj¹c¹ interfejsy danej klasy, </li><li>
newInstance() - tworz¹c¹ nowy obiekt danej klasy. </li></ul>


Obiektów-klas nie mo¿emy tworzyæ za pomoc¹ wyra¿enia new. <br>
Jedynie poprzez u¿ycie odpowiednich metod uzyskujemy odnoœniki do tych obiektów. <br>
<br>
Jedn¹ z takich metod jest statyczna metoda klasy Class: <br>
<br><b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; forName(String NazwaKlasy); </b><br>
<br>
Np. pisz¹c: <br>
<br>
Class c = Class.forName("javax.swing.JButton"); <br>
<br>lub <br>
<br>
Class c = javax.swing.JButton.class; &nbsp;&lt;--- <b>nazwa_klasy.<i>class</i></b> jest <b>litera³em</b> oznaczaj¹cym<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;obiekt-klasê<br>
<br>
uzyskujemy odnoœnik do&nbsp; klasy przycisków i mo¿emy siê nim pos³u¿yæ przy tworzeniu obiektu: <br>
<br>
JButton b = (JButton) c.newInstance(); <br>
&nbsp;&nbsp; <br>
W statycznym przypadku, gdy wszystko jest ustalone "w Ÿródle" programu, sens
takich konstrukcji jest niewielki. Ale bardzo czêsto warto od³o¿yæ pewne
ustalenia do fazy wykonania programu, zwiêkszaj¹c jego elastycznoœæ i uniwersalnoœæ.
Wtedy dynamiczna reprezentacja obiektów-klas bardzo siê przydaje. <br>
<br>
Najprostszy przyk³ad: odroczenie ustalenia sposobu obs³ugi akcji na przycisku
do fazy wykonania programu pokazano na poni¿szym wydruku.&nbsp; Jako argument
podajemy nazwê klasy, której obiekt obs³uguje akcjê. Mo¿emy mieæ wiele takich
(wariantowych) klas i bez ¿adnej rekompilacji zmieniaæ sposoby obs³ugi klikniêcia
w przycisk.<br>
<pre>package dynload;
import javax.swing.*;

class Main extends JFrame {

  static void exit(String s) {
    System.out.println(s);
    System.exit(1);
  }


  Main(String actionClassName) {
    Class actionClass = null;
    Action act = null;
    try {
      actionClass =  Class.forName(actionClassName);
      act = (Action) actionClass.newInstance();
    } catch (Exception exc) {
        exit("Obiekt klasy akcji nie mo¿e byæ utworzony");
    }

    JButton b = new JButton();
    b.setAction(act);
    add(b);
    setDefaultCloseOperation(DISPOSE_ON_CLOSE);
    pack();
    setLocationRelativeTo(null);
    setVisible(true);  }
  
  public static void main(String args[]) {
    final String in = JOptionPane.showInputDialog("Podaj nazwê klasy:");
    if (in != null) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          new Main(in);
        }
      });  
     
    }
  }

}

</pre>
Uwaga: w powy¿szym przypadku newInstance zwraca referencjê do obiektu klasy Object - st¹d potrzeba konwersji do typu Action.<br>
<br>
Jeœli teraz przygotujemy dwie klasy, opisuj¹ce ró¿ne akcje np.<br>
<pre>package dynload;
import javax.swing.*;
import java.awt.event.*;

public class DialogAction extends AbstractAction {

  final static String ACTION_NAME = "Show msg";

   public DialogAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     JOptionPane.showMessageDialog(null, ACTION_NAME);
   }

}
</pre>
i<br>
<pre>package dynload;
import javax.swing.*;
import java.awt.event.*;

public class PrintAction extends AbstractAction {

  final static String ACTION_NAME = "Print";

   public PrintAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     System.out.println("Wykonan akcja: " + ACTION_NAME);
   }

}
</pre>
to uruchomienie g³ównego programu z argumentem: DialogAction:<br>
<br>
java Main dynload.DialogAction<br>
<br>
spowoduje, ¿e przycisk w oknie uzyska nazwê Show Msg, a jego klikniecie otworzy okienko komunikaty.<br>
<br>
Natomiast po uruchomieniu programu z argumentem PrintAction<br>
<br>
java Main dynload.PrintAction<br>
<br>
nada przyciskowi nazwê Print, a jego klikniêcie wyprowadzi komunikat na konsolê.<br>
<br>Uwaga: jak widaæ podawane nazwy klas winny byæ kwalifikowane nazw¹ pakietu.<br>
<br>
Takie mo¿liwoœci istnia³y w Javie od zawsze. Ale samo dynamiczne ³adowanie
klas to zdecydowanie za ma³o, by mo¿na by³o tworzyæ naprawdê elastyczne programy.
Dopiero w wersji 1.1&nbsp; Java zyska³a prawdziw¹ elastycznoœæ dziêki wprowadzeniu
mechanizmów refleksji.<br><br><a name="DynJav.3"></a><h2>1.2. Mechanizm refleksji</h2><br>Podstawowy programistyczny interfejs refleksji (<b>Core Reflection API</b>) realizowany jest przez klasy pakietu <b>java.lang.reflect</b>&nbsp; oraz rozbudowan¹ klasê Class z pakietu java.lang.<br>
<br>
<div class="def"><b>Refleksja</b> oznacza mo¿liwoæ wykonywania W TRAKCIE WYKONANIA PROGRAMU nastêpuj¹cych dzia³añ:&nbsp; <br>
<ul><li>uzyskiwania pe³nej informacji o charakterystykach klasy (pola, metody, ich charakterystyki) </li><li>dzia³añ na polach danego obiektu, poprzez ich nazwy,&nbsp; </li><li>aktywowanie metod na rzecz danego obiektu poprzez ich nazwy i z podaniem argumentów.</li></ul>
</div><br>
<br>
U¿ycie refleksji pozwala m.in. na: <br>
&nbsp; <br>
<ul><li>stwierdzenie jakie i z jakimi argumentami metody wystêpuj¹ w danej
klasie (np. podawanej dynamicznie w trakcie wykonania programu) </li><li>dynamiczne wywo³ywanie metod (specyfikowanych w trakcie wykonania programu)
na rzecz jakiego obiektu (te¿ dynamicznie ustalanego), </li><li>dynamiczne uzyskiwanie i modyfikacje wartoœci pól obiektu. </li></ul>
Uzywaj¹c mechanizmów refleksji do metod i pól odwo³ujemy siê poprzez ich nazwy, a nie identyfikatory. <br>
Na czym polega ró¿nica wobec statycznego przypadku? <br>
<br>
W statyce odwo³ania s¹ skonkretyzowane na etapie kompilacji. <br>
Piszemy np. b.getText(). I tak ju¿ zostanie na zawsze. <br>
W dynamice konstrukcja jest ca³kiem inna - w³aœnie pos³uguj¹ca siê nazw¹ metody. Piszemy raczej tak: b.invokeMethod("getText"). <br>
Tu invokeMethod jest nasz¹ w³asn¹ metod¹. Jako argument podajemy nazwê metody
klasy, a poniewa¿ jest to String, mo¿emy go zmieniaæ w ka¿dym momencie wykonania
programu. Np. mo¿emy napisaæ: b.invokeMethod(s), a kolejne podstawienia pod
s ró¿nych nazw metod bêdzie zmieniaæ znaczenie tej linii programu. W³aœnie
w invokeMethod u¿ywamy œrodków refleksji.
<br>&nbsp;<br>Klasy pakietu java.lang.reflect
<br>
<table border="1" cellspacing="1" width="623">
<tbody><tr><td style="font-weight: bold; text-align: center;" valign="middle" width="14%">Klasa</td><td style="font-weight: bold; text-align: center;" valign="middle" width="86%">Przeznaczenie</td></tr><tr><td valign="middle" width="14%">Array&nbsp;</td><td valign="middle" width="86%">Tworzenie tablic, uzyskiwanie i ustalanie wartoœci elementów</td></tr><tr><td valign="middle" width="14%">Constructor&nbsp;</td><td valign="middle" width="86%">Informacja i dostêp do danego konstru
ktora danej klasy. W szczególnoœci wykorzystanie dla tworzenia obiektu.</td></tr><tr><td valign="middle" width="14%">Field&nbsp;</td><td valign="middle" width="86%">Informacja i dostêp do pola obiektu. Pobranie i zmiana wartoœci pola.</td></tr><tr><td valign="middle" width="14%">Method&nbsp;</td><td valign="middle" width="86%">Informacja o danej metodzie danej klasy. Dynamiczne wywo³anie metody na rzecz danego obiektu.
</td></tr><tr><td valign="middle" width="14%">Modifier&nbsp;</td><td valign="middle" width="86%">Uzyskiwanie informacji o modyfikatorach sk³adowej obiektu lub klasy.</td></tr></tbody>
</table>
<br>
&nbsp;<br>
U¿yteczne metody klasy java.lang.Class
<br>&nbsp; 
<table border="1" cellspacing="1" width="623">
<tbody><tr><td style="font-weight: bold; text-align: center;" valign="middle" width="45%">Metoda</td><td style="font-weight: bold; text-align: center;" valign="middle" width="55%">Przeznaczenie</td></tr><tr><td valign="middle" width="45%">getClasses()&nbsp; <br>getDeclaredClasses()&nbsp;</td><td valign="middle" width="55%">Zwraca tablicê obiektów klasy Class, które s¹ sk³adowymi danej klasy.</td></tr><tr><td valign="middle" width="45%">getConstructors()&nbsp; <br>getDeclaredConstructors()</td><td valign="middle" width="55%">Zwraca tablicê obiektów klasy Constructor; s¹ to konstruktory danej klasy</td></tr><tr><td valign="middle" width="45%">getConstructor(Class[]) getDeclaredConstructor(Class[])&nbsp;</td><td valign="middle" width="55%">Zwraca obiekt konstruktor (obiekt klasy konstruktor), który ma podane typy argumentów&nbsp;</td></tr><tr><td valign="middle" width="45%">getMethods()&nbsp; <br>getDeclaredMethods()&nbsp;</td><td valign="middle" width="55%">Zwraca tablicê, zawieraj¹c¹ odnoœniki do metod klasy. Metody s¹ obiektami klasy Method.</td></tr><tr><td valign="middle" width="45%">getMethod(String, Class[]) <br>getDeclaredMethod(String, Class[])&nbsp;</td><td valign="middle" width="55%">Zwraca metodê o podanej nazwie i podanych argumentach jako obiekt klsy Method.</td></tr></tbody>
</table>
<br>Uwaga : Rozró¿nienie pomiêdzy metodami maj¹cymi i nie maj¹cymi w nazwie tekstu "Declared" jest nastêpuj¹ce: 
<ul><li>
    
metody bez "Declared" zwracaj¹ sk³adowe tylko publiczne, ale jednoczeœnie równie¿ dziedziczone, 
    </li><li>
    
metody z "Declared" zwracaj¹ wszystkie sk³adowe (równie¿ prywatne i zabezpieczone), ale bez dziedziczonych
    </li></ul><br><a name="DynJav.4"></a><h2>1.3 &nbsp;Przyk³ady wykorzystania refleksji</h2>Przypomnijmy sobie najpierw
prezentacjê ró¿nych rodzajów ramek (wyklad o komponentach GUI). <br>Pos³u¿y³
jej nastêpuj¹cy program, w którym w sposób dynamiczny uzyskujemy informacje
o polach klasy.<br>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import java.lang.reflect.*;

public class Ramki extends JFrame {

   // Pola klasy okreœlaj¹ ró¿ne rodzaje ramek
   private Border
     // empty = BorderFactory.createEmptyBorder(),
     blackLine = BorderFactory.createLineBorder(Color.black),
     blueLine3 = BorderFactory.createLineBorder(Color.blue, 3),
     // titled1 = BorderFactory.createTitledBorder("Tytu³"),
     titled2 = new TitledBorder(blueLine3,"Tytu³",
                   TitledBorder.CENTER, TitledBorder.CENTER,
                   new Font("Dialog", Font.BOLD | Font.ITALIC, 16),
                   Color.blue),
     etched = BorderFactory.createEtchedBorder(),
     etchedC = BorderFactory.createEtchedBorder(Color.red, Color.yellow),
     // raisedBevel = BorderFactory.createRaisedBevelBorder(),
     // loweredBevel = BorderFactory.createLoweredBevelBorder(),
     matteColor = BorderFactory.createMatteBorder(5, 10, 5, 15, Color.red),
     matteIcon = new MatteBorder(new ImageIcon("FastForward24.gif")),
     softBevR = new SoftBevelBorder(SoftBevelBorder.RAISED),
     softBevL = new SoftBevelBorder(SoftBevelBorder.LOWERED),
     compound1 = BorderFactory.createCompoundBorder(softBevR, softBevL),
     compound2 = BorderFactory.createCompoundBorder(blueLine3, compound1),
     compound3 = BorderFactory.createCompoundBorder(compound1, matteIcon);


  Ramki() {
    super("Prezentacja ramek");
    getContentPane().setLayout (new GridLayout(0,4,5,5));

    // Klasa tego obiektu
    Class c = getClass();

    // Uzyskanie tablicy wszystkich zadeklarowanych pól tej klasy
    Field[] field = c.getDeclaredFields();

    // Przebiegamy po polach-ramkach
    for (int i=0; i&lt; field.length; i++) {

      // Nazwa pola (zmiennej) - opisuj¹cego kolejn¹ ramkê
      String fldName = field[i].getName();

      // Tê nazwê wypiszemy na etykiecie
      JLabel l = new JLabel(fldName, JLabel.CENTER);

      // Uzyskanie referencji do obiektu, reprezentowanego przez
      // pole field[i] tego (this) obiektu. Czyli - do kolejnej ramki

      Object ramka = null;
      try {
        ramka = field[i].get(this);
      } catch (IllegalAccessException exc) { // Ten wyjatek mo¿e wyst¹piæ
          exc.printStackTrace();             // gdy dostêp do pola jest zabroniony
      }                                      // np. z innej klasy do prywatnego pola

      // Dostaliœmy oczywiœcie ramkê, ale jako Object
      // - konieczna konwersja do Border

      l.setBorder((Border) ramka);

      getContentPane().add(l);
    }

    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    show();
  }

  public static void main(String[] args) {
    new Ramki();
  }
}
</pre>
Skrupulatny Czytelnik zapewne zauwa¿y, zê prezentacja jest teraz nieco inna ni¿ w rozdziale o GUI (zob. rysunek).<br>
<br>
<img src="images/Ramki.jpg" alt="r" border="1" height="263" width="531">
<br>
<br>
W programie, w definicjach pól klasy zmieniono (w stosunku do poprzedniej
prezentacji) niektóre w³asciwoœci ramek, niektóre zaœ ramki usuniêto (za
pomoc¹ komentarzy). Wszystkie manipulacje na zestawie ramek do prezentacji
- dziêki refleksji - wykonujemy wy³¹cznie "na" polach klasy (definiuj¹cych
ramki). Mo¿emy wiêc w prosty sposób dodac nowe ramki, i - jak widzieliœmy
- usun¹æ inne.<br>
Takie zastosowanie refleksji&nbsp; znacznie ograniczy³o pracoch³onnoœci pisania kodu. <br><br>Drugi przyk³ad dotyczy dynamicznego wywo³ania metod.<br>Program daje u¿ytkownikowi wybór co do nastêpstw
przyciœniêcia
jakiego przycisku. Co wiêcej, wyborów takich u¿ytkownik mo¿e dokonywaæ
w
fazie wykonania programu. <br>
Zestaw mo¿liwych akcji (na przyciskach) bêdzie zawarty w klasie
ActionsSet np. <br>
<pre>public class ActionSet {

 public void dodaj() { show("Dodaj"); }
 public void usuñ() { show("Usuñ"); }
 public void zast¹p() { show("Zast¹p"); }
 public void szukaj() { show("Szukaj"); }
 public void otwórz() { show("Otwórz"); }

 private void show(String string) {
   JOptionPane.showMessageDialog(null, string);
 }

}</pre>Opcje
dla u¿ytkownika bêd¹ przedstawione w menu kontekstowym, otwieranym
na przycisku. Z tego menu mo¿e on wybraæ (wielokrotnie i ró¿nie w
trakcie
dzia³ania programu) co konkretnie ma siê staæ, jeœli przyciœnie ten
przycisk.<br>
<br>Poni¿szy wydruk pokazuje konstrukcjê programu. Warto zwróciæ
uwagê&nbsp;na zmienn¹ liczbê argumentow metod refleksji.<br>

<pre>import java.lang.reflect.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ReflectionTest extends JFrame implements ActionListener {

  Method currAction = null; // bie¿¹ca metoda obs³ugi
  Class actionClass = null; // klasa obs³ugi
  Object actionObject = null; // obiekt obs³ugi
  JPopupMenu popUp = null; // menu kontekstowe z wyborem obs³ugi
  JButton b;

  public ReflectionTest() {
    super("Test refleksji");
    try {
      actionClass = Class.forName("ActionSet");
      actionObject = actionClass.newInstance();
    } catch (Exception exc) {
      throw new RuntimeException("Wadliwa klasa obs³ugi");
    }

    popUp = new JPopupMenu();
    createMenuItems();

    b = new JButton("U¿yj prawego klawisza myszki, by ustaliæ akcjê");
    b.setFont(new Font("Dialog", Font.BOLD, 24));
    b.addActionListener(this);
    b.setComponentPopupMenu(popUp); 

    setLayout(new FlowLayout());
    add(b);
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    pack();
    setLocationRelativeTo(null);
    setVisible(true);
  }

  void createMenuItems() {
    Method mets[] = null;
    try {
      mets = actionClass.getMethods();
    } catch (Exception exc) {
      throw new RuntimeException("Niedostêpna info o metodach klasy obs³ugi");
    }

    for (Method m : mets) {
      if (m.getDeclaringClass() == actionClass) {
        String name = m.getName();
        JMenuItem mi = new JMenuItem(name);
        mi.addActionListener(this);
        popUp.add(mi);
      }
    }
  }

  void setCurrentAction(String action) {
    try {
      currAction = actionClass.getMethod(action); // zm. liczba arg.!!!
      b.setText("Teraz akcj¹ jest: " + currAction.getName() + " - kliknij!");
    } catch (Exception exc) {
      throw new RuntimeException("Nieznana metoda obs³ugi");
    }
  }

  public void actionPerformed(ActionEvent e) {
    Object src = e.getSource();
    if (src instanceof JMenuItem)
      setCurrentAction(((JMenuItem) src).getText());
    else {
      try {
        currAction.invoke(actionObject); // zmienna liczba arg. !!!
      } catch (Exception exc) {
        JOptionPane.showMessageDialog(null, "Akcja na przycisku nieustalona!");
      }
    }
  }

  public static void main(String args[]) {
    new ReflectionTest();
  }

}
</pre><br><div style="text-align: left;">
<span style="font-style: italic;">Zobacz dzia³anie programu</span></div> 
<applet codebase="demo" code="starterApplet.StarterApplet.class" archive="StarterApplet.jar" align="left" height="70" vspace="20" width="250">
<param name="className" value="reflectmet.ReflectionTest">
<param name="title" value="Demo programu ReflectionTest"><param name="sourceCode" value="reflectmet/source.html">
<param name="hasArgs" value="no"><param name="hasConsole" value="no">
</applet>
<br><br><br><br><br><br><br><br>W programie korzystamy z klasy Method. Uzyskuj¹c odnoœnik do konkretnej metody,
mo¿emu ustaliæ j¹ jako obs³uguj¹c¹ zdarzenie (metoda setCurrentAction). Przy
zajœciu zdarzenia mo¿emy "poœrednio" (dynamicznie) wywo³aæ jego obs³ugê.
S³u¿y temu metoda invoke z klasy Method, u¿yta w actionPerformed. <br><br>Ogólnie:<br><br><ul><li>uzyskanie metody o nazwie name zadeklarowanej w klasie c i maj¹cej okreœlone przez t1, t2, ... typy argumentów:</li></ul><div style="margin-left: 40px;">String name = ....<br>Class t1 = ....<br>Class t2 - ...<br>Method m = c.getDeclaredMethod(name [, t1 [, t2 ...] )<br></div><br><div style="margin-left: 40px;">w szczegolnoœci metoda o nazwie name bez argumentów mo¿e byæ uzyskana przez getMethod(name).<br></div><br><ul><li>wywolanie metody m na rzecz obiektu trg z argumentami x, y, z:</li></ul><div style="margin-left: 40px;">m.invoke(trg, x, y, x)<br></div><br>
<br>
<hr>
<a name="DynJav.5"></a><h2>2. JavaBeans</h2><a name="DynJav.6"></a><h2>2.1. Pojêcie JavaBean</h2>
<br>
<div class="def"><b>JavaBean</b> - (bean – ziarno) – to programowy komponent "wielokretnego
u¿ytku", którego w³aœciwoœci i funkcjonalnoœæ mog¹ byæ odczytywane i/lub
zmieniane uniwersalnymi œrodkami programistycznymi.</div><br>
<br>
Uwaga: JavaBean oznacza zarówno obiekt, jak i klasê tego obiektu. Rozró¿nienie
zawsze jasno wynika z kontekstu. O JavaBean bêdziemy mówiæ krócej "ziarno".<br>
<br>
Co oznacza powy¿sza definicja?<br>
Gdy wbudowujemy zewnêtrzny komponent-ziarno do naszego programu, mamy do
dyspozycji œrodki programistyczne, które pozwalaj¹ uzyskaæ o nim informacje:<br>
<br>
<ul><li>jakie ma w³aœciwoœci? jakie metody s³u¿¹ do ich pobierania i ustalania? </li><li>jakie obs³uguje zdarzenia? jakie zdarzenia mog¹ siê mu przytrafiaæ? </li><li>jakie metody udostêpnia otoczeniu (eksportuje)? </li></ul>
Uniwersalnoœæ sposobów odczytywania i/lub zmieniana charakterystyk obiektu-ziarna opiera siê na:<br>
<ul><li>uzgodnionym protokole. dotycz¹cym informacji o ziarnie (standardowe wzorce deklaracji metod i/lub klasy informacyjne) </li><li>standardowych œrodkach pobierania informacji (introspekcja - realizowana przez klasê Introspector z pakietu java.beans) </li><li>standardowych œrodkach dostosowania obiektu </li></ul>
<br><a name="DynJav.7"></a><h2>2.2.&nbsp; W³aœciwoœci i akcesory </h2>
Ziarna maj¹ w³aœciwoœci (atrybuty).<br>
<br>
<div class="def">Dostêp do w³asciwoœci zapewniaj¹ metody klasy-ziarna nazywane akcesorami..<br>
Akcesor pobieraj¹cy w³aœciwoœci nazywa siê getter, a ustalaj¹cy – setter.</div><br>
<br>
Wyró¿niamy w³asciwoœci <b>proste </b>(w tym binarne) oraz w³aœciwoœci <b>indeksowane</b>.<br>
W³aœciwoœci proste maj¹ jedn¹ wartoœæ, w³aœciwoœci indeksowane – wiele wartoœci, przedstawianych jako tablica.<br>
<br>
<div class="syntax">Standardowe wzorce deklaracji akcesorów s¹ nastêpuj¹ce<br>
<br>
Dla&nbsp; prostej (niebinarnej) w³asciwoœci o nazwie NNN i typie Typ<br>
<br>
getter: Typ getNNN() <br>
setter: void&nbsp; setNNN(Typ)<br>
<br>
np. dla ziarna javax.swing.JButton i w³asciwoœci background mamy <br>
getter: Color getBackground()<br>
&nbsp;i setter: void setBackground(Color).<br>
<br>
Dla w³aœciwoœci binarnej o nazwie NNN:<br>
<br>
getter: boolean isNNN()<br>
setter: void setNNN(boolean)<br>
<br>
np. boolean isVisible(), setVisible(boolean)<br>
<br>
Dla w³aœciwoœci indeksowanej o nazwie NNN, której wartoœci reprezentowane s¹ jako tablice elementów typu Typ:<br>
&nbsp;<br>
getter elementu:&nbsp; Typ getNNN(int) // zwraca wartoœæ&nbsp; podanego indeksu w³aœciwoœci<br>
setter elementu: vois setNNN(int, Typ) // ustala wartoœæ&nbsp; podanego indeksu w³aœciwoœci<br>
<br>
getter tablicy: Typ[] getNNN()<br>
setter tablicy: void setNNN(Typ[])<br>
</div><br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>zwi¹zane (bounded)</b>. <br>
<br>
O zmianie zwi¹zanej w³aœciwoœci ziarna mog¹ byæ zawiadamiane inne komponenty i reagowaæ na tê zmianê. <br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>ograniczane (constrained)</b>.<br>
Ograniczana w³aœciwoœæ – to taka, o której zmianie powiadamiane s¹ zainteresowane
inne komponenty i s¹ pytane o zgodê na tê zmianê. Jeœli którykolwiek z komponentów
nie da takiej zgody (zawetuje zmianê)&nbsp; – zmiana nie dochodzi do skutku.<br>
<br>
Setter zwi¹zanej i/lub ograniczanej w³aœciwoœci ma obowi¹zek wygenerowaæ zdarzenie klasy <b>PropertyChangeEvent</b>..<br>
<br>
Klasy-ziarna , maj¹ce zwi¹zane w³aœciwoœci mus¿¹ dostarczyæ metody przy³¹czania s³uchaczy zmian w³aœciwoœci: <b>addPropertyChangeListener(PropertyChangeListener)</b><br>
<br>
Klasy-ziarna, maj¹ce ograniczane w³aœciwoœci, musz¹ dostarczyæ&nbsp; metody <b>addVetoableChangeListener(VetoableChangeListener)</b>.<br>
<br>
Ziarna mo¿emy wykorzystywaæ, mo¿emy te¿ je tworzyæ (w znaczeniu: definiowaæ klasê ziarna)<br>
<br>
Tworzenie ziarna (jako klasy) wymaga zdefiniowania klasy,&nbsp; która:<br>
<ul><li>stosuje ogólnie przyjête wzorce sygnatur metod&nbsp; i/lub uzupe³niona jest
przez dodatkow¹ specjaln¹ klasê opisuj¹c¹ "niestandardowe" informacje o ziarnie
(implementacja interfejsu BeanInfo) </li><li>zapewnia serializacjê obiektów</li><li>zawiera konstruktor bezparametrowy </li><li>uzwglêdnia dzia³ania w œrodowisku wielow¹tkowym (do obiektu klasy mo¿e równoczeœnie odwo³ywaæ siê kilka w¹tków) </li></ul>
<br><a name="DynJav.8"></a><h2>2.3.&nbsp; Nas³uch i wetowanie zmian w³aœciwosci</h2>
Zmiana w³aœciwoœci zwi¹zanej lub ograniczanej powinna generowaæ zdarzenie typu <b>PropertyChangeEvent</b>.<br>
<br>
Komponenty (obiekty) zainteresowane w œledzeniu zmian&nbsp; tej w³asciwoœci&nbsp; musz¹ implementowaæ interfejs <b>PropertyChangeListener</b>.&nbsp; W ten sposób staj¹ siê s³uchaczami zmian w³aœciwoœci.. <br>
Komponenty, które mog¹ wetowaæ zmiany w³aœciwoœci musz¹ implementowaæ interfejs <b>VetoableChangeListener</b> (bêd¹ wiêc s³uchaczami zmian w³aœciwoœci ograniczonych i bêdê mia³y mo¿liwoœæ wetowania tych zmian).<br>
<br>
Zdarzenie typu PropertChangeEvent mo¿emy zapytaæ o:<br>
<ul><li>nazwê w³aœciwoœci -&nbsp; String getPropertyName()</li><li>star¹ wartoœæ w³asciwoœci&nbsp; (przed zmian¹) – Object getOldValue()</li><li>now¹ wartoœæ w³asciwoœci – Object getNewValue() </li></ul>
Interfejs <b>PropertyChangeListener</b> ma jedn¹ metodê:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; public void propertyChange(PropertyChangeEvent)</b><br>
<br>
W implementacji tej metody, dowiaduj¹c siê o zmianach w³aœciwoœci, mo¿emy na nie odpowiednio reagowaæ.<br>
<br>
Równie¿ interfejs <b>VetoableChangeListener</b> ma jedn¹ metodê: <b>vetoableChange(...)</b>
 z argumentem–zdarzeniem typu PropertyChange. W jej implementacji , gdy dowiemy
siê ju¿ wszystkich niezbêdnych szczegó³ow o zmianie – mo¿emy j¹ zawetowaæ.<br>
<br>
<b>Wetowanie zmiany</b>&nbsp; odbywa siê na zasadzie zg³oszenia wyj¹tku <b>PropertyVetoException</b>, zatem deklaracja metody vetoableChange wygl¹da nastêpuj¹co:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; public void vetoableChange(PropertyChangeEvent e)&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throws
PropertyVetoException<br>
</b><br>
a w jej implementacji – gdy po sprawdzeniu waroœci w³aœciwoœci chcemy zg³osiæ veto – sygnalizujemy wyj¹tek: <b>throw new PropertyVetoException(...)</b>.<br>
<br>
<b>S³uchacze</b> zmian&nbsp; w³aœciwoœci&nbsp; zwi¹zanych (jak zawsze w Javie) mus¿¹
byæ przy³¹czeni do Ÿród³a zdarzenia., którym jest&nbsp; w tym przypadku ziarno.&nbsp;
<br><br>
Przy³¹czenie staje siê mo¿liwe, jesli w klasie-ziarnie zdefiniowano metodê <b>addPropertyChangeListener(...)</b><br>
Musi te¿ byæ zdefiniowana metoda <b>removePropertyChangeListener</b>, od³aczaj¹ca s³uchacza.<br>
<br>
To samo dotyczy nas³uchu zmian w³aœciwoœci ograniczanych: klasa zaiarno
musi dostarczyæ&nbsp; metody przy³¹czenia s³uchacza:&nbsp; <b>addVetoableChangeListener</b> oraz metody od³¹czania s³uchacza:&nbsp; <b>removeVetoableChangeListener</b>.<br>
<br><font color="#ff0000"><b>
Obowi¹zkiem klasy ziarna, która implementuje zwi¹zane i/lub ograniczane w³aœciwoœci
jest równie¿ dostarczenie odpowiednich definicji setterów dla tych w³aœciwoœci.
<br>


W setterach nale¿ey&nbsp; generowaæ zdarzenie PropertyChangeEvent&nbsp; i propagowaæ go poœród przy³¹czonych s³uchaczy.<br>
</b></font>
<br>
W pakiecie java.beans znajduj¹ siê dwie klasy narzêdziowe,&nbsp; znacznie u³atwiaj¹ce
wykonanie tych zadañ: PropertyChangeSupport i VetoableChangeSupport.<br>
Klasy dostarczaj¹ metod&nbsp; generowania zdarzeñ i propagacji zdarzeñ zmian:<br>
<ul><li>w³aœciwoœci zwi¹zanych -&nbsp; firePropertyChange </li><li>w³aœciwoœci ograniczanych -&nbsp; fireVetoableChange s³uchaczy.</li><li>a tak¿e metod przy³¹czanai i od³¹czania s³uchaczy tych zmian (addNNNListener, removeNNListener).</li></ul>
Konstruktory tych klas maj¹ jako argument&nbsp; referencjê do obiektu-ziarna.<br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci zwi¹zanej jest nastêpuj¹cy:</b></u><br>
<br>
<pre>class Ziarno .... {

  //wsparcie
  private PropertyChangeSupport chg = new PropertyChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc zwi¹zana o nazwie "text"
  ...
// setter
synchronized void setText(String newTxt) { // pamiêtamy o wielow¹tkowoœci!

    String oldTxt =  text;   // stara wartoœæ
    text = newTxt;           // ustalenie nowej wartoœci
     // powiadomienie
    chg.firePropertyChange("text", oldTxt, newTxt);
}
....

// metody dodawania i usuwania s³uchaczy
public synchronized void addPropertyChangeListener(PropertyChangeListener l) {
 chg.addPropertyChangeListener(l);
 }

public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
 chg.removePropertyChangeListener(l);
 }
...
}

</pre>
<br>
Implementacja w³aœciwoœci ograniczanych musi uzwglêdniaæ mo¿liwoœæ zawetowania zmiany przez któregoœ ze s³uchaczy. <br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci ograniczanej jest nastêpuj¹cy:</b></u><br>
<br>
<pre>class Ziarno .... {

  //wsparcie
  private VetoableChangeSupport veto = new VetoableChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc ograniczana o nazwie "tekst"
  ...
// setter

synchronized void setText(String newTxt)  throws PropertyVetoException
 {
    String oldTxt =  text;  // stara wartoœæ

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     //  przez metodê wywo³uj¹c¹ setText

     veto.fireVetoableChange("tekst", oldTxt, newTxt);

     // Tylko jeœli nikt nie zawetowa³ zmiany:

     text = newTxt;   // ustalenie nowej wartoœci
}
....
// metody dodawania i usuwania s³uchaczy

public synchronized void addVetoableChangeListener(PropertyChangeListener l) {
 veto.addVetoableChangeListener(l);
 }

public synchronized void removeVetoableChangeListener(PropertyChangeListener l) {
 veto.removeVetoableChangeListener(l);
 }
...
}

<b>// Uwaga: wsystkie klasy  zdarzeniowe i interfejsy nas³uchu
// dla w³aœciwoœci znajduj¹ siê w pakiecie java.beans.
</b>
</pre>
<br>
<br><a name="DynJav.9"></a><h2>
2.4. &nbsp;JavaBean - przyk³ad praktyczny</h2>

Bêdziemy budowaæ klasê-licznik jako JavaBean. Klasê nazwiemy <b>Counter</b>.<br>
Licznik bêdzie mia³ jedn¹ w³aœciwoœæ o nazwie <b>count</b> (stan licznika).<br>
W wersji pierwszej uczynimy tê w³aœciwoœæ zwi¹zan¹ (bounded), w&nbsp; wersji drugiej – zwi¹zan¹ i ograniczon¹ (constrained).<br>
<br> Przy budowie aplikacji zastosujemy koncepcjê&nbsp; "Model-View-Controller".
<br>
<br>
Sama klasa Counter odzwierciedla logikê dzia³ania licznika ("<b>model</b>
"). Obiekty tej klasy "s¹ niewidzialne", a zatem&nbsp; ¿eby zobaczyæ licznik musimy
stworzyæ dodatkow¹ klasê, która zdefiniuje widok licznika&nbsp; (<b>view</b>).<br>
Nazwiemy j¹ <b>CounterView</b>. Warto zwróciæ uwagê: separacja kodu jest
korzystna – widok uniezale¿niamy od modelu, a model od widoku, w ten sposób
mo¿emy mieæ np. wiele widoków licznika, lub zmieniaæ model nie zmieniaj¹c
widoku.<br>
<br>
Komunikacja miêdzy modelem i widokiem bêdzie siê odbywaæ na zasadzie nas³uchu
zmian w³aœciwoœci (zmian w³aœciwoœci count) czyli obiekt klasy CounterView
bêdzie te¿ s³uchaczem zmian w³aœciwoœci (PropertyChangeListener).<br>
<br>
Musimy te¿ mieæ jakieœ œrodki zmiany stanu licznika. Interakcjê u¿ytkownika z modelem/widokiem zapewnia tzw. kontroler.<br>
Widzieliœmy, ¿e w komponentach Swingu (w naturalny dla nich sposób) kontroler
po³¹czony jest z widokiem. Tu jednak odseparujemy jego kod od widoku, tworz¹c
klasê <b>CounterControlGui</b>, zapewniaj¹c¹ interfejs interakcji z licznikiem.. Widok zostanie dodany do tego GUI (ale kody obu klas bêd¹ odseparowane).<br>
<br>
W wersji drugiej – kiedy w³aœciwoœæ count bêdzie zwi¹zana i ograniczana musimy
dostarczyæ obiektu-nadzorcy, który bêdzie sprawdza³ czy zmiana w³aœciwoœci
jest dopuszczalna i jeœli stwierdzi, ¿e nie – bêdzie wetowa³ tê zmianê. Odpowiedni¹
klasê nazwiemy <b>CounterLimitator</b>.<br>
<br>
W metodzie main(...) klasy Main, w której nasza aplikacja zacznie ¿ycie stworzymy
wszystkie odpowiednie obiekty w/w klas i ustanowimy niezbêdne po³¹czenia
miêdzy nimi.<br>
<br>
W sumie logika dzia³ania aplikacji bêdzie wygl¹daæ tak:<br>
<br>
<br>
<img src="images/Counter1.jpg" alt="r" border="1" height="224" width="597">
<br>
<br>
Zaczynamy od wersji pierwszej, ubo¿szej, w której klasa Counter daje przyk³ad
typowego programowania JavaBean z wlaœciwoœci¹ zwi¹zan¹:<br>
<br>
<pre>// Klasa Counter

import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class Counter implements Serializable {

  private int count = 0;    // w³aœciwoœæ count

  // Pomocniczy obiekt do prowadzenia listy s³uchaczy zmian w³aœciwoœci oraz
  // propagowania zmian  wœród zarejestrowanych z³uchaczy
   private PropertyChangeSupport propertyChange = new PropertyChangeSupport(this);


  // Konstruktory

  public Counter() {
    this(0);
  }

  public Counter(int aCount) {
    setCount( aCount );
  }


  // Metody przy³¹czania i od³¹czania s³uchaczy zmian w³aœciwoœci

  public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
    propertyChange.addPropertyChangeListener(listener);
  }

  public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
    propertyChange.removePropertyChangeListener(l);
  }

  // Proste metody zwiêkszania i zmniejszania licznika

  public void increment() {
    setCount(getCount()+1);
  }

  public void decrement() {
    setCount(getCount()-1);
  }


  // Getter w³aœciwoœci "count"
  public int getCount() {
    return count;
  }

  // Setter w³aœciowœci "count"
  public synchronized void setCount(int aCount) {
    int oldValue = count;
    count = aCount;

    // wywo³anie metody firePropertChange z klasy PropertyChangeSupport
    // powoduje wygenerowanie zdarzenia PropertyChangeEvent i rozpropagowanie
    // go wœród wszystkich przy³¹czonych s³uchaczy, ale tylko wtedy, gdy nowa
    // wartoœæ w³aœciwoœci ró¿ni siê od starej wartoœci

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                            new Integer(aCount));
  }

}
</pre>
Widok licznika przedstawimy jako etykietê - klasa ta jednoczeœnie bêdzie
nas³uchiowaæ zmian w³aœciwoœci count i odpowiednio do tego zmieniaæ tekst
na etykiecie (a tak¿e wyprowadzaæ informacje o zmianach w³aœciwoœci count
na konsolê).<br>
<br>
<pre>//Klasa CounterView
//Widok licznika przedstawiamy w postaci etykiety

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;


public class CounterView extends JLabel implements PropertyChangeListener {


  // Konstruktor domyœlny: inicjalizuje etykietê tekstem "0"
  CounterView()  {
     this("0");
  }

  // Konstruktor inicjalizuj¹cy etykietê podanym tekstem
  CounterView(String lab) {
     super(lab);
     setOpaque(true);   // etykieta nie przezroczysta
       // ramka
     setBorder(BorderFactory.createLineBorder(Color.black));
       // rozmiary i wyrównanie tekstu
     setPreferredSize(new Dimension(75, 40));
     setHorizontalAlignment(CENTER);
  }

  // ob³uga zdarzenia PropertyChange
  public void propertyChange(PropertyChangeEvent e)  {
    Integer oldVal = (Integer) e.getOldValue(),
           newVal = (Integer) e.getNewValue();
    System.out.println("Value changed from " + oldVal + " to " + newVal);
    setText("" + newVal + "");  // pokazanie na etykiecie nowego stanu licznika
   }


}
</pre>
Klasa kontrolera - CounterControlGui dostarcza dwóch przycisków (zwiêksz,
zmniejsz licznik) oraz pole tekstowe, w którym mo¿na wpisaæ wartoœæ licznika
(ENTER)<br>
Zarówno klikniêcie w przyciski jak i ENTER na polu tekstowym powoduje powstanie
zdarzenia Action, które tu (w tej klasie) obs³ugujemy ustalaj¹c nowe&nbsp;wartoœci
licznika za pomoc¹ metod incremet() decrement() i setCount(...) z klasy &nbsp;Counter.
<br>
<br>
<pre>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class CounterControlGui extends JFrame implements ActionListener {

  Counter counter;
  JButton binc = new JButton("Increment");
  JButton bdec = new JButton("Decrement");
  JTextField txt = new JTextField(10);

  // Konstruktor otrzymuje jako argumenty obiekty typu Counter i CounterView
  // Pierwszy jest nam potrzebny do komunikacji z licznikiem, drugi - widok
  // wbudujemy w to GUI.

  CounterControlGui(Counter c, CounterView clab)  {
    counter = c;
    Container cp = getContentPane();
    cp.setLayout(new FlowLayout());
    binc.addActionListener(this);
    cp.add(binc);
    cp.add(clab);
    bdec.addActionListener(this);
    cp.add(bdec);
    txt.addActionListener(this);
    cp.add(txt);
    setDefaultCloseOperation(3);
    pack();
    show();
  }


  // Obs³uga akcji
  public void actionPerformed(ActionEvent e)  {
      if (e.getSource() == txt)  {
         int n = 0;
         try  {
            n = Integer.parseInt(txt.getText());
         } catch (NumberFormatException exc)  { return; }
         counter.setCount(n);
         return;
      }
      String cmd = e.getActionCommand();
      if (cmd.equals("Increment")) counter.increment();
      else if (cmd.equals("Decrement")) counter.decrement();
      else System.out.println("Unrecognized command");
  }

}
</pre>
I wreszcie lacz¹ca wszystko klasa Main, która inicjuje dzia³anie aplikacji.<br>
<br>
<pre>public class Main {

 public static void main(String[] args)  {

   // Tworzymy obiekty: licznik i jego widok
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());

   // Rejestrujemy widok jako s³uchacza zmian licznika
   counter.addPropertyChangeListener(counterView);

   // Tworzymu GUI kontrolera i pokazujemy go
   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
<br>
Diza³anie aplikacji ilustruje rysunek oraz komunikaty na konsoli, powsta³e
po kolejnych klilniêciach w przyciski Incremenet i Decrement oraz wprowadzeniu
liczby 23 w polu tekstowym i naciœnieciu ENTER.<br>
<br>
<img src="images/Counter1-v1.jpg" alt="r" border="1" height="75" width="407">
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to 1<br>
Value changed from 1 to 0<br>
Value changed from 0 to 23<br>
</div><br>
<br>
<b>Wersja 2</b><br>
<br>
W wersji drugiej chcemy dodaæ obiekt – nadzorcê, który bêdzie sprawdza³ czy
zmiana licznika jest dopuszczalna, a jeœli nie to bêdzie wetowa³ tê zmianê.<br>
Mechanizm wetowania polega na sygnalizowaniu wyj¹tku PropertyVetoException.<br>
Wyj¹tek ten bêdzie sygnalizowany przez obiekt-nadzorcê, który jest jednoczesnie
s³uchaczem zmian wartoœci w³aœciwoœci ograniczonych (VetoableChangeListener).
<br>
<br>
Klasa definiuj¹ca obiekty nadzoruj¹ce nasz licznik wygl¹da tak.<br>
<br>
<pre>import java.beans.*;

public class CounterLimitator implements VetoableChangeListener {

// minimalne i makszymalne dopuszczalne wartoœci licznika
private int min, max;

CounterLimitator(int minLim, int maxLim)  {
  min = minLim;
  max = maxLim;
}

// Obs³uga zdarzenia vetoableChange
// metoda mo¿e sygnalizowaæ PropertyVetoException
public void vetoableChange(PropertyChangeEvent e)
            throws PropertyVetoException {
   Integer newVal = (Integer) e.getNewValue();
   int val = newVal.intValue();
   // Sprawdzamy, czy zmiana  licznika jest dopuszczalna,
   // jeœli nie – sygnalizujemy wyjatek  PropertyVetoException
   if (val &lt; min || val &gt; max)
      throw new PropertyVetoException("Niedopuszczalna zmiana wartoœci", e);
   }

}

</pre>
W klasie Counter musimy poczyniæ zmiany, po to by w³aœciwoœæ count by³a zarazem zwi¹zana i ograniczana.<br>
Wykorzystamy podobn¹ do PropertyChangeSupport klasê pomocnicz¹ VetoableChangeSupport<br>
Obiekt tej klasy nazwiemy vetos, dostarczymy te¿ metod przy³¹czania i od³¹czania s³uchaczy zmian ograniczanych.<br>
<br>
<pre>public class Counter {

//...

private VetoableChangeSupport vetos = new VetoableChangeSupport(this);

public synchronized void addVetoableChangeListener(VetoableChangeListener l) {
	vetos.addVetoableChangeListener(l);
}

public synchronized void removeVetoableChangeListener(VetoableChangeListener l) {
	vetos.removeVetoableChangeListener(l);
}

// ...
}
</pre>
<br>
Zmianie ulegnie te¿ metoda setCount.<br>
<br>
<pre>public class Counter {

//...
public synchronized void setCount(int aCount)
                         throws PropertyVetoException {

     int oldValue = count;

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     // przez metodê wywo³uj¹c¹ setCount
     // (co zaznaczyliœmy w nag³ówku metody przez
     // throws PropertyVetoException)

    vetos.fireVetoableChange("count", new Integer(oldValue), new Integer(aCount));

    // tylko jeœli nikt nie zawetowa³

    count = aCount;  // ustalamy now¹ wartoœæ licznika

    // ... powiadamiamy nas³uchuj¹cych zmiany w³aœciwoœci count

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                       new Integer(aCount));
}

//...
}
</pre>
Poniewa¿ metody increment, decrement i konstruktory wywo³uj¹ metodê setCount,
to w sygnaturach tych metod i konstruktorów musimy dodaæ informacjê, ¿e wyj¹tek
PropertyVetoException ma byæ obs³ugiwany przez&nbsp; wo³aj¹cego te metody.<br>
<br>
A wo³amy je z GUI kontrolera.<br>
Tam jest miejsce do obs³ugi tego wyj¹tku:<br>
<pre>public class CounterControlGui .... {

....
public void actionPerformed(ActionEvent e)  {
  try  {
    if (e.getSource() == txt)  {
       int n = 0;
       try  {
          n = Integer.parseInt(txt.getText());
       } catch (NumberFormatException exc)  { return; }
       counter.setCount(n);
       return;
    }
    String cmd = e.getActionCommand();
    if (cmd.equals("Increment")) counter.increment();
    else if (cmd.equals("Decrement")) counter.decrement();
    else System.out.println("Unrecognized command");
  } catch (PropertyVetoException exc)  { // ob³uga wyjatku:
      System.out.println(""+ exc);       // podanie informacji
                                         //o niedopuszczalnej zmianie wartoœci
  }
}

//...
}
</pre>
W klasie Main dodajemy fragment dotycz¹cy tworzenia obiektu klasy CounterLimitator
(nadzorcy) i rejestrujemy go jako s³uchacza zmian w³aœciwoœci ograniczanej:<br>
<br>
<pre>import java.beans.*;
public class Main {

 public static void main(String[] args) throws PropertyVetoException {
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());
   counter.addPropertyChangeListener(counterView);

   // licznik mo¿e siê zmieniaæ od –5 do 10
   // bo Limitator zawetuje ka¿d¹ inn¹ zmianê
   CounterLimitator clim = new CounterLimitator(-5, 10);
   counter.addVetoableChangeListener(clim);

   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
Dzialanie programu &nbsp;(przy tym samym GUI kontrolera) zilustrujemy komunikatami
na konsoli po kolejneych klikniêciach w przycisk "Decrement".<br>
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to -1<br>
Value changed from -1 to -2<br>
Value changed from -2 to -3<br>
Value changed from -3 to -4<br>
Value changed from -4 to -5<br>
java.beans.PropertyVetoException: Niedopuszczalna zmiana wartoœci<br>
</div><br>
<br>
Jak widaæ, CounterLimitator nie dopuœci³ do zmiany wartoœci z -5 na -6.<br>
<br>
<br>
<br><a name="DynJav.10"></a><h2>2.5. Introspekcja</h2>
<br>
Srodowisko programistyczne, które ma umo¿liwiaæ dynamiczne odczytywanie w³asnoœci
i funkcjonalnoœci dowolnych "podrzucanych" mu ziaren analizuje ziarna za
pomoc¹ uniwerslanych metod introspekcji. <br>
<br>
Introspekcja kojarzy dwa mechanizmy: <br>
<ul><li>analizê komponentów za pomoc¹ metod refleksji przy za³o¿eniu, ¿e stosowane
s¹ pewne standardowe wzorce nazewnictwa, umo¿liwiaj¹ce okreœlenie&nbsp; w³asnœciwoœci
i ich typu, metod pobierania i ustalania tych w³aœciwoœci,&nbsp; rodzajóa zdarzeñ,&nbsp;
metod rejestracji s³uchaczy i nnych metod udostêpnianych przez dane ziarno
"na zewn¹trz" </li><li>okreœlanie uzewnêtrznianych w³aœciwoœci i funkcjonalnoœci ziarna na
podstawie dowolnie specyfikowanych przez twórcê ziarna elementów, zapisywanych
w odpowiedniej dla danego ziarna klasie BeanInfo. </li></ul>
Oba mechanizmy mog¹ byæ stosowane ³¹cznie. W prostych przypadkach (prostych
ziaren) nie ma potrzeby ¿mudnego tworzenia klasy BeanInfo, metody refleksji
s¹ ca³kiem wystarczaj¹ce. <br>
Introspekcja za pomoc¹ metod refleksji jest mo¿liwa dziêki kontraktowi dotycz¹cemu wzorców nazewnictwa. <br>
<br>
Dla w³aœciwoœci introspekcja okreœla pary metod <b>get... (is...)&nbsp; -&nbsp; set...</b>
 z tymi samymi nazwami w³aœciwoœci i z odpowiednimi sygnaturami. Mo¿e siê
okazaæ, ¿e niektóre w³aœciwoœci s¹ tylko do odczytu lub tylko do zapisu.
Uwzglêdnia siê te¿ indeksowane w³asciwoœci. <br>
<br>
Dla&nbsp; okreœlenia, czy istniej¹ mo¿liwoœæ obs³ugi zdarzeñ i jakich u¿ywane s¹ wzorce: <b>addXXXListener i removeXXXListener. </b><br>
<br>
Sam¹ introspekcje realizuje klasa <b>Introspector</b>. <br>
<br>
Introspector analizuje klasê-zarna (i nadrzêdne wobec niej klasy oraz implementowane
interfejsy) zbieraj¹c informacje o w³aœciowoœciach, metodach, zdarzeniach.
<br>
Informacja ta jest umieszczana w obiekcie typu <b>BeanInfo</b> (BeanInfo jest nazw¹ interfejsu). Wobec tego obiektu mo¿emy nastêpnie zastosowaæ metody zwracaj¹ce iinformacje o ziarnie. <br>
<br>
Np. analizê klasy-ziarna javax.swing.JButton uzyskujemy przez nastêpuj¹ce odwo³anie: <br>
<br>
<b>BeanInfo info = Introspector.getBeanInfo(Class.forName("javax.swing.JButton")); </b><br>
lub<br>
<b>BeanInfo info = Introspector.getBeanInfo(javax.swing.JButton.class)); </b><br>
<br>
<br>
Nastêpnie wobec obiektu info mo¿emu zastosowaæ metody interfejsu BeanInfo: <br>
<br>
<ul><li><b>EventSetDescriptor[]&nbsp; getEventSetDescriptors()&nbsp; - </b>zwraca tablicê deskryptorów zdarzeñ<b> </b></li><li><b>PropertyDescriptor[]&nbsp; getPropertyDescriptors()&nbsp; - </b>zwraca tablicê deskryptorów w³asnoœci<b> </b></li><li><b>MethodDescriptor[]&nbsp;&nbsp; getMethodDescriptors()&nbsp;&nbsp;&nbsp;&nbsp; - </b>zwraca tablicê deskryptorów metod</li><li>dla ka¿dgo deskryptora metody <b>ParameterDescriptor[] getParameterDexriptors()</b> - zwraca tablicê deskryptorów parametrów tej metody<br>
  </li></ul>
Zwracane tablice s¹ tablicami obiektów odpowiednich klas. Wobec tych obiektów
stosujemy metody tych klas pozwalaj¹ce na uzyskiwanie ró¿nej konkretnej informacji.
<br>
Np. program na poini¿szym wydruku analizuje klasê podan¹ jako argument i wypisuje niektóre informacje o niej: <br>
<br>
<pre>import java.lang.reflect.*;
import java.beans.*;

public class BeanAnalyze {

  static void say(String s) { System.out.println(s); }

  public static void main(String[] arg) throws Exception {

    BeanInfo beanInfo = Introspector.getBeanInfo(Class.forName(arg[0]));

    PropertyDescriptor[] pd = beanInfo.getPropertyDescriptors();
    MethodDescriptor[] md = beanInfo.getMethodDescriptors();
    EventSetDescriptor[] evd = beanInfo.getEventSetDescriptors();

    say("W³aœciwoœci:");
    for (int i = 0; i &lt; pd.length; i++) {
      say(pd[i].getShortDescription());
      // getReadMethod i getWriteMethod zwracaj¹ obiekty typu Method
      say(" getter: "+ pd[i].getReadMethod());
      say(" setter: "+ pd[i].getWriteMethod());
    }

    say("\nMetody:");
    for (int i=0; i&lt;md.length; i++) {
      say(" " + md[i].getMethod());
    }

    say("\nZdarzenia:");
    for (int i = 0; i &lt; evd.length; i++) {
      say("Zdarzenie : " + evd[i].getShortDescription());
      Method[] met = evd[i].getListenerMethods();
      say("Metody obs³ugi:");
      for (int j=0; j &lt; met.length; j++)  say(" " + met[j]);
    }
  }

}
</pre>
<br>
Fragmenty (du¿ego!) wydruku z programu uruchomionego z argumentem javax.swing.JButton:<br>
<br>
<div class="listingful"><br>
W³aœciwoœci:<br>
UI<br>
&nbsp;getter: public javax.swing.plaf.ButtonUI javax.swing.AbstractButton.getUI()<br>
&nbsp;setter: public void javax.swing.AbstractButton.setUI(javax.swing.plaf.ButtonUI)<br>
UIClassID<br>
&nbsp;getter: public java.lang.String javax.swing.JButton.getUIClassID()<br>
&nbsp;setter: null<br>
accessibleContext<br>
&nbsp;getter: public javax.accessibility.AccessibleContext javax.swing.JButton.getAccessibleContext()<br>
&nbsp;setter: null<br>
action<br>
&nbsp;getter: public javax.swing.Action javax.swing.AbstractButton.getAction()<br>
&nbsp;setter: public void javax.swing.AbstractButton.setAction(javax.swing.Action)<br>
actionCommand<br>
&nbsp;getter: public java.lang.String javax.swing.AbstractButton.getActionCommand()<br>
&nbsp;setter: public void javax.swing.AbstractButton.setActionCommand(java.lang.String)<br>
actionListeners<br>
&nbsp;getter: public java.awt.event.ActionListener[] javax.swing.AbstractButton.getActionListeners()<br>
&nbsp;setter: null<br>
actionMap<br>
&nbsp;getter: public final javax.swing.ActionMap javax.swing.JComponent.getActionMap()<br>
&nbsp;setter: public final void javax.swing.JComponent.setActionMap(javax.swing.ActionMap)<br>
...<br>
<br>
Metody:<br>
&nbsp;public boolean java.awt.Component.action(java.awt.Event,java.lang.Object)<br>
&nbsp;public synchronized void java.awt.Component.add(java.awt.PopupMenu)<br>
&nbsp;public java.awt.Component java.awt.Container.add(java.awt.Component)<br>
&nbsp;public java.awt.Component java.awt.Container.add(java.awt.Component,int)<br>
&nbsp;public void java.awt.Container.add(java.awt.Component,java.lang.Object)<br>
&nbsp;public void java.awt.Container.add(java.awt.Component,java.lang.Object,int)<br>
&nbsp;public java.awt.Component java.awt.Container.add(java.lang.String,java.awt.Component)<br>
&nbsp;public void javax.swing.AbstractButton.addActionListener(java.awt.event.ActionListener)<br>
...<br>
<br>
Zdarzenia:<br>
Zdarzenie : action<br>
Metody obs³ugi:<br>
&nbsp;public abstract void java.awt.event.ActionListener.actionPerformed(java.awt.event.ActionEvent)<br>
Zdarzenie : ancestor<br>
Metody obs³ugi:<br>
&nbsp;public abstract void javax.swing.event.AncestorListener.ancestorMoved(javax.swing.event.AncestorEvent)<br>
&nbsp;public abstract void javax.swing.event.AncestorListener.ancestorAdded(javax.swing.event.AncestorEvent)<br>
&nbsp;public abstract void javax.swing.event.AncestorListener.ancestorRemoved(javax.swing.event.AncestorEvent)<br>
Zdarzenie : change<br>
Metody obs³ugi:<br>
&nbsp;public abstract void javax.swing.event.ChangeListener.stateChanged(javax.swing.event.ChangeEvent)<br>
...<br>
</div><br>
<br>
Szczerze mowi¹c, za pomoc¹ metod instrospekcji sporo mo¿na siê dowiedziec o dostêpnych w³aœciwoœciach i metodach danej klasy.<br>
<br>
Oczywiœcie, maj¹c obiekty-metody (uzyskane z deskryptorów metod) mozemy je
dynamicznie wyow³ywac œrodkami refleksji. Ale istnieje te¿ nieco prostsza,
specjalnie dla JavaBean przygotowana mo¿liwoœæ dynamicznego pobierania i
ustalania wlaœciwoœci oraz wo³ania innych metod.<br>
<br>
<br><a name="DynJav.11"></a><h2>2.6. Dynamiczne pobieranie i ustalanie w³aœciwoœci</h2>
W pakiecie java.beans znajdziemy dwie ciekawe klasy&nbsp; Statement i Expression<br>
<br>
<div class="syntax">Obiekt klasy Statement tworzymy za pomoc¹ konstuktora:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; Statement s = &nbsp;Statement( Object target, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;String methodName, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;Object[] arguments );<br>
</b><br>
a wywo³anie na jego rzecz metody <b>void execute()</b> spowoduje wywo³anie na rzecz obiektu target metody o nazwie methodName z argumentami podanymi w tablicy arguments<br>
<br>
Zwykle stosujemy tê procedure do ustalania w³aœciowoœci JavaBean, ale mo¿e
ona byæ rownie¿ stosowana do wyo³ania dowolnych metod</div><br>
<br>
Klasa Expression dziedziczy klasê Statement. Czyli tu te¿ mo¿emy wo³aæ metodê
execute(). Jednak jej g³ówne zastosowanie polega na dynamicznym pobieraniu
w³aœciwoœci, lub - inaczej - dynamicznym wo³aniu metod, które zwracaj¹ wyniki
i uzyskiwaniu dostêpu do tych wyników. <br>
<br>
<div class="syntax">Obiekt klasy Expression tworzymy za pomoc¹ konstuktora:<br>
<br>
<b>
&nbsp;&nbsp;&nbsp; Expression e = &nbsp;Expression( Object target,<br>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; String methodName, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; Object[] arguments );<br>
</b><br>
<ul><li>
wywo³anie na jego rzecz metody <b>void execute()</b> spowoduje wywo³anie
na rzecz obiektu target metody o nazwie methodName z argumentami podanymi
w tablicy arguments oraz przechowanie wyniku wywo³anej metody w obiekcie
Expresion; wynik ten bêdzie dostêpny przez wywolanie metody Object getValue()
na rzecz obeiktu Expressiom</li><li>samo wywo³anie metody <b>Object getValue()</b> spowoduje ten sam efekt o ile wynik dla danego obiektu-wyra¿enia nie zosta³ jeszcze ustalony.</li></ul>
</div><br>
<br>
Szczegó³owo komentowany program ilustruje zastosowanie tych klas.<br>
W poni¿szym przyk³adzie metody klas Statement i Expression bedziemy stosowac
wobec obiektów klasy JButton oraz naszej w³asnej klasy TestBean, która wygl¹da
tak:<br>
<pre>public class TestBean {

  private String[] headers;
  private int count;


  public TestBean() {
  }

  public TestBean(int n) {
    count = n;
  }

  public String[] getHeaders() {
    return headers;
  }

  public void setHeaders(String[] value) {
    headers = value;
  }

  public int getCount() {
    return count;
  }

  public void setCount(int value) {
    count = value;
  }

}
</pre>
<br>
Szczegó³owo komentowany program ilustruje zastosowanie klas Statement i Expression,
daj¹c te¿ pewne dodatkowe na ich temat informacje.<br>
<pre>import java.beans.*;
import java.awt.*;
import javax.swing.*;

public class DynamicExec {

  public static void main(String[] args) throws Exception {

    Statement stmt;
    Expression expr;

    JButton b = new JButton();

    // Na rzecz przycisku wo³amy dynamicznie metodê setText
    // z argumentem "Przycisk"
    stmt = new Statement(b, "setText", new Object[] { "Przycisk" });
    stmt.execute();

    // Jaki wynik? Najpierw statyczne odwo³anie
    System.out.println("Tekst na przycisku 1: " + b.getText());

    // Teraz dynamicznie: stwórzmy wyra¿enie, którego wynikiem
    // jest wynik podanej metody z podanymi argumentami wywolanej
    // na rzecz b
    // Uwaga: brak argumentów - czyli tablica Object o rozmiarze 0
    expr = new Expression(b, "getText", new Object[0]);

    // Je¿eli wyra¿enie expr nie ma jeszcze wyniku
    // metoda getValue() wywo³uje podan¹ w wyra¿eniu metodê
    // i zwraca jej wynik; w przeciwnym razie zwraca
    // ustalony wczesniej wynik

    String txt = (String) expr.getValue();
    System.out.println("Tekst na przycisku 2: " + txt);

    // Mo¿emy te¿ stosowaæ klasy Statement i Expression
    // wobec naszych w³asnych klas JavaBeans

    TestBean tbean = new TestBean();

    // Uwaga: przy przekazywaniu argumentów i zwrocie wynikow
    // nastêpuj¹ automatyczne przeksztalcenia pomiedzy
    // typami prostymi i odpowiadaj¹cymi im klasami opakowuj¹cymi
    // np. int - Integer  - setCount wymaga argumentu int,
    // my podajemy Integer

    stmt = new Statement(tbean, "setCount",
                               new Object[] { new Integer(22) });
    stmt.execute();

    // Jaka jest teraz wartoœæ w³aœciwoœci count
    // I znowu: getCount() zwraca int, my odbieramy Integer

    expr = new Expression( tbean, "getCount", new Object[0] );
    Integer val = (Integer) expr.getValue();

    System.out.println("Wartoœæ count: " + val);

    // Czy mo¿emy dzia³aæ na tabliach? Ale¿ tak!

    stmt = new Statement(tbean, "setHeaders",
                         new Object[] { new String[] { "a", "b" } }
                        );
    stmt.execute();

    expr = new Expression(tbean, "getHeaders", new Object[0]);
    String[] hdr = (String[]) expr.getValue();

    System.out.println("Ustalone nag³ówki");
    for (int i=0; i&lt;hdr.length; i++)
       System.out.println(hdr[i]);

    // Mo¿emy nawet stworzyæ nowy obiekt
    // u¿ywaj¹c specjalnej nazwy metody - new  (oczywiœcie)

    expr = new Expression(TestBean.class, "new",
                          new Object[] { new Integer(111) }
                         );
    TestBean tb2 = (TestBean) expr.getValue();

    expr = new Expression (tb2, "getCount", new Object[0]);
    val = (Integer) expr.getValue();

    System.out.println("W nowym obiecie count = " + val);

  }
}

</pre>
<br>
<br>
<br><a name="DynJav.12"></a><h2>2.7. Serializacja JavaBeans</h2>
Oprócz zapisywania do strumieni obiektowych (ObjectOutputStream), obiekty
JavaBeans mo¿na serializowac w postaci tekstowej, w formacie XML (wersja
1.0, kodowanie UTF-8). Jest to nawet - w przypadku JavaBeans - bardziej "przenoœny"
sposób utrwalania obiektów.<br>
Zapisywaniem obiektów zajmuje siê klasa XMLEncoder, a ich odtwarzaniem -
klasa XMLDccoder. Przy tym &nbsp;stan obiektu zapisywany jest w postaci &nbsp;zdatnej
do wykorzystania przez klasy Statement i Expression przy odtwarzaniu tego
obiektu<br>
<br>
Najprostsze (przeznaczone wy³¹cznie dla JavaBeans) zastosowanie tych klas pokazuje poni¿szy program.<br>
<pre>import java.beans.*;
import java.awt.*;
import javax.swing.*;
import java.io.*;

public class SerialBean {

  String fname = "test.xml";

  public SerialBean() {
    JButton b = new JButton("K¹œliwie wróbel æwierka³");
    b.setBackground(Color.red);
    b.setForeground(Color.yellow);

    try {
      XMLEncoder enc = new XMLEncoder(
                         new BufferedOutputStream(
                            new FileOutputStream(fname)
                            )
                      );
      enc.writeObject(b);
      enc.close();
    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    nowReadAndReport();
  }

  private void nowReadAndReport() {
    try {
      XMLDecoder dec = new XMLDecoder(
                          new BufferedInputStream(
                              new FileInputStream(fname)));
      Object obj = dec.readObject();
      JButton b = (JButton) obj;
      dec.close();
      System.out.println("Napis na przycisku: " + b.getText());
      System.out.println("Kolor t³a: " + b.getBackground());
      System.out.println("Kolor tekstu : " + b.getForeground());

    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }



  public static void main(String[] args) {
    SerialBean serialbean = new SerialBean();
  }


}
</pre>
Wyprowadzi on na konsolê w³aœciw¹&nbsp; informacjê o stanie zapisanego a póŸniej odtworzonego obiektu:<br>
<div class="listing100"><br>
Napis na przycisku: K¹œliwie wróbel æwierka³<br>
Kolor t³a: java.awt.Color[r=255,g=0,b=0]<br>
Kolor tekstu : java.awt.Color[r=255,g=255,b=0]<br>
</div><br>
<br>
Z ciekawoœci mo¿na zajrzeæ do pliku test.xml.<br>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.4.1-rc" class="java.beans.XMLDecoder"&gt;
 &lt;object class="javax.swing.JButton"&gt;
  &lt;string&gt;KÄÅ&gt;liwie wrÃ³bel Ä+wierkaÅ'&lt;/string&gt;
  &lt;void property="background"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;void property="foreground"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
 &lt;/object&gt;
&lt;/java&gt;

</pre>
Faktycznie, jest do dok³adny szablon gotowy do zastosowania klas Expression
(dla metody-kostsruktora new z argumentem String) i Statement (dla setBackground
i setForeground). Wszystko opiera siê na zachowaniu protoko³u JavaBeans.<br>
<br>
Oczywiœcie, mo¿emy w ten sposób serializowaæ obiekty prawie wszystkich klas
Javy (bo prawie wszystkie s¹ JavaBeans) oraz&nbsp; w³asnych klas, spe³niaj¹cych
protokó³ JavaBeans.<br> A nawet mo¿na uwzglêdniæ pewne odstêpstwa od tego
protoko³u (np. inicjacjê w³aœciwoœci JavaBeans w konstruktorz, bez u¿ycia
setterów) poprzez dostosowanie delegata "persystencji", do którego odwo³uje
siê XMLEncoder - klasy <b>DefaultPersistanceDelegate</b>. <br>O takim bardziej zaawansowanym zastosowaniu, jak równie¿ o u¿yciu nas³uchu wyj¹tków dekodowania za pomoc¹ interfejsu <b>ExceptionListener</b> mo¿na przeczytaæ w dokumentacji API Javy.<br>
<br>
<br>
<br><a name="DynJav.13"></a><h2>2.8. Inne zagadnienia zwi¹zane z JavaBeans</h2>
<br>
To skrótowe wprowadzenie do JavaBeans nie wyczerpuje tematu.<br>
Warto wiêc na koniec zwróciæ uwagê na nieporuszone tu wa¿ne kwestie<br>
<ul><li>przystosowanie ziaren: klasy-edytory w³aœciwoœci u¿ywane m.in. w œrodowiskach wizualnych </li><li>tworzenie klas BeanInfo, opisuj¹cych informacje niedostêpn¹ metodami refleksji, </li><li>koteksty (BeanContext) - swoiste kontenery, dostarczaj¹ce generalnych mechanizmów i serwisów dla JavaBeans.</li></ul>

Informacje na te tematy mo¿na zanaleŸæ w dokumentacji.<br>
&nbsp;<br>
<hr>
<a name="DynJav.14"></a><h2>3. Metadane i adnotacje</h2>
<br><a name="DynJav.15"></a><h2>3.1.&nbsp;Wprowadzenie</h2>




<br>




<div class="def"><b><!---->Metadane</b> to dane opisuj¹ce dane. W przypadku programowania chodzi
o takie metadane, które opisuj¹ i uzupe³niaj¹ kod Ÿród³owy w znaczeniu semantycznym<!----></div><br>




<br>




Coraz czêœciej metadane s¹ obecne w jêzykach programowania.<br>




W Javie czêœciowo wystêpowa³y ju¿ wczeœniej - w samym œrodowisku (dokumentacyjne np. @author),
a czêœciowo jako zewnêtrzne uzupe³nienia (np. XDoclet, JBoss AOP).<br>




W C# nazywaj¹ siê (nieco nieszczêœliwie) atrybutami.<br>




<br>




Java 5 rozszerza i standaryzuje zastosowanie metadanych na platformie Javy poprzez <b>mechanizm <!----><a name="ind.3.2"></a>adnotacji</b><!---->.<br>




<br>




<b>Zastosowania</b> (bardzo ró¿norodne), m.in.
<ul><li>do celów poprawy niezawodnoœci programowania (np. @override),</li><li>do generacji dodatkowych kodów programu (uzupe³niaj¹cych klas),</li><li>do okreœlania sposobu funkcjonowaniu programu w fazie wykonania (mo¿na krótko zapisaæ ró¿ne rzeczy). </li><li>do celów konfiguracyjnych,</li><li>do generowania pomocniczych plików (np. ró¿nych deskryptorów itp.)</li></ul>




<div class="important">Mechanizm adnotacji jest najwa¿niejszym praktycznie uzupe³nieniem Javy
w wersji 5, choæby dlatego, ¿e ju¿ teraz kolejne wersje du¿ych platform,
takich jak J2EE, a tak¿e pakiety narzêdziowe , takie jak JDBC 4.0, intensywnie u¿ywaj¹
adnotacji.<br>




</div><br>




<br>




<b>Zalety adnotacji</b>:
<ul><li>zastosowanie adnotacji mo¿e znacznie u³atwiæ pisanie i wdra¿anie aplikacji,
szczególnie du¿ych; kody mog¹ byæ wielokrotnie mniejsze, pracoch³onnoœæ znacz¹co
ograniczona itp.</li></ul>




<br>




<b>Wady</b>:
<ul><li>pojawiaj¹ siê jakby nowe elementy sk³adniowo-semantyczne; poniewa¿
ka¿dy mo¿e definiowaæ w³asne adnotacje, to istnieje niebezpieczeñstwo, ¿e
pojawi siê mnóstwo "dialektów" Javy - czyli standard Javy + wymyœlne, niestandardowe
adnotacje,</li><li>adnotacje pozwalaj¹ upraszczaæ wiele rzeczy, zapisywaæ niejako symbolicznie
jednym s³owem, to co bez nich wymaga³o byæ mo¿e dziesi¹tek linii kodu; ale
tych zapisów (notacji i ich znaczeñ) trzeba siê te¿ uczyæ (dla ró¿nych œrodowisk
za ka¿dym razem od nowa) i mieæ œwiadomoœæ, do czego tego tak naprawdê te
skróty prowadz¹ (co robi¹),</li><li>na razie nie ma dobrej koncepcji sprawdzania b³êdowi na poziomie metadanych.</li></ul><br><br><br><a name="DynJav.16"></a><h2>3.2 <!---->Rodzaje adnotacji<!----></h2>




<span style="font-weight: normal;">Mo¿na wyró¿niæ nastêpuj¹ce rodzaje adnotacji:</span><br>




<ul><li><b>adnotacje wbudowane w Javê</b></li><ul><li>regularne</li><li>metaadnotacje</li></ul></ul>




<ul><li><b>adnotacje u¿ytkownika</b> (tworzone przez u¿ytkownika)</li><ul><li>stosowane na etapie kompilacji (przetwarzane przez narzêdzia)</li><li>stosowane w fazie wykonania (za pomoc¹ mechanizmów refleksji)</li></ul></ul>




<br>




<u>Adnotacje mog¹ byœ stosowane wobec</u>:<br>


<ul><li>

pakietów</li><li>

klas</li><li>

interfejsów</li><li>

pól</li><li>

konstruktorowi</li><li>

metod</li><li>

zmiennych lokalnych</li><li>

innych adnotacji</li></ul>




<br>




Mo¿na wyraŸnie zaznaczyæ do czego odnosi siê nowodefiniowana adnotacja za pomoc¹ metaadnotacji <b>@Target </b>(wtedy inne jej zastosowanie bêdzie wykryte jako b³¹d w fazie kompilacji).<b><br>




<br>


</b><div class="notec"><b>Mo¿liwe znaczenia (wartoœci) metaadnotacji @Target</b><br>




<br>




ANNOTATION_TYPE - dana adnotacja adnotuje inn¹,<br>




PACKAGE - dotyczy pakietu,<br>




TYPE - klas i interfejsów<br>




METHOD - metod<br>




CONSTRUCTOR - konstruktorów<br>




FIELD - pól<br>




PARAMETER - parametrów<br>




LOCAL_VARIABLE - zmiennych lokalnych<br>


</div><br>




<br>




Przyk³ad (fragment) definicji adnotacji o nazwie Test, która mo¿e dotyczyæ tylko metod:<br>




<br>




@Target(ElementType.METHOD)<br>




public @interface Test <br>




<br>




Uwagi: <br>




<ol><li>adnotacja nie oznaczona znacznikiem @Target ma zastosowanie wszêdzie.</li><li>aby okreœliæ kilka mo¿liwych zastosowañ piszemy @Target({ a, b, c }
), gdzie a, b, c to elementy w postaci <span style="font-weight: bold; font-style: italic;">ElementType.rodzaj,</span> a rodzaj to jeden
z PACKAGE, METHOD, FIELD itp.</li></ol>




<br>




Si³a adnotacji polega na tym, ¿e mog¹ one byæ przetwarzane: <br>


<ul><li>

przez narzêdzia do generacji (i ew. równoczesnej kompilacji) kodu (wtedy potrzebne s¹ tylko w fazie kompilacji), </li><li>

albo przez mechanizmy refleksji &nbsp;- wtedy powinny byæ zapisane w klasie wykonywalnej
i dostêpne dla tych mechanizmów w fazie wykonania programu,</li><li>

albo przez narzêdzia przetwarzania "binarnej" postaci klas (umo¿liwiaj¹ce
m.in. ró¿ne iniekcje, zmiany, usuwanie kodu binarnego) - wtedy powinny byæ
zapisane w klasie, ale nie musz¹ byæ dostêpne dla mechanizmów refleksji.</li></ul>




<br><!----><!---->




Odpowiadaj¹ temu trzy polityki utrzymywania adnotacji, specyfikowane przez metaadnotacjê @<b>Retention</b>.<br>


<br>


<div class="notec"><br>


<div style="text-align: center;">Polityki utrzymywania adnotacji<br>


</div>




<br>




RetentionPolicy.SOURCE - tylko w ¿ródle,<br>




RetentionPolicy.CLASS - w klasie skompilowanej, ale niedostêpne w fazie wykonania,<br>




RetentionPolicy.RUNTIME - dostêpne w fazie wykonania.<br>


</div><br>




<br>




Przyk³ad:<br>




@Retention(RetentionPolicy.SOURCE) &nbsp; // utrzymanie tylko w kodzie adnotacji AdapterFor<br>



public interface @AdapterFor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; // zostanie przetworzona przez narzêdzia w fazie<br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // kompilacji<br>




<br>




Wœrod metaadnotacji dostêpne s¹ jeszcze:<br>




<br>




<b>@Documented</b> &nbsp;- mowi o tym, ¿e dokumentacja dzia³ania
adnotacji ma byæ w³¹czona do dokumentacji wszystkich oznaczanych przez
ni¹ elementów<br>




<br>




<b>@Inherited</b> - mówi o tym, ¿e oznaczana przez ni¹ adnotacja
(zaznaczaj¹ca klasy) ma byæ dziedziczona przez podklasy zaznaczonych
klas.<br>




<br>




<br>




Zestaw regularnych, wbudowanych w Javê adnotacji jest na razie bardzo niewielki i obejmuje:<br>




<br>




@Deprecated - zaznacza dowolny element jako spadkowy ("przestarza³y"),<br>




<br>




@SupressWarnings - blokuje ostrze¿enia (podanego typu) ze strony kompilatora,<br>




<br>




@Override - stosowana &nbsp;wobec metod, oznacza intencjê programisty przedefiniowania
metody z nadklasy, dziêki czemu jest mo¿liwoœæ sprawdzenia w fazie kompilacji
czy programista nie pope³ni³ b³êdu,<br>




<br>




Ta ostatnia adnotacja jest b. u¿yteczna i nale¿y j¹ stosowaæ.<br>




Dziêki temu unikniemy b³êdów niewykrywalnych nie tylko w fazie kompilacji, ale równie¿ czasem w fazie wykonania.<br>




<br>




Np.<br>




<br>




class Push extends JButton {<br>




<br>




&nbsp;&nbsp;&nbsp; public Dimension getPrefferedSize() { ... }<br>




<br>




}<br>




<br>




Tutaj nast¹pi³a pomy³ka w nazwie metody - wobec czego pojawia siê nowa metoda
(nigdy nie wo³ana), a w³aœciwa (getPreferredSize()) nie jest przedefiniowana.
B³êdu nie ma &nbsp;ani w kompilacji ani w fazie wykonania (oprócz - byæ mo¿e
nie zawsze, nie od razu, nie w ka¿dych okolicznoœciach - widocznych niew³aœciwych
rozmiarów przycisku).<br>




<br>




Gdy napiszemy:<br>




<br>




class Push extends JButton {<br>




<br>





&nbsp; @Override&nbsp; public Dimension getPrefferedSize() { ... }<br>




<br>





}&nbsp;<br>




<br>




to kompilator wykryje b³¹d i powiadomi nas o tym.<br>




<br>




<br>




<div class="syntax">Jak widaæ, sk³adnia zastosowania adnotacji jest bardzo prosta.<br>




Adnotacje zaczynaj¹ sie znakiem @.<br>




Adnotacje poprzedzaj¹ inne kwalifikatory elementów (klas, metod, pól).<br>




</div><br><a name="DynJav.17"></a><h2>3.3. <!---->Definiowanie adnotacji<!----></h2>




Adnotacje s¹ definiowane jako swego rodzaju interfejsy, za pomoc¹ s³owa @<b>interface</b><br>




Wewn¹trz takiego interfejsu dostarcza siê deklaracji danych, które adnotacja mo¿e zawieraæ.<br>




<br>




<div class="syntax"><br>




[ew. kwalifikacja dostêpu]&nbsp; @<b>interface</b> NazwaAdnotacji {<br>




&nbsp; &nbsp; deklaracja1<br>




&nbsp; &nbsp; deklaracja2<br>




&nbsp; &nbsp; &nbsp;. . .<br>


&nbsp;&nbsp; &nbsp;deklaracjaN<br>




}<br>


</div><br>




<br>




Ka¿da deklaracja ma postaæ:<br>




<br>


<div class="syntax"> &nbsp;typ nazwaDanej();</div><br>




<br>




albo <br>




<br>


<div class="syntax">typ nazwaDanej() <b>default</b> wartoœæ_domyœlna;</div><br>




<br>




<br>




Przy zastosowaniu adnotacji mo¿emy podaæ konkretne dane:<br>




<br>




@NazwaAdnotacji(nazwaDanej1=wartoœæ1, nazwaDanej2=wartoœæ2, . . .)<br>




<br>




Typy danych w adnotacji mog¹ byæ nastêpuj¹ce:<br>




<br><ul><li>




typy proste (int, short, long, byte, char, double, float, boolean),</li><li>




String,</li><li>




typ referencyjny, reprezentowany przez Class, w tym tak¿e w wersji sparametryzowanej,</li><li>




enum.</li><li>




adnotacja,</li><li>




tablica (w/w elementów).</li></ul>




<br>




Przyk³ad:<br>


<pre>public @interface Opis {
&nbsp; &nbsp; String text() default "Brak opisu";
&nbsp; &nbsp; int version() default 1;
}


// i zastosowanie np. do opisu klasy:

@Opis(text="Klasa warzyw", version=2)
public class Warzywa { ... }



</pre>




<br>


Mo¿na te¿ tak:<br>




<br>




@Opis(version=5, text="Klasa warzyw")<br>




<br>


albo:<br>




<br>




@Opis(text="Klasa warzyw")<br>




<br>


tu pominiête dane przyjm¹ wartoœci domyœlne,<br>




w szczególnoœci:<br>




<br>


<div class="notec"><br>


@Opis <br>




oznacza to samo co<br>




<br>




@Opis()<br>




i co<br>




<br>




@Opis(text="Brak opisu", version=1)<br>




</div><br>




<br>


Mamy te¿ szczególny przypadek, kiedy mo¿na pomin¹æ nazwê danych i znak =. Mianowicie:<br>




<br>




public @interface JakaœAdnotacja {<br>




&nbsp; &nbsp;jakiœTyp value()<br>




}<br>




<br>




<br>




Wtedy mo¿na pisaæ np. tak (jeœli jakiœTyp to int):<br>




<br>




@JakaœAdnotacja(111)<br>




<br>




nadaj¹c danej oznaczanej przez value wartoœæ 111.<br>




<br>




<br>




Dane konkretnych adnotacji mog¹ byæ uzyskiwane od nich (w fazie wykonania
lub kompilacji) poprzez odwo³ania do "metod" interfejsu definiuj¹cego adnotacjê
<br>




(np. jeœli annot - jest uzyskan¹ metodami refleksji lub przez narzêdzia przetwarzania
w fazie kompilacji adnotacj¹ @Opis, to mo¿emy wo³aæ:<br>




<br>




String op = annot.txt();<br>




int v = annot.version();<br><br><a name="DynJav.18"></a><h2>3.4. <!---->Przetwarzanie adnotacji w fazie wykonania<!----></h2>




Aby przetwarzaæ - i odpowiednio stosowaæ - adnotacje w fazie wykonania, nale¿y:<br>




<br>




<ul><li>ustaliæ rodzaj adnotacji przez @Retention(RetentionPolicy.RUNTIME),</li><li>u¿yæ metod refleksji do uzyskania informacji które elementy i za pomoc¹ jakich adnotacji s¹ zaznaczane,</li><li>od uzyskanych adnotacji dowiedzieæ siê ew. dodatkowych informacji,
zapisanych w nich jako dane; po czym na podstawie adnotacji i tych danych
dynamicznie wytworzyæ i wykonaæ odpowiedni kod.</li></ul>




Dla ka¿dego elementu programu (uzyskanego dynamicznie): Class, Method, Field
itp. mo¿emy u¿yæ metod, które zwracaj¹ informacjê o adnotacjach zastosowanych
wobec tego elementu.<br>




<br>




<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">




  <tbody>



    <tr class="TableRowColor" bgcolor="white">



      <td align="right" valign="top" width="1%">




      <table summary="" border="0" cellpadding="0" cellspacing="0">




        <tbody>



          <tr align="right" valign="">



            <td nowrap="nowrap">&lt;T extends Annotation&gt;
            <br>





T</td>



          </tr>






        </tbody>




      </table>




      </td>



      <td>getAnnotation(Class&lt;T&gt;&nbsp;annotationType)<br>



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca adnotacjê
podanego typu, albu null, jeœli element nie jest oznaczony adnotacj¹.</td>



    </tr>



    <tr class="TableRowColor" bgcolor="white">



      <td align="right" valign="top" width="1%">&nbsp;Annotation[]</td>



      <td>getAnnotations()<br>




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca wszystkie adnotacje dla tego elementu</td>



    </tr>



    <tr class="TableRowColor" bgcolor="white">



      <td align="right" valign="top" width="1%">&nbsp;Annotation[]</td>



      <td>getDeclaredAnnotations()<br>



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca wszystkie
adnotacje bezpoœrednio zastosowane (z pominieciem dziedziczonych)</td>



    </tr>



    <tr class="TableRowColor" bgcolor="white">



      <td align="right" valign="top" width="1%">&nbsp;boolean</td>



      <td>isAnnotationPresent(Class&lt;? extends Annotation&gt;&nbsp;annotationType)<br>




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca true, jeœli wobec elementu zastosowano adnotacjê podanego typu.</td>



    </tr>






  </tbody>
</table>




<br>




Co to jest typ adnotacji?<br>




Nic innego jak nazwa interfejsu który j¹ definiuje. Np. dla adnotacji, zdefiniowanej jako:<br>




<br>




public @interface Opis { ... }<br>




<br>




typem jest:<br>




<br>




Opis.class<br>




albo<br>




Class.forName("Opis");<br>




<br>




Uwagi: <br>




<ul><li>przy zastosowaniu nazwanych pakietów nazwy interfejsów adnotacji musz¹ byæ kwalifikowane nazw¹ pakietu,</li><li>wszystkie adnotacje (jako interfejsy) rozszerzaj¹ interfejs Annotation,
wobec czego mog¹ byæ traktowane jako Annotation i dlatego takie s¹ wyniki
w/w metod; zwróæmy uwagê, ¿e dziêki parametryzacji nie musimy stosowaæ konwersji
zawê¿aj¹cych.</li></ul>




<br>




<b>Przyk³ad.</b><br>




<br>




Stworzymy i zastosujemy adnotacjê, dziêki której w prosty sposób w kodzie
Ÿród³owym bêdziemy ustalaæ do jakich kontenerów maj¹ byæ wk³adane wybrane
komponenty GUI.<br>




Adnotacjê nazwiemy Loc (od locate).<br>




<br>




<pre>import java.lang.annotation.*;
import java.awt.*;

@Target(ElementType.FIELD)             // do oznaczania pól
@Retention(RetentionPolicy.RUNTIME)    // faza wykonania

public @interface Loc {
   String to();
}
</pre>




<br>




Adnotacja ma jedn¹ "dan¹", swoisty atrybut, o nazwie<span style="font-weight: bold; font-style: italic;"> to</span>, który bêdzie reprezentowa³
za ka¿dym razem nazwê zmiennej oznaczaj¹cej kontener do którego dany komponent
(oznaczony t¹ adnotacj¹)&nbsp; ma byæ dodany.<br>




<br>




A oto jej zastosowanie:<br>




<br>




<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.lang.reflect.*;

public class Annot0 extends JFrame {

  JComponent cp = (JComponent) getContentPane();

  @Loc(to="cp") JPanel p1 = new JPanel();
  @Loc(to="cp") JPanel p2 = new JPanel();

  @Loc(to="p1") JButton b1 = new JButton("Przycisk 1");
  @Loc(to="p1") JButton b2 = new JButton("Przycisk 2");
  @Loc(to="p2") JButton b3 = new JButton("Przycisk 3");
  @Loc(to="p2") JButton b4 = new JButton("Przycisk 4");
  @Loc(to="p2") JButton b5 = new JButton("Przycisk 5");

  public Annot0() {
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    cp.setLayout(new BoxLayout(cp, BoxLayout.Y_AXIS));
    try {
      locateComponents();   // metoda ta zajmie siê wk³adaniem do kontenerow
    } catch(Exception exc) {
        exc.printStackTrace();
    }
    pack();
    show();
  }
//....
}
</pre>




<br>




<br>




Metoda locateComponents() nie jest trudna do napisania, jeœli tylko choæ trochê w³adamy metodami refleksji:<br>




<br>




<pre>  private void locateComponents() throws Exception {
    Class klasa =  getClass();
    for (Field f : klasa.getDeclaredFields()) {   // po polach klasy
      Loc annot = f.getAnnotation(Loc.class);     // dla f uzyskaæ anotacjê Loc
      if (annot == null) continue;                // nie ma - nastêpne pole
      System.out.println(annot);                  // zobaczmy jak wygl¹da
      String contName = annot.to();               // od adnotacji: nazwa kontenera
      Field contField = klasa.getDeclaredField(contName);  // pole, ktore go deklaruje
      Object container = contField.get(this);  // sam obiekt-kontener
      Method m = container.getClass().getMethod("add", Component.class); // metoda add
      m.invoke(container, f.get(this)); // i jej wywo³anie - dodajemy komponent
    }
}
</pre>Mo¿na powiedzieæ, ¿e ten sposób programowania, szczególnie w du¿ych projektach
mo¿e byæ bardzo u¿yteczny, bowiem ³atwo pozwala zmieniaæ u³o¿enie komponentów.<br>




Sama metoda locateComponents() mo¿e byæ nieco zmodyfikowana, tak by mog³a
znaleŸæ siê w jakiejœ klasie narzêdziowej i byæ zastosowana wobec dowolnych
klas o podobnej j.w. konstrukcji.<br><br><a name="DynJav.19"></a><h2>3.5. <!---->Przetwarzanie adnotacji w fazie kompilacji<!----></h2>




Niew¹tpliwie mo¿liwoœæ przetwarzania adnotacji &nbsp;w fazie kompilacji &nbsp;jest najbardziej ekscytuj¹ca. <br>




Umo¿liwia np. generowanie dodatkowych klas czy niezbêdnych plików zewnêtrznych.<br>




<br>




Do takiego przetwarzania powo³ane s¹ odpowiednie dodatkowe narzêdzia. <br>




<br>




Nale¿y do nich
<br>


<span style="font-weight: bold;"><!---->apt<!----></span><br>




czyli "Annotation Processing Tool", dostêpny w pakiecie Javy.<br>




<br>




Sk¹d apt ma wiedzieæ, jak nale¿y przetwarzaæ nasze adnotacje?<br><!----><!---->




Oto¿ musimy mu to sami powiedzieæ, dostarczaj¹c tzw. procesora adnotacji.<br>




<br>




<div class="syntax"><br>




Procesor adnotacji definiujemy implementuj¹c we w³asnej klasie interfejs <b>AnnotationProcessor</b> i dostarczaj¹c definicji jedynej jego metody public void process()<br>




<br>




Apt uzyskuje dostêp do naszego procesora za pomoc¹ metody getProcessorFor(...)
z klasy, któr¹ te¿ musimy zdefiniowaæ i która stanowi fabrykê procesorów
- implementacjê interfejsu <b>AnnotationProcessorFactory</b>.<br>




<br>




Podczas wywo³ania tej metodzie przekazywane jest œrodowisko dzia³ania dla procesora - <b>AnnotationProcessorEnvironment</b>. Z tego œrodowiska nasz procesor mo¿e odczytaæ wszystkie niezbêdne informacje
o strukturze kodu Ÿród³owego oraz sposobach tworzenia i generowania nowych
plików, a tak¿e raportowania b³êdów i ostrze¿eñ.<br>




<br>




Apt u¿ywa naszego procesora, który np. produkuje dodatkowe pliki, po czym wykonuje wszystkie niezbêdna kompilacje.<br>




<br>




Uwaga: konieczne s¹ importy pakietów z tools.jar - zob. przyk³adowy kod Ÿród³owy.<br>




</div><br>




<br>




Jako przyk³ad rozpatrzmy prosty sposób zapisu klas typu JavaBeans.<br>




Na podstawie tych bardzo uproszczonych zapisów bêd¹ mog³y byæ generowane
"prawdziwe" du¿e klasy JavaBeans. Przyk³ad jest raczej ilustracyjny i do
dalszego znacz¹cego rozszerzania i modyfikowania.<br>




<br>




Umówimy siê, ¿e na podstawie zapisu:<br>




<br>




<b>@BeanTemplate class <i>NazwaBeana</i>Template {</b><br>




&nbsp; &nbsp; &nbsp; &nbsp;typ1 nazwa1;<br>




&nbsp; &nbsp; &nbsp; &nbsp;typ2 nazwa2;<br>




&nbsp; &nbsp; &nbsp; &nbsp;....<br>




&nbsp; &nbsp; &nbsp; &nbsp;tyoN nazwaN;<br>




}<br>




<br>




ma byæ wygenerowana klasa JavaBean o nazwie NazwaBeana, zawieraj¹ce w³aœciwe
deklaracje pól (podanych) oraz odpowiednie dla nich settery i gettery.<br>




<br>




Musimy wiêc mieæ adnotacjê @BeanTemplate:<br>




<pre>import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface BeanTemplate {
}
</pre>




&nbsp; <br>




&nbsp;i odpowiedni procesor, dostarczany przez nasz¹ implementacjê fabryki procesorow adnotacji:<br>




<br>




<pre>import com.sun.mirror.apt.*;
import com.sun.mirror.declaration.*;
import com.sun.mirror.type.*;
import com.sun.mirror.util.*;

import java.beans.*;
import java.io.*;
import java.util.*;


public class BeanTemplateAnnotationFactory
       implements AnnotationProcessorFactory
{

   // Typ adnotacji
   private final String annoType = "BeanTemplate";

   public Collection&lt;String&gt; supportedAnnotationTypes() {
      return Arrays.asList(annoType);
   }

   public Collection&lt;String&gt; supportedOptions() {
      return Arrays.asList(new String[0]);
   }

   public AnnotationProcessor   <b>// wa¿na metoda getProcessorFor</b>
          getProcessorFor(Set&lt;AnnotationTypeDeclaration&gt; atds,
                          final <b>AnnotationProcessorEnvironment env</b>)
   {
      return new AnnotationProcessor() { <b>// procesor - w klasie wewnêtrznej</b>

        <b>public void process() {</b>
          // deklaracje markowane adnotacj¹ annoType (teraz "BeanTemplate")
          Collection&lt;Declaration&gt; dcls =
             env.getDeclarationsAnnotatedWith(
                (AnnotationTypeDeclaration) env.getTypeDeclaration(annoType));

          for (Declaration d : dcls) {&nbsp;
             if (d instanceof ClassDeclaration) {  <b>// je¿eli klasa</b>
               ClassDeclaration cdcl = (ClassDeclaration) d;
               String name = cdcl.getSimpleName();
               if (!name.endsWith("Template")) {
                  <b>// od env uzyskujemy œrodki raportowania b³êdów, ostrze¿eñ, info.</b>
                  env.getMessager().printWarning("Wadliwa nazwa klasy bean template");
                  continue;
               }
               String qname = cdcl.getQualifiedName();
               env.getMessager().printNotice(qname);
               qname = qname.substring(0, qname.lastIndexOf("Template"));
               name = name.substring(0, name.lastIndexOf("Template"));
               try {
                 <b>// od env uzyskamy plik i skojarzony z nim PrintWriter</b>
                 PrintWriter out = env.getFiler().createSourceFile(qname);
                 // generujemy œwie¿y kod na podstawie info o zaznaczonej klasie
                 out.println("public class " + name + " {" );
                 Collection&lt;FieldDeclaration&gt; fdcl = cdcl.getFields();
                 for (FieldDeclaration f : fdcl) {
                   String fname = f.getSimpleName();
                   String mname = Character.toUpperCase(fname.charAt(0)) +
                                  fname.substring(1);
                   String ftype = f.getType().toString();
                   out.println("  private " + ftype + " " + fname + ";");
                   out.println("  public " + ftype + " get" +  mname +
                               "() { return " + fname + "; }");
                   out.println("  public void set" +  mname +
                               "(" + ftype + " v) { " + fname + " = v; }");
                 }
                 out.println("}");
                 out.close();
               } catch(IOException exc) { exc.printStackTrace(); }
             }
             else  // jeœli nie byla klasa, to ktoœ siê pomyli³ i zazn. interfejs
               env.getMessager().printWarning("Adnotacja dotyczy interfejsu");
          }
        }
      };
   }



}</pre>




<br>




Po skompilowaniu tej fabryki umieszczamy wynik kompilacji w katalogu, w
którym znajduj¹ siê&nbsp; inne pliki Ÿród³owe. Np. takie przyk³adowe zastosowanie:<br>




<br>




Uproszczona definicja beana:<br>




<pre>import java.awt.*;
@BeanTemplate public class Bean1Template {
  String txt;
  Color color;
}
</pre>

Poniewa¿, zgodnie z umow¹ ma z tego powstaæ prawdziwa klasa JavaBean, to
plik j¹ wykorzystuj¹cy bêdzie siê odwo³ywa³ do Bean1, a nie Bean1Template:<br>




<br>




<pre>import java.awt.*;
public class Annot1 {


  public Annot1() {
    Bean1 b = new Bean1();
    b.setTxt("Pies");
    b.setColor(Color.BLUE);

    System.out.println(b.getTxt() + "\n" + b.getColor());

  }

  public static void main(String[] args) {
     new Annot1();
  }

}
</pre>




<br>




Aby to wszystko ze sob¹ pola¹czyæ, musimy wywo³aæ apt, podaj¹c mu lokalizacjê fabryki procesorow:<br>




<br>




<pre>apt -factory BeanTemplateAnnotationFactory *.java
</pre>




<br>




APT nie tylko przeprowadzi analizê adnotacji i odpowiednie ich substytucje,
nie tylko skorzysta z naszego procesora i pozwoli mu zapisaæ nowy plik Ÿród³owy,
ale równie¿ wywo³a normalny kompilator javy, aby wszystko z³o¿y³ do kupy.<br>




<br>




W efekcie uzyskamy nowowygenerowany plik Ÿród³owy (który "zastêpuje" uproszczony "template"):<br>




<pre>public class Bean1 {
  private java.awt.Color color;
  public java.awt.Color getColor() { return color; }
  public void setColor(java.awt.Color v) { color = v; }
  private java.lang.String txt;
  public java.lang.String getTxt() { return txt; }
  public void setTxt(java.lang.String v) { txt = v; }
}
</pre>




a w wyniku kompilacji wszystkiego razem dzia³aj¹cy plik Annot1.class, który wyprodukuje napis:<br>




<br>




Pies<br>




java.awt.Color[r=0,g=0,b=255]<br><br><br><a style="font-weight: bold;" href="mm/w3p1/w3p1.html" target="_blank">Zobacz multimedialn¹ prezentacjê u¿ycia APT</a><a href="mm/w3p1/w3p1.html"><img style="border: 0px solid ; width: 100px; height: 80px;" alt="r" src="../../../../ZaawTechPrg/Wyklady/STYLE/video2.gif"></a><br><br>Podany przyk³ad jest prosty, a tak¿e trochê dyskusyjny. Ale dobrze pokazuje
potencjalnie olbrzymie mo¿liwoœci tkwi¹ce w przetwarzaniu adnotacji w fazie kompilacji.<br><br><br><a name="DynJav.20"></a><h2>3.6. Adnotacje a transformowanie kodu binarnego</h2>

<br>

Polityka utrzymywania adnotacji oznaczana przez metaadnotacjê
@Retention jako RetentionPolicy.CLASS utrzymuje adnotacjê w klasie
(kodzie binarnym), ale nie udostêpnia jej mechanizmom refleksji.<br>

<br>

Taki typ adnotacji mo¿e byæ wykorzystywany przez ró¿ne narzêdzia
modyfikacji kodu binarnego klas. Nale¿¹ do nich takie narzêdzia jak:<br>

<ul><li>Javassist,</li><li>BCEL.</li></ul>

<br>

<span style="font-weight: bold;">Javassist</span> pozwala na bardzo ³atwe transformowanie kodu binarnego klas, polegaj¹ce m.in na:<br>

<ul><li>zastêpowaniu metod i konstruktorów.</li><li>dodawanie kodu na pocz¹tku lub w koñcu cia³a metod lub konstruktorów.</li></ul>

Modyfikacje s¹ ³atwe, poniewa¿ mo¿emy zapisaæ je w naturalnym jêzyku Javy.<br>

Javassist ma pewne ograniczenia. <br>

Znacznie potê¿niejszym narzêdziem jest BCEL (Byte Code Engineering
Library), który pozwala robiæ praktycznie wszystko, ale wymaga
zapisów w postaci podobnej do bajtkodu.<br>

<br>

Zobacz wiêcej o:<br>

<span style="font-weight: bold;">Javassist</span> - <a href="http://jboss.com/products/javassist">http://jboss.com/products/javassist</a><br>

<span style="font-weight: bold;">BCEL</span> - <a href="http://jakarta.apache.org/bcel/">http://jakarta.apache.org/bcel/</a>
<hr>
<a name="DynJav.21"></a><h2>4. Skrypty w Javie</h2>
<a name="DynJav.22"></a><h2>4.1. Wprowadzenie</h2><br>W Javie 6 wbudowano mo¿liwoœæ uruchamiania skryptów z poziomu
aplikacji. Naturalnie, taka mo¿liwoœc istnia³a zawsze, ale teraz
mechanizmy i interfejsy zosta³y ustandaryzowane, a w pakietach Javy
mamy javax.script, dodstarczaj¹cy gotowych klas i interfejsów do
wykorzystania w tym celu.<br><i><br></i><span style="font-weight: bold;">Co mo¿e robiæ aplikacja Javy ?</span><br><ul><li>wywo³ywaæ skrypt,</li><li>wywo³ywac wybrane funkcje/metody ze skryptu,</li><li>odczytywaæ informacje (zmienne) zmienione lub dostarczone przez skrypt</li></ul><br><span style="font-weight: bold;">Co mo¿e robiæ skrypt ?</span><br><ul><li>korzystaæ z mo¿liwoœci swojego jêzyka skryptowego</li><li>korzystaæ z bibliotek Javy</li><li>odczytywaæ informacje z aplikacji (dostêp do zmiennych)</li></ul><br><span style="font-weight: bold;">Jakie s¹ tego&nbsp;zastosowania
?</span><br><ul><li>prototypowanie aplikacji</li><li>testowanie aplikacji</li><li>wzbogacanie aplikacji o mo¿liwoœci jêzyków skryptowych (np. niektóre fragmenty ³atwiej napisaæ w skrypcie)</li><li>dostarczanie u¿utkownikowi œrodków prgramistycznego dostêpu do œrodowiska aplikacji</li><ul><li>np. makra-programy do elastycznych obliczeñ</li></ul><ul><li>np. makra edycyjne</li></ul></ul><br><a name="DynJav.23"></a><h2>4.2. Motory skryptowe i dostêp do nich z aplikacji Javy</h2><div class="def">Motor skryptowy (<span style="font-weight: bold; font-style: italic;">script engine</span>)
- to komponent software'wy, który wykonyje programy napisane w
jêzyku skryptowym. Wykonanie polega na interpretacji, sk³adaj¹cej siê z
nastêpuj¹cych faz: parsowanie kodu,&nbsp; utworzenie tablicy symboli do
przechowywania wartoœci, w³aœciwe wykonanie. Motor skryptowy nazywany
jest tak¿e interpreterem</div><br><br><span style="font-weight: bold;">Java Script Engines (JSE)</span> - to motory skryptowe zrealizowane jako modu³y napisane w Javie (pliki .jar) i eksponuj¹ce <span style="font-weight: bold;">jednolity interfejs programistyczny, zgodny ze specyfikacj¹ JSR-223</span>. <br>Oczywiœcie,
mog¹ one u¿ywac odwo³añ do funkcji rodzimych, a zatem mog¹ "powierzaæ"
w³asciwe wykonanie skryptu interpreterom, które maj¹ odpowiednie
API do takiego wspó³dzia³ania.<br><br>W bibliotekach Javy 1. 6&nbsp; dostêpny jest JSE dla jêzyka JavaScript w wersji Rhino.<br>Dodatkowe motory skryptowe s¹ dostêpne na stronie: <a href="https://scripting.dev.java.net/">https://scripting.dev.java.net/</a>.<br>Mog¹ powstawaæ (i powstaj¹) nowe motory skryptowe.<br><br>Tabela przedstawia wybrane motory skryptowe<br><br><table border="1"><tbody><tr><th>
Language
</th>
<th>
Description
</th>
<th>
Implementation
</th>
</tr>


<tr>
<td>
<a href="http://en.wikipedia.org/wiki/Awk">AWK</a>
</td>
<td>
AWK is a general purpose language that is designed for processing text-based
data, either in files or data streams. Jawk is Java-like, Awk-like reporting
language.
</td>
<td>
<a href="http://jawk.sourceforge.net/">Jawk</a>
</td>
</tr>

<tr>
<td>
<a href="http://jcp.org/en/jsr/detail?id=274">BeanShell</a>
</td>
<td>
BeanShell is a small, free, embeddable Java interpreter with object scripting
language features, written in Java. BeanShell dynamically executes standard
Java syntax and extends it with common scripting conveniences such as loose
types, commands, and method closures like those in Perl and JavaScript.
</td>
<td>
<a href="http://www.beanshell.org/">BeanShell 2.0b5</a>
</td>
</tr>

<tr>
<td>
<b>ejs</b>
</td>
<td>
"ejs" (Embedded JavaScript) is JSP-like templating engine for JavaScript.
It supports the usual &lt;%= expr %&gt;, &lt;% code %&gt; syntax. This engine
is completely implemented in JavaScript. You need to use JavaScript engine to
use this script engine.
</td>
<td>
Implementation contained in one JavaScript file.
</td>
</tr>

<tr>
<td>
<a href="http://freemarker.sourceforge.net/">FreeMarker</a>
</td>
<td>
FreeMarker is a Java-based general purpose template engine.
</td>
<td>
<a href="http://freemarker.sourceforge.net/">FreeMarker 2.3.8</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.jcp.org/en/jsr/detail?id=241">Groovy</a>
</td>
<td>
Groovy is an agile dynamic language for the Java 2 Platform that has many of the
features that people like so much in languages like Python, Ruby and Smalltalk,
making them available to Java developers using a Java-like syntax.
</td>
<td>
<a href="http://groovy.codehaus.org/">Groovy 1.0 jsr-06</a>
</td>
</tr>

<tr>
<td>
<a href="http://jaskell.codehaus.org/">Jaskell</a>
</td>
<td>
Jaskell is a lazy functional programming language. It stands for
"Java Haskell". It features higher-order functions, function currying,
string interpolation, lazy evaluation, dynamic typing.
</td>
<td>
<a href="http://jaskell.codehaus.org/">Jaskell 1.0</a>
</td>
</tr>

<tr>
<td>
<a href="http://java.sun.com/docs/books/jls">Java</a>
</td>
<td>
<a href="http://java.sun.com/">http://java.sun.com</a>
</td>
<td>
<a href="http://www.jcp.org/en/jsr/detail?id=199">Java Compiler API (JSR 199)</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.mozilla.org/js">JavaScript</a>
</td>
<td>
Web Browser's native JS interpreter is wrapped as javax.script API.
Note that this script engine works only under web browsers. i.e., only
within Java applets.
</td>
<td>
Web Browser's JS implementation (tested with Firefox 1.5.0)
</td>
</tr>

<tr>
<td>
<a href="http://jakarta.apache.org/commons/jelly/">Jelly</a>
</td>
<td>
Jelly is a tool for turning XML into executable code. So Jelly is a Java
and XML based scripting and processing engine. Jelly borrows many good ideas
from both JSP custom tags, Velocity, Cocoon, Ant. In this script engine,
&lt;script&gt; tag has been added. Any JSR-223 compliant language may be used.
Also, expressions [${xxx}] may be from any scripting language rather than
Jexl alone.
</td>
<td>
<a href="http://jakarta.apache.org/commons/jelly/">Jelly 1.0</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.singularsys.com/jep/">JEP</a>
</td>
<td>
JEP is a Java library for parsing and evaluating mathematical expressions.
JEP supports BigInteger, BigDecimal, complex, Vector/Matrix/Tensor arithmetic.
</td>
<td>
<a href="http://www.singularsys.com/jep/">JEP (Java Math Expression Parser) 2.4.0</a>
</td>
</tr>

<tr>
<td>
<a href="http://jakarta.apache.org/commons/jexl/">Jexl</a>
</td>
<td>
Java Expression Language (JEXL) is an expression language engine which can be embedded in
applications and frameworks. JEXL is inspired by Jakarta Velocity and the Expression Language
defined in the JavaServer Pages Standard Tag Library version 1.1 (JSTL) and JavaServer Pages
version 2.0 (JSP).
</td>
<td>
<a href="http://jakarta.apache.org/commons/jexl/">Jexl 1.0</a>
</td>
</tr>


<tr>
<td>
<b>jst</b>
</td>
<td>
"jst" (JavaScript Templates) is JSP/ASP/PHP-like templating engine for
JavaScript. This engine uses TrimPath's JavaScript Templates implementation.
This script engine is implemented in JavaScript. You need to use
JavaScript engine to use this script engine.
</td>
<td>
<a href="http://www.trimpath.com/project/wiki/JavaScriptTemplates">TrimPath JavaScript Templates (1.0.38)</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.judoscript.com/">JudoScript</a>
</td>
<td>
A scripting language built atop Java, and is a powerful general-purpose programming
language with intimate Java scripting support. JudoScript, or Judo for short, is a
general-purpose, Java scripting and multi-domain language. A full-fledged general-purpose
scripting language with full capability of Java scripting, JudoScript intimately supports
most of today's key computing areas.
</td>
<td>
<a href="http://www.judoscript.com/">JudoScript 0.9</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.ognl.org/">OGNL</a>
</td>
<td>
OGNL stands for Object-Graph Navigation Language; it is an expression language for
getting and setting properties of Java objects. You use the same expression for both
getting and setting the value of a property
</td>
<td>
<a href="http://www.ognl.org/">OGNL 2.6.9</a>
</td>
</tr>

<tr>
<td>
<a href="http://pnuts.dev.java.net/">Pnuts</a>
</td>
<td>
Pnuts is a simple but powerful scripring language that is embeddable into Java applications.
It has an extensible module system and a lot of ready-to-use modules.
</td>
<td>
<a href="http://pnuts.dev.java.net/">Pnuts 1.1</a>
</td>
</tr>


<tr>
<td>
<a href="http://www.python.org/">Python</a>
</td>
<td>
Python is a dynamic object oriented programming language that can be used for many kinds
of software development. It offers strong support for integration with other languages and tools,
comes with extensive standard libraries, and can be learned in a few days time.
</td>
<td>
<a href="http://jython.sourceforge.net/">Jython 2.1</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.ruby-lang.org/">Ruby</a>
</td>
<td>
Ruby is the interpreted scripting language for quick and easy object-oriented programming.
It has many features to process text files and to do system management tasks (as in Perl).
It is simple, straight-forward, extensible, and portable.
</td>
<td>
<a href="http://jruby.sourceforge.net/">JRuby 0.9.0</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.schemers.org/">Scheme</a>
</td>
<td>
Scheme is a statically scoped and properly tail-recursive dialect of the Lisp programming language
invented by Guy Lewis Steele Jr. and Gerald Jay Sussman. It was designed to have an exceptionally
clear and simple semantics and few different ways to form expressions. A wide variety of programming
paradigms, including imperative, functional, and message passing styles, find convenient expression
in Scheme.
</td>
<td>
<a href="http://sisc.sourceforge.net/">SISC 1.15.3</a>
</td>
</tr>


<tr>
<td>
<a href="http://sleep.hick.org/">Sleep</a>
</td>
<td>
Sleep is a Java-based scripting language heavily inspired by Perl.
</td>
<td>
<a href="http://sleep.hick.org/">Sleep 2.0</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.tcl.tk/">Tcl</a>
</td>
<td>
Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language,
suitable for a very wide range of uses, including web and desktop applications, networking,
administration, testing and many more. Open source and business-friendly, Tcl is a mature yet
evolving language that is truly cross platform, easily deployed and highly extensible.
</td>
<td>
<a href="http://tcljava.sourceforge.net/">Jacl 1.3.3</a>
</td>
</tr>

<tr>
<td>
<a href="http://jakarta.apache.org/velocity/">Velocity</a>
</td>
<td>
Velocity is a Java-based general purpose template engine.
</td>
<td>
<a href="http://jakarta.apache.org/velocity/">Velocity 1.4</a>
</td>
</tr>

<tr>
<td>
<a href="http://www.w3.org/TR/xpath">XPath</a>
</td>
<td>
JDK already includes <a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/xpath/package-summary.html">javax.xml.xpath</a>
package for XPath. But to extend XPath with user defined functions and variables, user needs to learn different set of
interfaces/classes in this (and few other) package(s). We are adding a javax.script engine on top of javax.xml.xpath API
- so that user can set variables, functions in ScriptContext and call "eval" method on ScriptEngine. Any Java method,
constructor may be used as XPath extension function - no need to wrap it as "XPathFunction".
</td>
<td>
JDK implementation of javax.xml.xpath is used.
</td>
</tr>

<tr>
<td>
<a href="http://www.w3.org/TR/xslt">XSLT</a>
</td>
<td>
JDK already includes <a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/package-summary.html">javax.xml.transform</a>
package for XSLT. But to use XSLT, user needs to learn different set of interfaces/classes in
this (and few other) package(s). We are adding a javax.script engine on top of javax.xml.transform API
- so that user can set source, result in ScriptContext and call "eval" method on ScriptEngine.
By default, ScriptContext's input Reader and output Writer are used for transform source and
result.
</td>
<td>
JDK implementation of javax.xml.transform is used.
</td>
</tr>


</tbody></table>

<span style="font-weight: normal;">Wszystkie w/w JSE s¹ dostêpne z w/w strony jako archiwum katalogów </span><b>sr223-engines.zip.</b><br><br>Dodatkowe JSE wg specyfikacji JSR 223:&nbsp;
<ul><li>AppleScript (<a href="https://jasconn.dev.java.net/">https://jasconn.dev.java.net</a> - <b>Mac OS X only</b>)
</li><li>Bex script (<a href="http://bexscript.sourceforge.net/">http://bexscript.sourceforge.net</a>)
</li><li>PHP (<a href="http://www.caucho.com/resin-3.0/quercus/">http://www.caucho.com/resin-3.0/quercus/</a>) - pure Java implementation of PHP.
</li><li>PHP (<a href="http://php-java-bridge.sourceforge.net/">http://php-java-bridge.sourceforge.net/</a>) - uses native PHP implementation through remoting.
</li><li>Python (<a href="http://jepp.sourceforge.net/">http://jepp.sourceforge.net/</a>) - uses the native Python implementation to implement JSR 223 engine.</li><li></li></ul><div class="important">Aby JSE by³ dostêpny z poziomu aplikacji Javy jego JAR
musi byæ widoczny dla ClassLoadera (np. umieszczony na œcie¿ce
CLASSPATH.</div><br>Dostêp do JSE z poziomu aplikacji Javy jest realizowany za poœrednictwem zarz¹dcy motorów -&nbsp; <span style="font-weight: bold;">ScriptEngineManager</span>. Zajmuje siê on m.in.&nbsp; wyszukiwaniem i instancjacj¹ odpowiednich JSE. <br><br>Do odnajdywania JSE s³u¿¹ nastêpuj¹ce metody klasy ScriptEngineManager.<br><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><br><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr><td style="background-color: rgb(255, 255, 255);">&nbsp;ScriptEngine</td><td style="background-color: rgb(255, 255, 255);"><br>getEngineByName(String&nbsp;shortName)

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wyszukuje i tworzy JSE dla podanej nazwy motoru (lub jej aliasu)</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">
&nbsp;ScriptEngine</td>
<td>getEngineByExtension(String&nbsp;extension)

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wyszukuje i
tworzy JSE dla podanego rozszerzenia plików skryptowych.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%">
&nbsp;ScriptEngine</td>
<td>getEngineByMimeType(String&nbsp;mimeType)

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. - tylko dla &nbsp;podanego typu MIME</td>
</tr>
</tbody></table><br><br><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><br><div style="text-align: center;">Uzyskanie JSE:<br></div><br><pre>ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(<span style="font-style: italic; font-weight: bold;">nazwa_motoru</span>);</pre><br>A jakie s¹ nazwy?<br>To
oczywiœcie podaje dokumentacja konkretnych JSE. Ale mo¿emy siê tego
sami szybko dowiedzieæ. Sprawdzenie nazw jest u¿yteczne wtedy, gdy
nazwy siê powtarzaj¹ dla ró¿nych JSE (np. javascript) i wtedy trzeba
zastosowac rozró¿niaj¹ce aliasy.<br><br>Metainformacje o JSE uzyskujemy za pomoc¹ interfejsu <span style="font-weight: bold;">ScriptEngineFactory</span>.<br>Tak
naprawdê ScriptEngineManager odnajduje w³aœnie odpowiednie fabryki dla
danych JSE i za pomoc¹ ich metod fabrycznych tworzy obiekty
ScriptEngine.<br><br>Uwaga: ScriptEngineManager stosuje mechanizm <span style="font-weight: bold;">service provider</span> zob.<br><br><a href="http://java.sun.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider">http://java.sun.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider</a><br><br>do wykrywania fabryk.<br><br>Wymaga to aby JARy JSE w katalogu <span style="font-weight: bold;">META-INF</span> &nbsp;zawiera³y podkatalog <span style="font-weight: bold; font-style: italic;">services</span> z plikiem o nazwie <span style="font-weight: bold;">javax.script.ScriptEngineFactory</span>,
zawieraj¹cym nazwê klasy bêd¹cej fabryk¹ tworz¹c¹ obiekty danego JSE.
Np. groovy-engine.jar w tym pliku zawiera nazwê
com.sun.script.groovy.GroovyScriptEngineFactory.&nbsp; <br><br><br>Wszystkie znane zarz¹dzcy fabryki mo¿na uzyskaæ za pomoca metody:<br><br><pre>ScriptEngineManager mgr ...
List&lt;ScriptEngineFactory&gt; factories = mgr.getEngineFactories();</pre><br>Przyk³adowy program pokazuje dostêpne informacje. <br><br><pre>import java.util.*;
import javax.script.*;

public class DiscoverEngines {
  
  public static void main(String[] args) {

    ScriptEngineManager mgr = new ScriptEngineManager();
   
    List&lt;ScriptEngineFactory&gt; factories = mgr.getEngineFactories();
    
    for (ScriptEngineFactory factory : factories) {
    
      System.out.println("ScriptEngineFactory Info");
      
      String engName = factory.getEngineName();
      String engVersion = factory.getEngineVersion();
      System.out.println("Script Engine: " + engName + " v. " + engVersion);

      List&lt;String&gt; engNames = factory.getNames();
      for(String name : engNames) System.out.println("Engine Alias: " + name);
      
      String langName = factory.getLanguageName();
      String langVersion = factory.getLanguageVersion();
      System.out.println("Language: " + langName + " v. " +  langVersion);
      
      List&lt;String&gt; exts = factory.getExtensions();
      for(String ext : exts) System.out.println("Script file extension: " + ext);
      
      System.out.println("-------------------------------------------");
    }    
  }

}</pre>W przypadku gdy na œcie¿ce classpath&nbsp; znajduj¹ siê JSE dla browserjs i groovy otrzymamy wynik:<br><br><div class="listing100"><br>ScriptEngineFactory Info<br>Script Engine: groovy v. <br>Engine Alias: groovy<br>Language: groovy v. 1.0<br>Script file extension: groovy<br>-------------------------------------------<br>ScriptEngineFactory Info<br>Script Engine: Browser JavaScript Engine v. 1.5<br>Engine Alias: js<br>Engine Alias: javascript<br>Engine Alias: JavaScript<br>Engine Alias: ecmascript<br>Engine Alias: ECMAScript<br>Engine Alias: BrowserJS<br>Engine Alias: NativeJS<br>Language: JavaScript v. 1.5<br>Script file extension: js<br>-------------------------------------------<br>ScriptEngineFactory Info<br>Script Engine: Mozilla Rhino v. 1.6 release 2<br>Engine Alias: js<br>Engine Alias: rhino<br>Engine Alias: JavaScript<br>Engine Alias: javascript<br>Engine Alias: ECMAScript<br>Engine Alias: ecmascript<br>Language: ECMAScript v. 1.6<br>Script file extension: js<br>-------------------------------------------<br></div><br><a name="DynJav.24"></a><h2>4.2. Wykonanie skryptów</h2>Skrypty traktowane s¹ jako ci¹gi znaków:<br><ul><li>zapisane jako String, </li><li>lub czytane z dowolnego strumienia typu Reader.</li></ul><br>Skrypt
mo¿e byæ wywo³any jako ca³oœæ lub te¿ - jesli jêzyk skryptowy to
dopuszcza - mo¿e byæ wywo³ana wybrana funkcja lub metoda ze skryptu.<br><br>Do <span style="font-weight: bold;">wykonania ca³ego skryptu</span> s³u¿y metoda <span style="font-weight: bold;">eval</span> wo³ana na rzecz obiektu typu ScriptEngine.<br><br><div class="syntax"><br><br><div style="margin-left: 40px;">ScriptEngine eng &nbsp;= ...;<br><span style="font-weight: bold;">eng.eval( skrypt);</span><br><br>gdzie:<br>&nbsp;&nbsp;&nbsp; skrypt - jest typu String lub typu Reader<br></div><br>Uwaga: przy wywo³aniu eval nalezy obs³ugiwac wyj¹tek ScriptException<br></div><br><br>Przyk³ad 1.<br><br><pre>import javax.script.*;


public class GroovyTest {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");
    try {
      String script = "\"Ala ma kota i psa\".tokenize().each { println it + ' ' + it.length()}";
      engine.eval(script);
    } catch (ScriptException e) {
      e.printStackTrace();
    }
  }

}</pre>Uwagi:<br><ol><li>treœc skryptu sformu³owano w jêzyku Groovy jako String</li><li>warto
zwróciæ uwagê na moc tego jêzyka - metoda tokenize(), konstrukcja each
oraz tzw. domkniêcie (zamiast definiowania tradycyjnej funkcji) bardzo
u³atwia programowanie.</li></ol><br>Wynik:<br><div class="listing100"><br>Ala 3<br>ma 2<br>kota 4<br>i 1<br>psa 3<br></div><br><br>Skrypt mo¿na wczytaæ te¿ bezpoœrednio z pliku:<br><br><pre>import java.io.*;
import javax.script.*;

public class GroovyTest2 {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");

    try {
      engine.eval(new FileReader("test1.groovy"));
    } catch (ScriptException e) {
      e.printStackTrace();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
  }

}</pre><br><br>Wywo³anie <span style="font-weight: bold;">okreœlonej funkcji</span> lub <span style="font-weight: bold;">metody</span>
- zdefiniowanej w &nbsp;skrypcie - jest mo¿liwe wtedy gdy ScriptEngine
implementuje interfejs Invocable. Nale¿y to zawsze sprawdziæ, a
nastêpnie dokonaæ konwersji do Invocable i wywolac metodê <span style="font-weight: bold;">invokeFunction</span> lub <span style="font-weight: bold;">invokeMethod</span>.<br><br><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1">
<code>&nbsp;Object</code></font></td>
<td><code><b>invokeFunction</b>(String&nbsp;name,
               Object...&nbsp;args)</code>

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wo³a funkcje
name zdefiniowan¹ w skrypcie z argumentami args i zwraca wynik w
postaci Object. Konwersje z typów wyniku funkcji do typów Javy s¹
zalezne od implementacji jêzyka skryptowego.<br>Przy braku funkcji zg³asza wyj¹tek NoSuchMethodException. Skrypt powinien byæ wczesniej przygotowany przez wywo³anie eval.</td>
</tr>
<tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%"><font size="-1">
<code>&nbsp;Object</code></font></td>
<td><code><b>invokeMethod</b>(Object obj,
             String&nbsp;name,
             Object...&nbsp;args)</code>

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wywo³uje metodê name na rzecz obiektu obj z argumentami args.</td></tr></tbody></table><br>Przyk³ad.<br><br>W pliku test1.js mamy nastêpuj¹cy zestaw funkcji:<br><br><pre>function square(n) {
  return n*n;
}

function cube(n) {
  return n*n*n;
}</pre>Bêdziemy je wywo³ywac z aplikacji Javy podaj¹c nazwê funkcji i argument:<br><br><pre>import java.io.*;
import javax.script.*;
import javax.swing.*;

public class InvokeTest {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("rhino");

    if (!(engine instanceof Invocable))
      throw new RuntimeException("Engine not invocable");

    Invocable eng = (Invocable) engine; // konieczna konwersja

    try {
      engine.eval(new FileReader("test1.js")); // przygotowanie skryptu
      String in;
      while ((in = JOptionPane.showInputDialog("Podaj nazwe funkcji i argument")) != null) {
        String[] call = in.split(" ");
        double res = (Double) eng.invokeFunction(call[0], call[1]); // wo³anie wybranej funkcji
        System.out.println("Wynik " + res);
      }
    } catch (ScriptException e) {
      e.printStackTrace();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    }
  }

}</pre><br><br>Skrypty - o ile dany JSE to dopuszcza - mog¹ byæ tak¿e <span style="font-weight: bold;">kompilowane</span> (do symbolicznej postaci) co przyspiesza wielokrotne wykonanie. &nbsp;W tym przypadku:<br><ul><li>JSE winien implementowaæ interfejs <span style="font-weight: bold;">Compilable</span>,</li><li>skompilowan¹ postaæ skryptu uzyskujemy z <span style="font-weight: bold;">engine.compile(skrypt)</span> w postaci wyniku typu <span style="font-weight: bold;">CompiledScript</span>,</li><li>na rzecz tego wyniku&nbsp;wo³amy metodê <span style="font-weight: bold;">eval()</span>.</li></ul><br><a name="DynJav.25"></a><h2>4.3. Wymiana danych</h2>Wymiana danych pomiêdzy aplikacj¹ i skryptem odbywa siê poprzez zestawy par: klucz - wartoœæ,&nbsp;zwane &nbsp;wi¹zaniami (<span style="font-weight: bold; font-style: italic;">bindings</span>). W tych parach kluczem jest nazwa zmiennej, a wartoœci¹ - wartoœæ zmiennej.<br>Wi¹zania
s¹ obiektami klas implementuj¹cych interfejs Bindings. Interfejs ten
rozszerza interfejs Map&lt;String, Object&gt;, zatem wi¹zania mog¹ byæ
traktowane &nbsp;generalnie tak jak mapy (np. dodawanie za pomoc¹ put,
pobieranie za pomoc¹ get). <br>Wi¹zania mog¹ byæ nastêpuj¹cych rodzajów:<br><br><ul><li>GLOBAL_SCOPE
- wi¹zanie globalnego zakresu (jego elementy s¹ dostêpne dla wszystkich
JSE tworzonych przez tego samego zarz¹dce ScriptEngineManager)</li><li>ENGINE_SCOPE
- wi¹zanie "zakresu motoru" dostêpne dla danego JSE (ca³y czas w cyklu
jego zycia, nie tylko w trakcie wykonania konkretnego skryptu),</li><li>wi¹zania dodatkowych zakresów - oprócz GLOABAL_SCOPE i ENGINE_SCOPE mog¹ byæ dodatkowe zakresy,</li><li>wi¹zanie tworzone ad hoc i podawane &nbsp;jako argument metody eval: <span style="font-weight: bold;">eval(skrypt, Bindings).</span>&nbsp;</li></ul><br>Zakresy s¹ zarz¹dzane przez <span style="font-weight: bold;">ScriptContext</span> (który oprócz tego daje dostêp do strumieni we-wy i b³êdów JSE).<br><br>Co jest w wi¹zaniach i jak z nimi postêpowaæ?<br><br>Automatycznie
wszystkie zmienne utworzone w trakcie wykonania skryptu (w skrypcie),
s¹ dodawane do wi¹zania zakresu SCRIPT_ENGINE (lub jeœli w eval podano
argument Bindings - do tego w³aœnie wi¹zania). W aplikacji mo¿emy:<br><ul><li>pobraæ
mapê wi¹zañ zakresu SCRIPT_ENGINE - metody getBindings(..) z klas
implementuj¹cych ScriptEngine lub ScriptContext i z tej mapy pobieraæ
wartoœci zmiennych,</li><li>pobraæ wartoœci zmiennych za pomoc¹ metod
get(key, value) ze ScriptEngine lub getAttribute(key,
ScriptContext.ENGINE_SCOPE) z interfejsu ScriptContext</li><li>pobieraæ wartoœci z mapy Bindings przekazanej w eval.</li></ul><br>Zmienne aplikacji Javy mo¿emy dodawaæ do wi¹zañ za pomoc¹ metod:<br><ul><li>scriptManager.put(key, value) // dodaje do zakresu &nbsp;GLOBAL_SCOPE</li><li>engine.put(key, value) &nbsp;// dodaje do zakresu ENGINE_SCOPE</li><li>scriptContext.setAttribute(key, value, scope) // dodaje do wybranego zakresu</li><li>put lub putAll na rzecz Bindings danego zakresu lub w³asnych (przekazanych w eval)</li></ul>Te zmienne bêd¹ bezpoœrednio dostêpne w skrypcie pod nazwami = kluczom.<br><br>Przyk³ady (JSE = Rhino):<br><br><pre>....
      String script = "a =1; b = 2; c =2;";
      engine.eval(script);
      showBindings();
....


  private static void showBindings() {
    System.out.println("Show bindings");
    ScriptContext ctx = engine.getContext();   // uzyskanie biez¹cego kontekstu
    List&lt;Integer&gt; scopes = ctx.getScopes();    // z tego kontekstu - jakie s¹ zakresy
    for (Integer scope : scopes) {             // dla ka¿dego zakresu.... :
      System.out.println("Scope: " + scope);
      Bindings bnd = ctx.getBindings(scope);            // wi¹zania
      System.out.println(bnd.getClass().getName());     // jaka to klasa?
      for (String key : bnd.keySet()) {                 // co jest w wi¹zaniach?
        System.out.println(key + " = " + bnd.get(key));
      }
    }
  }</pre>Wynik:<br><div class="listing100"><br>Show bindings<br>Scope:
100 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &lt;--- to jest ENGINE_SCOPE<br>javax.script.SimpleBindings &nbsp; &nbsp; // wi¹zania s¹ klasy SimpleBindings<br>b
= 2.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// zmienna ze
skryptu<br>c = 2.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //
zmienna ze skryptu<br>println = sun.org.mozilla.javascript.internal.InterpretedFunction@dd5b<br>a
= 1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// zmienna ze
skryptu <br>context = javax.script.SimpleScriptContext@c4bcdc<br>print = sun.org.mozilla.javascript.internal.InterpretedFunction@4b4333<br>Scope:
200 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &lt;--- zakres GLOBAL_SCOPE<br>javax.script.SimpleBindings &nbsp; &nbsp;// nic w nim nie ma bo nic nie dodaliœmy<br></div><br><br>Wi¹zania zakresu ENGINE_SCOPE trwaj¹ wraz z motorem - kolejne skrypty mog¹ je uzupe³niaæ:<br><br><pre>      String script = "a =1; b = 2; c =2;";
      engine.eval(script);
      script = "xyz = 10;";
      engine.eval(script);
      showBindings();</pre>showBindings poka¿e m.in.<br><br><div class="listing100"><br>b = 2.0<br>c = 2.0<br>a = 1.0<br>xyz = 10.0<br></div><br><br>£atwo mo¿emy przekazac zmienn¹ do skryptu:<br><br><pre>      String txt = "Ala ma kota";
      engine.put("txt", txt);
      script = "println('Ze skryptu : ' + txt + a + b + c + xyz);";
      engine.eval(script);
</pre>Dostaniemy (txt pochodzi z aplikacji, zmienne a, b, c, xyz z wykonañ poprzednich skryptów :<br><br>L100<br>Ze skryptu : Ala ma kota12210<br><br><br>Mo¿emy u¿yæ w³asnych Bindings:<br><pre>      Bindings sb = new SimpleBindings();
      int i = 1000;
      Date data = new Date();
      sb.put("i", i);
      sb.put("data", data);
      script = "println('Ze skryptu : ' + data + ' liczba ' + i); hhh = 7777;"; 

<span style="color: rgb(255, 0, 0);">      </span><span style="font-weight: bold; color: rgb(204, 0, 0);">engine.eval(script, sb);  // podajemy jako drugi argument Bindings</span>

      showBindings();
      System.out.println("A co jest w naszych bindings?");
      for (String key : sb.keySet()) {
        System.out.println(key + " = " + sb.get(key));
      }
      System.out.println("Koniec naszych");
</pre>Wynik:<br><br><div class="listingful">Ze skryptu : Tue Oct 10 09:35:44 CEST 2008 liczba 1000<br>Show bindings<br>Scope: 100<br>javax.script.SimpleBindings<br>b = 2.0<br>c = 2.0<br>println = sun.org.mozilla.javascript.internal.InterpretedFunction@15dfd77<br>a = 1.0<br>context = javax.script.SimpleScriptContext@c4bcdc<br>txt = Ala ma kota<br>print = sun.org.mozilla.javascript.internal.InterpretedFunction@1abc7b9<br>xyz = 10.0<br>Scope: 200<br>javax.script.SimpleBindings<br>A co jest w naszych bindings?<br>hhh = 7777.0<br>println = sun.org.mozilla.javascript.internal.InterpretedFunction@1621e42<br>context = javax.script.SimpleScriptContext@b09e89<br>data = Tue Oct 10 09:35:44 CEST 2006<br>print = sun.org.mozilla.javascript.internal.InterpretedFunction@1787038<br>i = 1000<br>Koniec naszych<br></div><br>Tutaj
widaæ, ¿e domyœlny ENGINE_SCOPE nie jest zmieniany, &nbsp;w
przekazanych wi¹zaniach znajdziemy dodane przez nas zmienne (i mog¹ one
byæ u¿yte w skrypcie), dodatkowo znajd¹ siê tam &nbsp;zmienne opisuj¹ce
kontekst (contezt, println, print).<br><br>Okazuje siê, ¿e nasze
wi¹zania zastêpuj¹ domyœlny ENGINE_SCOPE i dlatego w poni¿szym
fragmencie zmienna txt nie jest znana (chocia¿ jest w wi¹zaniach
zakresu ENGINE):<br><pre>      script = "println('Ze skryptu liczba = ' + i); print('Ze skryptu txt: '); println(txt);";
      engine.eval(script, sb);
</pre>Wynik:<br><div class="listing100"><br>Ze skryptu liczba = 1000<br>Ze
skryptu txt: javax.script.ScriptException:
sun.org.mozilla.javascript.internal.EcmaError: ReferenceError: "txt" is
not defined. (&lt;Unknown source&gt;#1) in &lt;Unknown source&gt; at
line number 1<br></div><br><br>Naturalnie, mo¿emy ³¹czyæ wi¹zania:<br><br><pre>      Bindings eb = engine.getBindings(ScriptContext.ENGINE_SCOPE);  // wi¹zania motoru
      eb.putAll(sb);  // dodajemy do nich nasze
      script = "println('Ze skryptu : ' + txt + ' liczba ' + i);";
      engine.eval(script);
      showBindings();
</pre>Teraz bêd¹ znane zmienne zarówno z zakresu ENGINE jak i z naszych Bindings.<br><br><div class="listing100"><br>Ze skryptu : Ala ma kota liczba 1000<br>Show bindings<br>Scope: 100<br>javax.script.SimpleBindings<br>hhh = 7777.0<br>b = 2.0<br>c = 2.0<br>println = sun.org.mozilla.javascript.internal.InterpretedFunction@fa9cf<br>a = 1.0<br>data = Tue Oct 10 10:08:19 CEST 2006<br>context = javax.script.SimpleScriptContext@c4bcdc<br>txt = Ala ma kota<br>print = sun.org.mozilla.javascript.internal.InterpretedFunction@55571e<br>i = 1000<br>xyz = 10.0<br></div><br><br>Nalezy zwróciæ uwagê, ¿e Bindings dzialaj¹ tak jak ka¿da mapa. Nie mo¿emy liczyæ na to, ¿e po dodaniu zmiennej <span style="font-weight: bold; font-style: italic;">i</span> oraz <span style="font-style: italic; font-weight: bold;">txt</span> do Bindings, wykonaniu skryptu i zmianie wartoœci zmiennych ponowne wykonanie skryptu dostrze¿e te zmiany:<br><br><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 99;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txt = "Nowy tekst";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; engine.eval(script);
</pre>L100<br>Ze skryptu : Ala ma kota liczba 1000<br><br><br>Oczywiœcie,
w mapie s¹ referencje (jako wartoœci), ale przecie¿ przy dodawaniu
zmiennych typów prostych do mapy nastêpuje boxing (i refrencja wskazuje
na wtedy utworzony obiekt). To samo dotyczy zmiennej txt - referencja w
mapie wskazuje na napis "Ala ma kota" &nbsp;(a nie na nowy napis "Nowy
tekst").<br>Wyjœciem z sytuacji jest albo u¿ycie obiektów klas
modyfikowalnych albo ponowne ³adowanie mapy Bindings po zmianie
wartoœci na poziomie aplikacji.<br><br>Uwaga: jako kluczy oznaczaj¹cych
nazwy zmiennych (lub inn¹ informacjê przekazywan¹ pomiêdzy skryptem i
aplikacj¹) nie wolno u¿ywaæ nazw zarezerwowanych, które zaczynaj¹ siê
od javax.script. Obecnie zdefiniowane s¹ nastêpuj¹ce klucze
zarezerwowane.<br><br><br><table style="background-color: rgb(255, 255, 204);" border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td style="background-color: rgb(255, 255, 255);">javax.script.argv</td><td colspan="1" rowspan="6" style="background-color: rgb(255, 255, 255); text-align: center;">Zobacz w dokumentacji znaczenie podanych zmiennych</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.filename</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.engine</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.engine_version</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.language</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.language_version</td></tr>
</tbody></table><br><i><br></i><a name="DynJav.26"></a><h2>4.4. Kontekst</h2><br>Wspomniany ju¿ ScriptContext zapewnia ³¹cznoœæ pomiêdzy aplikacj¹ i skryptem.<br>Ka¿dy skrypt wykonywany jest w jakimœ kontekœcie (w szczególnoœci - domyœlnym).<br>Mo¿emy zmieniæ kontekst domyœlny, podaj¹c w³asny kontekst w metodzie eval:<br>eval(skrypt, ScriptContext)<br><br>Mo¿emy te¿ modyfikowac domyœlny kontekst.<br><br>Oprócz wi¹zañ (zakresów) - kontekst zapewnia dostêp do strumieni wejœcia, wyjœcia oraz b³êdów dla skryptu.<br><i><br></i>Poni¿szy fragment pokazuje jak mo¿na przechwyciæ wyjœcie skryptu:<br><br><pre>      // Zobaczmy co mo¿na zrobiæ z Writerem
      StringWriter sw = new StringWriter();
      engine.getContext().setWriter(new PrintWriter(sw));
      script = "println('To powinno pójœæ na nowy Writer');";
      engine.eval(script);

      JOptionPane.showMessageDialog(null, sw.toString());</pre>W rezultacie poka¿e siê okienko dialogowe (komunikatów) z napisem "To powinno pójœæ na nowy Writer".<br><i><br></i><a name="DynJav.27"></a><h2><span style="font-weight: bold;">4.5. Dostêp do obiektów Javy ze skryptów</span></h2><br>Motory skryptowe zgodne ze specyfikacj¹ JSR-223 umo¿liwiaj¹ w skryptach dostêp do klas z pakietów Javy.<br>Szczegó³y (w tym sk³adnia wywo³ania konstruktorów i&nbsp; metod) zale¿ne s¹ od implementacji jêzyka skryptowego.<br>Generalnie poslugujemy siê &nbsp;kwalifikowanymi nazwami klas (np. javax.swing.JFrame).<br>W jêzykach, które umo¿liwiaj¹ dodanie do przestrzeni nazw nazw pakietów i klas Javy mo¿na stosowac konstrukcjê typu import.<br><br>Oczywiœcie, mo¿emy te¿ odwo³ywaæ siê do naszych w³asnych klas - do ich publicznych metod.<br><br>Przyk³ady.<br><pre>public class SwingFromRhino {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("rhino");
    
    String script = engine.getFactory().getProgram(
        "importPackage (javax.swing)",
        "f = new JFrame('Okno')",
        "f.setSize(200,200)",
        "f.show()"
        );
    
    System.out.println(script);
    
    try {
      engine.eval(script);
    } catch (ScriptException e) {
      e.printStackTrace();
    }

  }

}</pre>Warto
zwróciæ uwagê na metodê z getProgram(String ...) interfejsu
ScriptEngineFactory, która zwraca gotowy do wykonania&nbsp; program,
sk³adaj¹cy siê z indtrukcji podanych jako argumenty, zgodnie ze
sk³adni¹ danego jêzyka skryptowego.<br><br>W tym kontekœcie warto swpomnieæ te¿ o innych u¿ytecznych metodach pomocniczych interfejsu ScriptEngineFactory:<br><table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">
&nbsp;String</td>
<td>getMethodCallSyntax(String&nbsp;obj,
                    String&nbsp;m,
                    String...&nbsp;args)

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca napis,
który mo¿e byæ u¿yty w danym jêzyku skryptowym do wywolania metody
klasy Javy na rzecz obiektu&nbsp;<span style="font-style: italic;"></span></td>
</tr>


<tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%">
&nbsp;String</td>
<td>getOutputStatement(String&nbsp;toDisplay)

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca napis,
który mo¿e byæ u¿yty jako instrukcja danego jêzyka skryptowego do
wyprowadzenia napisu toDisplay</td></tr></tbody></table><br><br>Przyk³ad.<br><pre>class Person {
  String name;

  public Person(String name) {
    super();
    this.name = name;
  }


  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }

}

public class Groovy2 {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");
    try {

      Person p = new Person("Ala");
      String call = engine.getFactory().getMethodCallSyntax("p", "setName", "\"Pies\"");

      System.out.println(call);
      engine.put("p", p);

      engine.eval(call);
      System.out.println(p.getName());

      String out = engine.getFactory().getOutputStatement(p.getName());
      System.out.println(out);
      engine.eval(out);

    } catch (ScriptException e) {
      e.printStackTrace();
    }

  }

}</pre><br>Wynik:<br><div class="listing100"><br>p.setName("Pies")<br>Pies<br>println("Pies")<br>Pies<br></div><br><br><br><a name="DynJav.28"></a><h2>4.6. Przyk³ad: programowanie skryptowe na zmiennych aplikacji</h2><br>W poni¿szym programie przedstawiono:<br><ul><li>automatyczne przekazywanie zmiennych aplikacji do œrodowiska skryptowego, w tym tablic,</li><li>wykonywanie na nich obliczeñ w skrypcie (w tym na tablicach),</li><li>uzyskiwanie wyników obliczeñ w aplikacji,</li><li>komunikacjê skryptu z elementami GUI (np. pole tekstowe).</li></ul>Wykonywany skrypt wygl¹da nastêpuj¹co:<br><pre>importPackage(javax.swing);
a = a + 1;
b = 33;
c = a + b;
sum = 0;
for (i in arr) { 
  arr[i] = arr[i]*2;
  sum += arr[i];
}
JOptionPane.showMessageDialog(null, "Suma = " + sum);
infoText.setText("Suma = " + sum);
</pre>przy czym zmienne a, b, c s¹ zmiennymi liczbowymi z aplikacji, arr - tablica z aplikacji, infoText - pole tekstowe z aplikacji.<br><br>Aplikacja ma nastêpuj¹c¹ postaæ:<br><pre>class Varman {
  
  private Object vars;
  private Bindings bindings;
  private Field[] fields;
  
  public Varman(Bindings bindings, Object vars) {
    this.vars = vars;
    this.bindings = bindings;
    fields = vars.getClass().getDeclaredFields();
    for (int i = 0; i &lt; fields.length; i++) {
      try {
        String name = fields[i].getName();
        if (name.indexOf("this$") != -1) continue;
        Object value =  fields[i].get(vars);
        bindings.put(name, value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
  }
  
  public void getVars() {
    for (int i = 0; i &lt; fields.length; i++) {
      String name = fields[i].getName();
      if (name.indexOf("this$") != -1) continue;      
      Object value =  bindings.get(name);
      try {
        fields[i].set(vars, value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
  }
  
  public String getVarsPageView() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; fields.length; i++) {
      try {
        String name = fields[i].getName();
        if (name.indexOf("this$") != -1) continue;
        Object value = fields[i].get(vars);
        if (fields[i].getType().isArray()) {
          StringBuilder tmp = new StringBuilder("{ ");
          tmp.append(Array.get(value, 0));
          for (int j=1; j &lt; Array.getLength(value); j++) tmp.append(", ").append(Array.get(value, j));
          tmp.append(" }");
          value = tmp;
        }
        sb.append('\n').append(name).append(" = ").append(value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
    return sb.toString();
  }
}


public class CalcJs1 {

  private ScriptEngineManager manager = new ScriptEngineManager();
  private ScriptEngine engine = manager.getEngineByName("rhino");
  private Bindings bindings = engine.createBindings();
  
  private class Var {
    double a = 7, b, c, d, e, f;
    int[] arr = { 1, 2, 3 };
  }
  
  public CalcJs1() {
    Var v = new Var();
    Varman vm = new Varman(bindings, v);
    showInfoFrame(bindings);
    try {
      engine.eval(new FileReader("testCalc.js"), bindings);
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (ScriptException e) {
      e.printStackTrace();
    }
    vm.getVars();
    JOptionPane.showMessageDialog(null, vm.getVarsPageView(), "Wyniki", 1);
    for (int i = 0; i &lt; v.arr.length; i++) {
      System.out.println("arr " +i+ " = " + v.arr[i]);
    }
  }  
  
  private void showInfoFrame(Bindings bindings) {
    JFrame f = new JFrame("Wyniki");
    JTextField tf = new JTextField("Na razie nie ma wyniku               ");
    f.add(tf);
    f.pack();
    f.setLocation(600, 300);
    f.setVisible(true);
    bindings.put("infoText", tf);
  }

  public static void main(String[] args) {
    new CalcJs1();
  }
  

}</pre><br><br><a target="_self" href="mm/Prezent1.htm">Pokaz dzia³ania aplikacji</a>.<a href="mm/Prezent1.htm"><img style="border: 0px solid ; width: 100px; height: 80px;" alt="r" src="../STYLE/video2.gif"></a><br><br><br><a name="DynJav.29"></a><h2>4.7. Przyk³ad: wykorzystanie mo¿liwoœci JavaScript w apletach Javy</h2><br>W tym przyk³adzie stworzymy aplet, dostarczaj¹cy "eleganckiego" menu.<br>Jedna z opcji menu daje mo¿liwoœæ zmiany stylu strony.<br>Aby
uzyskaæ zmianê stylu wykorzystamy motor skryptowy dla natywnych
przegl¹darek (BrowserJS) i napiszemy odpowiedni skrypt js, który bêdzie
wykonywany po wyborze opcji w menu apletu.<br><br><a href="mm/Prezent2.htm" target="_self">Demonstracja dzia³ania</a><a href="mm/Prezent2.htm"><img style="border: 0px solid ; width: 100px; height: 80px;" alt="r" src="../STYLE/video2.gif"></a><br><br>Skrypt:<br><br><pre>function chgStyle(cssFile) {
  var link = document.getElementById("slink");
  link.setAttribute('href', cssFile);
}</pre>Aplet:<br><pre>import java.awt.*;
import java.awt.event.*;
import java.io.*;

import javax.script.*;
import javax.swing.*;

@SuppressWarnings("serial")
public class Konfigurator extends JApplet implements ActionListener {

  ScriptEngine engine;
  String[] cssFiles = { "style/first.css", "style/second.css", "style/third.css", "style/last.css" };
  String[] opis = { "Surowy", "Kolorowy", "Powiêkszony", "S³oneczny" };
  String script;

  @Override
  public void init() {
    ClassLoader myloader = getClass().getClassLoader();
    ScriptEngineManager manager = new ScriptEngineManager(myloader);
    engine = manager.getEngineByName("BrowserJS");
    engine.put("applet", this);
    
    BufferedReader br;
    StringBuilder sb = new StringBuilder();
    try {
      br = new BufferedReader(new FileReader("menu.js"));
      for (String line; (line = br.readLine()) != null;)
        sb.append(line).append('\n');
    } catch (IOException e1) {
      e1.printStackTrace();
    }
    
    script = sb.toString();
    
    JMenu[] menu = { new JMenu("Wygl¹d"), new JMenu("Spis treœci"), 
                     new JMenu("Wa¿ne linki"), new JMenu("Wyszukiwanie"),  new JMenu("Pomoc") }; 
    for (int i = 0; i &lt; opis.length; i++) {
      JMenuItem mi = new JMenuItem(opis[i]);
      mi.setActionCommand(cssFiles[i]);
      mi.addActionListener(this);
      menu[0].add(mi);
    }
     
    JMenuBar mb = new JMenuBar();
    for (int i = 0; i &lt; menu.length; i++) {
      if (i == menu.length-1) mb.add(Box.createHorizontalGlue());
      mb.add(menu[i]);
      menu[i].addMouseListener(new MouseAdapter() {
        Color back; 
        @Override
        public void mouseEntered(MouseEvent e) {
          Component c = e.getComponent();
          back = c.getForeground();
          c.setForeground(Color.BLUE);
        }

        @Override
        public void mouseExited(MouseEvent e) {
          e.getComponent().setForeground(back);
        }
        
      });
    }

    this.setJMenuBar(mb);
  }
  
   public void actionPerformed(ActionEvent e) {
        try {
          String name = e.getActionCommand();
          engine.eval(script);
          if (engine instanceof Invocable) {
            Invocable inv = (Invocable) engine;
            inv.invokeFunction("chgStyle", name);
          }
          else JOptionPane.showMessageDialog(null, "Engine not invocable");
        } catch (Exception exp) {
          throw new RuntimeException(exp);
        }
  }
   
}</pre><br><br>
<hr>
<a name="DynJav.30"></a><h2>5. Zadania i æwiczenia</h2><br>Bêd¹ podane w trakcie semestru
<br>
<hr>

</body></html>