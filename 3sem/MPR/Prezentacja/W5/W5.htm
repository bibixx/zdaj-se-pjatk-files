<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN"><html><head rel="stylesheet" type="text/css" href="../style/common.css">
 <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
 <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]"><title>F2</title>
 <link rel="stylesheet" type="text/css" href="../style/common.css">
 <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script></head><body bgcolor="#efefef">
<div align="Center"><a name="W8"></a><a name="W5"></a><a name="W5"></a><h1>5. Programowanie klient-serwer z u¿yciem gniazd i protoko³ów sieciowych</h1></div>
<hr><a name="W5.1"></a><a name="W5.1"></a><h2>5.1. Architektura klient-serwer i sieæ.</h2>
Architektura klient-serwer jest technologi¹ budowy systemów informatycznych,
polegaj¹c¹ na podziale systemu na wspó³dzia³aj¹ce ze sob¹ dwie kategorie
programów lub procesów: klientów i serwerów. <br>
<br>
<div class="def"><b>Klient</b> to program lub proces, który - oprócz wykonywania swoistych dla
niego dzia³añ -  ³¹czy siê z innym programem lub procesem, zwanym serwerem
i poprzez kana³y komunikacyjne zleca mu wykonanie okreœlonych dzia³añ; w
szczególnoœci dostarczenia jakichœ danych lub wyników przetwarzania danych</div><br>
<br>
<div class="def"><b>Serwer</b> jest programem lub procesem, który - na zlecenie klientów - œwiadczy
okreœlone us³ugi - np. dostarcza im dane lub wyniki przetwarzania jakichœ
danych</div><br>
<br>
<br><b>Pojêcie "klient-serwer" jest natury software'owej,
a nie hardware'owej. </b><br>
Mechanizmy IPC (semafory, potoki, dzielone obszary pamiêci) - ró¿ne implementacje.<br>
<br>
Œrodowiska rozproszone: <ul><li>mo¿liwoœæ podzia³u pracy pomiêdzy ró¿nymi maszynami odpowiednio do ich potencja³u i efektywnoœci,</li>
  <li>mo¿liwoœæ uzyskiwania us³ug serwera na odleg³oœæ,</li>
  <li>dane mog¹ byæ prowadzone w sposób scentralizowany (na serwerze) co zapewnia spójnoœæ i bezpieczeñstwo,</li>
  <li>mog¹ te¿ byæ przechowywane w sposób rozproszony pomiêdzy róznymi loakalizacjami
geograficznymi (ró¿nymi serwerami i/lub klientami w ró¿nych miejscach), co
zmniejsza ryzyko utraty danych przy awariach.</li>
</ul>
Wraz z rozpowszechnieniem œrodowisk rozproszonych (sieci) pojawi³a siê potrzeba
swoistej unifikacji mechanizmów IPC, tak by mog³y byæ stosowane w jednolity
sposób do komunikacji  klientów i serwerów dzia³aj¹cych na dowolnych komputerach
w sieci (równie¿ na jednym i tym samym komputerze).<br>
<br>Oczywiœcie, komunikacja wymaga przestrzegania pewnych regu³. Regu³y te s¹ definiowane przez protoko³y.<br>
<br>
<div class="def"><b>Protokó³</b> - to swoisty jêzyk i zasady za pomoc¹ których komunikuj¹ siê programy i procesy, w szczególnoœci serwery i klienci</div><br>
<br>
Protoko³y interakcji sieciowej s¹ podzielone na warstwy, które wyznaczaj¹
poziomy komunikacji. Dziêki temu z³o¿ony problem interakcji sieciowej jest
podzielony na podproblemy, za rozwi¹zywanie których odpowiadaj¹ protoko³y
poszczególnych warstw.<br>
<br>
Ogólny standard tego podzia³u  tzw.  model  ISO-OSI (OSI -Open Standards Interconnect).<br>
<p>Model OSI sk³ada siê z  siedmiu warstw:</p>
<table cellspacing="0" cellpadding="0" align="Center" border="0">
<tbody><tr><td bgcolor="#666666"><table cellspacing="2" cellpadding="2" border="0" bgcolor="#ffffcc"><tbody><tr align="Center" bgcolor="#cccccc"><td align="Center" colspan="3" bgcolor="#ffffff"><p><strong>Komputer 1</strong></p></td><td bgcolor="#ffffcc"> </td><td valign="Bottom" colspan="3" bgcolor="#ffffff"><p><strong>Komputer 2</strong></p></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Wa
rstwa aplikacji</font></td><td valign="Bottom" rowspan="6" bgcolor="#ffffcc"><font color="#000000"><img height="110" src="images/v-arrow-r.gif" width="8">
            </font></td><td bgcolor="#ffffcc"><font color="#000000"><img height="7" src="images/h-arrow.gif" width="30">
            </font></td><td valign="Bottom" rowspan="6" bgcolor="#ffffcc"><font color="#000000"><img height="110" src="images/v-arrow-r.gif" width="8">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa aplikacji</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa prezentacji</font></td><td bgcolor="#ffffcc"><font color="#000000"><img height="7" src="images/h-arrow.gif" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa prezentacji</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sesji</font></td><td bgcolor="#ffffcc"><font color="#000000"><img height="7" src=
"images/h-arrow.gif" width="30" alt="r">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sesji</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">||</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa transportowa</font></td><td bgcolor="#ffffcc"><font colo
="" r="#000000"><img height="7" src="images/h-arrow.gif" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa transportowa</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">||</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">|||</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sieci</font></td><td bgcolor="#ffffcc"><font co
="" lor="#000000"><img height="7" src="images/h-arrow.gif" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sieci</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">|||</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">|||||</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa ³¹cza danych
                        </font></td><td bgcolor="#ffffcc"><font color="#000000"><img height="7" src="images/h-arrow.gif" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa ³¹cza danych</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">|||||</font><font color="#000000">dane</font></td></tr><tr align="Center" bgcolor="#cccccc"><td align="Right" bgcolor="#ffffff"><font color="#000000">||||||</font><font color="#000000">dane</font></td><td align="Center" bgcolor="#ffffff"><font color="#000000">Warstwa fizyczna</font></td><td colspan="3" bgcolor="#ffffcc"><font color="#000000"><img heigh
="" t="7" src="images/h-arrow-r.gif" width="52"></font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa fizyczna</font></td><td align="Right" bgcolor="#ffffff"><font color="#000000">||||||</font><font color="#000000">dane</font></td></tr></tbody></table></td></tr></tbody>
</table>
<p></p><p></p>
<ol>
<li>aplikacje, dzia³aj¹ce na dwóch komputerachw  sieci (klient i serwer) wymieniaj¹ dane.
                </li><li>kolejne protoko³y w kolejnych warstwach dodaj¹
nag³ówki do danych otrzymywanycyh z warstwy powy¿ej. Dane opakowane w nag³ówki
s¹ transmitowane w tzw.  <font color="#ff0000"><font color="#000000">Protocol
                Data Units</font> </font>(PDUs). 
                </li><li>PDU s¹ przesy³ane w dó³ sekwencji warstw i transmitowane
fizycznie przez warstwê fizyczn¹, która reprezentuje fizyczne po³¹czenie
w sieci.
                </li><li>Dane otrzymane s¹ przesy³ane "w górê" warstw i "odpakowywane" z kolejnych nag³ówków.
                </li>
</ol>
Jedn¹ z mo¿liwych, a przy tym obecnie czêsto wystêpuj¹c¹ realizacjê tego modelu przedstawia poni¿szy rysunek.<br>
<br>
<img src="images/osi2.jpg" alt="r" width="645" height="461" border="1">
<br>
<br>
<br>
<a name="W5.2"></a><a name="W5.2"></a><h2>5.2. Gniazda.</h2>
<br>
Jak widaæ z poprzedniego rysunku  komunikacja pomiêdzy procesami w sieci
mo¿e  odbywaæ siê za pomoc¹ jednego z wysokopoziomowych protoko³ów sieciowych
(HTTP, FTP itp.), a  tak¿e bardziej zaawansowanych mechanizmów takich jak
zdalne wywo³anie metod (RMI, CORBA), zdalne wywo³anie procedur (RPC), czy
SOAP (pozwalaj¹cy na zdalne wolanie metod i procedur - inaczej: zlecanie
us³ug - za pomoc¹ przekazywania odpowiednio ustrukturyzowanych plików XML
z zapisem "zadañ do wykonania").<br>
<br>
U podstaw wymiany informacji za pomoc¹ protoko³ów najwy¿szego poziomu le¿y obecnie (najczêœciej) komunikacja za pomoc¹ gniazd.<br>
<br>
<div class="def"><b>Gniazdo (socket)</b> - to abstrakcja programistyczna, oznaczaj¹ca punkt
docelowy dwustronnej komunikacji dwóch procesów dzia³aj¹cych równolegle w
sieci</div> <br>
<br>
To w³aœnie koncepcja gniazd, wprowadzona w Uniksie w latach 70-tych, stanowi
wspomnian¹ wczeœniej, sieciowo-zorientowan¹, unifikacjê mechanizmu IPC.<br>Naturalne by³o
uczynienie  komunikacji za pomoc¹ gniazd w idei podobnej do dobrze znanego
programistom paradygmatu operacji wejœcia-wyjœcia. Zatem mamy to naturaln¹
sekwencjê: otwarcie kana³u komunikacji (gniazda), zapis lub odczyt (przes³anie
lub otrzymanie danych za pomoc¹ gniazda), zamkniêcie kana³u komunikacyjnego
(zamkniecie gniazda).<br>
<br>
Zwykle komunikacja za pomoc¹ gniazd implementowane jest na bazie protoko³u TCP lub protoko³u UDP.<br>
<br><b>
 Protokó³ TCP (Transport Control Protocol)</b> jest protoko³em po³¹czeniowym
(co znaczy, ¿e ustanawiana jest dwustronne po³¹czenie pomiêdzy klientem i
serwerem). Zapewnia, ¿e dane posy³ane poprzez gniazda docieraj¹ w ca³oœci
i w odpowiedniej kolejnoœci. Inaczeje mo¿emy powiedzieæ, ¿e realizowana jest
tu strumieniowa koncepeja wymiany danych, co oznacza, ¿e po ustanowieniu
po³aczenia mo¿na przes³aæ dane o dowolnym rozmiarze i - jak zobaczymy - operacje
wymiany danych mo¿emy wykonywaæ tutaj za pomoc¹ dobrze nam znanych œrodków
strumieniowych.<br>
<br><b>
Protokó³ UDP (User Datagrams Protocol)</b> jest protoko³em bezpo³¹czeniowym.
Dane przesy³ane s¹ pomiêdzy procesami jako datagramy (pakiety danych o okreœlonej
maksymalnej wielkoœci np. 64 kB), przy czym z ka¿dym datagramem posy³any
jest "adres" odbiorcy. Datagramy mog¹ wiêc przybywac na miejsce przeznaczenia
(do innego procesu) w dowolnje kolejnoœci (a niektóre nawet mog¹ w ogóle
nie dotrzeæ). <br>
<br>
Oba protoko³y (TCP i UDP) s¹ protoko³ami typu "point-to-point", czyli ka¿dorazowo
zapewniaj¹cymi komunikacjê tylko pomiêdzy dwoma procesami (w szczególnoœci
na dwóch ró¿nych maszynach w sieci). <br>

Istnieje równie¿ mo¿liwoœæ u¿ycia tzw. <b>multicastingu</b>. Ten rodzaj protoko³ów
oznacza dystrybucje informacji z serwera od razu do wielu klientów. Oparty
jest on na protokole UDP. <br>
<br>
Identyfikacji maszyn bior¹cych udzia³
w komunikacji (tzw. hostów) s³u¿y protokól IP (Internet Protocol). Adresy
IP maj¹ ogólnie formê 32-bitowych (lub 128-bitowych w wersji IPv6) liczb i mog¹ byæ zapisywane jako sekwencja
czterech (oœmiu)  liczb rozdzielonych kropkami (np. 192.33.71.12) lub - w formie "strawniejszej",
wykorzystuj¹cej DNS (Domain Name Service) jako: nazwa_hosta.nazwa_domeny
(np. boulder.ibm.com).<br><br>
Identyfikacja hosta jest jednak nie wystarczaj¹ca dla komunikacji miedzy
procesami: na danym komputerze mo¿e siê przecie¿ wykonywaæ równolegle wiele procesów.<br><br>
<div class="notel">Termin port u¿ywany jest rownie¿ w innych znaczeniach, dotycz¹cych fizycznego
³¹czenia urz¹dzeñ np. port szeregowy czy USB</div>Po to, by dane dotar³y do okreœlonego
procesu protoko³y TCP i UDP pos³uguj¹ siê tzw. <b>portami</b>. <br>
Porty s¹ identyfikowane przez 16-bitowe liczby - numery portów. Numery te
s¹ u¿ywane przez TCP lub UDP do przesy³anie danych do odpowiedniego procesu.<br>
<br>
W proko³ach po³¹czeniowych (takich jak TCP) proces-serwer przydziela sobie
port o okreœloneym numerze i poprzez ten w³aœnie port procesy klienckie mog¹
ustanawiaæ po³¹czenia z serwerem.<br>
<br>
<img src="images/2tcp.gif" alt="r" width="302" height="60" border="1">
<br>
<br><br>
<br>
W protoko³ach opartych na datagramach, pakiety datagramów zawieraj¹ numer
portu dziêki któremy dane kierowane s¹ do w³aœciwego procesu (aplikacji).<br>
<br>
<img src="images/3tcpudp.gif" alt="r" width="334" height="169" border="1">
<br>
<br><br>
<br>Teraz zajmiemy siê tylko najprostszym TCP.<br>
Inne:<br>
<ul>
  <li>multicasting
(w Javie - klasa MulticastDatagramSocket) </li>
  <li>bezpieczn¹ transmisja danych opart¹ na protokole SSL/TSL (Secure Socket
Layer/Transport Secure Layer). </li>
</ul>

<b>
Typowa interakcja pomiêdzy klientem i serwerem opiera siê na nastêpuj¹cym modelu</b>.<br>
<br>
<ol>
  <li>Serwer tworzy gniazdo zwi¹zane z okreœlonym portem i na tym kanale komunikacyjnym czeka na proœbê po³¹czenia od klienta.</li>
  <li>Inicjatywa po³¹czenia wychodzi od klienta; klient musi znaæ host serwera
oraz numer portu otwartego do przyjmowania po³¹czeñ i podaje tê informacjê
tworz¹c "u siebie" gniazdo zwi¹zane z tak okreœlonym adresem</li>
  <li>Serwer akceptuje po³aczenie od klienta i - aby pozostaæ dostêpnym dla
innych klientów na "kanale po³¹czeniowym" - tworzy inne gniazdo do komunikacji
z danym klientem; </li>
  <li>Z punktu widzenia klienta jest to (zazwyczaj) to samo gniazdo na którym zainicjowano
po³¹czenie; strumienie wejœciowy i wyjœciowy zwi¹zane z tym gniazdem s³u¿¹
do komunikacji pomiêdzy klientem i serwerem zgodnie z protoko³em serwera.</li>
</ol>
<br>
Ilustruje to poni¿szy rysunek.<br>
<img src="images/sockets1.jpg" alt="r" width="610" height="315" border="1">
<br>
<br>
Jest to oczywiœcie ogólny model. Niektóre protoko³y mog¹ wprowadzaæ pewne odstêpstwa<br>
 od niego. Przyk³adem jest protokól FTP, gdzie do komunikacji z serwerem
wykorzystywane s¹ dwa gniazda: do posy³ania poleceñ i do posy³ania/odczytywania
danych.<br>
<br>
Zatem pos³ugujemy siê dwoma rodzajami gniazd:<br>
<ul>
  <li>gniazdami serwerowymi, w Javie  reprezentowanymi przez klasê <b>ServerSocket</b>, u¿ywanymi przy programowaniu serwerów,</li>
  <li>gniazdami klienckimi, w Javie reprezentowanymi przez klasê <b>Socket</b>,
u¿ywanymi w  programowaniu klientów, a w serwerach do komunikacji z klientem
po zaakceptowaniu po³¹czenia od niego.</li>
</ul><a name="W5.3"></a><a name="W5.3"></a><h2>5.3. Klienci. Protoko³y i porty</h2>W Javie oprogramowanie klienta, komunikuj¹cego sie z serwerem - w wiêkszoœci przypadków - jest niezwykle proste i polega na:<br>

<ol>
  <li>Utworzeniu gniazda - obiektu klasy Socket, daj¹cego po³¹czenie  z serwerem.</li>
  <li>Uzyskaniu od tego obiektu strumieni wyjœciowego i wejœciowego, zwi¹zanych z gniazdem.</li>
  <li>Posy³anie zleceñ dla serwera poprzez zapis do strumienia wyjœciowego gniazda.</li>
  <li>Odczytywanie odpowiedzi serwera poprzez odczyt ze strumienia wejœciowego.</li><li>Zamkniêcie strumieni.</li>
  <li>Zamkniêcie gniazda<br>
  </li>

</ol><div class="syntax"><br>
<div align="Center"><b>Najprostszy schemat komunikacji klienta z serwerem przez gniazda  </b><br>
</div>
<br>
try {<br>
  // Utworzenie gniazda<br>
  String serverHost = ... ; // adres IP serwera ("cyfrowo" lub z u¿yciem DNS)<br>
  int serverPort = ... ;      // numer portu na którym nas³uchuje serwer  <br><br>
  Socket socket = new Socket(serverHost, serverPort)<br>
  <br>
  // Uzyskanie strumieni do komunikacji<br>
  OutputStream sockOut = socket.getOutputStream();<br>
  InputStream  sockIn = socket.getInputStream();<br>
<br>
  // Komunikacja (zale¿na od protoko³u)<br>
  <br>
  // Wys³anie zlecenia do serwera<br>
  sockOut.write(...);<br>
    ...<br>
<br>
  // Odczytanie odpowiedzi serwera<br>
  sockIn.read(...);<br>
   ...<br>
<br>
  // Po zakoñczeniu komunikacji - zamkniecie strumieni i gniazda<br>
  sockOut.close();<br>
  sockIn.close();<br>
  socket.close();  <br>
<br>
} catch (UnknownHostException exc) {<br>
    // nieznany host<br>
} catch (SocketException exc) {<br>
    // wyj¹tki zwi¹zane z komunikacj¹ przez gniazda<br>
} catch (IOException exc) {<br>
    // inne wyj¹tki we/wy<br>
}<br>
<br>
Uwaga: zazwyczaj strumienie zwi¹zane z gniazdem bêdziemy opakowywaæ, zapewniaj¹c
okreœlone rodzaje przetwarzania (np. buforowanie, kodowanie-dekodowanie,
odczyt/zapis danych binarnych itp.).    <br>
</div><br>
 <br>
W komunikacji pomiêdzy klientem i serwerem kluczow¹ spraw¹ jest znajomoœæ
protoko³u (czyli rodzajów i formatów zleceñ, które mo¿na pos³aæ do serwera
oraz treœci i formatów odpowiedzi, które serwer przyszy³a w reakcji na konkretne
zlecenia). <br>
<br><br>
Istniej¹  pewne standardowe protoko³y, dziêki którym uzyskujemy dostêp
do ró¿norodnych us³ug w Internecie. Do najbardziej znanych (a czasem i  u¿ytecznych)
nale¿¹ protoko³y:<br>
<ul>
  <li> HTTP (Hypertext Transfer Protocol) s³u¿¹cy m.in. do uzyskiwania dostêpu
do stron WWW oraz przesy³ania fromularzy (jego wersja HTTPS, oparta na protokole
TSL/ SSL - Transport Security Layer/Secure Sockets Layer - pozwala na bezpieczn¹
transmisjê danych),</li>
  <li>
FTP (File Transfer Protocol) s³u¿¹cy do pobierania/zapisywania plików (i jego bezpieczna wersja oparta na TSL/SSL - FTPS) </li>
  <li>
SMTP (Simple Mail Transfer Protocol)  s³u¿¹cy do przesy³ania poczty elektronicznej (ESMPT -  SMPT z rozszerzeniami).</li>
  <li>POP3 (Post Office Protocol) s³u¿¹cy do pobierania poczty z serwera </li>
  <li>IMAP (Internet Message Access Protocol) j.w., z dodatkowymi mo¿liwoœciami.</li>
  <li>TELNET - umo¿liwiaj¹cy zdaln¹ prace na komputerze-hoœcie</li>
  <li>TIME  - proste uzyskiwanie aktualnego czasu od serwerów czasu</li>
  <li>DAYTIME - proste uzyskiwanie daty i czasu</li>
  <li>NTP (Network Time Protocol) - zaawansowane mo¿liwoœci uzyskiwania dok³adnego czasu</li>
  <li>NNTP (Network News Transfer Protocol) - przesy³anie, dystrybucja i odbiór wiadomoœci z tzw. newsgroups.</li>
  <li>IRC - Internet Relay Chat - znane wszystkim internetowe "czaty",</li>
  <li>ECHO -  "odbijaj¹cy" dane posy³ane przez klienta (s³u¿y g³ównie do celów testowania klientów)</li>
  <li>DICT - wyszukiwanie definicji w bazach s³ownikowych.</li>
</ul>

Protoko³y te (a zatem format zleceñ klienta i odpowiedzi serwera, kolejnoœæ
wymiany informacji itp.) s¹ szczegó³owo opisane w dokumentach RFC (Request
For Comments). Dokumenty RFC opisuj¹ technologiczne i organizacyjne aspekty
Internetu. Od 1969 roku opublikowano prawie 4000 dokumentów RFC. Wiele z
nich uzyska³o status standardu (m.in. prawie wszystkie opisuj¹ce w/w protokoly).
Standartyzacj¹ protoko³ów internetowych zajmuj¹ siê nastêpuj¹ce organizacje:<br>
IETF - The Internet Engineering Task Force - http://www.ietf.org/home.html<br>
IESG - The Internet Engineering Steering Group<br>
IANA - Internet Assigned Numbers Authority (http://www.iana.org/), która
m.in. ustala ró¿nego rodzaju parametry protoko³ów, np. numery portów, czy
nazwy zbiorów znaków.<br>
<br>
Przyjête jako standardy dokumenty RFC (Official Internet Protocol Standards),
w szczególnoœci opisuj¹ce protoko³y, mo¿na znaleŸæ na stronie: http://www.rfc-editor.org/rfc.html.
Uzyskamy tam równie¿ dostêp do bazy danych wszystkich dokumentów RFC. <br>
<br>
Tworz¹c program kliencki, który ma komunikowaæ siê z serwerem, musimy  (oczywiœcie) wiedzieæ na jakim hoœcie
dzia³a serwer i przez jaki port mo¿emy siê z nim skontaktowaæ.<br>
<br>
Z serwerami udostêpniaj¹cymi opisane wczeœniej protoko³y-us³ugi (oprócz serwerów
DICT) ³¹czymy siê przez tzw. <b>dobrze-znane-porty</b>. "Dobrze-znane-porty" maj¹
zarezerwowane numery od <b>0 do 1023</b> (tych numerów nie powinniœmy przydzielaæ swoim
serwerom). Porty o numerach 1024-49151 s¹ natomiast tzw. portami zarejestrowanymi.
Tych numerów mo¿emy u¿ywaæ, ale nale¿y liczyæ siê z tym, ¿e wybrany przez
nas numer mo¿e byæ "zarejestrowany" - czyli jego u¿ycie opisane  publicznie
jako skojarzone z jakimœ protoko³em. Przyk³adem jest protokól DICT, któremu
przypisano port 2628.<br>
Pozosta³y zakres numerów portów 49152-65535 okreœla tzw. porty dynamiczne lub prywatne. Mo¿emy ich u¿ywac.<br>
<br>
Ka¿dy ze standardowych protoko³ów (a œciœlej ka¿dy z serwerów realizuj¹cych
dany protokó³) ma œciœle okreœlony port kontaktowy, za pomoc¹ którgo klient
nawi¹zuje po³¹czenie. Numery portów okreœla standard IANA - mo¿na je znaleŸæ
na stronie: http://www.iana.org/assignments/port-numbers.<br>
<br>
W poni¿szej tabeli pokazano niektóre standardowe numery portów.<br>
<br>
<br>

		
<table border="1" width="468">
<tbody><tr><th>Numer portu
			</th><th>Protokó³
			</th></tr><tr><td>7</td><td>ECHO</td></tr><tr><td>20</td><td>FTP -- Dane</td></tr><tr><td>21</td><td>FTP -- Polecenia<br>
 Uwaga: protokól FTP posluguje siê dwoma portami (a w konsekwencji dwoma
gniazdami): jednym dla przekazywania poleceñ, drugim - dla transferu plików).
W zale¿noœci od trybu p[rort danych mo¿e mieæ numer 20, albo inny.  <br>
</td></tr><tr><td>22</td><td>SSH Remote Login Protocol</td></tr><tr><td>23</td><td>Telnet</td></tr><tr><td>25</td><td>Simple Mail Transfer Protocol (SMTP)</td></tr><tr><td>37</td><td>Time</td></tr><tr><td>70</td><td>Gopher ("przodek" HTTP)<br>
Uwaga: jest jeszcze trochê dzia³aj¹cych serwerów Gopher m.in. w Kanadyjskim Urzêdzie Statystycznym<br>
</td></tr><tr><td>80</td><td>HTTP</td></tr><tr><td>110</td><td>POP3</td></tr><tr><td>119</td><td>Newsgroup (NNTP)</td></tr><tr>
      <td valign="Top">123<br>
      </td>
      <td valign="Top">Network Time Protocol (NTP)<br>
      </td>
    </tr>
<tr><td>143</td><td>Internet Mail Access Protocol (IMAP)</td></tr><tr><td>194</td><td>Internet Relay Chat (IRC)</td></tr><tr><td>443</td><td>HTTPS (HTTP w oparciu o TSL/SSL)</td></tr><tr>
      <td valign="Top">989<br>
      </td>
      <td valign="Top">FTPS (w oparciu o TSL/SSL) - dane<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">990<br>
      </td>
      <td valign="Top">FTPS (w oparciu o TSL/SSL) - polecenia<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">992<br>
      </td>
      <td valign="Top">Telnets (Telnet w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">993<br>
      </td>
      <td valign="Top">IMAPS (IMAP4 w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">994<br>
      </td>
      <td valign="Top">IRCS (IRC w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">995<br>
      </td>
      <td valign="Top">POP3S (POP3 w oparciu o TSL/SSL)<br>
      </td>
    </tr>
<tr><td>2628</td><td>DICT</td></tr></tbody>
</table>
<br> Zanim przeanalizujemy nieco bardziej rozbudowane przyk³ady programów
klienckich warto przyjrzeæ najprostszym ilustracjom, i na ich  przyk³adach
poznaæ pewne cechy gniazd. Zaczniemy od protoko³u DAYTIME, zgodnie z którym
- zaraz po po³¹czeniu - serwer przesy³a klientowi aktualn¹ date i czas, po
czym zamyka po³¹czenie. Format odpowiedzi nie jest przez RFC okreœlony, jednak
ka¿dy serwer dostarcza  informacji o sk³adni komunikatu, zawieraj¹cego datê
i czas.<br>
<br>
W najprostszej postaci  program odczytuj¹cy datê i czas z serwera czasu  mo¿e wygl¹daæ tak.<br>
<pre>
import java.net.*;
import java.io.*;

class DateTime1 {

  public static void main(String[] args) {

    String host = null;
    int port = 13;

    try {
      host = args[0];  // host - jako argument wywo³ania

      // Utworzenie gniazda
      Socket socket = new Socket(host, port);

      // Pobranie strumienia wejœciowego gniazda
      // Nak³adamy dekodowanie i buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             <b>socket.getInputStream()</b>
                             )
                          );

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // Zamkniêcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

}
</pre>
<br>
Po uruchomieniu w wierszu poleceñ np. z argumentem <b>time.nist.gov</b> uzyskamy odpowiedŸ w nastêpujacej postaci:<br>
<div class="listing100"><br>
52943 03-10-31 22:06:50 00 0 0 223.2 UTC(NIST) *<br>
</div><br>
Uwaga: wyjaœnienie szczegó³ów sk³adni tej odpowiedzi mo¿na znaleŸæ na stronie www.time.nist.gov.<br>
<br>
<a name="W8.4"></a><a name="W5.4"></a><a name="W5.4"></a><h2>8.4. Adresowanie i wyj¹tki przy próbie po³¹czenia z serwerem</h2>
Przy tworzeniu gniazda adresy hostów mo¿na podawaæ w postaci tekstowej (w formie DNS lub w formie "liczbowego" adresu IP).<br>
Np.<br>
<br>
Socket socket = new Socket("time.nist.gov", 13);<br>
lub<br>
Socket socket = new Socket("192.43.244.18", 13);<br>
<br>
Te formy konstruktorów klasy Socket zapewniaj¹ nie tylko utworzenie gniazda, ale równie¿ próbê po³¹czenia z serwerem.<br>
Podany serwer mo¿e nie istnieæ, mo¿e istnieæ ale nie zgodziæ siê na po³¹czenie,
mo¿e siê te¿ zdarzyæ ¿e przekroczony zostanie maksymalny czas oczekiwania na uzyskanie
po³¹czenia. Wszystkie te sytuacje s¹ sygnalizowane jako odpowiednie wyj¹tki.<br>
<br>
Pokazuje to poni¿szy przyk³ad, w którym staramy siê po³¹czyæ z ró¿nymi potencjalnymi
serwerami ECHO (serwery takie przyjmuj¹ jako zlecenie dowolny tekst, a ich
funkcj¹ jest zwrócenie tego samego tekstu - by³y kiedyœ powszechnie wykorzystywane
do testowania, teraz jednak, ze wzglêdów bezpieczeñstwa, porty s¹ blokowane
i raczej trudno jest znaleŸæ jakiœ dzia³aj¹cy echo-serwer).<br>
<br>
<pre>
import java.io.*;
import java.net.*;

public class EchoClient {

  final static int ECHO_PORT = 7;
  private Socket sck;
  private PrintWriter out;
  private BufferedReader in;

  public EchoClient() {}

  public void connect(String host)
              throws UnknownHostException, IOException   {
    sck = new Socket(host, ECHO_PORT);
    in = new BufferedReader (
            new InputStreamReader(sck.getInputStream()));
    out = new PrintWriter (
            new OutputStreamWriter(sck.getOutputStream()), true);
    System.out.println("Po³¹czony z hostem:" + sck.getInetAddress() );
  }

  public void echoMsg(String msg) throws IOException {
    out.println(msg);
    String response = in.readLine();
    System.out.println("Klient: " + msg);
    System.out.println("Serwer: " + response);
  }

  public void disconnect() throws IOException  {
    in.close();
    out.close();
    sck.close();
  }



  public static void main(String[] args) {
    String[] hosts = { "aeneas.mit.edu",
                       "cs.toronto.edu",
                       "cs.utah.edu",
                       "web.mit.edu",
                       "boulder.ibm.com",
                       "somethin"
                     };
    int i = 0;
    EchoClient ec = new EchoClient();
    for (; i&lt;hosts.length; i++) {
      try {
        ec.connect(hosts[i]);
        ec.echoMsg("Dzieñ dobry!");
        ec.disconnect();
      } catch(UnknownHostException exc) {
          System.out.println("Nieznany host: " + hosts[i]);
      } catch(IOException exc) {
          System.out.println(hosts[i] + " - " + exc);
      }
    }
  }


}
</pre>
Program wyprowadzi nastêpuj¹c¹ informacjê:<br>
<div class="listing100"><br>
aeneas.mit.edu - java.net.ConnectException: Connection refused: connect<br>
cs.toronto.edu - java.net.ConnectException: Connection refused: connect<br>
cs.utah.edu - java.net.ConnectException: Connection timed out: connect<br>
web.mit.edu - java.net.ConnectException: Connection timed out: connect<br>
boulder.ibm.com - java.net.ConnectException: Connection timed out: connect<br>
Nieznany host: somethin<br>
</div><br>
<br>
Zauwa¿my:<br>
<ul>
  <li>wyj¹tki powstaj¹ce przy braku mo¿liwoœci po³¹czenia s¹ klasy ConnectException (i jest to podklasa IOException),</li>
  <li>wadliwy (nieistniej¹cy) host zg³aszany jest w  formie wyj¹tku UnknownHostException,</li>
</ul>
Istnieje jeszcze inny sposób tworzenia gniazd i u¿ycia adresów internetowych. <br>
Mo¿emy w tym celu wykorzystaæ klasy InetAddress i InetSocketAddress.<br>
<br>
Obiekty klasy InetAddress reprezentuj¹ adresy IP (podklasa Inet4Address w
wersji 4, a podklasa Inet6Adrres w wersji 6 protoko³u IP) i zapewniaj¹ translacjê
adresów z postaci tekstowej do binarnej i odwrotnie. Adresy IP - obiekty
klasy uzyskujemy  stosuj¹c statyczne metody klasy m.in.<br>
<ul>
  <li>InetAddres InetAddress.getByName(nazwa_hosta) - zwraca adres IP podanego hosta,</li>
  <li>InetAddress[] InetAddress.getAllByName(nazwa_hosta) - zwraca tablicê
adresów IP podanego hosta (nazwa hosta np. java.sun.com mo¿e byæ skojarzona
z kilkoma adresami IP, u¿ywanymi alternatywnie dla zmniejszania obci¹¿enia
serwerów).</li>
</ul>
Uwagi: <br>
<ul>
  <li>podaj¹c nazwê hosta w postaci DNS (np. java.sun.com) uzyskujemy rozwi¹zanie
referencji przez serwisy DNS (Domain Name Service) czy NIS (Network Information
Service); wywo³anie jest blokuj¹ce i ew. - dla nieistniej¹cego hosta mo¿e
powstaæ wyj¹tek UnknownHostException</li>
  <li>podaj¹c nazwê hosta w tekstowej postaci IP (np. "192.33.87.12") uzyskujemy tylko formalne sprawdzenie poprawnoœci adresu,</li>
  <li>podaj¹c null uzyskamy adres interfejsu loopback.</li>
</ul>
Referencje do obiektu klasy InetAddress mo¿emy podaæ przy tworzeniu gniazda np.<br>
<br>
<pre>
    String host = "time.nist.gov";
    int port = 13;

    try {
      // Utworzenie adresu
      InetAddress inetadr = InetAddress.getByName(host);

      // Utworzenie gniazda
      Socket socket = new Socket(inetadr, port);
     ....
    }
</pre>
<br>
Oprócz bardziej zaawansowanych dzia³añ na adresach sieciowych, klasa InetAdress
jest wykorzystywana przy tworzeniu "adresów gniazd" (adres IP + port), które
s¹ obiektami klasy InetSocketAddress. Te z kolei mog¹ byæ zastosowane do
odroczenia (odseparowania) ³¹czenia z serwerem od aktu utworzenia gniazda.<br>
<br>
Mo¿emy mianowicie najpierw utworzyæ "niezwi¹zane" gniazdo:<br>
<br><b>    Socket socket = new Socket();</b><br>
<br>
<br>
odpowiednie adresy:<br>
<br><b>    InetAdress inetadr = InetAddress.getByName(host);<br>
    InetSocketAddress conadr = new InetSocketAddress(inetadr, port);<br>
</b>
<br>
po czym w odpowiednim, wybranym momencie po³¹czyæ siê z serwerem:<br>
<br><b>    socket.connect(conadr);</b><br>
<br>
Dok³adniej obrazuje to poni¿szy fragment programu:<br>
<pre>
  public static void main(String[] args) {

    String host = "time.nist.gov";
    int port = 13;
    Socket socket = new Socket(); // utworzenie niezwi¹zanego gniazda

    try {
      // Utworzenie adresów
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po³aczenie z serwerem
      socket.connect(conadr);

      // Pobranie strumienia wejœciowego gniazda
      // Nak³adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // Zamkniêcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }
</pre>
Ten sposób programowania mo¿e sprzyjaæ lepszemu izolowaniu fragmentów kodu,
oka¿e siê tak¿e przydatny wtedy, gdy chcemy precyzyjnie okreœliæ maksymalny
czas oczekiwania na po³¹czenie.<br>
<br>
<a name="W8.5"></a><a name="W5.5"></a><a name="W5.5"></a><h2>5.5.  Limity czasu ³¹czenia i odczytu</h2>
Czasami przydatne jest okreœlenie maksymalnego czasu oczekiwania na po³¹czenie
z serwerem jak równie¿ masymalnego czasu oczekiwania na odczyt kolejnych
danych z serwera. Na przyk³ad - nie chcemy uzyskaæ informacji o czasie od serwera
czasu po up³ywie kilku sekund - chcemy mieæ raczej dok³adny, aktualny pomiar.<br>
<br>
Limit czasu na po³¹czenie (w milisekundach) specyfikujemy jako drugi argument
przeci¹¿onej metody connect. Gdybyœmy np. w poprzednim programie napisali:<br>
<pre>
socket.connect(conadr, 100);
</pre>
to nie uzyskanie po³¹czenia w ci¹gu 100 milisekund bêdzie skutkowa³o powstaniem wyj¹tku SocketTimeoutException np.<br>
<div class="listing100"><br>
java.net.SocketTimeoutException: connect timed out<br>
</div><br>
<br>
Innym limitem czasowym jest limit odczytu. Mo¿emy uzyskaæ po³¹czenie, ale
w komunikacji z serwerem (w trakcie czytania odpowiedzi serwera) mog¹ wyst¹piæ
jakieœ opóŸnienia, których nie chcemy zaakceptowaæ. Limity czasu na odczyt
specyfikujemy w milisekunadach za pomoc¹ metody <b>setSoTimeout(...)</b>
z klasy Socket. Ten limit okreœla maksymalny czas blokowania operacji czytania
strumienia wejœciowego gniazda. Po przekroczeniu tego czasu blokowanie na
wejœciu jest przerywane i powstaje wyj¹tek SocketTimedOutException. Gniazdo
i jego strumieñ wejœciowy mog¹ byæ ponownie u¿yte.<br>
Ustalenie limitu musi poprzedzaæ wprowadzanie jakiejkolwiek blokuj¹cego czytania strumienia gniazda.<br>
 <br>
Przyk³adowy program pokazuje, ¿e po uzyskaniu po³aczenia z serwerem czasu
odpowiedŸ (aktualny czas) uzyskujemy nie doœæ szybko (jak sobie tego ¿yczymy)   i powstaje
wyj¹tek SocketTimeoutException.<br>
<pre>
    try {
      // Utworzenie adresów
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po³aczenie z serwerem
      // Okreœlenie maksymalnego czasu oczekiwania na po³¹czenie
      socket.connect(conadr, 200);


      // Pobranie strumienia wejœciowego gniazda
      // Nak³adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );
      // Okreslenie maksymalnego czasu oczekiwania na odczyt danych z serwera
      <b>socket.setSoTimeout(50);</b>

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // Zamkniêcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

</pre>
<div class="listing100"><br>
java.net.SocketTimeoutException: Read timed out<br>
        at java.net.SocketInputStream.socketRead0(Native Method)<br>
        at java.net.SocketInputStream.read(SocketInputStream.java:129)<br>
        at sun.nio.cs.StreamDecoder$CharsetSD.readBytes(StreamDecoder.java:408)<br>
        at sun.nio.cs.StreamDecoder$CharsetSD.implRead(StreamDecoder.java:450)<br>
        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:182)<br>
        at java.io.InputStreamReader.read(InputStreamReader.java:167)<br>
        at java.io.BufferedReader.fill(BufferedReader.java:136)<br>
        at java.io.BufferedReader.readLine(BufferedReader.java:299)<br>
        at java.io.BufferedReader.readLine(BufferedReader.java:362)<br>
        at DateTime2.main(DateTime2.java:36)<br>
</div><br>
<br>
<a name="W8.6"></a><a name="W5.6"></a><a name="W5.6"></a><h2>5.6. Inne parametry gniazd kliencich.</h2>
<br>
Klasa Socket dostarcza wielu metod uzyskiwania informacji o stanie i opcjach gniazda. <br>
W syntetyczny sposób mo¿emy poznaæ je za pomoc¹ poni¿szego programiku, który
refleksyjnie wywo³uje publiczne metody get...() i is...() z klasy Socket.<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.lang.reflect.*;

class DateTime2 {

  public static void main(String[] args) {

    String host = "time.nist.gov";
    int port = 13;
    Socket socket = new Socket();

    try {
      // Utworzenie adresów
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po³aczenie z serwerem
      // Okreœlenie maksymalnego czasu oczekiwania na po³¹czenie
      socket.connect(conadr, 200);


      // Pobranie strumienia wejœciowego gniazda
      // Nak³adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );
      // Okreslenie maksymalnego czasu oczekiwania na odczyt danych z serwera
      socket.setSoTimeout(200);

      // Czego mo¿emy siê dowiedzieæ o stanie gniazda?
      report(socket);

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // Zamkniêcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

  // Dynamiczne wo³anie metod z klasy Socket
  static void report(Socket s) throws Exception {
    Method[] methods = (java.net.Socket.class).getMethods();
    Object[] args = {};
    for (int i=0; i&lt;methods.length; i++) {
      String name = methods[i].getName();
      if ((name.startsWith("get") || name.startsWith("is")) &amp;&amp;
          !name.equals("getChannel") &amp;&amp;
          !name.equals("getInputStream") &amp;&amp;
          !name.equals("getOutputStream")) {

        System.out.println(name + "() = " +
                           methods[i].invoke(s, args));
      }
    }
  }


}
</pre>

<br>
Program wyprowadzi:<br>
<div class="listing100"><br>
getPort() = 13<br>
isClosed() = false<br>
getInetAddress() = time.nist.gov/192.43.244.18<br>
getKeepAlive() = false<br>
getLocalAddress() = /61.120.87.131<br>
getLocalPort() = 1178<br>
getLocalSocketAddress() = /61.120.87.131:1178<br>
getOOBInline() = false<br>
getReceiveBufferSize() = 8192<br>
getRemoteSocketAddress() = time.nist.gov/192.43.244.18:13<br>
getReuseAddress() = false<br>
getSendBufferSize() = 8192<br>
getSoLinger() = -1<br>
getSoTimeout() = 200<br>
getTcpNoDelay() = false<br>
getTrafficClass() = 0<br>
isBound() = true<br>
isConnected() = true<br>
isInputShutdown() = false<br>
isOutputShutdown() = false<br>
getClass() = class java.net.Socket<br>
<br>
52944 03-11-01 00:36:14 00 0 0 913.5 UTC(NIST) * <br>
</div><br>
<br>Proszê sprawdziæ w dokumentacji znaczenie poszczególnych opcji.<br>
<a name="W5.7"></a><a name="W5.7"></a><h2>
5.7. Klient SMTP</h2><br>
<b>Protokó³ - to jest wa¿ne !!!</b><br>
<br>
Klient posy³a zlecenia w okreœlonej formie, serwer odpowiada wierszami danych,
w których na pocz¹tku znajduj¹ siê numeryczne kody, okreœlaj¹ce wynik przetworzenia
zlecenia, a po nich nastêpuj¹ werbalne (ró¿ne dla ró¿nych serwerów) informacje
(np. informacja o serwerze, s³ówko "Ok", ¿e wszystko w porz¹dku, lub napis
typu "go ahead"). Oczywiœcie, napisy mog¹ byæ w ró¿nych jêzykach; w przeciwieñstwie
do numetycznych kodów nie s¹ one okreœlone przez protokó³ SMTP i ka¿dy serwer
mo¿e opisywac wyniki swego dzia³ania w dowolny sposób.<br>
<br>
Wa¿na jest równie¿ kolejnoœæ zleceñ i odpowiedzi oraz to, by klient identyfikowa³
wyniki  zleceñ i odpowiednio do tego reagowa³ (np. nie ma sensu posy³ania
poczty,  je¿eli serwer zwraca wynik, œwiadcz¹cy o tym, ¿e transakcja nie mo¿e
dojœæ do skutku).<br><br>
<br>
<b>klient</b>: po³¹czenie przez port 25,<br>
<b>serwer:</b> kod potwierdzenia uzyskania po³¹czenia 220,<br>
<b>klient:</b> inicjacja komunikacji HELO lub EHLO (ESMPTP) + identyfikacja domeny,<br>
<b>serwer:</b> OK? - 250, nie - kody b³êdów (np. brak autoryzacji). Odp: wiele wierszy (nie wiadomo ile).<br>
<b>klient:</b> inicjacja transakci - MAIL, RCPT (odbiorcy)<br>
<b>serwer:</b> OK? - 250<br>
<b>klient:</b> posy³anie danych - polecenie DATA<br>
<b>serwer:</b> 354 (go ahead),<br>
<b>klient:</b> list (koniec listu: jedna kropka w wierszu, sic!)<br>
<b>serwer:</b> odebra³em? - 250<br>
i dalej nastêpne zlecenia (inne transakcje pocztowe itp.)<br>
Zamkniêcie kana³u przez klienta.<br>
<br><br>
Przyk³adowy program wysy³a listy, których zawartosæ pobierana jest z plików.
Przeslanie zleceñ do serwera - metoda doRequest(String
zlecenie, int checkCode). Zapisuje ona zlecenie do strumienia wyjœciowego
gniazda ³¹cz¹cego klienta z  serwerem SMTP, po czym wywo³uje
metodê readResponse(int checkCode), która odczytuje odpowiedŸ serwera. Przekazywany jako argument tej metody
checkCode jest spodziewanym (i wymaganym) kodem wyniku. Przy jego niezgodnoœci
z kodem odczytywanym ze strumienia wejœciowego gniazda (czyli przekazanym
przez serwer) zg³aszamy wyj¹tek IOException z komunikatem "Niespodziewany
kod wyniku".<br>
W obu metodach - doRequest i readResponse - wypisuejmy informacjê na konsole,
uzyskuj¹c w ten sposób prezentacjê komunikacji pomiêdzy klientem i serwerem.<br>
<br>
<pre>
import java.io.*;
import java.net.*;

public class EmailClient {

  Socket smtpSocket = null;
  PrintWriter sockOut = null;
  InputStream sockIn = null;

  public void connect(String server, String myDomain) {
    try {
      smtpSocket = new Socket(server, 25);
      sockOut = new PrintWriter(
             new OutputStreamWriter(smtpSocket.getOutputStream(), "UTF-8"),
             true);
      sockIn = smtpSocket.getInputStream();

      // Czy po³¹czenie zosta³o nawi¹zane?
      // Musi byæ kod 220 - wtedy Ok
      // Odczytuj¹c odpowied¿ serwera,
      // sprawdzamy w metodzie readResponse kod 220

      readResponse(220);

      // Przedstawiamy siê serwerowi
      // Jeœli nas zaakceptuje - poda kod 250
      doRequest("HELO " + myDomain, 250);


    } catch (UnknownHostException e) {
        System.err.println("Nieznany host: " + server);
        cleanExit(1);
    } catch (IOException exc) {
        System.err.println(exc);
        cleanExit(2);
    }
  }


  // Posy³anie maila
  public void send(String from, String to, String fname) {
    try {

      // Inicjacja transakcji
      // Kod 250 - jesli OK
      doRequest("MAIL FROM:&lt;" + from + "&gt;", 250);

      // Okreœlenie adresata
      // Kod 250 - jesli OK
      doRequest("RCPT TO:&lt;" + to + "&gt;", 250);

      // Posy³anie danych listu
      // OdpowiedŸ serwera - 354 = jestem gotowy na przyjêcie danych
      doRequest("DATA", 354);

      // Teraz bêdziemy zapisywaæ treœæ listu
      // bezpoœrednio do strumienia wyjœciowego gniazda
      // Najpierw jakieœ nag³ówki
      sockOut.println("From: " + from);
      sockOut.println("To: " + to);

      // Czytanie treœci listu z pliku
      // Poniewa¿ samotna kropka w wierszu koñczy dane listu
      // to samotn¹ kropkê w treœci zamieniamy na dwie kropki
      BufferedReader br = new BufferedReader(
                            new FileReader(fname));
      String line;
      while ((line = br.readLine()) != null) {
        if (line.equals(".")) line += ".";
        sockOut.println(line);
      }
      // Sekwencja CRLF.CRLF oznacza koniec treœci listu
      // Drugie CRLF dodane w metodzie doRequest przez println
      doRequest("\r\n.", 250);

    } catch (IOException e) {
        System.err.println(e);
        cleanExit(2);
    }
  }

  // Zamkniêcie po³¹czenia
  public void closeConnection() {
    try {
      doRequest("QUIT", 221);
    } catch (Exception exc) {
      System.err.println(exc);
    }
    cleanExit(0);
  }


  private void doRequest(String req, int checkCode)
              throws IOException {
    sockOut.println(req);
    System.out.println("Klient: " + req);
    readResponse(checkCode);
  }

  // Uwaga: nie powinniœmy tu stosowaæ buforowania i metody
  // readLine(), poniewa¿ nie wiadomo ile wierszy zwrówci serwer
  // a wywo³anie readLine jest blokuj¹ce
  // Zak³¹damy: ¿e ka¿da odpowiedŸ zmieœci siê w 10000 bajtów  
  private void readResponse(int checkCode) throws IOException {
    byte[] readBytes = new byte[10000];
    int num = sockIn.read(readBytes);
    String resp = new String(readBytes, 0, num);
    System.out.println("Serwer: " + resp);
    if (!resp.startsWith(String.valueOf(checkCode)))
     throw new IOException("Niespodziewany kod wyniku od serwera");
  }

  private void cleanExit(int code) {
    try {
      sockIn.close();
      sockOut.close();
      smtpSocket.close();
    }
    catch (Exception exc) {}
    System.exit(code);
  }

  public static void main(String[] args) {
    String server = "mail.somemailer.net";
    String myDomain = "62.125.12.111";
    String from = "me@somemailer.net";
    String to = "you@anywhere";
    EmailClient email = new EmailClient();
    email.connect(server, myDomain);
    email.send(from, to, "list1");
    email.send(from, to, "list2");
    email.closeConnection();
  }
}
</pre>
<br>
Przyk³adowy wynik dzia³ania programu:<br>
<br>
<div class="listing100"><br>
Serwer: 220 mail.somemailer.net ESMTP<br>
<br>
Klient: HELO 62.125.12.111      <br>
Serwer: 250 mail3.somemailer.net<br>
<br>
Klient: MAIL FROM:&lt;me@somemailer.net&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: RCPT TO:&lt;someone@anywhere&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: DATA<br>
Serwer: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;<br>
<br>
Klient: <br>
.<br>
Serwer: 250 Ok: queued as 28F372E815A<br>
<br>
Klient: MAIL FROM:&lt;me@somemailer.net&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: RCPT TO:&lt;someone@anywhere&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: DATA<br>
Serwer: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;<br>
<br>
Klient: <br>
.<br>
Serwer: 250 Ok: queued as 8FA212E81EC<br>
<br>
Klient: QUIT<br>
Serwer: 221 Bye<br>
</div><br>
<br>
<br>
Ten przyk³ad oprogramowania klienta ilustruje dwie wa¿ne kwestie:<br>
<ul>
  <li>
potrzebê zgodnego z protoko³em, starannego ustalenia kolejnoœci przesy³ania zleceñ i odczytywania odpowiedzi,</li>
  <li>
potrzebê uwa¿nej analizy mo¿liwych (czêsto elastycznych) formatów odpowiedzi
serwera: tutaj musieliœmy siê liczyæ z wielowierszowymi odpowiedziami serwera,
przy czym liczba wierszy nie jest ustalona - wobec tego przy czytaniu odpowiedzi
serwera nie nale¿a³o stosowaæ metody readLine (która - oczywiœcie - jest
blokuj¹ca), a zamiast tego trzeba by³o czytaæ ze strumienia bajty.</li>

</ul>
Szczegó³owy opis protoko³u SMTP zawiera RFC0821, a jego rozszerzeñ (ESMTP) - RFC1869.<br>



<br> Naturalnie, omówiony przyk³ad nie jest ani uniwersalny ani nazbyt
u¿yteczny.  Prawdziwe klienckie programy pocztowe mog¹ byæ bardzo rozbudowane
i dostarczaæ wielu mo¿liwoœci. W œrodowisku Javy mo¿emy wykorzystaæ do ich
budowy (jak równie¿ do budowy serwerów pocztowych) <b>Java Mail API</b>.
Zestaw klas tego pakietu umo¿liwia m.in. pos³ugiwanie siê protokolami SMTP,
POP3, IMAP, prowadzenie folderów wiadomoœci, ³atw¹ kompozycjê wiadomoœci
(m.in. do³¹czanie do listów ró¿nego rodzaju plików jako za³¹czników), a wszystko to bez eksponowania
szczegó³ów dotycz¹cych niskopoziomowej komunikacji poprzez gniazda. <br>
<br>
<br>
<a name="W8.8"></a><a name="W5.8"></a><a name="W5.8"></a><h2>
5.8. Klient DICT</h2>

Ciekawym, choæ ma³o popularnym protoko³em jest DICT.<br>
Jest on opisany w RFC2229.<br>Serwery DICT prowadz¹ bazy danych definicji ró¿nych terminów i dostarczaj¹ - na zlecenie klientów - odpowiednich informacji.<br>
Nie bêdziemy oczywiœcie szczegó³owo omawiaæ tego protoko³u. Dla potrzeb demonstracji wystarczy wiedzieæ, ¿e:<br>
<ul>
  <li>
polecenie "DEFINE * s³owo" powoduje, i¿ serwer przegl¹da wszystkie prowadzone
przez niego bazy danych i przesy³a klientowi wszystkie odnalezione w nich
definicje s³owa.</li>
  <li>
koniec ci¹gu definicji oznaczany jest kodem 250 w nowym wierszu,</li>
  <li>
jeœli brak definicji - zwracany jest wiersz zawieraj¹cy na pocz¹tku kod 552.</li>
</ul>


Przyk³adowy program pokazuje, ¿e tym razem mo¿emy spokojnie pos³ugiwac siê
buforowanym czytaniem i metod¹ readLine() (serwer zwraca wiersze, a my przy
czytaniu bêdziemy czatowac na odpowiednie kody). Ponadto - uczynimy nasz
program nieco bardziej przyjaznym dostarczaj¹c GUI (to dobra idea i krok
naprzód - generalnie programy tego typu powinny posiadaæ odpowiednie wygodne
GUI).<br>
<br>
Program przedstawiono na poni¿szym wydruku.<br>
<pre>
import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class DictClient extends JFrame
{
   public final static int port = 2628;
   private String server;
   private Socket clientSocket;
   private PrintWriter out;
   private BufferedReader in;
   private String database = "*";  // info ze wszystkich baz

   JTextArea ta = new JTextArea(20, 40);
   Container cp = getContentPane();



   public DictClient (String server, int timeout)   {

     try {
       clientSocket = new Socket (server, port);
       in = new BufferedReader (
                new InputStreamReader(clientSocket.getInputStream(), "UTF8"));
       out = new PrintWriter (
                new OutputStreamWriter(clientSocket.getOutputStream(), "UTF8"),
                             true);

       String resp = in.readLine(); // po³¹czenie nawi¹zane - info o tym
       System.out.println(resp);
       if (!resp.startsWith("220")) {
         cleanExit(1); // je¿eli dostêp niemo¿liwy
       }

       // Ustalenie maksymalnego czasu blokowania
       // na operacji czytania ze strumienia gniazda

       clientSocket.setSoTimeout(timeout);


     } catch(UnknownHostException exc) {
         System.err.println("Uknown host " + server);
         System.exit(2);
     } catch(Exception exc) {
         exc.printStackTrace();
         System.exit(3);
     }

     // wszystko posz³o dobrze - tworzymy i pokazujemy okno wyszukiwania

    Font f = new Font("Dialog", Font.BOLD, 14);
    ta.setFont(f);
    cp.add(new JScrollPane(ta));
    final JTextField tf = new JTextField();
    tf.setFont(f);
    tf.setBorder(BorderFactory.createLineBorder(Color.blue, 2));
    cp.add(tf, "South");

    tf.addActionListener( new ActionListener() {
      public void actionPerformed(ActionEvent e) {
         doSearch(tf.getText());
      }
    });

    addWindowListener( new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        dispose();
        cleanExit(0);
      }
    });

    pack();
    show();

    // Ustalenie fokusu na polu wprowadzania szukanych s³ów
    SwingUtilities.invokeLater( new Runnable() {
      public void run() {
        tf.requestFocus();
      }
    });
  }

  // Wyszukiwanie

  public void doSearch(String word) {
    try {
      String resp = "",
            defin = "Uzyskano nastêpuj¹ce definicje:\n";

      // Zlecenie dla serwera
      out.println("DEFINE " + database + " " + word);

      // Czytamy odpowiedŸ
      // Kod 250 na pocz¹tku wiersza oznacza koniec definicji
      while (resp != null &amp;&amp; !resp.startsWith("250")) {
        resp = in.readLine();
        defin += resp + "\n";
        if (resp.startsWith("552")) break;  // s³owo nie znalezione
      }
      ta.setText(defin);
    } catch(SocketTimeoutException exc) {
       ta.setText("Za d³ugie oczekiwanie na odpowiedŸ");
    } catch(Exception exc) {
          exc.printStackTrace();
    }
  }

  private void cleanExit(int code) {
    try {
      out.close();
      in.close();
      clientSocket.close();
    } catch(Exception exc) {}
    System.exit(code);
  }

  public static void main(String[] args) {

    int timeout = 0;
    String server = "dict.org";
    try {
      timeout = Integer.parseInt(args[0]);
      server = args[1];
    } catch(NumberFormatException exc) {
      server = args[0];
    } catch(ArrayIndexOutOfBoundsException exc) {}

    new DictClient(server, timeout);
  }

}
</pre>

Uruchamiaj¹c program podajemy adres hosta serwera oraz maksymalne oczekiwanie
na odpowiedŸ (wykorzystamy je póŸniej w metodzie setSoTimeout(...)). Adresy
ró¿nych serwerów s³ownikowych mo¿na znaleŸæ na stronie www.dict.org. Jesli
nie podamy adresu - domyœlnie zostanie przyjêty podstawowy (choæ nie najwiêkszy
i nie najbardziej wszechstronny) serwer dict.org. <br>
<br>
Po³¹czenie z nim wyprowadzi na konsolê:<br>
<div class="listing100"><br>
220 pan.alephnull.com dictd 1.8.0/rf on Linux 2.4.18-14 &lt;auth.mime&gt; &lt;1094327.262<br>
00.1067095370@pan.alephnull.com&gt;</div><br>
<br>
i od tego momentu bêdziemy mogli w oknie, w polu tekstowym u dolu wprowadzaæ
szukane s³owa i poprzez wciœniêcie ENTER uzyskiwaæ ich definicje (co pokazuj¹
rysunki)<br>
<br>
<img src="images/dict1.jpg" alt="r" width="491" height="473">
<br>
<br>
<br>
<img src="images/dict2.jpg" alt="r" width="419" height="172">
<br>
<br><br>
Programik ten ma jedn¹ istotn¹ wadê. Zlecenia obs³ugiwane s¹ synchronicznie.
Nie mo¿emy np. pisaæ w edytorze (wielopolu tekstowym w górnej czêœci okna)
i jednoczeœnie przeszukiwaæ baz danych serwerów s³ownikowych. Zapewne moglibyœmy
sobie z tym poradziæ wyodrêbniaj¹c w programie w¹tek komunikacji z serwerem.
<br>
Zaraz to zrobimy, ale chcielibyœmy równie¿, aby w¹tek ten na bie¿¹co informowa³
nas o tym co robi i ile czasu mu to zajmuje. Przy normalnym, blokuj¹cym wejœciu/wyjœciu
taka precyzyjna, na bie¿¹co podawana informacja nie jest dostêpna. Je¿eli
w¹tek czeka na odczyt danych (jest zablokowany na operacji czytania), to
nie mo¿e równoczeœnie przekazywaæ informacji np. o up³ywaj¹cym czasie oczekiwania.<br>
Powinniœmy zatem zastosowac mechanizmy NIO - mianowicie kana³y gniazd klienckich i nieblokuj¹ce wejœcie/wyjœcie.<br>
<br>
<a name="W8.9"></a><a name="W5.9"></a><a name="W5.9"></a><h2>5.9. Kana³y gniazd klienckich i nieblokuj¹ce wejœcie/wyjœcie </h2>
Mechanizmy
NIO (nowego wejœcia-wyjœcia) w Javie s¹ nam ju¿ znane. Przed dalsz¹ lektur¹ niew¹tpliwie warto odœwie¿yæ
sobie te informacje.  <br>
<br>
W odró¿nieniu od kana³ów plikowych <b>kana³y gniazd</b> umo¿liwiaj¹ nieblokuj¹ce (asynchroniczne) wejœcie-wyjœcie.<br>
Przy czytaniu z takiego kana³u za pomoca metody read(...), w¹tek nie jest
blokowany, gdy brak danych. Metoda read(...) natychmiast zwraca wynik - liczbê
przeczytanych bajtów (jeœli nie ma jeszcze danych - to 0). Mo¿emy zatem w
pêtli odpytywaæ kana³ czy dane ju¿ nadesz³y, a jeœli nie - wykonywaæ inne
zadania. Za chwilê zobaczymy to na przyk³adzie zmodyfikowanego klienta DICT.
<br><br>
Inn¹, odró¿niaj¹c¹ i wa¿n¹ cech¹ <b>kana³ów gniazd</b> jest to, i¿ mo¿liwe jest ich <b>multipleksowanie</b> czyli obs³ugiwanie przez jeden w¹tek wielu kana³ów. Klasy kana³ów gniazd (<b>SocketChannel</b> i <b>ServerSocketChannel</b>) pochodz¹ bowiem od klasy <b>SelectableChannel</b>, która pozwala na rejestrowanie kana³ów do u¿ycia z <b>selektorami</b>
. Te zaœ obs³uguj¹ selekcjê kana³u (zdarzenia po³¹czenia, czytania, pisania
...), dziêki czemu mo¿emy fragmenty programów odpowiedzialne np. za odczytywanie
danych z kanalów pisaæ w konwencji call-back.<br>
W³aœciwoœæ tê maj¹ zarówno kana³y gniazd klienckich jak i gniazd serwerowych,
niew¹tpliwie jednak prawdziwie przydatna jest ona przy programowaniu serwerów,
które przecie¿ powinny obs³ugiwac równolegle wielu klientów. Programy klienckie
zwykle korzystaj¹ z jednego kana³u komunikacyjnego, w zwi¹zku z tym mechanizm
selektorów omówiony zostanie w dalszych punktach przy okazji programowania serwerów,
teraz natomisat zajmiemy siê nieblokuj¹cym wejœciem-wyjœciem dla kana³ów
klienckich.<br>
<br>
Kana³y gniazd klienckich tworzymy za pomoc¹ statycznej metody <b>open() klasy
SocketChannel.</b> <br>
Po stworzeniu kana³u w  ten sposób  kana³ jeszcze nie jest
po³¹czony (poprzez gniazdo) z serwerem. <br>
Po³¹czenie uzyskujemy u¿ywaj¹c metody
<b>connect</b> z argumentem typu <b>SocketAddress</b> (zwykle bêdzie to znana nam ju¿ 
klasa InetSocketAddress, której obiekty specyfikuj¹ adresy gniazd, czyli
adres hosta + numer portu).<br>
<b><br>
<font color="#ff0000">Uwaga</font><font color="#ff0000">: w obecnej postaci kana³y gniazd nie s¹ wystarczaj¹c¹ abstrakcj¹
dla obs³ugi po³¹czeñ. Ustalanie opcji gniazd oraz ich zamykanie odbywa siê
nadal za pomoc¹ klasy Socket (dostêp do obiektu-gniazda, zwi¹zanego z danym
kana³em uzyskujemy za pomoc¹ metody socket() z klasy SocketChannel). <br>
</font></b>
<br>
Kana³y gniazd mo¿emy skonfigurowaæ w dwóch trybach: blokuj¹cym lub nieblokuj¹cym.
S³u¿y do tego metoda <b>configureBlocking(true | false)</b>. <br>
<br>
W trybie biokuj¹cym ka¿da operacja I/O
blokuje w¹tek, dopóki nie zostanie zakoñczona. <br>
<br>
W trybie nieblokuj¹cym operacja
nie blokuje w¹tku (jej wywo³anie wraca natychmiast) i mo¿e przekazaæ mniej
bajtów danych ni¿ by³o wymagane lub nawet wcale.<br>
<br><b><font color="#3333ff">
Dla nieblokuj¹cych kana³ów metoda connect()  nie blokuje w¹tku</font></b>, wynik jest
zwracany natychmiast i wskazuje na to czy po³¹czenie zosta³o nawi¹zane (true),
lub, ¿e jest w trakcie nawi¹zywania (false).<br>
 Zwykle po³¹czenie nie mo¿e byæ
nawi¹zane natychmiast (ew. wyj¹tkiem s¹ po³¹czenia z lokalnym hostem), zatem
potrzebny jest mechanizm uzyskania informacji o tym czy i kiedy po³¹czenie
zosta³o nawi¹zane. S³u¿y temu metoda <b>finishConnect()</b>, której wywo³anie zwraca
true, jesli proces ³¹czenbia zosta³ zakoñczony a false w przeciwnym razie.<br>
<br>
Schemat nawi¹zania po³¹czenia poprzez kana³ w trybie nieblokuj¹cym przedstawiono poni¿ej.<br>
<br>
<div class="syntax"><br>
     SocketChannel channel;<br>
     String server = ...; // adres hosta serwera<br>
     int port =         ...; // numer portu<br>
     ....  <br>
<br>
     try {<br>
        channel = SocketChannel.open();<br>
        channel.configureBlocking(false);<br>
        channel.connect(new InetSocketAddress(server, port));<br>
        <br>
        System.out.print("£¹cze siê ...");<br>
        while (!channel.finishConnect()) {<br>
           // ew. pokazywanie czasu ³¹czenia (np. pasek postêpu)<br>
           // lub wykonywanie jakichœ innych (krótkotrwa³ych) dzia³añ<br>
        }<br>
     } catch(UnknownHostException exc) {<br>
         System.err.println("Uknown host " + server);<br>
         // ...<br>
     } catch(Exception exc) {<br>
         exc.printStackTrace();<br>
         // ...<br>
     }<br>
     System.out.println("\nPo³aczony");<br>
</div><br>
<br>
Skrócow¹ form¹ utworzenia kana³u i po³¹czenia jest wywo³anie metody:<br>
<br>
        <b>SocketChannel  SocketChannel.open(InetSocketAddress)</b><br>
<br><b><font color="#3333ff">
To odwo³anie jest blokuj¹ce</font></b> (bowiem kana³y s¹ domyœlnie tworzone w trybie
blokuj¹cym), ale tryb ten mo¿emy w dowolnym momencie zmieniæ na nieblokuj¹cy
za pomoc¹ metody <b>configureBlocking(...)</b> i od tego momenty wszetkie operacje
we/wy na kanale bêd¹ nieblokuj¹ce.<br>
<br>
Po stworzeniu kana³u mo¿emy do niego pisaæ (przekazywaæ zlecenia do serwera)
lub z niego czytaæ (odczytywaæ dane przekazane przez serwer).  <b>W sumie jest
to wygodne, bowiem zamiast dwóch strumieni zwi¹zanych z gniazdem mamy jeden
kana³</b>. Przy tym jednak musimy pos³ugiwac siê buforami NIO. Przypomnijmy, ¿e:<br>
<ul>
  <li>czytamy dane z kana³u do bufora bajtowego (ByteBuffer) za pomoc¹ metod
<b>read(...)</b>, zapisujemy dane do kana³u z bufora bajtowego (ByteBuffer) za pomoc¹
metody <b>write(...)</b>; mo¿emy przy tym korzystaæ z tzw. czytania rozprowadzaj¹cego
po wielu buforach (<b>scattering read</b>) i gromadz¹cego pisania z wielu buforów
(<b>gathering write</b>),</li>
  <li>bufory bajtowe musz¹ byæ <b>alokowane</b> za pomoc¹ metod allocate(...), allocateDirect(...),
albo musz¹ <b>opakowywaæ</b> istniej¹ce w postaci tablic typu byte[] struktury danych.</li>
  <li> praca z buforami bajtowymi jest specyficzna, wymaga bowiem manipulacji
<b>parametrami </b>(pozycjami) bufora; np. po wczytaniu danych do bufora musimy
go przestawiæ zapomoc¹ metody <b><font color="#009900">flip()</font></b>, po to by móc z tych dancyh korzystaæ,</li>
  <li>przekazywanie danych znakowych (tekstów) za poœrednictwem kana³ów wymaga
ich <b>kodowania/dekodowania</b> (u¿ycie klas Charset i CharBuffer).</li>
</ul>Schemat nieblokuj¹cego czytania.<br>
<br>
<div class="syntax"><br>
<div align="Center"><b>Mo¿liwy schemat nieblokuj¹cego czytania<br>
z kana³u gniazda<br>
</b></div>
<br>
<b>SocketChannel channel;</b><br>
<br>
// Utworzenie i po³¹czenie kana³u<br>
// ...<br>
// Ustalenie trybu nieblokuj¹cego<br>
<b><br>
channel.configureBlocking(false);</b><br>
// ...<br>
<br>
// Alokowanie bufora bajtowego<br>
// allocateDirect pozwala na wykorzystanie mechanizmów sprzêtowych<br>
// do przyspieszenia operacji we/wy<br>
// Uwaga: taki bufor powinien byæ alokowany jednokrotnie<br>
// i wielokrotnie wykorzystywany w operacjach we/wy<br>
<b><br>
  ByteBuffer inBuf = ByteBuffer.allocateDirect(<i>rozmiar_bufora</i>);</b><br>
<br>
  // pêtla czytania<br>
<b>  while (true) {      </b><br>
<br>
      <b>inBuf.clear();</b>                                         // opró¿nienie bufora<br>
<br>
      <b>int readBytes = channel.read(inBuf);</b>     // czytanie nieblokuj¹ce<br>
                                                                   // natychmiast zwraca liczbê<br>
                                                                   // przeczytanych bajtów<br>
<br>
      <b>if (readBytes == 0) { </b>                             // jeszcze nie ma danych<br>
          // jakieœ (krótkotrwa³e) dzia³ania np. info o up³ywaj¹cym czasie<br>
<b>         continue;</b><br>
<b>      }</b><br>
<b>      else if (readBytes == -1) {  </b>                   // kana³ zamkniêty po stronie serwera<br>
                                                                  // dalsze czytanie niemo¿lwe<br>
<b>          // ...<br>
          break;<br>
      }<br>
      else { </b>                                                  // dane dostêpne w buforze<br>
<b>          inBuf.flip();</b>                                     // przestawienie bufora<br>
          // pobranie danych z bufora<br>
          // ew. decyzje o tym czy mamay komplet danych - wtedy break<br>
          // czy te¿ mamy jeszcze coœ do odebrania z serwera - kontynuacja <br>
      }<br>
   }<br>
<br>
Uwaga: na schemacie nie pokazano koniecznej obs³ugi wyj¹tków; generalnei
dotyczy ona po³¹czenia i konfiguracji kana³u a tak¿e operacji read.<br>
</div><br>
<br>Nowa wersja klienta DICT.<br>
Program bêdzie sk³adaæ siê z dwóch klas:<br>
<ul>

  <li>klasa DictGui utworzy kana³, skonfiguruje go w trybie nieblokuj¹cym
i po³¹czy go z serwerem s³ownikowym; definiuje ona równie¿ interfej graficzny, w którym mamy do dyspozycji
edytor tekstu oraz pole tekstowe, do którego mo¿emy wpisaæ szukany termin;
po wciœniêciu ENTER na polu tekstowym uruchomioiny zostanie w¹tek wyszukiwania
s³ownikowego (klasa ReadDef), a informacje o postêpach szukania bêd¹ uwidaczniane
w informacyjnej etykiecie interfejsu graficznego; po skompletowaniu wyników
przyciskiem "Wklej definicje" bêdziemy mogli wkleiæ wyniki otrzymane od serwera
s³ownikowego do edytora w miejscu kursora; klasa ta równie¿ (jeszcze przed
utworzeniem GUI) utworzy kana³, skonfiguruje go w trybie nieblokuj¹cym i po³¹czy go z serwerem s³ownikowym;</li>
  <li>klasa ReadDef zapisuje do kana³u zlecenie dla serwera (podaj definicjê
s³owa przekazanego jako argument kosntruktora) i w sposób nieblokuj¹cy czyta
odpowiedŸ serwera, pokazuj¹c w GUI ile czasu serwerowi zajê³o szukanie i
ile porcji danych trzeba by³o odczytaæ z kana³u.</li>
</ul>
Kod programu pokazano na poni¿szym wydruku:<br>
<pre>
import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.regex.*;


class DictGui extends JFrame implements ActionListener {

  public final static int port = 2628;
  private String server;
  private SocketChannel channel;

  private JTextArea ta = new JTextArea(20, 20);
  private JTextField tf = new JTextField(20);
  private JLabel infoLab = new JLabel("Nie by³o szukania");
  private JButton paste = new JButton("Wklej definicjê");
  private Container cp = getContentPane();
  private ReadDef rd;

  public DictGui(String server) {
    this.server = server;

    // Otwarcie i po³¹czenie kana³u
    // metoda connect - zdefiniowana u koñca klasy
    try {
      channel = SocketChannel.open();
      channel.configureBlocking(false);
      connect();
    } catch(UnknownHostException exc) {
        System.err.println("Uknown host " + server);
        System.exit(1);
    } catch(IOException exc) {
        exc.printStackTrace();
        System.exit(2);
    }

    // Konfiguracja GUI
    Font f = new Font("Dialog", Font.BOLD, 14);
    ta.setFont(f);
    tf.setFont(f);
    tf.setBorder(BorderFactory.createLineBorder(Color.orange, 1));
    infoLab.setPreferredSize(new Dimension(200,30));
    JPanel p = new JPanel();
    p.setBorder(BorderFactory.createLineBorder(Color.red, 2));
    p.add(tf);
    p.add(infoLab);
    p.add(paste);
    cp.add(new JScrollPane(ta));
    cp.add(p, "South");

    tf.addActionListener(this);
    paste.addActionListener(this);

    // Przy zamykaniu aplikacji
    // zamykamy kana³ i gniazdo
    addWindowListener( new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        dispose();
        try {
         channel.close();
         channel.socket().close();
        } catch(Exception exc) {}
        System.exit(0);
      }
    });

    pack();
    show();
  }

  // Obs³uga akcji
  public void actionPerformed(ActionEvent e) {
    // Klikniêcie w przycisk "Wklej definicjê"
    // definicjê przechowuje dla nas obiekr klasy ReadDef
    if (e.getSource() == paste &amp;&amp; rd != null) {
       ta.insert(rd.getResult(), ta.getCaretPosition());
    }
    else {  // ENTER na polu tekstowym tf - start w¹tku komuniakcji z serwerem
     if (!channel.isConnected()) try {
       connect();
     } catch(Exception exc) {
        exc.printStackTrace();
        return;
     }
     rd = new ReadDef(this, channel, tf.getText());
     rd.start();
    }
  }

  // £¹czenie kana³u z serwerem
  private void connect() throws UnknownHostException, IOException {
    if (!channel.isOpen()) channel = SocketChannel.open();
    channel.connect(new InetSocketAddress(server, port));
    System.out.print("£¹cze siê ...");
    while (!channel.finishConnect()) {
      try { Thread.sleep(200); } catch(Exception exc) { return; }
      System.out.print(".");
    }
    System.out.println("\nPo³¹czony.");
  }

  // Metoda wykorzystywana przez ReadDef
  // do pokazywania postepów komuniakcji z serwerem
  public void setInfo(String s) {
    infoLab.setText(s);
  }
}

class ReadDef extends Thread {

  private static Charset charset  = Charset.forName("ISO-8859-2");
  private static ByteBuffer inBuf = ByteBuffer.allocateDirect(1024);
  private static Matcher matchCode =
                 Pattern.compile("(\n250 ok)|(552 no match)").matcher("");
  private SocketChannel channel;
  private DictGui gui;
  private String word;


  public ReadDef(DictGui gui, SocketChannel ch, String wordToSearch) {
    this.gui = gui;
    channel = ch;
    word = wordToSearch;
  }

  private StringBuffer result;

  public void run() {
    result = new StringBuffer("Wyniki wyszukiwania:\n");
    int count = 0, rcount = 0;
    try {
      CharBuffer cbuf = CharBuffer.wrap("DEFINE * " + word + "\n");
      ByteBuffer outBuf = charset.encode(cbuf);
      channel.write(outBuf);

      while (true) {
        inBuf.clear();
        int readBytes = channel.read(inBuf);
        if (readBytes == 0) {
          gui.setInfo("Czekam ... " + ++count);
          Thread.sleep(200);
          continue;
        }
        else if (readBytes == -1) {
          gui.setInfo("Kana³ zamkniêty");
          channel.close();
          break;
        }
        else {
          inBuf.flip();
          cbuf = charset.decode(inBuf);
          result.append(cbuf);
          matchCode.reset(cbuf);
          if (matchCode.find()) break;
          else gui.setInfo("Czytam ... " + ++rcount);
        }
      }
    } catch(Exception exc) {
         exc.printStackTrace();
         return;
    }
    gui.setInfo("Czeka³em: " + count + " / Czyta³em: " + rcount + ". Gotowe.");
  }

  public String getResult() {
    if (result == null) return "Brak wyników wyszukiwania";
    return result.toString();
  }
}

class Main {
  public static void main(String[] args) {
    String server = "dict.org";
    new DictGui(server);
  }
}
</pre>
Komentarze:<br>
<ul>
  <li>przed utworzeniem i wystartowaniem w¹tku ReadDef sprawdzane jest czy
kana³ nadal jest po³¹czony (isConnected()); jeœli nie to nastêpuje próba
ponownego po³¹czenia;</li>
  <li>przy ³¹czeniu w metodzie connect() sprawdzamy czy kana³ jest otwarty,
jeœli nie to otwieramy go ponownie; kana³ mo¿e byæ automatycznie zamkniêty
na skutek utraty po³¹czenia z serwerem.</li>  <li>interakcja pomiêdzy klasami DictGUI i ReadDef odbywa siê za pomoc¹
metod: setInfo(...) i getResult(...); metoda klasy DictGUI setInfo(), wywo³ywana
z klasy ReadDef jest wielow¹tkowo bezpieczna, gdy¿ praktycznie wywo³uje tylko
wielow¹tkowo bezpieczn¹ metodê setlText(...) z klasy JLabel;</li>
  <li>przy czytaniu/zapisywaniu tekstów z/do kana³u stosujemy dekodowanie/kodowanie za pomoc¹ klas Charset (teksty mamy w CharBuffer),</li>
  <li>kody zwracane przez serwer wyszukujemy za pomoc¹ wyra¿eñ regularnych;
wzorzec zastosowany do wyszukiwania nie jest najbardziej uniwersalny, ale
wystarczaj¹cy dla celów ilustracji,</li>
  <li>u¿yte w programie rozwi¹zanie polegaj¹ce na uruchamianiu nowego w¹tku
ReadDef dla ka¿dego wyszukiwania nie jest najlepsze; ogólnie powinien dzia³aæ
jeden w¹tek ReadDef synchronizowany i koordynowany z DictGUI za pomoc¹ mechanizmu
wait-notify; tego rozwi¹zania nie pokazujê, aby nie zaciemniaæ obrazu, który
ma jedynie ilustrowaæ nieblokuj¹ce wejœcie-wyjœcie i u¿ycie kana³ów gniazd
klienckich.</li>
</ul>
Sposób dzia³ania programu ilustruje rysunek.<br>
<img src="images/dict3.jpg" alt="r" width="592" height="464">
<br>
<br>
Widzimy tu (w obszarze etykiety informacyjnej), ¿e nasz klient czeka³ ok.
600 ms (3 *200) na uzyskanie pierwszej odpowiedzi serwera na zapytanie o definicjê s³owa "words<br>
, a odpowiedŸ przeczyta³ w dwóch porcjach danych (pierwsza 1024B, druga co najwy¿ej 1024 bajty).<br>
<a name="W8.10"></a><a name="W5.10"></a><a name="W5.10"></a><h2>
5.10. Serwery</h2>

Serwery dostarczaj¹ - na zlecenie klientów - okreœlonych us³ug (m.in. informacji).<br>
Typowe dzia³anie serwera polega na:<br>
<ol>
  <li>Utworzeniu gniazda serwera (klasa ServerSocket)</li>
  <li>Zwi¹zaniu go z okreœlonym adresem (adres hosta, na którym dzia³a serwer + adres portu)</li>
  <li>Oczekiwaniu na po³¹czenie od klienta "na tym" gnieŸdzie</li>
  <li>Po zaakceptowaniu po³¹czenia od klienta - utworzeniu ganiazda wymiany
informacji z po³¹czonym klientem (klasa Socket) i obs³udze zleceñ tego klienta
posy³anych poprzez strumieñ zwi¹zany z tym gniazdem.</li>
  <li>Kontynuacji "nas³uchu" po³¹czeñ od innych klientów na gnie¿dzie serwera.</li>
</ol>
Poni¿szy schemat ilustruje oprogramowanie serwera.<br>
<br>
<div class="syntax"><br>
     <br>
      String host = ...;  // nazwa hosta<br>
      int port = ...;     // numer portu<br>
<br>
      InetSocketAddress isa = new InetSocketAddress(host, port);<br>
<br>
      // Utworzenie gniazda serwera<br>
      ServerSocket serverSock =  new ServerSocket();<br>
<br>
      // Zwi¹zanie gniazda serwera z adresem hosta i portu<br>
      serverSock.bind(isa);<br>
 <br>
      // W pêtli nastêpuje akceptacja po³¹czeñ kolejnych klientów<br>
      // i obs³uga ich zleceñ<br>
      <br>
      boolean serverIsRunning = true;         // przy zamykaniu serwera<br>
                                                             // ustalane na false (np. przez inny w¹tek)<br>
<br>
      while (serverIsRunning) {  <br>
<br>
        // akceptacja po³¹czenia<br>
        // i utworzenie gniazda komunikacji z po³¹czonym klientem<br>
<br>
        Socket connection = serverSock.accept();<br>
<br>
        // obs³uga zleceñ klienta<br>
        // za poœrednictwem strumieni we/wy zwi¹zanych z gniazdem connection<br>
        // ...<br>
        // po zakoñczeniu interakcji z klientem<br>
        // - zamkniêcie strumieni i gniazda<br>
        // ...<br>
        connection.close()<br>
        <br>
     }<br>
     <br>
     // zamkniêcie gniazda serwera<br>
<br>
     serverSock.close();<br>
</div><br>
<br>
Przy tworzenie adresu gniazda (InetSocketAddress) podajemy host serwera oraz
port poprzez który serwer bêdzie dostêpny dla klientów.<br>
W naszych eksperymentach domowych jako host mo¿emy podaæ "localhost" (lub adres "127.0.0.1").<br>
Specyfikuj¹c numer portu, nale¿y pamiêtaæ o tym, ¿e pierwsze 1024 porty s¹
zarezerwowane (wspominane wczeœniej "dobrze-znane-porty"). Mo¿emy oczywiœcie
pisaæ serwer FTP czy HTTP, ale u¿ycie w³aœciwych dla nich numerów portów
wymaga uprawnieñ administrtora systemu (przy braku takich uprawnieñ, u¿ywamy
dostêpnych numerów portów, czasem konwencjonalnych np. dla serwera HTTP -
8080).<br>
<br>
<br>
Metoda <b>bind</b>(...) wi¹¿e gniazdo serwera z podanym adresem. Mo¿emy podaæ równie¿
- jako jej drugi argument - maksymaln¹ liczbê klientów oczekuj¹cych na po³¹czenie
(domyœlnie jest to liczba 50). Wtedy przy wyd³u¿eniu kolejki oczekuj¹cych
klientów poza podan¹ liczbê, kolejni próbuj¹cy ³¹czyæ sie z serwerem klienci
bêd¹ uzyskiwaæ odmowê po³¹czenia (wyj¹tek "Connection refused").<br>
<br>
Metoda <b>accept()</b> jest blokuj¹ca<b> </b>i wstrzymuje wykonanie w¹tku do chwili
zg³oszenia chêci po³¹czenia ze strony klienta (klient ³¹czy siê z serwerem,
podaj¹c - czy to w konstruktorze klasy Socket, czy w metodzie connect() host
serwera i numer portu, który przydzieli³ sobie serwer).  Gdy po³¹czenie jest
akceptowane, metoda accept() zwraca gniazdo (obiekt klasy Socket), poprzez
które bêdzie odbywaæ siê interakcja klienta z serwerem. <br>
Metoda accept() zmo¿e sygnalizowaæ m.in. wyj¹tek SocketTimeoutException, który
powstaje, gdy przekroczony zostanie limit czasowy na uzyskanie po³¹czenia.
Dla gniazda serwera mo¿emy ustaliæ ten limit za pomoc¹ metody setSoTimeout().
<br>
<br>
Od gniazda, zwróconego przez metodê accept() mo¿na uzyskaæ strumienie wejœciowy
i wyjœciowy i za ich pomoc¹ "rozmawiaæ" z klientem.<br>
<br>
Pisz¹c w³asny serwer nale¿y przemyœleæ i ustaliæ protokó³ komunikacji. Oczywiœcie,
mo¿emy skorzystaæ z gotowych protoko³ów (np. HTTP czy FTP). Takie serwery
s¹ jednak ju¿ gotowe - celowoœæ pisania w³asnych serwerów HTTP czy FTP jest
uzasadniona tylko w przypadkach jakiegoœ testowania czy te¿ specjalnego dostosowywania
tych protoko³ów. Najczêœciej zatem bêdziemy tworzyæ ca³kiem nowy, w³asny protokó³.<br>
<br> Zilustruje to przyk³ad serwera - ksi¹¿ki telefonicznej. Serwer ma dostêp
do "bazy" numerów telefonów. Dla prostoty wykorzystamy mapê, w której osobom-kluczom
bêd¹ przypisane numery telefonów - wartoœci, a dostêp do niej zrealizujemy
poprzez klasê PhoneDirectory.<br>
<pre>
import java.util.*;
import java.io.*;

public class PhoneDirectory {

  private Map pbMap = new HashMap();

  public PhoneDirectory(String fileName) {
    // Inicjalna zawartoœæ ksi¹¿ki telefonicznej
    // jest wczytywana z pliku o formacie
    //  imiê  numer_telefonu
    try {
      BufferedReader br = new BufferedReader(
                             new FileReader(fileName));
      String line;
      while ((line = br.readLine()) != null) {
        String[] info = line.split(" +", 2);
        pbMap.put(info[0], info[1]);
      }
    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

  // Zwraca numer telefonu dla podanej osoby
  public String getPhoneNumber(String name) {
    return (String) pbMap.get(name);
  }

  // Dodaje now¹ osobê do ksi¹¿ki
  // Wynik:
  // - true - dodana
  // - false - nie (przy próbie dodania osoby zapisanej ju¿ w ksi¹¿ce)
  public boolean addPhoneNumber(String name, String num) {
    if (pbMap.containsKey(name)) return false;
    pbMap.put(name, num);
    return true;
  }

  // Zastêpuje numer podanej osoby nowym
  // Wynik:
  // - true (numer zast¹piony)
  // - false (nie - próba podania nowegu numeru nieistniej¹cej osoby)
  public boolean replacePhoneNumber(String name, String num) {
    if (!pbMap.containsKey(name)) return false;
    pbMap.put(name, num);
    return true;
  }

}  </pre>
<br>
Serwer obs³uguje zlecenia klientów: <br>
<ul>
  <li><b>get imiê</b> (podaj numer telefonu dla wskazanej osoby),</li>
  <li><b>add imiê numer</b> (dopisz do ksi¹¿ki osobê i jej numer telefoniczny),</li>
  <li><b>replace imiê numer</b> (zast¹p w ksi¹¿ece numer telefony pdoanej osoby nowym numerem).</li>
  <li><b>bye</b> ( zakoñczenie komunikacji)<br>
  </li>
</ul>
Na ka¿de zlecenie klienta serwer odpowiada posy³aj¹c (jako jeden wiersz)
kod numeryczny wyniku przetworzenia zlecenia oraz opis tego wyniku. Przy
zleceniu get posy³any jest w odpowiedzi dodatkowy, kolejny wiersz zawieraj¹cy
numer telefonu.<br>
Ustalimy nastêpuj¹ce kody:<br>
0 - zlecenie wykonane (Ok)<br>
1 - b³êdna sk³adnia zlecenia lub nieznane zlecenie (Invalid request)<br>
2 - nie znaleziono numeru dla podanej osoby, dotyczy tylko zlecenia get (Not found)<br>
3 - b³¹d w zleceniu add - próba dodania osoby-numeru, która ju¿ istnieje w ksi¹¿ce<br>
4 - b³¹d w zleceniu replace - próba podania nowego numeru dla nie istniej¹cej osoby<br>
<br>
Program serwera podano na wydruku.<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.regex.*;

public class PhoneBookServer1  {

  private PhoneDirectory pd = null;  // mapa osoby-numery tel.
  private ServerSocket ss = null;
  private BufferedReader in = null;  // strumienie gniazda
  private PrintWriter out = null;    // komunikacji z klientem

  public PhoneBookServer1(PhoneDirectory pd, ServerSocket ss) {
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server started");
    System.out.println("at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    serviceConnections();  // nas³uchiwanie po³¹czeñ
  }

  // Metoda nas³uchuje po³¹czeñ od klientów
  // po zaakceptowaniu po³¹czenia - tworzy gniazdo komunikacyjne
  // i przekazuje obs³ugê zleceñ metdodzie serviceRequest

  private void serviceConnections() {
    boolean serverRunning = true;   // serwer dzia³a ci¹gle
    while (serverRunning) {
      try {
        Socket conn = ss.accept();  // nas³uch i akceptaccja po³¹czeñ

        System.out.println("Connection established");

        serviceRequests(conn);      // obs³uga zleceñ dla tego po³¹czenia

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }                               // zamkniêcie gniazda serwera
    try { ss.close(); } catch (Exception exc) {}
  }

  // wzorzec do rozbioru zlecenia (maks. trzy "s³owa" rozdzielone spacjami)
  private static Pattern reqPatt = Pattern.compile(" +", 3);

  // S³owne komunikaty serwera
  // odpowidaj¹ce im indeksy tablicy - kody wyniku
  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };


  // Obs³uga zleceñ od klienta
  private void serviceRequests(Socket connection)
                              throws IOException {
    try {
      in = new BufferedReader(                   // utworzenie strumieni
               new InputStreamReader(
                   connection.getInputStream()));
      out = new PrintWriter(
                connection.getOutputStream(), true);

      // Odczytywanie zleceñ (line zawiera kolejne zlecenie)
      for (String line; (line = in.readLine()) != null; ) {

        String resp;                           // odpowiedŸ
        String[] req = reqPatt.split(line, 3); // rozbiór zlecenia
        String cmd = req[0];                   // pierwsze s³owo - polecenie

        if (cmd.equals("bye")) {        // zlecenie "bye" - koniec komunikacji
          writeResp(0, null);
          break;
        }
        else if (cmd.equals("get")) {   // "get" - klient chce dostaæ nr tel.
          if (req.length != 2) writeResp(1, null);
          else {
            String phNum = (String) pd.getPhoneNumber(req[1]); // pobranie
            if (phNum == null) writeResp(2, null);             // numeru tel.
            else writeResp(0, phNum);                          // i zapis
          }
        }
        else if (cmd.equals("add"))  {  // "add" - klient chce dodaæ numer
          if (req.length != 3) writeResp(1, null);
          else {
            boolean added = pd.addPhoneNumber(req[1], req[2]); // dodany?
            if (added) writeResp(0, null);                     // tak - ok
            else writeResp(3, null);                           // nie
          }
        }
        else if (cmd.equals("replace"))  {  // klient chce zmieniæ nr tel.
          if (req.length != 3) writeResp(1, null);
          else {
            boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
            if (replaced) writeResp(0, null);
            else writeResp(4, null);
          }
        }
        else writeResp(1, null);             // nieznane zlecenie
      }
    } catch (Exception exc) {
        exc.printStackTrace();

    } finally {
        try {                                // zamkniêcie strumieni
          in.close();                        // i gniazda
          out.close();
          connection.close();
          connection = null;
        } catch (Exception exc) { }
    }
  }


  // Przekazanie odpowiedzi klientowi poprzez zapis do strumienia
  // gniazda komuniakcyjnego
  private void writeResp(int rc, String addMsg)
               throws IOException {
    out.println(rc + " " + msg[rc]);
    if (addMsg != null) out.println(addMsg);
  }

  public static void main(String[] args) {
    PhoneDirectory pd = null;
    ServerSocket ss = null;
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);

      pd = new PhoneDirectory(phdFileName); // utworzenie mapy numerów z pliku

      InetSocketAddress isa = new InetSocketAddress(host, port);

      ss =  new ServerSocket();             // Utworzenie gniazda serwera
      ss.bind(isa);                         // i zwi¹zanie go z adresem

    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    new PhoneBookServer1(pd, ss);
  }

}
</pre>
<br>
Przyk³adowy klient, który wykonuje szereg testuj¹cych operacji mo¿e wygl¹daæ tak jak na poni¿szym wydruku.<br>
<br>
<pre>
import java.net.*;
import java.io.*;

public class PhoneBookClient {

  private Socket sock = null;
  private PrintWriter out = null;
  private BufferedReader in = null;

  public PhoneBookClient(String host, int port) {
    try {
      sock = new Socket(host, port);
      out = new PrintWriter(sock.getOutputStream(), true);
      in = new BufferedReader(
               new InputStreamReader(
                   sock.getInputStream()));

      makeRequest("get Asia");
      makeRequest("get Alicja");
      makeRequest("add Adam 77777");
      makeRequest("add Adam");
      makeRequest("get Adam");
      makeRequest("add Adam 333333");
      makeRequest("replace Adam 333333");
      makeRequest("replace Alicja 202020");
      makeRequest("get Adam");
      makeRequest("add");
      makeRequest("");
      makeRequest("bye");
      in.close();
      out.close();
      sock.close();
    } catch (UnknownHostException e) {
        System.err.println("Nieznany host: "+host);
        System.exit(2);
    } catch (IOException e) {
        System.err.println("I/O err dla");
        System.exit(3);
    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(4);
    }
  }

  private boolean makeRequest(String req) throws IOException {
    System.out.println("Request: " + req);
    out.println(req);
    String resp = in.readLine();
    System.out.println(resp);
    boolean ok = resp.startsWith("0");
    if (req.startsWith("get") &amp;&amp; ok)
       System.out.println(in.readLine());
    return ok;
  }

  public static void main(String[] args) {
    new PhoneBookClient(args[0], Integer.parseInt(args[1]));
  }
}
</pre>
<br>
Po kompilacji programów, uruchamiamy serwer w sesji znakowej poleceniem i otrzymujemy potwierdzenie uruchomienia serwera:<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookServer1 Book.txt localhost 2300<br>
<br>
Server started<br>

at port: 2300<br>

bind address: localhost/127.0.0.1<br>
</div><br>
<br>
Wybraliœmy tu  port 2300 i wszyscy klienci ³¹cz¹cy siê z tym serwerem bêd¹ musieli korzystaæ z tego portu.<br>
Klienta uruchamiamy w innej sesji znakowej (jako odrêbny proces):<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookClient localhost 2300<br>
</div><br>
<br>
Po uruchomieniu, klient podejmie próbê po³¹czenia z serwerem, nas³uchuj¹ca
metoda accept() serwera przyjmie po³¹czenie, a nasz program serwera wypisze
inforrmacjê o ustanowieniu po³¹czenia:<br>
<br>
<div class="listing100"><br>
Connection established<br>
</div><br>
<br>
<br>
Od tego momentu zacznie siê interakcja klienta i serwera. Klient bêdzie posy³a³
kolejne polecenia (zapisanie w programie przyka¹dowym), a serwer je realizowa³
i odpowiada³ klientowi podaj¹c wynik przetworzenia zlecenia oraz (ew.) dodatkow¹
informacjê (numery telefonów). W programie klienta zapewniono wypisywanie
na konsoli kolejnych kroków tej komunikacji. Wygl¹da to tak.<br>
<div class="listing100"><br>
Request: get Asia<br>
0 Ok<br>
171717<br>
Request: get Alicja<br>
2 Not found<br>
Request: add Adam 77777<br>
0 Ok<br>
Request: add Adam<br>
1 Invalid request<br>
Request: get Adam<br>
0 Ok<br>
77777<br>
Request: add Adam 333333<br>
3 Couldn't add - entry already exists<br>
Request: replace Adam 333333<br>
0 Ok<br>
Request: replace Alicja 202020<br>
4 Couldn't replace non-existing entry<br>
Request: get Adam<br>
0 Ok<br>
333333<br>
Request: add<br>
1 Invalid request<br>
Request: <br>
1 Invalid request<br>
Request: bye<br>
0 Ok<br>
</div> <br>
<br>
Opisywany serwer "telefoniczny" ma jedn¹ bardzo istotn¹ wadê: nie jest przygotowany
do tego by równolegle obs³ugiwaæ wielu klientów. <br><br>
Ilustruje to fragmencik programu,  tworz¹cy trzech klientów naszej ksi¹¿ki
telefonicznej (dzia³aj¹cych jako w¹tki). Ka¿dy z klientów kilkakrotnie pyta
o numer telefonu wlaœciwiej dla niego osoby, nie zaw³aszczaj¹c przy tym ca³kowicie procesora
(u¿ycie Thread.sleep). <br>
<br>
<pre>
import java.net.*;
import java.io.*;

public class PhoneBookClients extends Thread {

  private Socket sock = null;
  private PrintWriter out = null;
  private BufferedReader in = null;
  private String nameToSearch;

  public PhoneBookClients(String host, int port, String name ) {
    try {
      sock = new Socket(host, port);
      out = new PrintWriter(sock.getOutputStream(), true);
      in = new BufferedReader(
               new InputStreamReader(
                   sock.getInputStream()));

      nameToSearch = name;

    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(4);
    }
    start();
  }

  public void run() {
    try {
      for (int i=1; i &lt;= 5; i++) {
        find(nameToSearch);
        Thread.sleep(500);
      }
      out.println("bye");
    } catch (Exception exc) {
        exc.printStackTrace();
    }
  }

  private void find(String name) throws IOException {
    out.println("get " + name);
    String resp = in.readLine();
    boolean ok = resp.startsWith("0");
    String tel = ok ? in.readLine() : " - not found";
    System.out.println(name + " - tel. " + tel);
  }

  public static void main(String[] args) {
    String host = args[0];
    int port = Integer.parseInt(args[1]);
    String[] names = { "Asia", "Adam", "Jacek" };
    for (int i=0; i&lt;names.length; i++)
      new PhoneBookClients(host, port, names[i]);
  }
}
</pre>
<br>
Zatem ka¿dy klient jest wyw³aszczany i wtedy o nuner telefonu ma szansê zapytaæ inny klient.<br>
Nic takiego siê jednak nie dzieje, bowiem  nasz serwer nie potrafi równolegle
obs³ugiwaæ wielu klientów i musi zawsze zakoñczyæ rozpoczet¹ komunikacjê.
W efekcie klienci obs³ugiwani s¹ po kolei (a nie rownolegle) co obrazuje
wynik dzia³ania programu.<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookClients localhost 2300<br>
<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
</div><br>
<br>
Serwery dzia³aj¹ce w ten sposób nosz¹ nazwê <b>serwerów sekwencyjnych</b>.<br>
Ich u¿ytecznoœæ jest ograniczona: zwykle wymaga siê bowiem by serwer obs³ugiwa³ równolegle wielu klientów.<br>
 <br>
<br>
<br>
<a name="W8.11"></a><a name="W5.11"></a><a name="W5.11"></a><h2>
5.11. Serwery wielow¹tkowe</h2>

Klasycznym rozwi¹zaniem wspomnianego przed chwil¹ problemu jest zastosowanie wspó³bie¿noœci w programowaniu serwerów.<br>
<br>
Jednym z mo¿liwych podejœæ jest:<br>
<ul>
  <li>utworzenie gniazda serwera (ServerSocket) i zwi¹zanie go z adresem (bind),</li>
  <li>po czym uruchomienie wielu w¹tków serwera, ka¿dy z których bêdzie rownolegle 
nas³uchiwa³ i akceptowa³ po³¹czenia na tym gnieŸdzie i obs³ugiwa³ akceptowane
po³¹czenia.</li>
</ul><br>
Przyjrzyjmy siê temu rozwi¹zaniu w praktyce na przyk³adzie zmodyfikowanego
serwera "ksi¹zki telefonicznej", który teraz uczynimy wielow¹tkowym.<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.regex.*;

public class PhoneBookServerMT1 extends Thread {

  private PhoneDirectory pd = null;
  private ServerSocket ss = null;
  private BufferedReader in = null;
  private PrintWriter out = null;

  private volatile boolean serverRunning = true; // mo¿na zakoñczyæ w¹tek
                                         // metod¹ ustalaj¹c¹
                                         // wartoœæ tej zmiennej na false

  private String serverTID;              // identyfikator w¹tku

  public PhoneBookServerMT1(String serverTID, PhoneDirectory pd,
                          ServerSocket ss) {
    this.serverTID = serverTID;
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server " + serverTID + " started");
    System.out.println("listening at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    start();    // uruchomienie w¹tku
  }


  public void run() {
    while (serverRunning) {
      try {
        Socket conn = ss.accept();

        System.out.println("Connection established by " + serverTID);

        serviceRequests(conn);

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }                               // zamkniêcie gniazda serwera
    try { ss.close(); } catch (Exception exc) {}
  }

  // Pozoate³e metody m.in.serviceRequest jak w poprzednio pokazanej klaeie

  private void serviceRequests(Socket connection) {
     // ...
  }

  private void writeResp(int rc, String addMsg)
               throws IOException {
     // ...
  }

  public static void main(String[] args) {
    final int SERVERS_NUM = 4;   // liczba serwerów
    PhoneDirectory pd = null;
    ServerSocket ss = null;
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);
      pd = new PhoneDirectory(phdFileName);
      InetSocketAddress isa = new InetSocketAddress(host, port);
      ss =  new ServerSocket();
      ss.bind(isa);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Start wielu w¹tków (serwerow) dzialaj¹cych równolegle
    // na tym samym gnie¿dzie serwera

    for (int i=1; i &lt;= SERVERS_NUM; i++) {
      new PhoneBookServerMT1("serv thread " + i, pd, ss);
    }
  }

}
</pre>
Tym razem nasza klasa serwera dziedziczy Thread, a jej obiekty-w¹tki s¹ uruchamiane
metod¹ start() z konstruktora. Akceptacja i obs³uga po³¹czeñ (przekazywana
metodzie serviceRequests) jest zapisana w metodzie run(). Zatem ka¿dy z uruchomionych
w¹tków-serwerów jest zdolny do równoleg³ej z innymi w¹tkami-serwerami obs³ugi
po³¹czeñ od klientów.<br>
<br>
W metodzie main() tworzymy kilka egzemplarzy serwerów. Po uruchomieniu programu uzyskamy nastêpuj¹ce komunikaty:<br>
<div class="listing100"><br>
&gt;java PhoneBookServerMT1 Book.txt localhost 2300<br>
<br>
Server serv thread 1 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 2 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 3 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 4 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
</div><br>
<br>
Cztery serwery czekaj¹ tu na po³¹czenia klientów. Ka¿dy z nich mo¿e je zaakceptowaæ i obs³u¿yæ zlecenia.<br>
<br>
Teraz nasz poprzedni program testuj¹cy, w którym trzy w¹tki klienckic pyta³y
po kilka razy o telefony (jeden - do Asi, drugi - do Adama, trzeci - do Jacka)
bêdzie siê wykonywa³ jak trzeba:  klienci  bêd¹ mieli praktycznie równoleg³y
dostêp do serwera.<br>
Pokazuje to wydruk dzia³ania programu.<br>
<div class="listing100"><br>
&gt;java PhoneBookClients localhost 2300<br>
Adam - tel. 333333<br>
Jacek - tel. 111111<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
</div><br>
<br>
Widzimy tu, ¿e ¿aden z w¹tków klienckich nie blokuje innym dostêpu do serwera
(w trakcie obs³ugi zleceñ jednego klienta, obs³ugiwane s¹ równie¿ - przez
inny egzemplarz serwera - zlecenia innego klienta).<br>
<br>
Inn¹ mo¿lwoœci¹ zapewnienia wspó³bie¿nej obs³ugi wielu klientów jest <b>wyodrêbnienie
w¹tków obs³ugi zleceñ</b>. <br>
<br>
Ideê t¹ mo¿na zrealizowaæ na wiele sposobów skladniowych. Tutaj pokazany
zostanie przyk³ad, w ktorym obs³ugiwaæ zlecenia klientów bêd¹ obiekty-w¹tki
klasy RequestHandler (dziedzicz¹cej Thread). <br>
Zobaczmy najpierw co - w tej sytuacji - robi g³ówny fragment serwera.<br>
<pre>
import java.net.*;
import java.io.*;

public class PhoneBookServerMT2  {

  private PhoneDirectory pd = null;
  private ServerSocket ss = null;

  public PhoneBookServerMT2(PhoneDirectory pd,ServerSocket ss) {
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server started");
    System.out.println("listening at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    serviceConnections();
  }


  private void serviceConnections() {
    boolean serverRunning = true;
    while (serverRunning) {
      try {
        Socket conn = ss.accept();
        System.out.println("Connection established");

        <b>// start w¹tku obs³ugi zleceñ
        new RequestHandler(pd, conn).start();</b>

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }
    try { ss.close(); } catch (Exception exc) {}
  }

//...

}
</pre>
<br>
Klasê obs³ugi zleceñ (RequestHandler) pokazuje poni¿szy wydruk.<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.regex.*;

class RequestHandler extends Thread {

  private PhoneDirectory pd = null;
  private Socket connection = null;
  private BufferedReader in = null;
  private PrintWriter out = null;

  private static Pattern reqPatt = Pattern.compile(" +", 3);

  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };

  public RequestHandler(PhoneDirectory pd, Socket connection) {
    this.pd = pd;
    this.connection = connection;
    try {
      in = new BufferedReader(
               new InputStreamReader(
                   connection.getInputStream()));
      out = new PrintWriter(
                connection.getOutputStream(), true);
    } catch (Exception exc) {
        exc.printStackTrace();
        try { connection.close(); } catch(Exception e) {}
        return;
    }
  }

  public void run() {
    try {
      for (String line; (line = in.readLine()) != null; ) {
        String resp;
        String[] req = reqPatt.split(line, 3);
        String cmd = req[0];
        if (cmd.equals("bye")) {
          writeResp(0, null);
          break;
        }
        else if (cmd.equals("get")) {
          if (req.length != 2) writeResp(1, null);
          else {
            String phNum = (String) pd.getPhoneNumber(req[1]);
            if (phNum == null) writeResp(2, null);
            else writeResp(0, phNum);
          }
        }
        else if (cmd.equals("add"))  {
          if (req.length != 3) writeResp(1, null);
          else {
            boolean added = pd.addPhoneNumber(req[1], req[2]);
            if (added) writeResp(0, null);
            else writeResp(3, null);
          }
        }
        else if (cmd.equals("replace"))  {
          if (req.length != 3) writeResp(1, null);
          else {
            boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
            if (replaced) writeResp(0, null);
            else writeResp(4, null);
          }
        }
        else writeResp(1, null);
      }
    } catch (Exception exc) {
        exc.printStackTrace();

    } finally {
        try {                  // by nie byæ zbyt drobiazgowym:
          connection.close();  // przy zamkniêciu gniazda
          connection = null;   // strumienie s¹ zamykane automatycznie
        } catch (Exception exc) { }
    }
  }

  private void writeResp(int rc, String addMsg)
               throws IOException {
    out.println(rc + " " + msg[rc]);
    if (addMsg != null) out.println(addMsg);
  }
}
</pre>
<br>Przy programowaniu serwerów wielow¹tkowych musimy zadbaæ o w³aœciw¹ synchronizacjê dostêpu do wspóldzielonych zasobów.<br>
W przypadku omawianych tu serwerów "ksi¹¿ki telefonicznej" takim zasobem jest mapa zdefiniowana w klasie PhoneDirectory.<br>
Nie jest ona synchronizowana, ale mo¿emy ( i powinniœmy) zast¹piæ j¹ wersj¹ synchronizowan¹:<br>
<br>
<pre>
public class PhoneDirectory {

  private Map pbMap = Collections.synchronizedMap(new HashMap());
  // ...
}
</pre><b><font color="#ff0000">Uwaga:</font></b> to rozwi¹zanie nie zapewnia synchronizacji dostêpu do wiêkszych fragmentów mapy (np. operacje zbiorcze lub iterowanie).<br>
<br>
Ale synchronizacja zmniejsza efektywnoœæ dzialania (przypomnijmy  programowanie
wspólbie¿ne). Przy tym,  wszystkie rodzaje dostêpu bêd¹ synchronizowane, 
a przecie¿ nie jest to konieczne przy dostêpie "tylko do odczytu" (pobieraniu
numerów telefonów).<br>
Mo¿e wiêc moglibyœmy zrobiæ tak: nie synchronizowac mapy, a jedynie te metody
w klasie PhoneDirectory, które modyfikuj¹ jej zawartoœæ. Niestety, to nie
jest dobry pomys³.<br>
Przecie¿, jeœli nie zsynchronizujemy równie¿ metody odczytuj¹cej numer telefonu,
to jej wyniki mog¹ byæ niespójne z aktualnym stanem mapy (odczyt mo¿e pokazaæ
np. brak numeru, który by³ akurat zapisywany przez wyw³aszczony w¹tek).<br><br>
Rozwi¹zaniem tego dylematu s¹ tzw. <b>read-write locks</b>, semafory, które pozwalaj¹
w¹tkom czytaj¹cym pobieraæ informacje bez narzutu synchronizacji (o ile akurat
zasób nie jest zajêty przez w¹tek modyfikuj¹cy). Krótkie wprowadznie do tej
problematyki mo¿na znaleŸæ w artukule Amandeep Singha "Implementig Read/Write
Locks in Java" (http://www.asingh.net/technical/rwlocks.html).<br>
<br>
<b><font color="#ff0000">W Javie 1.5 mamy w pakiecie java.util.concurrent
interfejs ReadWriteLock oraz jefo implementacjê w klasie ReentrantReadWriteLock.<br>
</font></b><br><br>
<a name="W8.12"></a><a name="W5.12"></a><a name="W5.12"></a><h2>
5.12. Nieblokuj¹ce kana³y i  u¿ycie selektorów przy programowaniu serwerów</h2>

Oba przedstawione w poprzednim punkcie rozwi¹zania serwerów wielow¹tkowych maj¹ swoje
wady. <br>
<br>
Pierwsze (wiele egzemplarzy serwera) jest praktycznie <b>nieskalowalne</b>
(uruchamiamy zadan¹ liczbê w¹tków-serwerów i nie wiadomo czy jest to liczba
za du¿a czy za ma³a wobec nie znanych a priori, dynamicznie zmieniaj¹cych
sie, potrzeb).<br><br>
W drugim rozwi¹zaniu - po akceptacji po³¹czenia z klientem - uruchamiamy
odrêbny dla ka¿dego klienta w¹tek obs³ugi zleceñ. Przy bardzo du¿ej liczbie
klientów, <b>³¹cz¹cych siê i koñcz¹cych po³¹czenia z du¿¹ czestotliwoœci¹, powstaje
bardzo du¿o w¹tków i bardzo du¿o w¹tków koñczy dzia³anie. Maszyna wirtualna
Java mo¿e nie nad¹¿aæ w tej sytuacji z odœmiecaniem pamiêci. </b><br><br>
Z problemami skali - czêœciowo - mo¿na radziæ sobie  prowadz¹c <b>dynamiczn¹ pulê w¹tków-po³¹czeñ</b>.<br>
W ka¿dym przypadku jednak bêdziemy mieli do czynienia z <b>pelnowymiarowymi
problemami synchronizacji dostêpu do wspólnych zasobów</b>, które to problemy
nie tylko utrudniaj¹ programowanie, ale czêsto obni¿aj¹ efektywnoœæ dzia³ania
serwera.<br>
<br>
Pewnym rozwi¹zaniem i u³atwieniem jest u¿ycie nieblokuj¹cych kana³ów gniazd
(zob. te¿ punkt 9 tego wyk³adu oraz - ogólnie o NIO).<br><br>
Dla nieblokujacych kana³ów mo¿liwe jest ich <b>multipleksowanie</b> czyli obs³ugiwanie przez jeden w¹tek wielu kana³ów, bowiem klasy kana³ów gniazd (<b>SocketChannel</b> i <b>ServerSocketChannel</b>) pochodz¹ od klasy <b>SelectableChannel</b>, która pozwala na rejestrowanie kana³ów do monitorowania przez <b>selektory</b>.<br>
<br>
<div class="def"><b>Selektor</b> jest obiektem monitoruj¹cym zarejestrowane kana³y, reaguj¹cym
na zlecenia przychodz¹ce od klientów przez te kana³y i przekazuj¹cym serwerowi
sygna³y o gotowoœci do wykonania konkretnych operacji na poszczególnych kana³ach</div><br>
<br>
"Sygna³y gotowoœci" s¹ przekazywane w <b>kluczach selekcji</b> (obiektach
klasy SelectionKey). Obiekty te zawieraj¹ informacjê o kanale i o rodzaju
operacji, która aktualnie mo¿e byæ na kanale wykonana (jest "gotowa do wykonania").<br>
<br>Ideowy schemat dzia³ania slektora przedstawia poni¿szy rysunek.<br>
<img src="images/selektor1.jpg" alt="r" width="503" height="392" border="1">
<br>
<br>
 
<br>
<ol>
  <li>Najpierw kana³y s¹ rejestrowane do monitorowania przez selektor (obiekt
klasy Selector). Rejestracja kana³u tworzy klucz selekcji dla tego kana³u
(obiekt klasy SelectionKey). </li>
  <li>W kluczach zapisywane s¹ stany gotowoœci kana³ów
do wykonania okreœlonych operacji.</li>
  <li>
Selektor reaguje na zmiany stanów kana³ów, wynikaj¹ce z ¿¹dañ klientów. </li>
  <li>Gdy
jakiœ klient ³¹czy siê z serwerem przez kana³, zwi¹zany z gniazdem serwera,
selektor ustala stan gotowoœci klucza identyfikuj¹cego ten kana³, tak by
klucz wskazywa³ , ¿e istnieje po³¹czenie gotowe do zaakceptowania przez serwer.
</li>
  <li>Gdy klient pisze do kana³u komunikacyjnego, selektor ustala stan gotowoœci
klucza  identyfikuj¹cego ten kana³, tak by wskazywa³ na  to, ¿e w kanale
s¹ gotowe dane do odczytania   </li>
</ol>
Wka¿dym momencie mo¿e byæ dostêpnych wiele kluczy w zbiorze kluczy, opisuj¹cych gotowe do wykonania operacje. <br>
<b>Serwer przegl¹da
ten (zmieniaj¹cy siê) zbiór kluczy i odpowiednio do rodzaju gotowych do wykonania operacji wykonuje
je na identyfikowanych przez klucze kanalach. <font color="#ff0000">Poniewa¿ kana³y s¹ w trybie nieblokuj¹cym,
to operacje kana³owe nie blokuj¹ w¹tku</font>. <br>
</b><br>
W tej sytuacji obs³uga zleceñ klientów mo¿e byæ wykonywana <b>synchronicznie</b> <b>(!!!)</b>. <br>
W przeciwieñstwie
do tak¿e synchronicznie dzialaj¹cego serwera sekwencyjnego uzyskujemy przy
tym efekt rownoleg³ej obs³ugi klientów (o ile obs³uga zlecenia nie trwa d³ugo).
<br>
Serwer sekwencyjny musia³ bowiem obs³u¿yæ jednego klienta niejako "od pocz¹tku
do koñca" (w naszym przypadku serwera telefonicznego od po³¹czenia, poprzez
wszystkie zlecenia odczytywania czy zapisywania ksi¹¿ki telefonicznej, a¿
do koñcz¹cego komunikacjê zlecenia "bye"). <br>
Natomiast przy nieblokuj¹cych
kana³ach selektory rozbijaj¹ komunikacjê na pojedyñcze zlecenia (np. odczytu
konkretnego numeru telefonu) i ka¿de takie zlecenie (przychodz¹ce od ró¿nych
klientów przez ró¿ne kana³y) jest obs³ugiwane przez serwer niezale¿nie od
innych.<br>
<br><b>Przyk³adowy schemat programowaniu serwerów z u¿yciem
selektorów </b><br>
 <br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Middle" width="10%" align="Center" rowspan="3" colspan="1"><a name="W8.13"></a><a name="W5.13"></a><a name="W5.13"></a><h2>1</h2></td><td valign="Top"><div align="Center"><b>Utworzenie kana³u gniazda serwera<br>
i zwi¹zanie go z konkretnym adresem (host+port)</b><br></div></td></tr><tr><td valign="Top"><br>
String host = ...;<br>
int port = ...;<br>
ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>
serverChannel.socket().bind(new InetSocketAddress(host, port));<br>
<br></td></tr><tr><td valign="Top">Uwaga: metoda socket() z klasy ServerSocketChannel
zwraca skojarzone z kana³em gniazdo klasy ServerSocket. U¿ywamy tu jednej
z wersji metody bind tej klasy.<br></td></tr></tbody>
</table>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Middle" width="10%" align="Center" rowspan="3" colspan="1"><br>
<a name="W8.14"></a><a name="W5.14"></a><a name="W5.14"></a><h2>2</h2></td><td valign="Top"><div align="Center"><b>Ustalenie trybu nieblokuj¹cego <br>
dla kana³u serwera gniazda</b><br></div></td></tr><tr><td valign="Top"><br>
serverChannel.configureBlocking(false);<br>
<br></td></tr><tr><td valign="Top">Uwaga: kana³y rejestrowane z selektorami
(a wiêc przeznaczone do multipleksowania) musz¹ byæ skonfigurowane w trybie
nieblokuj¹cym i nie mo¿na zmieniæ tego trybu na blokuj¹cy, zanim kana³ nie zostanie wyrejestrowany.<br></td></tr></tbody>
</table>
<br>
.<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Middle" width="10%" align="Center" rowspan="3" colspan="1"><br>
<a name="W8.15"></a><a name="W5.15"></a><a name="W5.15"></a><h2>3</h2></td><td valign="Top">
      <div align="Center"><b>Utworzenie selektora</b><br>
      </div>
</td></tr><tr><td valign="Top"><br>
Selector selector = Selector.open();<br>
<br></td></tr><tr><td valign="Top">Statyczna metoda open() z klasy Selector
zwraca refencjê do obiektu-selektora, który jest tworzony przez domyœlnego,
systemowego kreatora selektorów. Mo¿na jednak  stworzyæ w³asn¹ klasê "dostawcy
selektorów" dostarczaj¹c¹ selektory niejako "w³asnej konstrukcji".<br></td></tr></tbody>
</table>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Middle" width="10%" align="Center" rowspan="3" colspan="1">
      <a name="W8.16"></a><a name="W5.16"></a><a name="W5.16"></a><h2>4</h2>
<a name="W8.17"></a><a name="W5.17"></a><a name="W5.17"></a><h2></h2></td><td valign="Top"><div align="Center"><b>Rejestracja kana³u gniazda serwera u selektora</b><br></div></td></tr><tr><td valign="Top"><br>
SelectionKey sscKey = serverChannel.register(selector,                  
                                                                         
          SelectionKey.OP_ACCEPT);<br>
<br></td></tr><tr><td valign="Top">Drugi argument wywolania okreœla rodzaje
operacji na danym kanale, którymi jesteœmy zainteresowani przy wykorzystaniu
tego selektora do wyboru operacji. <br>
Rodzaje operacji s¹ okreœlane przez bity liczby ca³kowitej i mo¿emy je podawaæ
jako bitow¹ alternatywê nastêpuj¹cych sta³ych statycznych typu int z klasy
SelectionKey:<br>
      <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td><code><b>OP_ACCEPT</b></code><br>
          Akceptacja po³aczenia.</td></tr><tr bgcolor="white" class="TableRowColor"><td><code><b>OP_CONNECT</b></code><br>
          Operacja ³¹czenie (kana³y gniazd klienckich).</td></tr><tr bgcolor="white" class="TableRowColor"><td><code><b>OP_READ</b></code><br>
          Operacja czytania</td></tr><tr bgcolor="white" class="TableRowColor"><td><code><b>OP_WRITE</b></code><br>
          Operacja pisania</td></tr></tbody>
      </table>
Na kanale gniazda serwera interesuj¹ nas tylko gotowe do zaakceptowania po³¹czenia - dlatego podajemy SelectionKey.OP_ACCEPT.<br>
Uwaga: mo¿na specyfikowaæ tylko operacje w³aœciwe dla danego rodzaju kana³u.
Dopuszczalen operacje mo¿emy uzyskaæ od kana³u za pomoc¹ metody validOps().
Rodzaje operacji s¹ w³aœciwosci¹ tworzonego przez rejestracjê klucza. Mo¿emy
je w ka¿dej chwili zmieniæ za pomoc¹ metody interestOps(int) z klasy SelectionKey.<br>
      <br>
Metoda zwraca klucz selekcji dla zarejestrowanego kana³u.<br>
      <br>
Kana³ zostaje wyrejestrowany, gdy wobec klucza reprezentuj¹cego jego rejestracjê
(zwróconego przez metodê register) zastosujemy odwo³anie cancel, lub gdy
kana³ zostanie zamkniêty. <br></td></tr></tbody>
</table>
<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
<tbody><tr><td valign="Middle" width="10%" align="Center" rowspan="2" colspan="1"><a name="W8.18"></a><a name="W5.18"></a><a name="W5.18"></a><h2>5</h2></td><td valign="Top"><div align="Center"><b>Selekcja gotowych operacji do wykonania i ich obs³uga<br>
w pêtli dzialania serwera</b><br></div></td></tr><tr><td valign="Top">for(;;) {                                     // Nieskoñczona pêtla dzia³ania serwera<br>
      <br>
      <i>  // Selekcja gotowej operacji<br>
  // To wywolanie jest blokuj¹ce<br>
  // Czeka a¿ selektor powiadomi <br>
  // o gotowoœci jakiejœ operacji na jakimœ kanale<br>
      </i><b>  selector.select();</b><br>
  <br>
      <b><i>  </i></b><i>// Teraz jakieœ operacje s¹ gotowe do wykonania<br>
  // Zbiór kluczy opisuje te operacje (i kana³y</i><i>)</i><b><i><br>
      </i>  Set keys = selector.selectedKeys();</b><br>
  <br>
      <i>  // Przegl¹damy "gotowe" klucze</i><br>
      <b>  Iterator iter = keys.iterator();<br>
  while(iter.hasNext()) {   <br>
      </b>    <i>// pobranie klucza</i> <br>
    <b>SelectionKey key = (SelectionKey) iter.next();</b> <br>
      <i>    // musi byæ usuniêty ze zbioru (nie ma autonatycznego usuwania)<br>
    // w przeciwnym razie w kolejnym kroku pêtli "obs³u¿ony" klucz<br>
    // dostalibyœmy do ponownej obs³ugi<br>
      </i>    <b>iter.remove();</b>                                                   <br>
      <i>    // Wykonanie operacji opisywanej przez klucz</i><br>
    <b>if (key.isAcceptable()) {</b> <i>// po³aczenie klienta gotowe do akceptacji</i><br>
      <i>      // Uzyskanie kana³u do komunikacji z klientem<br>
      // accept jest nieblokuj¹ce, bo ju¿ klient czeka<br>
      </i>      <b>SocketChannel cc = serverChannel.accept();</b><br>
      <i>      // Kana³ nieblokuj¹cy, bo bêdzie rejestrowany u selektora</i><br>
      <b>      cc.configureBlocking(false);</b><br>
      <i>      // rejestrujemy kana³ komunikacji z klientem<br>
      // do monitorowania <font color="#ff0000"><b>przez ten sam</b></font> selektor<br>
      </i><b>      cc.register(selector, SelectionKey.OP_READ | OP_WRITE);</b><br>
      <b>      continue;<br>
    }</b><br>
    <b>if (key.isReadable()) {</b>  <i>// któryœ z kana³ów gotowy do czytania</i><br>
      <i>      // Uzyskanie kana³u na którym czekaj¹ dane do odczytania</i><br>
      <b>      SocketChannel cc = (SocketChannel) key.channel();<br>
      </b><i>      // obs³uga zleceñ klienta<br>
      // ...<br>
      </i><b>      continue;</b><br>
      <b>    }</b><br>
      <b>    if (key.isWriteable())</b> {  // któryœ z kana³ów gotowy do pisania<br>
      <i>      // Uzyskanie kana³u </i><br>
      <b>      SocketChannel cc = (SocketChannel) key.channel();</b><br>
      <i>      // pisanie do kana³u<br>
      // ...</i><br>
      <b>      continue;<br>
    }<br>
  }<br>
}</b> <br></td></tr></tbody>
</table>
<br>
Pokazan¹ pêtlê dzia³ania serwera mo¿na bli¿ej wyjasniæ w nastêpuj¹cy sposób..<br>
Metoda select() wstrzymuje dzialanie pêtli dopóki selektor monituraj¹cy zarejestrowane
u niego kana³y nie okreœli gotowych do wykonania operacji. Gotowe operacje
s¹ reprezentowane przez podzbiór wszystkich kluczy (tzw. selected-keys set)
i podzbiór ten przy ka¿dorazowym wywo³aniu select() jest przez selektor modyfikowany
zgodnie z aktualnym stanem kana³ów. W ka¿dym kroku pêtli przegl¹dany jest
aktualny zbiór "selected-keys" (metoda selectedKeys()) i dla ka¿dego klucza
z tego zbioru wykonywane s¹ na kanale identyfikowanym przez ten klucz (kana³
uzyskujemy od klucza za pomoc¹ metody channel()) okreœlone przez klucz operacje
(rodzaj operacji uzyskujemy wo³aj¹c metody isAccepteble(), isReadable(),
isWriteable()). <br>
Sczególn¹ operacj¹ jest akceptacja po³¹czenia nowego klienta. Jak wspomniano
na schemacie wywolanie metody accept() tym razem nie jest blokuj¹ce (bo selektor
ju¿ okreœli³, ¿e na kanale gniazda serwera czeka kolejny klient). Wywo³uj¹c
metodê accept() natychmiast wiêc tworzymy kana³ komunikacji z klientem (SocketChannel).
Ten kana³ rejestrujemy u tego samego selektora który monitoruje kana³ gniazda
serwera i inne kana³y klienckie (zwrócmy uwagê - mamy tu jeden selektor).
W ten sposób ta sama pêtla, w sposób jednolity, obs³uguje wszystkie zlecenia.<br>
<br>
Tê w³aœciwoœæ pokazanego podejœcia ilustruje poni¿szy rysunek.<br>
<img src="images/selektor2.jpg" alt="r" width="593" height="451" border="1">
<br>
<br>
Mamy ju¿ teraz wystarczaj¹ce wiadomoœci, aby napisaæ omawiany w poprzednich
punktach serwer "ksi¹¿ki telefonicznej" w konwencji nieblokuj¹cego we/wy
i selektorów.<br>
Jego kod mo¿e wygl¹daæ tak.<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class PhoneBookServerNB {

  private PhoneDirectory pd = null;
  private ServerSocketChannel ssc = null;
  private Selector selector = null;

  public PhoneBookServerNB(PhoneDirectory pd, String host, int port ) {
    this.pd = pd;
    try {
      // Utworzenie kana³u dla gniazda serwera
      ssc = ServerSocketChannel.open();

      // Tryb nieblokuj¹cy
      ssc.configureBlocking(false);

      // Ustalenie adresu (host+port) gniazda kana³u
      ssc.socket().bind(new InetSocketAddress(host, port));

      // Utworzenie selektora
      selector = Selector.open();

      // Zarejestrowanie kana³u do obs³ugi przez selektor
      // dla tego kana³u interesuje nas tylko nawi¹zywanie po³¹czeñ
      // tryb - OP_ACCEPT
      ssc.register(selector,SelectionKey.OP_ACCEPT);

    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    System.out.println("Server started and ready for handling requests");
    serviceConnections();
  }

  private void serviceConnections() {
    boolean serverIsRunning = true;

    while(serverIsRunning) {
      try {
        // Wywo³anie blokuj¹ce
        // czeka na zajœcie  zdarzenia zwi¹zanego z kana³ami
        // zarejestrowanymi do obslugi przez selektor
        selector.select();

        // Coœ siê wydarzy³o na kana³ach
        // Zbiór kluczy opisuje zdarzenia
        Set keys = selector.selectedKeys();

        Iterator iter = keys.iterator();
        while(iter.hasNext()) {   // dla ka¿dego klucza

          SelectionKey key = (SelectionKey) iter.next(); // pobranie klucza
          iter.remove();                                 // usuwamy, bo ju¿
                                                         // go zaraz obs³u¿ymy

          if (key.isAcceptable()) { // jakiœ klient chce siê po³¹czyæ

            // Uzyskanie kana³u do komunikacji z klientem
            // accept jest nieblokuj¹ce, bo ju¿ klient siê zg³osi³
            SocketChannel cc = ssc.accept();

            // Komunikacja z klientem - nieblokuj¹ce we/wy
            cc.configureBlocking(false);

            // rejestrujemy kana³ komunikacji z klientem
            // do obs³ugi przez selektor
            // - typ zdarzenia - dane gotowe do czytania przez serwer
            cc.register(selector, SelectionKey.OP_READ);
            continue;
          }

          if (key.isReadable()) {  // któryœ z kana³ów gotowy do czytania
            // Uzyskanie kana³u na którym czekaj¹ dane do odczytania
            SocketChannel cc = (SocketChannel) key.channel();
            serviceRequest(cc);    // obsluga zlecenia
            continue;
          }
        }
      } catch(Exception exc) {
          exc.printStackTrace();
          continue;
      }
    }
  }

  private static Pattern reqPatt = Pattern.compile(" +", 3);

  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };

  // Strona kodowa do kodowania/dekodowania buforów
  private static Charset charset  = Charset.forName("ISO-8859-2");
  private static final int BSIZE = 1024;

  // Bufor bajtowy - do niego s¹ wczytywane dane z kana³u
  private ByteBuffer bbuf = ByteBuffer.allocate(BSIZE);

  // Tu bêdzie zlecenie do pezetworzenia
  private StringBuffer reqString = new StringBuffer();

  // Obs³uga (JEDNEGO) zlecania
  private void serviceRequest(SocketChannel sc) {
    if (!sc.isOpen()) return; // je¿eli kana³ zamkniêty - nie ma nic do roboty

    // Odczytanie zlecenia
    reqString.setLength(0);
    bbuf.clear();
    try {
      readLoop:                    // Czytanie jest nieblokuj¹ce
      while (true) {               // kontynujemy je dopóki
        int n = sc.read(bbuf);     // nie natrafimy na koniec wiersza
        if (n &gt; 0) {
          bbuf.flip();
          CharBuffer cbuf = charset.decode(bbuf);
          while(cbuf.hasRemaining()) {
            char c = cbuf.get();
            if (c == '\r' || c == '\n') break readLoop;
            reqString.append(c);
          }
        }
      }
      // Analiza zlecenia (jak poprzednio) i wo³anie nowej metody
      // writeResp zapisuj¹cej odpowiedŸ do kana³u
      String[] req = reqPatt.split(reqString, 3);
      String cmd = req[0];

      if (cmd.equals("bye")) {             // koniec komunikacji
          writeResp(sc, 0, null);          // - zamkniêcie kana³u
          sc.close();                      // i gniazda
          sc.socket().close();
      }
      else if (cmd.equals("get")) {
        if (req.length != 2) writeResp(sc, 1, null);
        else {
          String phNum = (String) pd.getPhoneNumber(req[1]);
          if (phNum == null) writeResp(sc, 2, null);
          else writeResp(sc, 0, phNum);
        }
      }
      else if (cmd.equals("add"))  {
        if (req.length != 3) writeResp(sc, 1, null);
        else {
          boolean added = pd.addPhoneNumber(req[1], req[2]);
          if (added) writeResp(sc, 0, null);
          else writeResp(sc, 3, null);
        }
      }
      else if (cmd.equals("replace"))  {
        if (req.length != 3) writeResp(sc, 1, null);
        else {
          boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
          if (replaced) writeResp(sc, 0, null);
          else writeResp(sc, 4, null);
        }
      }
      else writeResp(sc, 1, null);             // nieznane zlecenie

    } catch (Exception exc) {                  // przerwane pol¹czenie?
        exc.printStackTrace();
        try { sc.close();
              sc.socket().close();
        } catch (Exception e) {}
    }
  }

  private StringBuffer remsg = new StringBuffer(); // OdpowiedŸ

  private void writeResp(SocketChannel sc, int rc, String addMsg)
                         throws IOException {
    remsg.setLength(0);
    remsg.append(rc);
    remsg.append(' ');
    remsg.append(msg[rc]);
    remsg.append('\n');
    if (addMsg != null) {
      remsg.append(addMsg);
      remsg.append('\n');
    }
    ByteBuffer buf = charset.encode(CharBuffer.wrap(remsg));
    sc.write(buf);
  }

  public static void main(String[] args) {
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);

      PhoneDirectory pd = new PhoneDirectory(phdFileName);
      new PhoneBookServerNB(pd, host, port);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

}
</pre>
W programie tym warto zwróciæ uwagê na zastosowanie buforów  i na sposób radzenia sobie z niepewnoœci¹
co do liczby odczytanych w jednej operacji read() bajtów przy nieblokuj¹cym
wejœciu-wyjœciu. Na uwagê zas³uguje równie¿ staranie by nie tworzyæ zbyt
wielkiej liczby obiektów. Dlatego bufor bajtowy, wykorzystywany do czytania
z kana³u utworzono i alokowano jednorazowo na poziomie pól klasy. Takie podejœcie
jest uzasadnione, gdy nie ma wielu w¹tków, które mog³yby dzieliæ ten zasób.
<br>
No, w³aœnie, nasza nowy serwer w ogóle nie wykorzystuje w¹tków i nie mamy
rownie¿ problemów z synchronizacj¹ odwo³añ do klasy PhoneDirectory (bowiem
wszystkie operacje na zawartej w niej mapie s¹ wykonywane synchronicznie,
kolejno).<br>
A jego dzia³anie jest tak samo efektywne przy równoleg³ej obs³udze wielu
klientów, jak dzia³anie serwerów wielow¹tkowych (<i><b>ale: z mutexami, w œrodowiskach jednoprocesorowych</b></i>). <br>
<br>
Trzeba jednak wyraŸnie podkreœliæ, ¿e w praktycznym programowaniu "powa¿nych"
serwerów stosowane s¹ zarówno selektory jak i wspólbie¿noœæ (pule w¹tków).
Tylko w ten sposób mo¿na uzyskaæ wymagan¹ efektywnoœæ dzia³ania, a zastosowanie
nieblokuj¹cego wejœcia-wyjœcia i selektorów pomaga przy tym rozwi¹zywaæ problemy
skalowalnoœci i syncjronizacji.<br>
W takich zastosowanich u¿ywane s¹ jeszcze inne œrodki klas SelectableChannel, 
Selector i SelectionKey. Na koniec wiêc krótko o nich:<br>
<br>
<ul>
  <li>istnieje wersja metody register(...) z klasy SelectableChannel, pozwalaj¹ca
podaæ - jako trzeci argument - dowolny obiekt, który bêdzie zwi¹zany z utworzonym
przy rejestracji kluczem. Mo¿emy te¿ zwi¹zaæ obiekt z kluczem ju¿ po rejestracji
za pomoc¹ metody <b>attach(Object)</b> z klasy SelctionKey. Obiekt ten pó¿niej -
w fazie selekcji gotowych do wykonania operacji - bêdziemy mogli uzyskaæ
od klucza za pomoc¹ metody attachment() i wykorzystaæ np. do wykonania wybranej
operacji. Pozwala to nie tylko na lepsz¹ strukturyzacjê kodu, ale jest jednym
ze sposobów uruchamiania w¹tków obs³ugi zleceñ;</li>
  <li>oprócz blokuj¹cej metody select() w klasie Selector mamy do dyspozycji
dwie inne  wersje tej metody: select(long) blokuje, ale nie d³u¿ej ni¿ podany
jako arguemnt czas, selectNow() jest wywo³aniem nieblokuj¹cym (zatem przy
braku gotowosci kana³ów i operacji nasz serwer mo¿e wykonywac inne czynnoœci,
sprawdzaj¹c tê gotowoœc co jakiœ czas np. 300 ms);</li>
  <li>metoda wakeup() z klasy Selector przerywa blokowanie na select(..);
jest intensywnie u¿ywana przy ³¹czeniu "du¿ej dozy" wspó³bie¿noœci z mechanizmem
selekcji.</li>
</ul>
<br>
<a name="W8.19"></a><a name="W5.19"></a><a name="W5.19"></a><h2>5.13. Klasy Javy wspomagaj¹ce programowanie aplikacji klienckich</h2>Tworz¹c programy klienckie nie zawsze musimy siêgaæ do programownaia na poziomie gniazd.<br>
W Javie istniej¹ zestawy klas, które ukrywaj¹ przed programist¹ szczegó³y
komunikacji poprzez gniazda. O jednym takim zestawie ju¿ wspominano -  jest
nim bogato oprzyrz¹dowany pakiet Java Mail API.<br>
Inne to: <br>
<ul>
  <li>(niestandardowy) pakiet sun.net.ftp, s³u¿¹cy do programowania klientów
FTP (a tak¿e liczne, publicznie dostêpne pakiety klientów FTP dostêpne w
Sieci),</li>
  <li>zestaw klas pozwalajacych na po³¹czenia i komuniakcjê z zasobami sieciowymi, w szczególnoœci przy wykorzystaniu protoko³u HTTP.</li>
</ul>Poni¿szy program ³¹czy sie z  serwerem FTP, w kolejnych dialogach wejœciowych
pyta u¿ytkownika o pliki do pobrania i zapisuje je na lokalnym dysku.<br>
<pre>
import java.io.*;
import sun.net.ftp.FtpClient;    // podstawowa klasa pakietu sun.net.ftp
import java.text.*;

import javax.swing.*;

public class FtpFileRetriever {

  public static void main(String args[]) {
    FtpClient client = null;
    String userName = null;
    try {
     String host = args[0];
     userName = args[1];
     String password = args[2];
     client = new FtpClient(host);
     client.login(userName, password);  // logowanie
     client.binary();                   // tryb transmisji - binarny
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    String dir = null;
    String file = "";
    String dialogMsg = "Podaj nazwê pliku do pobrania:";
    while((file = JOptionPane.showInputDialog(dialogMsg)) != null) {
      try {
        String fileName = file;
        int lastSlash = file.lastIndexOf('/');

        // je¿eli w podanej nazwie pliku wystêpuje œcie¿ka katalogowa
        // zmieniamy biez¹cy katalog, jesli nie - pobierany jest plik
        // z aktualnego bie¿¹cego katalogu
        if (lastSlash != -1) {
           fileName = file.substring(lastSlash+1);
           dir = file.substring(0,lastSlash);
           client.cd(dir);                     // zmiana biez¹cego katalogu
        }
        BufferedInputStream in = new BufferedInputStream(
                                  client.get(fileName)  // zwraca strumieñ
                                 );                     // do czytania pliku

        BufferedOutputStream out = new BufferedOutputStream(
                                     new FileOutputStream(fileName)
                                   );
        System.out.println("Pobieram: " + fileName);

        byte[] data = new byte[1024];
        int bytesRead, totalBytes = 0;
        long start = System.currentTimeMillis();
        while( (bytesRead = in.read(data)) &gt; 0) {
          out.write(data, 0, bytesRead);
          totalBytes += bytesRead;
          System.out.print("\r... " + totalBytes);
        }
        out.close();
        double sec = (System.currentTimeMillis() - start)/1000.0;
        double kb =   totalBytes/1024.0;
        double kbps = kb/sec;
        DecimalFormat dn = new DecimalFormat("#.#");
        System.out.println("\nPobieranie ukonczone");
        System.out.println("Pobrano " + dn.format(kb) + "KB" +
                            " - " + dn.format(kbps) + " KB/sek.");
      } catch (IOException exc) {
         exc.printStackTrace();
      }
      dialogMsg = "Ostatnio pobrany plik: " + file +'\n' +
                  "Podaj nazwê pliku do pobrania:";
    }
    // Zamkniecie po³aczenia
    try {client.closeServer(); } catch(Exception exc) {}
    System.exit(1);
  }
}
</pre>
Dzia³anie tego programiku ilustruje rysunek.<br>
<br>
<img src="images/ftp1.jpg" alt="r" width="526" height="229">
<br>
<br>
<br>
Jak wspomniano, pakiet sun.net.ftp nie nale¿y do standardu Javy.<br>
W pakiecie java.net znajdziemy natomiast <b>standardowe</b> klasy przeznaczone
do pracy z zasobami sieciowymi, m.in.  klasy URL i URI oraz  URLConnection i HttpURLConnection.<br>
<br>
Obiekty klasy URL (Uniform Resource Locator) reprezentuj¹ - dobrze chyba
znane wszystkim - adresy zasobów sieciowych (jednolite lokalizatory zasobów).<br>
Sk³adniowo lokalizator taki sk³ada siê z kilku czêœci, m.in.:<br>
<ul>
  <li>opisu protoko³u (np. http, ftp, gopher, file)</li>
  <li>nazwy hosta (np. www.ibm.com)</li>
  <li>odniesienia do konkretnego zasobu  (np. œcie¿ki dostêpu do pliku i jego nazwy).</li>
</ul>
Przyk³ad:<br>
http://www.java.sun.con/j2ee/index.html<br>
<br>
Konkretne znaczenie treœci zasobu zale¿y od protoko³u i hosta (np. http://www.java.sun.com/j2ee/index.html
mo¿e oznaczac konkretny dokument lub treœæ dokumentu generowan¹ dynamicznie).
Zasoby sieciowe - to nie tylko pliki czy katalogi. mog¹ oznaczaæ równie¿
inne rodzaje informacji (np. wynik zapytania kierowanego do bazy danych).<br>
<br>
O lokalizatorach zasobów sieciowych bedziemy czasem mówiæ krótko: url.<br>
<br><b>
URI (Uniform Resource Identifier)</b> jest uogólnieniem pojêcia URL - opisuje
dowolne (fizyczne i abstrakcyjne) zasoby w sieci, które mog¹ byæ w jakikolwiek
sposób zidentyfikowane.<br>
Lokalizatory (URLe) s¹ podzbiorem identyfikatorów (URI).<br>
 O ile lokalizator (url) opisuje zasób w  taki sposób, ¿e jednoznaczny jest
mechanizm dostêpu do niego (np. po³o¿enie pliku w sieci i protokó³), to identyfikator
(URI) mo¿e oznaczaæ zasób o nieznanej lub niejednoznacznej konkretnej lokalizacji
i mechanizmie dostêpu, charakteryzuj¹cy sie jedynie unikaln¹, jednoznaczn¹
nazw¹ (Uniform Resource Name - URN).<br>
<br>
Wiêcej informacji na ten temat mo¿na znaleŸæ w dokumencie  RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax.<br>
<br>
<b>URI - identyfikacja, parsowanie<br>
URL - fizyczny dostêp<br></b><br>
Klasa URI w Javie nie dostarcza metod dostêpu do zasobów (znajdziemy tu
g³ównie metody s³u¿¹ce do rozbioru identyfikatorów na czêœci sk³adowe, normalizacji,
relatywizacji i rozwik³ywania idnetyfikatorów - o rozwik³ywaniu zob. w nastêpnym
przyk³adowym programie).<br>
<br>
Natomiast poprzez obiekty klasy URL mo¿emy uzyskaæ dostêp do zasobów sieciowych i to co najmniej na dwa sposoby.<br>
<br>
Najprostszy sposób (zarazem jednak najmniej elastyczny) uzyskiwania dostêpu
do zasobow sieciowych polega na wykorzystaniu strumienia wejœciowego, zwi¹zanego
z lokalizatorem zasobu (URLem - obiektem klasy URL).<br>
<br>
Kolejne kroki s¹ nastêpuj¹ce:<br>
<ul>
  <li>
stworzyæ URL za pomoc¹ jednego z konstruktorów klasy URL (jêsli podamy b³êdny adres powstanie wyj¹tek MalformedURLException),</li>
  <li>
uzyskaæ od niego strumieñ wejœciowy za pomoc¹ metody getInputStream(),</li>
  <li>
odczytaæ treœæ zasobu ze strumienia.</li>
</ul>

 Przyk³adowy program wykorzystuj¹cy ten sposób wczytuje podan¹ stronê WWW
i dokonuje jej analizy sk³adniowej w celu wyró¿nia znajduj¹cych siê na stronie
plików graficznych, po czym ³aduje te pliki i pokazuje w "przegl¹darce obrazków",
zbudowanej jako w³asna klasa ImageViewer.<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;

public class SimpleGet {

  public SimpleGet(String urlString) {
    try {
      URL url = new URL(urlString);
      BufferedReader in = new BufferedReader(
                          new InputStreamReader(
                               url.openStream() // zwraca InputStream
                                                // zwi¹zany z URLem
                          ));
      // Czêsci URL-a
      String protocol = url.getProtocol();
      String host = url.getHost();
      String file = url.getFile();
      System.out.println("Protocol: " + protocol);
      System.out.println("Host: " + host);
      System.out.println("File: " + file);

      // Zapiszemy dokument za pomoc¹ strumienia StringWriter
      StringWriter sw = new StringWriter(10240);
      String line;
      while ((line = in.readLine()) != null) {
         sw.write(line);
      }
      in.close();

      // Matcher do wyodrebniania referencji do plików graficznych na stronie
      Matcher matcher = Pattern.compile("img src=\"(.+?)\"",
                            Pattern.CASE_INSENSITIVE).matcher(sw.toString());

      // Obrazy bêdziemy przechosywaæ na liœcie
      java.util.List imgList = new ArrayList();

      while (matcher.find()) {
        String imgRef = matcher.group(1); // wyodrêbniamy zapisany na stronie
                                          // url obrazka
        // zwykle bêdzie relatywny
        // za pomoc¹ konstruktora URL(kontekst, referencja)
        // uzyskamy w³aœciwy lokalizator wskazuj¹cy zasób
        URL imgUrl = new URL(url, imgRef);
        System.out.println(imgRef + " ==&gt; " + imgUrl);
        // utworzenie obiektu Image i dodanie do listy
        imgList.add(Toolkit.getDefaultToolkit().createImage(imgUrl));
      }
      System.out.println("Preparation complete... wait for viewer init");

      // Listê obrazów przeka¿emy utworzonemu obiektowi przegl¹darki obrazków
      new ImageViewer(imgList);

    } catch (MalformedURLException exc) {
        exc.printStackTrace();
        System.exit(1);
    } catch (Exception exc) {
        exc.printStackTrace();
    }

  }

  public static void main(String[] args) {
    String url = JOptionPane.showInputDialog("Adres");
    new SimpleGet(url);
  }
}
</pre>
W programie wczytujemy stronê, której adres podano w dialogu i wyodrêbniamy
na niej wszystkie zapisane w znacznikach &lt;img src ... &gt; odniesienia
do obrazków.<br>
Takie odniesienie mo¿e byæ relatywne (w stosunku do lokalizacji wczytanej
strony). Dlatego urle obrazków tworzymy za pomoca konstruktora <b>URL(URL context, String spec)</b>. Konstruktor ten potrafi: <br>
<ul>
  <li><b>rozwik³aæ</b> relatywne adresy, czyli skomponowaæ url, w którym brakuj¹ce w <i><b>spec</b></i> sk³adniki s¹ brane z <b>context</b> (urla dokumentu bazowego - czyli adresu wczytanej strony),</li>
  <li><b>znormalizowaæ </b>rozwik³ane adresy, czyli odpowiednio usun¹æ wszystkie
niepotrzebne "." i ".." (oznaczaj¹ce w symboliczny sposób: katalog bie¿¹cy
i katalog nadrzêdny) ze œcie¿ki opisuj¹cej dostep do zasobu.</li>
</ul>
Przyk³adowo, jezeli nasz program uruchomimy podaj¹c jako adres:<br>
<br>
http://bugbog.com/beaches/beach_pictures_thailand/beach_pictures_ko%20samet_4.html;<br>
<br>
to na konsoli uzyskamy najpierw wydruk sk³adników urla (ilustracja metod get... pobieraj¹cych ró¿ne czeœci lokalizatora);<br>
<div class="listing100"><br>
Protocol: http<br>
Host: bugbog.com<br>
File: /beaches/beach_pictures_thailand/beach_pictures_ko%20samet_4.html<br>
</div><br>
<br>
a  z czêœci programu wyodrêbniaj¹cj adresy obrazków uzyskamy wydruk tych
adresów  w literalnie zapisanej na stronie postaci, z nastêpuj¹cym po znakach
==&gt; adresem rozwik³anym i znormalizowanym przez konstruktor URL(URL context,
String spec):<br>
<br>
<div class="listing100"><br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_9.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_9.jpg<br>
<br>
../../images/bugbog/bugbog.gif ==&gt; http://bugbog.com/images/bugbog/bugbog.gif<br>
<br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_7.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_7.jpg<br>
<br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_8.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_8.jpg<br>
<br>
../../images/bugbog/line.gif ==&gt; http://bugbog.com/images/bugbog/line.gif<br>
</div><br>
<br>
Program z uzyskanych urli obrazków za pomoc¹ metody createImage z klasy Toolkit
tworzy obiekty klasy Image i dodaje je do listy. Ta lista jesr przekazywana
przegl¹darce obrazków - ImageViewer.<br>
<br> Klasy ImageViewer i wykorzystaywana przez ni¹ ImagePanel (stanowi¹ca
obszar prezentacji obrazu z pliku) przedstawiono - dla porz¹dku -  na poni¿szym
wydruku (warto na nie spojrzeæ choæby dla przypomnienia wiadomoœci o kolekcjach
i programowaniu GUI):<br>
<pre>
import java.util.*;
import java.util.regex.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class ImagePanel extends JPanel {

  private Image img;
  private boolean correct;
  private Dimension defd = new Dimension(200,200);
  private String msg;

  public ImagePanel(String msg) {
    this.msg = msg;
    setPreferredSize(defd);
    setBorder(BorderFactory.createLineBorder(Color.blue, 2));
  }

  public void setImage(Image img) {
    this.img = img;
    int w = img.getWidth(this);       // szerokoœæ obrazka
    int h = img. getHeight(this);     // wysokoœæ obrazka
    if (w != -1 &amp;&amp; w != 0 &amp;&amp; h != -1 &amp;&amp; h != 0) {
      correct = true;
      setPreferredSize(new Dimension(w, h));
    }
    else setPreferredSize(defd);
    repaint();
  }

  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (img != null &amp;&amp; correct)
      g.drawImage(img, 0, 0, getWidth(), getHeight(), this);
    else
      g.drawString(msg, 10, 10);
  }

}

class ImageViewer extends JFrame implements ActionListener {

  private ListIterator lit;
  private ImagePanel imagePanel = new ImagePanel("Loading images ...");
  private JButton left = new JButton(new ImageIcon("arrow1.gif"));
  private  JButton right = new JButton(new ImageIcon("arrow2.gif"));
  private JButton os = new JButton("&lt;html&gt;&lt;b&gt;Oryginalna&lt;br&gt;skala&lt;/b&gt;&lt;/html&gt;");

  public ImageViewer(java.util.List imgList) {

    lit = imgList.listIterator();

    getContentPane().add(imagePanel);
    JPanel p = new JPanel(new FlowLayout(FlowLayout.CENTER));
    left.addActionListener(this);
    right.addActionListener(this);
    os.addActionListener(this);
    p.add(left); p.add(right); p.add(os);
    getContentPane().add(p, "South");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    show();


    MediaTracker mt = new MediaTracker(this);
    int i=0;
    while(lit.hasNext()) mt.addImage((Image) lit.next(), ++i);
    try {
      mt.waitForAll();
    } catch (InterruptedException exc) { }
    System.out.println("Image viewer ready");

    SwingUtilities.invokeLater(new Runnable() {
      public void run() { getNext(); }
    });
  }

  public void actionPerformed(ActionEvent e) {
    Object src = e.getSource();
    if (src == right) getNext();
    else if (src == left) getPrevious();
    else pack();
  }

  private boolean lastOperWasNext = true;

  private void getNext() {
    if (!lastOperWasNext) lit.next();
    if (!lit.hasNext()) while (lit.hasPrevious()) lit.previous();
    imagePanel.setImage( (Image) lit.next() );
    lastOperWasNext = true;
  }

  private void getPrevious() {
    if (lastOperWasNext) lit.previous();
    if (!lit.hasPrevious()) while (lit.hasNext()) lit.next();
    imagePanel.setImage( (Image) lit.previous() );
    lastOperWasNext = false;
  }

}

</pre>
 Wynik dzialania programu ilustruje rysunek (dwa przyciski - strza³ki, w
programie oznaczane jako left i right) s³u¿¹ do przechodzenia do kolejnych
obrazków; warto przy okazji zwróciæ uwage na zastosowanie w tym celu iteratora
listowego).<br>
<br>
<img src="images/Http1.jpg" alt="r" width="398" height="329">
<br>
<br>
<br>
Przedstawiony bardzo prosty sposób pobierania zasobów (za pomoc¹ strumienia uzyskanego do URLa) ma jednak co najmniej dwie wady:<br>
<ul>
  <li>nie pozwala na odczytanie i interpretacjê nag³ówków odpowiedzi serwera HTTP,</li>
  <li>nie pozwala na uzyskanie przekazywanych przez serwer kodów b³êdów  HTTP i zwi¹zanych z nimi komunikatów. </li>
</ul>
Klasa URLConnection i pochodna od niej HttpURLConnection usuwaj¹ te wady,
a co wiêcej pozwalaj¹ nie tylko na odczytywanie treœci zasobów, ale równie¿
na posy³anie do serwera innych zleceñ HTTP.<br>
<br>
No, w³aœnie - jak w ka¿dym protokole - komunikacja pomiêdzy klientem i serwerem
HTTP polega na wymianie zleceñ (od klienta) i odpowiedzi (od serwera).  Rodzaje
zleceñ HTTP podaje poni¿sza tabela.<br>
<br><br>
<table cellspacing="0" cellpadding="0" width="100%" border="1">
<tbody><tr><td valign="Top" width="20%">
      <div align="Center"><b>Zlecenie </b><br>
      <b>(request method)</b><br>
      </div>
</td><td valign="Top" width="60%">
      <div align="Center"><b>Znaczenie</b><br>
      </div>
</td></tr><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">GET <!--mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">uzyskanie zasobu identyfikowanego przez URL (odczytanie treœci zasobu)<br></td></tr><!--msthemelist--><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">HEAD <!--mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">Uzyskanie nag³ówków <br></td></tr><!--msthemelist--><tr><td valign="Top" width=
"20%"><!--mstheme--><font face="times new roman, times">POST <!--mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">Wys³anie danych o nielimiotowanej d³ugoœci <br></td></tr><!--msthemelist--><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">PUT <!--mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">Zapisanie zasobu <br></td></tr><!--msthemelist--><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">DELETE <!--
mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">Usuniêcie zasobu<br></td></tr><!--msthemelist--><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">OPTIONS <!--mstheme--></font><!--msthemelist--></td><td valign="Top" width="60%">Zwraca metody HTTP podtrzymywane przez serwer<br></td></tr><!--msthemelist--><tr><td valign="Top" width="20%"><!--mstheme--><font face="times new roman, times">TRACE</font></td><td valign="Top" width="60%">Zwraca nag³ówki wys³ane z
leceniem TRACE (do celów testowania_<br></td></tr></tbody>
</table>
<br>
Ka¿de zlecenie sk³ada siê m.in. z
<ul>
<li>nazwy metody zlecenia ,</li><li>nag³ówków HTTP zlecenia ,</li><li>treœci. </li>
</ul> W odpowiedzi serwera równie¿ wystêpuj¹ nag³ówki, opisuj¹ce "parametry"
treœci odpowiedzi ( np. wielkoœc, datê modyfikacji, typ treœci)<br>
<br>
W odró¿nieniu od komunikacji z serwerem HTTP za pomoc¹ gniazd, gdzie do/z
strumieni gniazda zapisuje siê/czyta ca³¹ wymagan¹ przez protokó³ informacjê
  przy zastosowaniu klas URL i URLConnection nag³ówki nie mog¹ byæ zapisywane
do strumieni i nie mog¹ byæ z tych strumieni odczytane.<br>Analizê nag³ówków
odpowiedzi serwera umo¿liwj¹ metody klasy URLConnection. Klasa ta (wraz z pochodn¹ od niej HttpURLConnection) 
pozwala równie¿ na wysy³anie do serwera innych od najprostszego GET zleceñ HTTP  i ustalanie nag³ówków tych zleceñ.<br>
<br>Komunikacjê z serwerem HTTP za pomoc¹ klasy URLConnection mo¿na przedstawiæ w nastepuj¹cych krokach.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top" width="10%">1<br>
      </td>
      <td valign="Top">
Tworzymy obiekt klasy URLConnection, wi¹¿¹c go z podanym URLem:<br>
      <b>URL url = new URL(...);<br>
URLConenction conn = URLConnection.open(url);</b><br>
      </td>
    </tr>
    <tr>
      <td valign="Top" width="10%">2<br>
      </td>
      <td valign="Top">Opcjonalnie: <br>
      <ul>
        <li>Za pomoc¹ metody <b>setRequestProperty(String key, String value)</b> ustalamy zawartoœæ nag³ówków zlecenia (np. nag³ówek "accept-language")</li>
        <li>Za pomoc¹ wywolania metody <b>conn.doOutput()</b> ustalamy, ¿e
zlecenie bêdzie zleceniem POST, s³u¿¹cym do przesy³ania do serwera  dowolnych
danych, najczêœciej danych formularza HTTP, zapisanych jako parametry zlecenia.</li>
      </ul>
Domyœlnie zlecnie jest typu GET (a do ustalenia tego trybu s³u¿y metoda doInput). </td>
    </tr>
    <tr>
      <td valign="Top" width="10%">3<br>
      </td>
      <td valign="Top">Nawi¹zujemy po³¹czenie:<br>
      <b>conn.connect()</b><br>
      </td>
    </tr>
    <tr>
      <td valign="Top" width="10%">4<br>
      </td>
      <td valign="Top">Mo¿emy teraz - jeœli tego potrzebujemy - odczytaæ
nag³ówki przes³ane przez serwer za pomoc¹ metod getHeader(...), getHeaders(...)
oraz metod przeznaczonych do odczytywania czêsto u¿ywanych nag³ówków (np.
getContentType()).<br>
      </td>
    </tr>
    <tr>
      <td valign="Top" width="10%">5<br>
      </td>
      <td valign="Top">Je¿eli zlecenie jest typu POST (ustalone metod¹ doOutput()) to za pomoca metody <b>conn.getOutputStream()</b> uzyskujemy dostêp do strumienia wyjœciowego po³¹czenia i zapisujemy do niego treœc zlecenia (np. parametry formularza)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">6<br>
      </td>
      <td valign="Top">Uzyskujemy strumieñ wejœciowy do czytania odpowiedzi serwera (<b>conn.getInputStream()</b>) i za jego pomoca czytamy tê odpowiedŸ<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>Spójrzmy najpierw na bardzo prosty program, odczytuj¹cy z serwera dokument
HTML za pomoc¹ obiektu klasy URLConnection (domyœlnie posy³ane zlecenie jest
typu GET).<br>
Przy okazji zapoznamy sie ze sposobem uzyskiwania ca³ego zestawu nag³ówków
odpowiedzi (w mapie zawierajacej jako klucze nazwy nag³ówków a jako wartoœci
- ich zawartoœæ). Dla czêsto u¿ywanych nag³ówków (np. contnet-type, content-length)
istniej¹ dodatkowe odrêbne metody pobierania (np. getContentType(), getVontentLength()).<br>
<br>
<pre>
import java.net.*;
import java.io.*;
import java.util.*;
import javax.swing.*;

public class Connection1 {

  public Connection1(String urlString) {
    try {
      URL url = new URL(urlString);
      URLConnection conn = url.openConnection();
      conn.setUseCaches(false);
      conn.connect();

      Map map = conn.getHeaderFields();
      for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {
        String header = (String) it.next();
        System.out.println(header + ":" + map.get(header));
      }

      BufferedReader in = new BufferedReader(
                           new InputStreamReader(
                            conn.getInputStream() ) );

      for ( String line; (line = in.readLine()) != null; ) {
        System.out.println(line);
      }
      in.close();
    } catch (MalformedURLException exc) {
        exc.printStackTrace();
        System.exit(1);
    } catch (FileNotFoundException exc) {
        System.out.println("Podanego zasobu nie ma na serwerze");
        System.exit(2);
    } catch (Exception exc) {
        exc.printStackTrace();
    }
  }

  public static void main(String[] args) {
    String url = JOptionPane.showInputDialog("Adres");
    new Connection1(url);
  }
}
</pre>

<br>Po wprowaddzeniu jakiegoœ (prawid³owego) adresu dokumnetu na pocz¹tku wydruku uzyskamy nag³ówki np.<br>
<div class="listing100"><br>
null:[HTTP/1.1 200 OK]<br>
Content-Language:[pl]<br>
Date:[Mon, 17 Nov 2003 02:29:38 GMT]<br>
Accept-Ranges:[bytes]<br>
Server:[Apache]<br>
Content-Type:[text/html; charset=iso-8859-2]<br>
Transfer-Encoding:[chunked]<br>
...<br>
// dalej treœc dokumentu html<br>
</div><br>
<br>
Zwróæmy uwagê, interpretacja nag³ówków mo¿e sie nam przydaæ do prawid³owego
kodowania treœci dokumentu (nag³ówek Content-Type bêdzie czêsto, choæ nie
zawsze, podawa³ stronê kodow¹).<br>
Zauwa¿my te¿, ¿e w pierwszesj linii wydruku podany jest kod odpowiedzi serwera
(200) i zwi¹zany z nim komunikat (OK - zlecenie by³o poprawne i uzyskaliœmy
odpowiedŸ).<br>
Gdyby np. podaæ nieistniej¹cy plik, to uzyskalibyœmy nag³ówki np.:<br>
<div class="listing100"><br>
null:[HTTP/1.1 404 Not Found]<br>
Connection:[Keep-Alive]<br>
Expires:[Tue, 01 Jan 1980 12:00:00 GMT]<br>
Date:[Mon, 17 Nov 2003 02:39:46 GMT]<br>
Keep-Alive:[timeout=15, max=100]<br>
Pragma:[no-cache]<br>
Server:[Apache]<br>
Content-Type:[text/html]<br>
Last-Modified:[Thu, 01 Jan 1970 00:00:00 GMT]<br>
Transfer-Encoding:[chunked]<br>
Cache-control:[no-cache, must-revalidate]<br>
</div><br>
<br>
ale przy czytaniu treœci odpowiedzi wyst¹pi³by wyj¹tek FileNotFoundException.<br>
<br>
Na marginesie nalezy dodaæ tu, ¿e wygodniejszym i  bardziej szczegó³owym
sposobem identyfikacji wyniku zlecenia jest u¿ycie metod getResponseCode()
i getResponseMessage() z klasy HttpURLConnection (obiekt tej klasy dla URLi
z protoko³em HTTP jest zwracany z metody URLConnection.openConnectuin(),
musimy tylko dokonaæ zawê¿ajacej konwesrji referencyjnej z formalnego typu
URLConncetion do  HttpURLConnection).<br>
<br>
Drugi przykladowy programik kliencki, u¿ywaj¹cy klasy URLConenction jest
nieco ciekawszy, pokazuje bowiem jak zapisywaæ zlecenie typu POST. W tym
celu ustalamy w³aœciwoœæ po³¹czenia jako "do pisania" - metod¹ doOutput().
Mo¿emy tak¿e ustaliæ nag³ówki naszego zlecenia. Ustalimy tu jêzyk, dziêki
czemu aplikacje dzialajace po stronie serwera bed¹ mog³y wykorzystaæ informacje
o lokalizacji (np. przesy³aæ informacje po polsku). <br>
Nastepnie piszemy treœæ zlecenia do strumienia wyjœciowego. Mo¿e to byæ dowolna
informacja, któr¹ umiej¹ przetworzyæ aplikacje serwerowe. Najczeœciej bêdziemy
tu zapisywaæ parametry formularzy HTTP w formie: nazwa_parametru=wartoœc_
parametru. Poniewa¿ przy przekazywaniu parametrów przyjêto konwencje, ¿e
musz¹ one byæ specjalnie kodowane (tzw. url-kodowanie), to parametry bêdziemy
kodowaæ za pomoc¹ klasy URLEncoder (o sczegó³ach url-kodowania zobacz w dokumentacji
tej klasy).<br>
Po przekazaniu parametrów odczytujemy odpowiedŸ serwera. Umówimy siê, ¿e  
aplikacja obs³uguj¹ca po stronie serwera zlecenia naszego przyk³adowego klienta 
zwraca informacje tekstow¹ o rodzaju zlecenia, lokalizacji, kodowaniu,  jego
nag³ówkach oraz przekazanych wartoœciach parametrów.<br>
Klient wypisze te informacje na konsoli.<br>
<br>
<pre>
import java.io.*;
import java.net.*;

public class Client1 {

    public static void main(String[] args) throws Exception {

     // Z tego pliku przeczytamy zlecnie do pos³ania
     // bed¹ to pary "nazwa_parametru=wartoœæ"
      BufferedReader br = new BufferedReader(
                              new FileReader(args[0])
                            );

      URL url = new URL("http://....");                // adres aplikacji
                                                       // po stronie serwera
                                                       // obs³uguj¹cej klienta
      URLConnection connection = url.openConnection();

      // Ustalenie nag³ówka "accept-language" zlecenia
      // Po stronie serwera da to informacjê o lokalizacji
      // Tutaj jej nie u¿ywamy, ale mo¿e sie przydac w innych okolicznoœciach  
      connection.setRequestProperty("accept-language", "pl");

      // Bêdziemy pisaæ treœæ zlecenia
      connection.setDoOutput(true);

      String charset = "UTF-8";          // kodowanie treœci
      PrintWriter out = new PrintWriter(
                             new OutputStreamWriter(
                              connection.getOutputStream(), charset)
                           );
      // Czytamy z pliku i zapisujemy jako treœæ zlecenia
      // pary: nazwa_parametru=wartoœc parametru
      String line;
      while ((line = br.readLine()) != null)
       out.println(URLEncoder.encode(line, "UTF-8"));
      br.close();
      out.close();

      System.out.println("Zapis dokonany");

      // Odczytujemy odpowiedŸ serwera
      BufferedReader in = new BufferedReader(
                            new InputStreamReader(
                              connection.getInputStream(), charset));

      while ((line = in.readLine()) != null)
        System.out.println(line);

      in.close();
   }


}
</pre>
Jesli w pliku podanym jako argument znajduj¹ siê zapisy:<br>
parametr1=Pies<br>

parametr2=Kot<br>

parametr3=Wróbel æwierkaj¹cy &gt; 20 <br>
<br>
to program wyprowadzi na konsoli:<br>
<br>
<div class="listing100"><br>
Zapis dokonany<br>
Klient wys³a³ zlecenie<br>
Metoda: POST                     <br>
Locale: pl<br>
Character encoding: UTF-8<br>
<br>
Nag³ówki:<br>
accept-language: pl<br>
user-agent: Java/1.4.2<br>
host: localhost:8080<br>
accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2<br>
connection: keep-alive<br>
content-type: application/x-www-form-urlencoded<br>
content-length: 90<br>
<br>
Parametry:<br>
parametr1=Pies<br>
parametr2=Kot<br>
parametr3=Wróbel æwierkaj¹cy &gt; 20 <br>
</div><br>
<br>
Warto zauwa¿yæ, ¿e do url-kodowania przyjêliœmy bezpieczn¹ stronê kodow¹
UTF-8. W zwi¹zku z tym i treœci kodujemy w tej stronie kodowej.<br>
<br> Oczywiœcie, tajemnicze jest nieco sk¹d akurat bierze sie taka odpowiedŸ
serwera. Napisano, ¿e tworzy j¹ aplikacja dzialaj¹ca po stronie serwera.
Pora wiêc na zapoznanie siê z takimi aplikacjami i temu poœwiêcony bêdzie
nastêpny wyk³ad. Jednoczeœnie mo¿na tam znaleŸæ dodatkowe infomacje o protokole
HTTP, zleceniach i ich obs³udze, a tak¿e kwestiach zwi¹zanych z formularzami
HTTP  i ich parametrami.<br>
<br>
<br>
<br>


</body></html>
