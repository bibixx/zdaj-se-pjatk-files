<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN"><html><head rel="stylesheet" type="text/css" href="../style/common.css">
  <meta http-equiv="Content-Type" content="text/html;">
  <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]"><title>W1</title>

  <link rel="stylesheet" type="text/css" href="../style/common.css">
  <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script></head><body bgcolor="#efefef">
<div align="Center">
<a name="W1"></a><a name="W1"></a><h1>Formatowanie, lokalizacja i internacjonalizacja</h1>
</div><br>
<a name="W1.1"></a><a name="W1.1"></a><h2></h2>
<a name="W1.2"></a><a name="W1.2"></a><h2>Pierwsze spotkanie z lokalizacj¹</h2>
<br>
    double d = 10/3.0;<br>



    System.out.println(d);<br>
<br>
wynik:<br>
<br>



3.3333333333333335<br>
<br>
Sformatowaæ wynik.<br>
<br>
<pre>
     NumberFormat nf = NumberFormat.getInstance();
     nf.setMaximumFractionDigits(3);
     String wynik = nf.format(d);
     System.out.println(wynik);

</pre>
wynik (na komputerze w Polsce):
<h1>3,333</h1>
<br>
wynik (na komputerze w Anglii):<br>
<br>
<h1>3.333</h1>
Co siê dzieje? Dlaczego? <br>
<a name="W1.3"></a><a name="W1.3"></a><h2>Lokalizacje </h2><div class="def">Specyficzne
dla danego jêzyka, regionu/kraju - regu³y, dotycz¹ce prezentacji ró¿nych
informacji (np.formatowania liczb i dat, pisowni tekstów, porz¹dku alfabetycznego)
nazwiemy lokalizacj¹</div>. <br>
<br>
<b>Potrzebny jest mechanizm lokalizacji i internacjonalizacji aplikacji, co wynika z kosztów dostosowania (zmian kodu).<br>
</b><br>W Javie ca³y zestaw klas:<br>
java.text i trochê w java.util.<br>
<br>
Taligent ====&gt; Sun zastosowa³ w Javie 1.1.  <br>
Do dziœ bez wiêkszych zmian. <br>
<br>
Taligent ====&gt; Unicode group w IBM Globalization Center of Competency
w Cupertino (rozwój, przenoszenie do jêzyków C++i C, na zasadach "open source").<br><br>
Bblioteka <font color="#cc0000"><b>  International Components for Unicode</b></font>:<br>
poszerzone wersje klas lokalizacyjno-internacjonalizacyjnych, 
a tak¿e pewne dodatkowe klasy, których w standardzie Javy brak. <br>
Biblioteka
wdra¿a najnowsze standardy Unicode (w tej chwili Unicode 4.0) i  jest dostêpna
w wersjach dla jêzyków Java (ICU4J),  C++ i C (ICU4C) na stronie <a href="http://oss.software.ibm.com/icu/">http://oss.software.ibm.com/icu/</a>
.<br>
<br><div class="def">W Javie lokalizacje reprezentowane s¹ przez obiekty klasy <b>Locale</b> z pakietu java.util</div>.<br>
<br>
<div class="syntax">Lokalizacja okreœlana jest przez kombinacjê:<br>
<ul>
  <li>kodu jêzyka, </li>
  <li>kodu kraju,</li>
  <li>kodu wariantu.</li>
</ul>
Kody te - wartoœci typu String -  podajemy przy tworzeniu obiektu klasy Locale
jako argumenty konstruktora tej klasy, przy czym mamy do dyspozycji trzy
przeci¹¿one konstruktory:<br>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td><code><b>Locale</b>(String language)</code>          </td></tr><tr bgcolor="white" class="TableRowColor"><td><code><b>Locale</b>(String language,
       String country)</code></td></tr><tr bgcolor="white" class="TableRowColor"><td><code><b>Locale</b>(String language,
       String country,
       String variant)</code></td></tr></tbody>
</table>
<br><b>
Kod jêzyka</b> - kombinacja dwóch ma³ych liter, standard
ISO-639 (zob dostêpne kody : <a href="http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt">http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt</a>
)<br><br>
<b>Kod kraju</b> - to  kombinacja dwóch du¿ych liter, okreœlaj¹ca kraj
wg standardu ISO-3166 (<a href="http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html">http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html</a>
)<br><br>
<b>Kod wariantu</b> - dodatkowa  informacja, któr¹ mo¿emy dodaæ i która nie
musi spe³niaæ ¿adnych standardów, wobec czego jest specyficzna w danych warunkach (np. pakietu lokalizacyjnego) lub dla danej
aplikacji.<br>
</div><br>
<br>
Przyk³ady:<br>
<br>
Locale a = new Locale("en", "GB");  // jêzyk angielski, kraj Wielka Brytania <br>
Locale b = new Locale("en", "US");  // jêzyk angielski, kraj Stany Zjednoczone<br>
Locale c = new Locale("en");            // jêzyk angielski, kraj nieokreœlony<br>
<br>
Locale d = new Locale("pl", "PL", "Zakopane");<br><br>
Jakie s¹ dostêpne lokalizacje?<br>
<br>
<pre>
Locale[] loc = Locale.getAvailableLocales();</pre>
<b>Domyœlna lokalizacja</b> - na podstawie w³aœciwoœci ustalonych dla platformy systemowej.<br>
<br>

Mo¿na siê dowiedzieæ:

<pre>
Locale dloc = Locale.getDefault();</pre>

i zmieniæ:
<pre>
Locale newDefLoc = new Locale(...);
Locale.setDefault(newDefLoc)</pre>
<br>
<br>
Obiekt klasy Locale okreœla lokalizacjê (czyli wspomniane wczeœniej regu³y), <br><br>
<div class="important">Zastosowanie tych regu³ - przy przetwarzaniu  i formatowaniu informacji -
spoczywa na obiektach innych klas. Te klasy, które bior¹ pod uwagê wymagania
lokalizacyjne nazywaj¹ siê <b>czu³ymi na lokalizacjê</b> (locale-sensitive).</div><br>
<br>
Nale¿¹ do nich:<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">
      <div align="Center"><b>Klasa<br>
      </b></div>
      </td>
      <td valign="Top">
      <div align="Center"><b>Przeznaczenie<br>
      </b></div>
      </td>
    </tr>
    <tr>
      <td valign="Top">NumberFormat (i pochodne)<br>
      </td>
      <td valign="Top">Do formatowania liczb<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Calendar (i pochodne)<br>
      </td>
      <td valign="Top">Do operowania na datach i czasie<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">DateFormat (i pochodne)<br>
      </td>
      <td valign="Top">Do formatowania dat i czasu<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Collator<br>
      </td>
      <td valign="Top">Do okreœlania porz¹dku alfabetycznego<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">BreakIterator<br>
      </td>
      <td valign="Top">Do zlokalizowanego rozbioru tekstu<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<b>Aby przetwarzaæ informacje w  zlokalizowanej formie pos³ugujemy siê obiektami
klas czu³ych na lokalizacjê. <br>
</b><br>
Dla zastosowania domyœlnych regu³ lokalizacyjnych
uzyskujemy te obiekty za pomoc¹ statycznych metod <br>
<h3>    get...Instance() </h3>
<h3><b>    bez argumentu, okreœlaj¹cego lokalizacjê</b>.</h3>
Np. kod na listingu pokazuje domyœln¹ lokalizacjê i zgodnie z t¹ lokalizacj¹
wypisuje bie¿¹c¹ datê oraz liczbê 1234567.1, przy czym w trakcie dzia³ania
zmienia domyœln¹ lokalizacjê i ponawia wyprowadzanie informacji.<br>
<pre>
import java.text.*;
import java.util.*;

public class DefLok {

  static public void report() {
    Locale defLoc = Locale.getDefault();
    System.out.println("Domyœlna lokalizacja : " + defLoc);
    DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
    NumberFormat nf = NumberFormat.getInstance();
    System.out.println(df.format(new Date()));
    System.out.println(nf.format(1234567.1));
  }

  public static void main(String[] args) {
    report();
    Locale.setDefault(new Locale("en"));
    report();
  }

}
</pre>
 Wydruk programu:<br>
<div class="listing100"><br>
Domyœlna lokalizacja : pl_PL<br>
12 lipiec 2003<br>
1_234_567,1<br>
Domyœlna lokalizacja : en<br>
July 12, 2003<br>
1,234,567.1<br>
</div><br>
<br>Klasy lokalizacyjnie-czu³e pozwalaj¹ równie¿ na uzyskiwanie ich obiektów
przetwarzaj¹cych informacje w sposób wymagany przez konkretn¹ (nie domyœln¹)
lokalizacjê: <br>
<br>
<h3>     get...Instance(...) </h3>
<h3>     z argumentem
typu Locale - okreœlaj¹cym konkretn¹ lokalizacjê. </h3>
<h3>
</h3>

Np. poni¿szy program wyprowadz datê w lokalizacji domyœlnej, a liczbê - najpierw
w domyœlnej, a póŸniej zgodnej z jêzykiem angielskim.<br>
<pre>
import java.text.*;
import java.util.*;

public class MiscLok {

  public static void main(String[] args) {
    System.out.println("Domyœlna lokalizacja : " + Locale.getDefault());
    DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
    System.out.println(df.format(new Date()));
    double num = 123.4;
    NumberFormat nf = NumberFormat.getInstance();
    System.out.println("Liczba " + num +
                       " w lokalizacji domyœlnej: " + nf.format(num));
    nf = NumberFormat.getInstance(new Locale("en"));
    System.out.println("Liczba " + num +
                       " w lokalizacji angielskiej: " + nf.format(num));
  }

}
</pre>
<br>
<div class="listing100">Domyœlna lokalizacja : pl_PL<br>
12 lipiec 2003<br>
Liczba 123.4 w lokalizacji domyœlnej: 123,4<br>
Liczba 123.4 w lokalizacji angielskiej: 123.4<br>
</div><br><br>Poni¿szy przyk³adowy program pokazuje wykorzystanie prostej klasy Locale w celu t³umaczenia nazw krajów na ró¿ne jêzyki.<br>
<pre>
import java.util.*;
import java.text.*;
import javax.swing.*;

class CountryTranslator {

  public static void main(String[] args) {

    Locale[] loc = Locale.getAvailableLocales();
    Map map = new HashMap();
    String kraj;

    // Dodanie dostêpnych lokalizacji do mapy
    // klucz: nazwa kraju po polsku, wartoœc - lokealizacja
    for (int i=0; i&lt;loc.length; i++) {
      String countryCode = loc[i].getCountry();  // kod kraju
      if (countryCode.equals("")) continue;
      kraj =  loc[i].getDisplayCountry();
      map.put(kraj, loc[i]);
    }

    String msg = "Podaj kraj";
    String in = "";
    while((kraj = JOptionPane.showInputDialog(msg)) != null ) {
      // Pobieramy lokalizacjê dla podanego kraju
      Locale savedLoc = (Locale) map.get(kraj);
      if (savedLoc == null) continue;
      msg = "Podaj kody jêzyków, rozdzielone spacjami";
      while((in = JOptionPane.showInputDialog(null, msg, in)) != null ) {
        StringTokenizer st = new StringTokenizer(in);
        if (st.countTokens() == 0) continue;
        String rep = "Nazwa kraju " + kraj + ":\n";

        // Dla kolejnych kodów jêzyków
        // uzyskujemy nazwê kraju w jêzyku odpowiadaj¹cym
        // lokalizacji zwi¹zanej z kodem jêsyka
        while(st.hasMoreTokens()) {
          Locale lang = new Locale(st.nextToken());
          rep += lang.getDisplayLanguage() + "   =   " +
                 savedLoc.getDisplayCountry(lang) + "\n";
        }
      JOptionPane.showMessageDialog(null,rep);
      }
      msg = "Podaj kraj";
    }
    System.exit(0);
  }
}
</pre>
<img src="images/nazwykraj.jpg" alt="r" width="268" height="229" border="1" align="Right">
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<a name="W1.4"></a><a name="W1.4"></a><h2>Formatowanie liczb</h2>NumberFormat.<br>
Ale wygodniejszy i bardziej uniwersalny sposób formatowania liczb polega na specyfikowaniu
wzorców formatu. <br>
Mog¹ one byæ stosowane wobec formatorów, które s¹ obiektami
klasy DecimalFormat. <br>
<br><br>
Mo¿emy post¹piæ tak:<br>
<ul>
<li>stworzyæ obiekt klasy DecimalFormat, podaj¹c jako argument konstruktora wzorzec formatowania,</li><li>wywo³aæ metodê format na rzecz tego obiektu.</li>
</ul>


Na przyk³ad:<br>
<pre>
     double d = 10/3.0;
     DecimalFormat dform = new DecimalFormat("###.###");
     String wynik = dform.format(d);
     System.out.println(wynik);
</pre>Wynik: 3,333.<br>
<br>
<div class="syntax">Wzorce formatowania s¹ ³añcuchami znakowymi i maj¹ nastêpuj¹c¹ postaæ:<br><br>
[prefiks][czêœc_ca³kowita][.czêœæ_dziesiêtna][sufiks]
<br><br>
gdzie: <br><ul><li>prefiks i sufiks - dowolny ci¹g znaków oprócz znaków specjalnych,</li><li>czêœæ ca³kowita i czêœæ dziesiêtna - zero lub wiêcej znaków specjalnych 
'#' albo zero lub wiêcej znaków specjalnych  '0' oraz ew. pojedyncze inne
znaki specjalne.</li></ul><i>Uwagi: <br></i><ol><li><i>nawiasy kwadratowe oznaczaj¹ opcjonalnoœæ elememetu wzorca, z tym, ¿e co najmniej jeden z elementów musi wyst¹piæ;</i></li><li><i>jako wzorzec formatuj¹cy mo¿na podac dwa wzorce w powy¿szej postaci,
rozdzielone œrednikiem; pierwszy z nich bêdzie dotyczy³ liczb dodatnich,
drugi - ujemnych.</i></li></ol></div>
<br>
<br>


Najwa¿niejsze znaki specjalne u¿ywane we wzorcach formatuj¹cych podaje tabela.<br>
<br>
<table border="1">
<tbody><tr><th>Symbol</th><th>Opis</th></tr><tr><td>0</td><td>cyfra, jeœli jest nieznacz¹cym zerem pokazywana jako 0</td></tr><tr><td>#</td><td>cyfra, nieznacz¹ce zera nie s¹ pokazywane</td></tr><tr><td>.</td><td>miejsce separatora dziesiêtnego</td></tr><tr><td>,</td><td>miejsce separatora grup cyfr (np. tysiêcy)</td></tr><tr><td>E</td><td>miejsce separatora dla notacji  in¿ynieryjnej lub naukowej ( np. 1E-11)</td></tr><tr><td>;</td><td>separator formatu dla liczb dodatnich i formatu dla liczb ujemnych<br>&
lt;
/td&gt;</td></tr><tr><td>-</td><td>znak minus</td></tr><tr><td>%</td><td>powoduje mno¿enie liczby przez 100 i pokazanie jej w postaci procentowej<br></td></tr><tr><td>¤</td><td>symbol waluty (np. z³); u¿yty dwukrotnie daje miêdzynarodowy symbol waluty </td></tr><tr><td>'</td><td>ujête w apostrofy znaki specjalne mog¹ byæ pokazywane w czêœci prefiks lub sufiks<br></td></tr></tbody>
</table>
<br>


Program na wydruku pokazuje jak mo¿na korzystaæ z ró¿nych formatów.<br>
<pre>
import java.text.*;
import java.math.*;

public class Format1 {

  public static void show(double n1, Double n2, BigDecimal n3,
                          String format) {
    DecimalFormat df = new DecimalFormat(format);
    System.out.println("Format " + format);
    System.out.println("Liczba: " +  n1 + " wygl¹da tak: " + df.format(n1));
    System.out.println("Liczba: " +  n2 + " wygl¹da tak: " + df.format(n2));
    System.out.println("Liczba: " +  n3 + " wygl¹da tak: " + df.format(n3));
  }


  public static void main(String[] args) {
    double num1  = 1.346;
    Double num2  = new Double(0.765474);
    BigDecimal num3 = new BigDecimal("100.2189091");

    show(num1, num2, num3, "#.##");
    show(num1, num2, num3, "#.## %");
    show(num1, num2, num3, "#.0000");
    show(num1, num2, num3, "#.00 ¤");
    show(num1, num2, num3, "#.00 ¤¤");
    show(num1, num2, num3, "[ 000.0 ]");

 }

}
</pre>


Wyniki jego dzialania pokazuje wydruk.<br>
<div class="listing100"><br>
Format #.##<br>
Liczba: 1.346 wygl¹da tak: 1,35<br>
Liczba: 0.765474 wygl¹da tak: 0,77<br>
Liczba: 100.2189091 wygl¹da tak: 100,22<br>
Format #.## %<br>
Liczba: 1.346 wygl¹da tak: 134,6 %<br>
Liczba: 0.765474 wygl¹da tak: 76,55 %<br>
Liczba: 100.2189091 wygl¹da tak: 10021,89 %<br>
Format #.0000<br>
Liczba: 1.346 wygl¹da tak: 1,3460<br>
Liczba: 0.765474 wygl¹da tak: ,7655<br>
Liczba: 100.2189091 wygl¹da tak: 100,2189<br>
Format #.00 ¤<br>
Liczba: 1.346 wygl¹da tak: 1,35 z³<br>
Liczba: 0.765474 wygl¹da tak: ,77 z³<br>
Liczba: 100.2189091 wygl¹da tak: 100,22 z³<br>
Format #.00 ¤¤<br>
Liczba: 1.346 wygl¹da tak: 1,35 PLN<br>
Liczba: 0.765474 wygl¹da tak: ,77 PLN<br>
Liczba: 100.2189091 wygl¹da tak: 100,22 PLN<br>
Format [ 000.0 ]<br>
Liczba: 1.346 wygl¹da tak: [ 001,3 ]<br>
Liczba: 0.765474 wygl¹da tak: [ 000,8 ]<br>
Liczba: 100.2189091 wygl¹da tak: [ 100,2 ]</div>
<br>
<br>   Za pomoc¹ metody format(...) mo¿na formatowac nie
tylko liczby typu double, ale równie¿ typu long oraz obiekty klas pochodnych
od Number (np. Double, Float, Long, Integer) i BigInteger oraz BigDecimal.<br>
<br>
Klasy formatuj¹ce liczby
s¹ przygotowane na prezentacjê liczb wed³ug regu³ lokalizacyjnych. Jeœli
w metodzie getInstance() nie podamy lokalizacji - bêdzie u¿yta lokalizacja domyœlna (np. polska z przecinkiem).<br><br>
Jak uzyskaæ kropkê zamiast przecinka? <br>
<pre>
    DecimalFormat df = (DecimalFormat)
                       NumberFormat.getInstance(new Locale("en", "US"));
    df.applyPattern(format);

</pre>Problem z walut¹ (bêdzie USD).<br>Mo¿na: setCurrency(...).<br>
Albo nie zmieniaæ lokalizacji, a zmieniæ symbole formatora decymalnego:<br>
 <br>


Zmiana separatora miejsc dziesiêtnych na kropkê mo¿e wygl¹daæ tak:<br>

<pre>
DecimalFormat df = new DecimalFormat(format);  // formator w domyœlnej lokalizacji
DecimalFormatSymbols sym = df.getDecimalFormatSymbols(); // symbole
sym.setDecimalSeparator('.');                  // ustalenie separatora miejsc dziesiêtnych
</pre>Inne symbole u¿ywane przy formatowaniu i metody ich zmian opisane s¹ w dokumentacji.<br>
<br>Specjalne formatory do formatowania:<br>
<ul>
  <li>liczb ca³kowitych - metoda NumberFormat.getIntegerInstance(...)</li>
  <li>wartoœci wyra¿onych w walucie - metoda NumberFormat.getCurrencyInstance(...)</li>
  <li>wartoœci w procentach - metoda NumberFormat.getPercentInstance(...)</li>
</ul>Prostsza drog¹ uzyskiwania efektów podobnych
do u¿ycia wzorców formatowania w szczególnych przypadkach.<br>
<br>
Formatory potrafi¹ tak¿e dokonywaæ przekszta³ceñ odwrotnych: zamieniaæ napisy
reprezentuj¹ce liczby na postaæ binarn¹ tych liczb. <br>
Np. tekst, w którym liczby podawane s¹ z przecinkami jako separatorami miejsc
dziesiêtnych, Metoda parseDouble z klasy Double nie da oczekiwanych wyników (wyj¹tek).
<br>
<br>
Nale¿y zastosowaæ metodê <b>parse(..)</b> zdefiniowan¹ w klasach formatorów
i metoda ta poradzi sobie z dowolnymi sposobami zapisu liczb wedle ró¿nych
regu³ lokalizacyjnych (a tak¿e wedle ró¿nych formatów).<br>
<br>Metoda parse(String) u¿yta na rzecz formatora.
<ul>
  <li>zwraca referencjê do obiektu podklasy klasy Number,
który - w zale¿noœci od wartoœci interpretowanego napisu mo¿e wskazywaæ na
Long lub Double,</li>
  <li>napis podlega interpretacji jako liczba zgodnie z  lokalizacj¹ (np.
w polskiej lokalizacji u¿ycie przecinka jako separatora miejsc dziesiêtnych),</li>
  <li>w zale¿noœci od zastosowanego formatu w trakcie interpretacji napisu
mo¿e wyst¹piæ wyj¹tek ParseException (albo interpretacja bêdzie przebiegaæ
"dopóki siê da", a nie pasuj¹ce znaki bêd¹ pominiête).<br>
</li>
</ul><div class="important">W tych przypadkach, gdy b³¹d mo¿e pojawiæ siê nie tylko na samym pocz¹tku
napisu, u¿yteczna mo¿e okazaæ siê metoda <b>getErrorOffset() z klasy ParseException</b>,
która zwraca pozycjê w napisie, na której pojawi³ siê b³¹d.</div><br>
<br>
Zobaczmy na przyk³adzie zmodyfikowanego programu:<br>
<pre>
  public static void main(String[] args) {
    NumberFormat format = new DecimalFormat("[ #.0000 ]");
    //...
    while ((in = JOptionPane.showInputDialog(msg)) != null) {
      System.out.println("Wejscie: " + in);
      try {
        num = format.parse(in);
      } catch (ParseException exc) {
          System.out.println("Wadliwe dane: " + in);
          System.out.println(exc);
          System.out.println("Wadliwa pozycja: " + exc.getErrorOffset());
          continue;
      }
      System.out.println("Parse daje: " +
                          num.getClass().getName()+ " = " + num);
    }
  }
</pre>
<br>
Przyk³adowy wydruk zmodyfikowanego programu :<br>
<div class="listing100"><br>
Wejscie: [23]<br>
Wadliwe dane [23]<br>
java.text.ParseException: Unparseable number: "[23]"<br>
Wadliwa pozycja: 0<br>
Wejscie: [ 23 ]<br>
Parse daje: java.lang.Long = 23<br>
Wejscie: [ 23<br>
Wadliwe dane: [ 23<br>
java.text.ParseException: Unparseable number: "[ 23 "<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23 a ]<br>
Wadliwe dane: [ 23 a ]<br>
java.text.ParseException: Unparseable number: "[ 23 a ]"<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23.000 ]<br>
Wadliwe dane: [ 23.000 ]<br>
java.text.ParseException: Unparseable number: "[ 23.000 ]"<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23, 00 ]<br>
Wadliwe dane: [ 23, 00 ]<br>
java.text.ParseException: Unparseable number: "[ 23, 00 ]"<br>
Wadliwa pozycja: 5<br>
Wejscie: [ 23,0 ]<br>
Parse daje: java.lang.Long = 23<br>
 </div><br>
<br>
Inn¹ form¹ metody parse z klas formatorów jest:<br>
<br>
    Number num = parse(String dane, ParsePosition pos);<br>
<br>
Tutaj u¿ywamy obiektu <i><b>pos</b></i> klasy <b>ParsePosition</b>, który okreœla bie¿¹c¹ pozycjê rozbioru napisu <b><i>dane</i></b> oraz ew. pozycjê (indeks) na której wyst¹pi³ b³¹d.<br>
Rozbiór danych (wedle formatu) rozpoczyna siê od pozycji okreslonej przez
podany obiekt klasy ParsePosition. Napis podlega interpretacji (dopóki kolejne
jego znaki mo¿na traktowaæ jako znaki liczby wg danego formatu), po czym
bie¿¹ca pozycja rozbioru (indeks) jest ustawiana za ostatnim zinterpretowanym
znakiem i zwracana jest liczba jako obiekt klasy Number. <br><b>
Ta metoda nie zg³asza ¿adnych wyj¹tków</b>. W przypadku b³êdu interpretacji (a
w zale¿noœci od formatu - wystêpuje on albo tylko na pocz¹tku napisu, albo
gdzieœ dalej)  zwracana jest wartoœæ null, bie¿¹ca pozycja nie ulega zmianie,
a  indeks b³êdu ustawiany jest na znaku, który spowodow³¹ b³ad. Je¿eli nie
ma b³êdu indeks b³êdu ma wartoœæ -1.<br>
Pozycje (indeks)  - bie¿¹cy i b³êdu - mo¿emy uzyskiwac od obiektu ParsePosition
za pomoc¹ metod getIndex() i getErrorIndex() oraz ustawiaæ za pomoc¹ odpowiednich
metod setIndex(...) i setErrorIndex(...).<br>
<br>
Program na wydruku pokazuje przyk³adowe u¿ycie tej metody parse do wyodrêbnienia
z pliku tekstowego wszystkich informacji zapisanych w formacie walutowym
(mo¿emy sobie wyobra¿aæ, ¿e jest to plik opisuj¹cy jakieœ wydatki, a naszym
zadaniem jest ich podsumowanie)<br>
<br>
<pre>
.import java.io.*;
import java.text.*;
import java.util.*;

public class Parse2 {

  public static void main(String[] args) {

    // Format walutowy w domyœlnej lokalizacji
    // czyli w PL np. 12 z³
    NumberFormat format = NumberFormat.getCurrencyInstance();

    // Lista wartoœci wydatków (zapisanych w tekœcie pliku)
    List numList = new ArrayList();

    try {
      BufferedReader br = new BufferedReader(
                            new FileReader("testdata.txt")
                          );

      // czytanie kolejnych wierszu
      String in;
      while ((in = br.readLine()) != null) {

        int p = 0;                    // bie¿¹cy indeks rozbioru
        int last  = in.length() - 1;  // ostatni indeks w wierszu

        // Utworzenie pozycji rozbioru wiersza (od 0)
        ParsePosition ppos = new ParsePosition(0);

        // Dopóki nie dobiegliœmy do koñca wiersza
        while (p &lt;= last) {
           // Próbujemy pobraæ kolejn¹ liczbê w formacie walutowym
           Number num = format.parse(in, ppos);

           if (num == null)              // je¿eli b³¹d,
             p = ppos.getErrorIndex()+1; // indeks na znaku po b³êdzie
           else {                        // je¿eli uda³o siê sczytaæ wartoœæ
             numList.add(num);           // dodajemy j¹ do listy
             p =  ppos.getIndex();   // indeks na nastêpnym znaku po
           }
           ppos.setIndex(p);         // ustawiamy nastêpn¹ pozycjê
        }                            // od której kontynuacja rozbioru
      }
      br.close();
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Wypisanie i podsumowanie zapisanych w pliku wydatków
    System.out.println("Wydatki w z³:");
    double suma = 0;
    for (Iterator iter = numList.iterator(); iter.hasNext(); ) {
      Number val  = (Number) iter.next();
      System.out.println(val);
      suma += val.doubleValue();
    }
    System.out.println("Wydano w sumie: " + format.format(suma));
  }
}</pre>
<br>
Gdy u¿yjemy tego programu wobec  pliku, zawieraj¹cego nastêpuj¹cy tekst:<br>
<br>
Wydano najpierw 123 z³ na 23 kilo jab³ek<br>
Kolejny wydatek obj¹³ 77,77 z³ (70 litrów maœlanki)<br>
a potem jeszcze dosz³o 999,99 z³ w 4 ratach.<br>
<br>
to w wyniku uzyskamy:<br>
<div class="listing100"><br>
Wydatki w z³:<br>
123<br>
77.77<br>
999.99<br>
Wydano w sumie: 1 200,76 z³<br>
</div><br>
<br>
<br>
Przy okazji: spójrzmy na nowe œrodki Javy 1.5<br>
<br>
<pre>
import java.io.*;
import java.text.*;
import java.util.*;

public class Parse2j5 {

  public static void main(String[] args) {

    // Format walutowy w domyœlnej lokalizacji
    // czyli w PL np. 12 z³
    NumberFormat format = NumberFormat.getCurrencyInstance();

    // Lista wartoœci wydatków (zapisanych w tekœcie pliku)
    <b><font color="#ff0000">// GENERIC!!!</font></b>
    List&lt;Double&gt; numList = new ArrayList&lt;Double&gt;();

    try {
      BufferedReader br = new BufferedReader(
                            new FileReader("testdata.txt")
                          );

      // czytanie kolejnych wierszu
      String in;
      while ((in = br.readLine()) != null) {

        int p = 0;                    // bie¿¹cy indeks rozbioru
        int last  = in.length() - 1;  // ostatni indeks w wierszu

        // Utworzenie pozycji rozbioru wiersza (od 0)
        ParsePosition ppos = new ParsePosition(0);

        // Dopóki nie dobiegliœmy do koñca wiersza
        while (p &lt;= last) {
           // Próbujemy pobraæ kolejn¹ liczbê w formacie walutowym
           Number num = format.parse(in, ppos);

           if (num == null)              // je¿eli b³¹d,
             p = ppos.getErrorIndex()+1; // indeks na znaku po b³êdzie
           else {                        // je¿eli uda³o siê sczytaæ wartoœæ
             numList.add(num.doubleValue()); <b><font color="#ff0000">// BOXING!!!</font></b>
             p =  ppos.getIndex();   // indeks na nastêpnym znaku po
           }
           ppos.setIndex(p);         // ustawiamy nastêpn¹ pozycjê
        }                            // od której kontynuacja rozbioru
      }
      br.close();
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Wypisanie i podsumowanie zapisanych w pliku wydatków
    System.out.println("Wydatki w z³:");
    double suma = 0;
    for( Double val : numList ) { <b><font color="#ff0000">// FOR-EACH</font></b>
      System.out.println(val);
      suma += val; <b><font color="#ff0000">// UNBOXING!!!</font></b>
    }

    /*for (Iterator iter = numList.iterator(); iter.hasNext(); ) {
      Number val  = (Number) iter.next();
      System.out.println(val);
      suma += val.doubleValue();
    }*/

    System.out.println("Wydano w sumie: " + format.format(suma));
  }
}
</pre>
Kontrola wyjœcia - sposobu formayowania:  klasa <b>FieldPosition</b>.<br>
<br>Istniej¹ te¿  inne sposoby formatowania liczb.<br>
Wœród podklas klasy NumberFormat znajdziemy klasê ChoiceFormat.<br>
Generalnie pozwala ona kojarzyæ dowolne napisy z  (pó³otwartymi  z prawej
strony) przedzia³ami liczb. Formatowanie za jej pomoc¹ polega na zast¹pieniu
liczby, "trafiaj¹cej" w dany przedzia³, skojarzonym z tym przedzia³em napisem.<br>
<br><br>
Klasa ChoiceFormat jest szczególnie u¿yteczna przy internacjonalizacji napisów
w programie z wykorzystaniem klasy MessageFormat.<br>
<br><div class="notel">Uwaga: aby korzystaæ z klas pakietów ICU nale¿y udostêpniæ archiwum
JAR z tymi pakietami. Mo¿emy to uczyniæ na kilka sposobów:<br>
<ul>
  <li>umieœciæ archiwum w katalogu javax katalogu instalacyjnego Javy (wtedy
biblioteka ICU stanie siê standardowym rozszerzeniem - inaczej zwanym pakietem
opcjonalnym - i nasze programy bêd¹ mia³y do niej dostêp,</li>
  <li>umieœciæ nazwê archiwum JAR biblioteki ICU na œcie¿ce classpath,</li>
  <li>kompilowaæ i uruchamiaæ programy z opcj¹ -classpath, podaj¹c archiwum
JAR biblioteki ICU wraz z innymi elmentami œcie¿ki (%classpath%); przy uruchamianiu
klas z pakietu domyœlnego nie nale¿y zapomnieæ o podaniu jako elementu œcie¿ki
bie¿¹cego katalogu, oznaczanego kropk¹,</li>
</ul>
</div>W bibliotekach ICU4J znajdziemy znacznie bardziej zaawansowany odpowiednik  klasy ChoiceFormat - klasê  RuleBasedNumberFormat.<br>
Pozwala ona na formatowanie liczb za pomoc¹ definiowania zestawów regu³.<br>
Przyk³adowe zdefiniowane ju¿ regu³y dla formatora RuleBasedNumber to:<br>
<ul>
  <li>SPELLOUT - przedstawianie liczb w postaci s³ownej,</li>
  <li>ORDINAL - przedstawianie liczb jako liczebników porz¹dkowych (z odpowiednimi koñcówkami),</li>
  <li>DURATION -  przekszta³canie liczb na jednostki czasu (godziny, minuty, sekundy).</li>
</ul><br>
<a name="W1.5"></a><a name="W1.5"></a><h2>Waluty</h2>
Klasa Currency z pakietu java.util opisuje waluty. Obiekty tego typu s¹ wykorzystywane
przez klasê DecimalFormat i mo¿emy je np. stosowaæ dla zmiany formatów walutowych
(metoda setCurrency(Currency) z klasy DecimalFormat).<br><br>
Klasa Currency mo¿e byæ u¿yteczna w ró¿nych sytuacjach.<br>
WyobraŸmy sobie taki scenariusz: mamy stworzyæ aplikacjê, która generuje
raporty o aktualnych kursach wybranych walut w kilku jêzykach. Aktualne kursy
pobieramy z jakiegoœ serwisu WEB na podstawie podanych miêdzynarodowych symboli
walut.<br>
Aby taki program mo¿na by³o napisaæ, trzeba wiedzieæ jakie s¹ symbole walut i umieæ  t³umaczyæ symbole walut na wybrane jêzyki.<br>
<br><br>
Pakiet ICU dostarcza dodatkowych mo¿liwoœci, gdy chodzi o waluty. M.in. mo¿emy
uzyskaæ bardziej opisow¹, stosowan¹ w podanej lokalizacji nazwê waluty. Pokazuje
to poni¿szy program.<br>
<br>
<a name="W1.6"></a><a name="W1.6"></a><h2>Strefy czasowe</h2>Strefy czasowe s¹ przedstawiane przez obiekty klasy TimeZone z pakietu java.util.<br>
Aby uzyskaæ aktualn¹, domyœln¹ dla komputera na którym dzia³a nasz program,
strefê czasow¹ stosujemy statyczn¹ metodê getDefault() z klasy TimeZone.<br>W naszym programie mo¿emy skonstruowaæ dowoln¹ strefê czasow¹, u¿ywaj¹c metody
TimeZone.getTimeZone(String ID) i podaj¹c jako argument identyfikator strefy
czasowej.<br>
Listê dostêpnych identyfikatorów mo¿na uzyskaæ jako tablicê Stringów za pomoca odwo³ania TimeZone.getAvailableIDs().<br>
<br>
Poni¿szy przyk³adowy programik pokazuje jak mo¿na wyliczyæ aktualn¹ ró¿nicê
czasu pomiêdzy podanymi strefami czasowymi oraz jak mo¿na dowiedzieæ siê
jakie strefy czasowe maj¹ podan¹ ró¿nicê czasu wobec GMT.<br>
<br>
<pre>
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Strefy1 {

  public static void main(String[] args) {

    // Konstruowanie stref czasowych
    TimeZone myTz = TimeZone.getTimeZone("Europe/Warsaw");
    TimeZone java = TimeZone.getTimeZone("Asia/Jakarta");
    TimeZone cuba = TimeZone.getTimeZone("America/Havana");

    // za pomoc¹ pokazanej dalej metody getDiffMsg
    // wyliczamy i pokazujemy aktualn¹ ró¿nicê czasu
    // pomiêdzy sterfami czasowymi

    System.out.println(getDiffMsg(myTz, java));
    System.out.println("--------------------------------------------------");
    System.out.println(getDiffMsg(myTz, cuba));
    System.out.println("--------------------------------------------------");
    System.out.println(getDiffMsg(cuba, java));
    System.out.println("--------------------------------------------------");

    // Jakie strefy czasowe maj¹ podan¹ ró¿nicê czasu wobec GMT

   for (int k = 12; k &lt;= 14; k++) {
     String[] ids = TimeZone.getAvailableIDs(k*3600000);
     Arrays.sort(ids);
     System.out.println(
      "Strefy czasowe maj¹ce ró¿nice +" + k + " godzin wobec GMT" );
     for (int i=0; i &lt; ids.length; i++) {
       System.out.println(ids[i]);
     }
     System.out.println("--------------------------------------------------");
   }
  }

  static String getDiffMsg(TimeZone z1, TimeZone z2) {
    Date data = new Date();
    long teraz = data.getTime();
    double offset1 = z1.getOffset(teraz)/3600000.0;
    double offset2 = z2.getOffset(teraz)/3600000.0;
    double diff;
    if (offset1 &gt; offset2)  diff = -(offset1 - offset2);
    else diff = offset2 - offset1;
    String out =  "Ró¿nica czasu pomiêdzy" + '\n' +
                  z1.getID() + " i " + z2.getID()  + '\n' +
                  "wynosi teraz : " + diff + " godz."  + '\n' +
                  "W strefie " + z1.getID() +
                       (z1.inDaylightTime(data) ? " " : " nie ") +
                       "dzia³a czas letni"  + '\n' +
                  "W strefie " + z2.getID() +
                       (z2.inDaylightTime(data) ? " " : " nie ") +
                       "dzia³a czas letni";

    return out;
  }

}
</pre>
Wydruk:<br>
<div class="listing100"><br>
Ró¿nica czasu pomiêdzy<br>
Europe/Warsaw i Asia/Jakarta<br>
wynosi teraz : 5.0 godz.<br>
W strefie Europe/Warsaw dzia³a czas letni<br>
W strefie Asia/Jakarta nie dzia³a czas letni<br>
--------------------------------------------------<br>
Ró¿nica czasu pomiêdzy<br>
Europe/Warsaw i America/Havana<br>
wynosi teraz : -6.0 godz.<br>
W strefie Europe/Warsaw dzia³a czas letni<br>
W strefie America/Havana dzia³a czas letni<br>
--------------------------------------------------<br>
Ró¿nica czasu pomiêdzy<br>
America/Havana i Asia/Jakarta<br>
wynosi teraz : 11.0 godz.<br>
W strefie America/Havana dzia³a czas letni<br>
W strefie Asia/Jakarta nie dzia³a czas letni<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +12 godzin wobec GMT<br>
Antarctica/McMurdo<br>
Antarctica/South_Pole<br>
Asia/Anadyr<br>
Asia/Kamchatka<br>
Etc/GMT-12<br>
Kwajalein<br>
NST<br>
NZ<br>
Pacific/Auckland<br>
Pacific/Fiji<br>
Pacific/Funafuti<br>
Pacific/Kwajalein<br>
Pacific/Majuro<br>
Pacific/Nauru<br>
Pacific/Tarawa<br>
Pacific/Wake<br>
Pacific/Wallis<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +13 godzin wobec GMT<br>
Etc/GMT-13<br>
Pacific/Enderbury<br>
Pacific/Tongatapu<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +14 godzin wobec GMT<br>
Etc/GMT-14<br>
Pacific/Kiritimati<br>
--------------------------------------------------<br>
</div><a name="W1.7"></a><a name="W1.7"></a><h2><br>
</h2>
<a name="W1.8"></a><a name="W1.8"></a><h2>Kalendarze</h2>


Informacje o datach i czasie s¹ w Javie reprezentowane przez obiekty klasy Calendar.<br>
<br>


<div class="syntax">Informacje o bie¿¹cej dacie i czasie mo¿emy uzyskaæ m.in. za pomoc¹ odwo³ania:<br>
<br>


        Calendar c = Calendar.getInstance();<br>
<br>   które zwraca obiekt - domyœlny kalendarz dla domyœlnej lokalizacji
ustawiony na bie¿¹c¹ datê i czas w strefie czasowej w³aœciwej dla domyœlnej
lokalizacji.<br>


</div><br>
<br>


Informacje o dacie i czasie s¹ zapisane w polach obiektu-kalendarza. Dostêp do tych pól uzyskujemy za pomoc¹ metody <b>get(...)</b>
 , u¿ytej na rzecz obiektu-kalendarza, z argumentem - sta³¹ statyczn¹ klasy
Calendar, okreslaj¹c¹ o jaki rodzaj informacji nam chodzi. Oprócz tego pewne
informacje, zwi¹zane z w³aœciwoœciami danego kalendarza lub dla danej lokalizacji
mo¿na uzyskaæ za pomoc¹ innych metod get... (np. jaki jest pierwszy dzieñ
tygodnia - niedziela czy poniedzia³ek - getFirstDayOfWeek()).<br>
<br>


Przyk³adowy program spe³nia funkcjê przewodnika po polach kalendarza,  pokazuj¹
ich znaczenie oraz sposoby uzyskiwania ich wartoœci.<br>
<br>
<pre>
import java.util.*;

public class Kal1 {

  public static void say(String s) { System.out.println(s+'\n'); }

  public static void main(String[] args) {

    // uzyskanie kalendarza domyœlnego
    // (obowi¹zuj¹cgo dla domyœlnej lokalizacji - tu dla Polski)
    // ustawionego na bie¿¹c¹ datê i czas

    <b>Calendar cal = Calendar.getInstance()</b>;

    say("ERA.............. " + <b>cal.get(Calendar.ERA)</b> +
        " (tu: 0=pne, 1=AD)");

    say("ROK.............. " + <b>cal.get(Calendar.YEAR)</b>);
    say("MIESI¥C.......... " + <b>cal.get(Calendar.MONTH)</b> +
        " (0-styczeñ, 2-luty, ..., 11-grudzieñ)");

    say("LICZBA DNI\n" +
        "W MIESI¥CU....... " + <b>cal.getActualMaximum(Calendar.DAY_OF_MONTH)</b>);

    say("DZIEÑ MIESI¥CA... " + <b>cal.get(Calendar.DAY_OF_MONTH)</b>);
    say("DZIEÑ MIESI¥CA... " + <b>cal.get(Calendar.DATE)</b>);
    say("TYDZIEÑ ROKU..... " + <b>cal.get(Calendar.WEEK_OF_YEAR)</b><b>)</b>;
    say("TYDZIEÑ MIESI¥CA. " + <b>cal.get(Calendar.WEEK_OF_MONTH)</b>);
    say("DZIEÑ W ROKU..... " + <b>cal.get(Calendar.DAY_OF_YEAR)</b>);

    say("PIERWSZY DZIEÑ\n" +
        "TYGODNIA......... " + <b>cal.getFirstDayOfWeek()</b> +
        " (1-niedziela, 2-poniedzia³ek, ..., 7 sobota)");

    say("DZIEÑ TYGODNIA... " + <b>cal.get(Calendar.DAY_OF_WEEK)</b> +
        " (1-niedziela, 2-poniedzia³ek, ..., 7-sobota)");

    say("GODZINA.......... " + <b>cal.get(Calendar.HOUR)</b> +
        " (12 godzinna skala; nastêpne odwolanie czy AM czy PM)");

    say("AM/PM............ " + <b>cal.get(Calendar.AM_PM)</b> +
        " (AM=0, PM=1)");

    say("GODZINA.......... " + <b>cal.get(Calendar.HOUR_OF_DAY)</b> +
        " (24 godzinna skala)");

    say("MINUTA........... " + <b>cal.get(Calendar.MINUTE)</b>);
    say("SEKUNDA.........  " + <b>cal.get(Calendar.SECOND)</b>);
    say("MILISEKUNDA:      " + <b>cal.get(Calendar.MILLISECOND)</b>);

    int msh = 3600*1000; // liczba milisekund w godzinie

    say("RÓ¯NICA CZASU\n" +
        "WOBEC GMT........ " + <b>cal.get(Calendar.ZONE_OFFSET</b>)/msh);

    say("PRZESUNIÊCIE\n" +
        "CZASU............ " + <b>cal.get(Calendar.DST_OFFSET)</b>/msh +
        " (w Polsce obowi¹zuje w lecie)");

  }

}
</pre>


Na wydruku pokazano wyniki dzia³ania programu, uruchomionego we wtorek 6 maja 2003 roku o godzinie 18:05:00.<br>


Wydruk:<br>
<pre>
ERA.............. 1 (tu: 0=pne, 1=AD)

ROK.............. 2003

MIESI¥C.......... 4 (0-styczeñ, 2-luty, ..., 11-grudzieñ)

LICZBA DNI
W MIESI¥CU....... 31

DZIEÑ MIESI¥CA... 6

DZIEÑ MIESI¥CA... 6

TYDZIEÑ ROKU..... 19

TYDZIEÑ MIESI¥CA. 2

DZIEÑ W ROKU..... 126

PIERWSZY DZIEÑ
TYGODNIA......... 2 (1-niedziela, 2-poniedzia³ek, ..., 7 sobota)

DZIEÑ TYGODNIA... 3 (1-niedziela, 2-poniedzia³ek, ..., 7-sobota)

GODZINA.......... 6 (12 godzinna skala; nastêpne odwolanie czy AM czy PM)

AM/PM............ 1 (AM=0, PM=1)

GODZINA.......... 18 (24 godzinna skala)

MINUTA........... 5

SEKUNDA.........  0

MILISEKUNDA:      550

RÓ¯NICA CZASU
WOBEC GMT........ 1

PRZESUNIÊCIE
CZASU............ 1 (w Polsce obowi¹zuje w lecie)

</pre><div class="important">Uwaga: nale¿y zwróciæ baczn¹ uwagê na to, ¿e indeksowanie miesiêcy rozpoczyna
siê od 0, a nie od 1 (czyli styczeñ ma numer 0). Jest to fatalny b³¹d, który
pope³niono w pierwszej wersji Javy, wprowadzaj¹c klasê Date.</div><br><br>
Za pomoc¹ metod set... kalendarza mo¿emy ustawiaæ jego bie¿¹c¹ datê i czas.<br>


Np. aby ustawiæ kalendarz na 7 maja 2003 roku na tê sam¹ godzinê co "teraz" mo¿emy napisaæ:<br>
<br>


    Calendar c = Calendar.getInstance();<br>


    c.set(2003, 4, 7);  // rok 2003, indeks miesi¹ca = 4 (maj), dzieñ 7<br>
<br>


a jeœli chcemy zarazem ustaliæ godzinê 18 minut 05 napiszemy:<br>
<br>


    c.set(2003, 4, 7, 18, 5);<br>
<br>


Mo¿emy te¿ zmieniaæ (ustawiaæ) wartoœci poszczególnych pól.<br>


S³u¿¹ do tego metody, które wykonuj¹ operacje na datach.<br>
<br>


<div class="syntax">Operacje na datach wykonujemy za pomoc¹ nastêpuj¹cych metod:<br>
<br>


        <b>set</b>(id_pola,  wartoœæ)<br>


        <b>add</b>(id_pola, wartoœæ)<br>


        <b>roll</b>(id_pola, wartoœæ) <br>
<br>


    gdzie:<br>

         id_pola - sta³a statyczna z klasy
Calendar, okreœlaj¹ca pole na którym wykonywana jest oparacja,<br>


        wartoœæ - nowa wartoœæ pola.<br>


</div><br>
<br>


Wszystkie w/w operacje uwzglêdniaj¹ regu³y danego kalendarza, a ró¿nica pomiêdzy nimi jest nastêpuj¹ca:<br>
<ul>
<li>set - ustala wartoœæ pola; jeœli trzeba  dostosowuj¹c inne pola (np.
ustawienie pola DAY_OF_MONTH na wartoœæ 31 dla kalendarza ustawionego na
dowoln¹ datê w czerwcu spowoduje, ¿e kalendarz bêdzie wskazywa³ na 1 lipca,
gdy¿ w czerwcu jest tylko 30 dni),</li><li>add  - dodaje do pola podan¹ wartoœæ, stosuj¹c przy tym arytmetykê
kalendarzow¹ (np. dodanie do 30 maja 2 dni spowoduje ustawienie kalendarza
na  1 czerwca),</li><li>roll - równie¿ wykonuje dodawanie, ale przy tym nie zmienia wartoœci
"starszych" pól np. je¿eli dodajemy dni i oka¿e siê, ¿e nowa data znajdzie
siê w innym ni¿ teraz miesi¹cu, to miesi¹c nie zostanie zmieniony, zaœ "nadwy¿ka"
dni (poza koñcem bie¿¹cego miesi¹ca) bêdzie dodawana od pocz¹tku miesi¹ca.</li>
</ul>


Dok³adne regu³y obliczeniowe s¹ podane w dokumentacji klasy Calendar. <br><br><br>
Mo¿emy  uzyskaæ inne kalendarze (ni¿ domyœlny):<br>
<ul>
  <li>dla domyœlnej lokalizacji, ale ustawiony na podan¹ strefê czasow¹ (Calendar.getInstance(TimeZone)),</li>
  <li>dla podanej lokalizacji (Calendar.getInstance(Locale)),</li>
  <li>dla podanej lokalizacji i strefy czasowej (Calendar.getInstance(TimeZone,Locale)),</li>
</ul>
Oto prosty przyk³ady. <br>
W poni¿szym fragmencie kodu:<br>
<pre>
    TimeZone tz = TimeZone.getTimeZone("Asia/Jakarta");
    Calendar c = Calendar.getInstance(tz);
    System.out.println("Current time: " + c.getTime());
    System.out.println("Java time: " +
         c.get(Calendar.HOUR_OF_DAY) + ":" + c.get(Calendar.MINUTE));

</pre>
kalendarz ustawiany jest na strefê czasow¹ Javy (wyspy, nie jêzyka). Metoda
getTime() zwróæi  aktualny czas w domyœlnej lokalizacji, ale pola kalendarza
s¹ ustawiane z uwzglêdnieniem ró¿nicy czasu.<br>
W wyniku otrzymamy.<br>
<div class="listing100">Current time: Fri Jul 18 12:44:47 CEST 2003<br>
Java time: 17:44</div><br>
<br>
Czym ró¿ni¹ siê kalendarze dla ró¿nych lokalizacji?<br>Nastêpuj¹cy fragment kodu:<br>
<pre>
    Calendar c = Calendar.getInstance();
    System.out.println(c.getClass().getName());
    c = Calendar.getInstance(new Locale("th", "TH"));
    System.out.println(c.getClass().getName());
</pre>
wyprowadzi:<br>
<div class="listing100">java.util.GregorianCalendar<br>
sun.util.BuddhistCalendar<br>
</div><br>
<br>
Du¿o wiêcej kalendarzy znajdziemy w pakiecie ICU.<br>
Mamy tam kalendarze: buddyjski, tradycyjny chiñski, tradycyjny japoñski, islamski, hebrajski. <br>
<br>
Sposób u¿ycia tych kalendarzy oraz tó¿nice pomiêdzy nimi pokazuje poni¿szy program.<br>
<pre>
import com.ibm.icu.util.*;
import com.ibm.icu.text.*;

public class MiscCal {

  public static void main(String[] args) {
    Calendar[] kal = {
               Calendar.getInstance(),   // domyœlny kalendarz - gregoriañski
               new GregorianCalendar(),  // jeszcze raz - ale inaczej tworzony
               new BuddhistCalendar(),   // buddyjski
               new ChineseCalendar(),    // chiñski
               new JapaneseCalendar(),   // japoñski
               new IslamicCalendar(),    // islamski
               new HebrewCalendar(),     // hebrajski
               };
    java.util.Date teraz = new java.util.Date(); // aktualny czas
    System.out.println("Teraz jest: " + teraz);  // po angielsku

    // przebiegamy po klaendarzach
    // ustawiamy je na bie¿¹cy czas
    // i pokazujemy wartoœci takich pól jak rok, miesi¹c itp.

    for (int i=0; i&lt;kal.length; i++) {
      kal[i].setTime(teraz);
      String className = kal[i].getClass().getName();
      String name = className.substring(className.lastIndexOf(".") + 1);
      System.out.println(name + " - " +
            "era " + kal[i].get(Calendar.ERA) +
            "; rok " + kal[i].get(Calendar.YEAR) +
            (name.equals("ChineseCalendar") ?
                  " czyli " + kal[i].get(Calendar.EXTENDED_YEAR)  : "") +
            "; mies " + kal[i].get(Calendar.MONTH) +
            "; dzieñ mies. " + kal[i].get(Calendar.DAY_OF_MONTH) +
            "; dzieñ tyg. " + kal[i].get(Calendar.DAY_OF_WEEK)
            );
    }
  }

}
</pre>
Program wyprowadzi nastêpuj¹ce wyniki.<br>
<div class="listing100">Teraz jest: Fri Jul 18 15:02:24 CEST 2003<br>
GregorianCalendar - era 1; rok 2003; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
GregorianCalendar - era 1; rok 2003; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
BuddhistCalendar - era 0; rok 2546; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
ChineseCalendar - era 78; rok 20 czyli 4640; mies 5; dzieñ mies. 19; dzieñ tyg. 6<br>
JapaneseCalendar - era 235; rok 15; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
IslamicCalendar - era 0; rok 1424; mies 4; dzieñ mies. 18; dzieñ tyg. 6<br>
HebrewCalendar - era 0; rok 5763; mies 10; dzieñ mies. 18; dzieñ tyg. 6<br>
</div><br>
<br>
Dostosowanie kalendarza do lokalizacji nie polega tylko na zmianie samego
kalendarza. Ten sam kalendarz - np. gregoriañski - w ró¿nych lokalizacjach
mo¿e siê ró¿niæ np. pierwszym dniem tygodnia. W Polsce pierwszym dniem tygodnia
jest poniedzia³ek (indeks 2).  Dla innych krajów - mo¿e byæ to inny dzieñ
tygodnia.<br><a name="W1.9"></a><a name="W1.9"></a><h2>Formatowanie dat</h2><div class="def">Przy formatowaniu dat podobnie jak w przypadku liczb musimy najpierw uzyskaæ odpowiedni formator
za  pomoc¹ statycznych metod getXXXInstance(...) z klasy DateFormat, a nastêpnie
na jego rzecz u¿yæ metody format z argumentem typu Date.</div><br>
<br>


Mo¿emy zastosowaæ:<br>
<ul>
<li>formator dla dat - metody getDateInstance(...)</li><li>formator dla czasu - metody getTimeInstance(...)</li><li>formator dla daty i czasu - metody getDateTimeInstance(...)</li><li>domyœlny formator dla daty i czasu - metoda getInstance().</li>
</ul>


Argumenty w/w metod okreœlaj¹ lokalizacjê oraz styl formatowania .<br>Oprócz tego mo¿emy pos³u¿yæ siê wzorcami formatowania.<br>
<br>Metoda getXXXInstance() klasy DateFormat zwraca (zlokalizowany, jeœli mo¿na)
obiekt klasy SimpleDateFormat. Za pomoc¹ tej klasy mo¿emy  zastosowaæ wzorce
formatowania do pokazywania (i parsowania) dat i czasu.<br>
<br>
Wzorzec formatowania sk³ada siê z liter ('a' - 'z', 'A' - 'Z')), które maj¹
specjalne znaczenie i s¹ interpretowane jako sk³adowe daty/czasu (lub zarezerwowane)
oraz innych symboli, które s¹ po prostu kopiowane przy formatowaniu. Litery
ujête w apostrofy nie s¹ interpretowane.<br>
Litery, maj¹ce specjalne znaczenie pokazuje tablica.<br>
<br>
<table border="0" cellspacing="3" cellpadding="0">
<tbody><tr bgcolor="#ccccff"><th align="Left">Litera
         </th><th align="Left"> Znaczenie
         </th><th align="Left">Typ
         </th><th align="Left">Przyk³ad
     </th></tr><tr><td><code>G</code></td><td>Era 
         </td><td>Tekst</td><td><code>AD</code></td></tr><tr bgcolor="#eeeeff"><td><code>y</code></td><td>Rok
         </td><td>Rok</td><td><code>1996</code>; <code>96</code></td></tr><tr><td><code>M</code></td><td>Miesi¹c w roku
         </td><td>Miesi¹c</td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr bgcolor="#eeeeff"><td><code>w</code></td><td>Tydzieñ w roku
         </td><td>Liczba<br>
</td><td><code>27</code></td></tr><tr><td><code>W</code></td><td>Tydzieñ w  miesi¹cu</td><td>Liczba</td><td><code>2</code></td></tr><tr bgcolor="#eeeeff"><td><code>D</code></td><td>Dzieñ roku
         </td><td>Liczba</td><td><code>189</code></td></tr><tr><td><code>d</code></td><td>Dzieñ miesi¹ca
         </td><td>Liczba</td><td><code>10</code></td></tr><tr bgcolor="#eeeeff"><td><code>F</code></td><td>Dzieñ tygodnia 
         </td><td>Liczba</td><td><code>2</code></td></tr><tr><td><code>E</code></td><td>Dzieñ tygodnia
         </td><td>Tekst</td><td><code>Tuesday</code>; <code>Tue</code></td></tr><tr bgcolor="#eeeeff"><td><code>a</code></td><td>Tekst  Am/pm 
         </td><td>Tekst</td><td><code>PM</code></td></tr><tr><td><code>H</code></td><td>Godzina dnia (0-23)
         </td><td>Liczba</td><td><code>0</code></td></tr><tr bgcolor="#eeeeff"><td><code>k</code></td><td>Godzina dnia (1-24)
         </td><td>Liczba</td><td><code>24</code></td></tr><tr><td><code>K</code></td><td>Godzina  am/pm (0-11)
         </td><td>Liczba</td><td><code>0</code></td></tr><tr bgcolor="#eeeeff"><td><code>h</code></td><td>Gdodzina am/pm (1-12)</td><td>Liczba</td>
<td><br>
</td><td><code>12</code></td></tr><tr><td><code>m</code></td><td>Minuta
         </td><td>Liczba</td><td><code>30</code></td></tr><tr bgcolor="#eeeeff"><td><code>s</code></td><td>Sekunda
         </td><td>Liczba</td><td><code>55</code></td></tr><tr><td><code>S</code></td><td>Milisekunda</td><td>Liczba</td><td><code>978</code></td></tr><tr bgcolor="#eeeeff"><td><code>z</code></td><td>Strefa czasowa
         </td><td>Symbol strefy<br>
</td><td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td></tr><tr><td><code>Z</code></td><td>Strefa czasowa
         </td><td>Symbol RFC 822 </td><td><code>-0800</code></td></tr></tbody>
</table>
<br>Przyjrzyjmy
siê  kilku przyk³adom zastosowania wzorców formatowania dat.<br>
<br>
Poni¿szy program:<br>
<pre>
import java.util.*;

public class Daty1 {

  public static void main(String[] args) {

    Calendar c = Calendar.getInstance();
    Date teraz = c.getTime();

    SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateInstance();

    String[] pattern = {"dd-MM-yyyy",
                        "MMMM, 'dzieñ 'dd ( EE ), 'roku 'yyyy GGGG",
                        "EEEE, dd MMM yyyy 'r.'"
                       };
    for (int i=0; i&lt;pattern.length; i++) {
      df.applyPattern(pattern[i]);
      System.out.println(df.format(teraz));
    }

  }

}
</pre>
wyprowadzi:<br>
<div class="listing100"><br>
18-07-2003<br>
lipiec, dzieñ 18 ( Pt ), roku 2003 n.e.<br>
pi¹tek, 18 lip 2003 r.<br>
</div><br>
<br>
Przy parsowaniu z u¿yciem zdefiniowanych wzorców formatowania teksty (zapisane
zgodnie z tymi wzorcami) przekszta³cane s¹ na daty (obiekty klasy Date).
Regu³y parsowania s¹ podobne jak w przypadku klasy NaumberFormat.<br>
Poni¿szy przyk³adowy fragment:<br>
<pre>
   public static void main(String[] args) {


    SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateInstance();

    String[] pattern = {"dd-MM-yyyy",
                        "MMMM, 'dzieñ 'dd ( EE ), 'roku 'yyyy GGGG",
                        "EEEE, dd MMM yyyy 'r.'"
                       };

    for (int i=0; i&lt;pattern.length; i++) {

      String in=JOptionPane.
                showInputDialog("WprowadŸ datê wg wzorca " + pattern[i]);
      df.applyPattern(pattern[i]);
      Date data = df.parse(in, new ParsePosition(0));
      System.out.println(data);
    }
  }

</pre>
po wprowadzeniu w dialogach tekstów:<br>
12-12-1999<br>
lipiec, dzieñ 18 ( Pt ), roku 2003 n.e.<br>
wtorek, 12 lipiec 2003 r.<br>
<br>
wyprowadzi na konsolê:<br>
Sun Dec 12 00:00:00 CET 1999<br>
Fri Jul 18 00:00:00 CEST 2003<br>
Sat Jul 12 00:00:00 CEST 2003<br>
<br>
Zwróæmy uwagê: b³êdny dzieñ tygodnia (wtorek zamiast soboty) nie spowodowa³
b³êdu interpretacji, ale uzyskana data jest w³aœciwa (nazwa dnia tygodnia
zosta³a skorygowana).<br>
<br>
Oczywiœcie, formatowanie i parsowanie podlega zasadom lokalizacji.<br>
Istotnych informacji lokalizacyjnych dostarcza klasa DateFormatSymbols.<br>
<br>
Przyk³adowy program tworzy obiekty klasy DateFormatSymbols dla kilku lokalizacji
i wywo³uje na ich rzecz metody takie jak getWeekdays() (zwracaj¹c¹ nazwê
dni tygodnia) czy getMonths() (nazwy dni miesi¹ca). Nazwy metod pozyskuj¹cych
zlokalizowane informacje s¹ samoobjaœniaj¹ce sie, wynik dzia³ania programu
pokazujemy w obszarze wielowierszowego pola edycyhnego (JTextArea) po to
by w³aœciwie by³y interpretowane znaki Unicode (zob. rysunek).<br>
<br>
<pre>
import java.util.*;
import java.text.*;
import java.awt.*;
import javax.swing.*;

public class DateFormatSymbolsShow {

  String[] lang = { "fr", "es", "de", "ru" };

  String out = "";

  public DateFormatSymbolsShow() {
    for (int i=0; i&lt;lang.length; i++) {
      Locale  loc = new Locale(lang[i]);
      DateFormatSymbols dfs = new DateFormatSymbols(loc);
      out += '\n' + loc.getDisplayLanguage();
      // nazwy er
      addToOut("Ery: ", dfs.getEras());
      // nazwy miesiêcy
      addToOut("Miesi¹ce: ", dfs.getMonths());
      // skróty miesiêcy
      addToOut("Miesi¹ce - skróty: ", dfs.getShortMonths());
      // nazwy dni tygodnia
      addToOut("Dni tygodnia: ", dfs.getWeekdays());
      // skróty nazw dni tygodnia
      addToOut("Dni tygodnia - skróty: ", dfs.getShortWeekdays());
    }
    JTextArea ta = new JTextArea(out);
    ta.setFont(new Font("Dialog", Font.BOLD, 14));
    JFrame f = new JFrame();
    f.getContentPane().add(ta);
    f.pack();
    f.show();
  }

  void addToOut(String msg, String[] s) {
    out += "\n" + msg;
    for (int i=0; i&lt;s.length; i++) {
      out += ' ' + s[i];
    }
  }

  public static void main(String[] args) {
    new DateFormatSymbolsShow();
  }

}
</pre>
<br>
<br>
<img src="images/datefsym.jpg" alt="r" width="734" height="487" border="1">
<br>
<br>
<br>
Zwykle nie korzystamy z klasy DateFormatSymbols (jest ona u¿ywana automatycznei
przy formatowaniu dat), Czasem jednak mo¿e zajœæ taka potrzeba. Wtedy mo¿na
u¿yc konstruktora klasy SimpleDateFormat, dostarczaj¹c mu oprócz pierwszego
argumentu (wzorca formatowania) argument drugi - refrencjê do obiektu DateFormatSymbols.<br>
<br>
Wykorzystamy to teraz do poprawieniu b³êdów gramatycznych, które nieuchronnie
powstaj¹ przy formatowaniu dat w jêzyku polskim ze wzglêdu na brak uwzglêdnienia
w³aœciwej odmiany nazw miesiêcy.
Przy okazji zobaczymy, ¿e w³aœciwoœci lokalizacyjne formatowania dat mo¿na
³atwo zmieniaæ (za pomoc¹ rozlicznych metod set... z klasy DateFormatSymbols).<br>
<br>
<pre>
import java.util.*;
import java.text.*;

public class DateFormatPol {

  public static String polskaData(Date data) {
    String[] mies = { "stycznia", "lutego", "marca", "kwietnia",
                      "maja", "czerwca", "lipca", "sierpnia",
                      "wrzeœnia", "paŸdziernika", "listopada",
                      "grudnia"
                    };
    DateFormatSymbols dfs = new DateFormatSymbols();
    dfs.setMonths(mies);
    SimpleDateFormat df = new SimpleDateFormat("dd MMMM yyyy", dfs);
    return df.format(data);
  }



  public static void main(String[] args) {
    System.out.println( polskaData( new Date() ) );
  }

}
</pre>

<br>
Prrzyk³adowy listing programui:<br>
<div class="listing33r">20 lipca 2003<br>
</div> <br>
<br>
<a name="W1.10"></a><a name="W1.10"></a><h2>
Zlokalizowany rozbiór tekstów</h2>zob. w ksi¹¿ce <br>
<br>
<a name="W1.11"></a><a name="W1.11"></a><h2>Porównywanie i sortowanie napisów</h2>

Ró¿ne jêzyki implikuj¹ ró¿ny alfabetyczny porz¹dek napisów.<br>
W³aœciwe porównywanie napisów mo¿emy przeprowadziæ za pomoc¹ obiektu klasy <b>Collator</b> z pakietu java.text.<br>
<br>
Jest to klasa czu³a na lokalizacjê, zatem w³aœciw¹ instancjê kolatora dla
domyœlnej lokalizacji uzyskamy za pomoc¹ odwo³ania Collator.getInstance().
Mo¿emy te¿ uzyskaæ kolator dla dowolnej lokalizacji, podaj¹c w metodzie getInstance(...) argument-lokalizacjê<br>
<br>
Maj¹c obiekt-kolator dla okreslonej (domyœlnej lub podanej) lokalizacji mo¿emy
za pomoc¹ metody compare(...) wywo³anej na jego rzecz uzyskaæ w³asciwy dla
danej lokalizacji wynik porównania dwóch napisów podanych jako argumenty
metody.<br>
<br>
£atwo siê domyœliæ, ¿e klasa Collator implementuje interfejs Comparator.
Zatem porównania uzyskiwane za pomoca metody compare(...) kolatora ³atwo
uczyniæ podstaw¹ sortowania tablic i kolekcji, a tak¿e decydowania o dodawaniu
elementów do uporz¹dkowanych zbiorów i map.<br>
<br><b>
Zobaczmy najprostszy przyk³ad. Niech domyœlna lokalizacja bêdzie lokalizacj¹
polsk¹, Jak posortowaæ tablicê napisów w tej lokalizacji ? Regu³a jest prosta:<br>
</b>
<ul>
  <li><b>uzyskaæ kolator dla lokalizacji domyslnej (polskiej) - metoda Collator.getInstance(),</b></li>
  <li><b>podaæ ten kolator jako komparator w metodzie Arrays.sort(...) </b></li>
</ul><br>
<pre>
import java.util.*;
import java.text.*;

public class Kolator0 {

  static void sortShow(String msg, String[] txt, Collator col) {
    String[] copyTxt = (String[]) txt.clone();
    Arrays.sort(copyTxt, col);
    System.out.println(msg);
    for (int i=0; i &lt; copyTxt.length; i++) {
      System.out.println(copyTxt[i]);
    }
  }


  public static void main(String[] args) {
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "æ", "my", "My", "Myk", "myk"  };
    Collator col = Collator.getInstance();
    sortShow("Sort pol", txt, col);
    Collator col1 = Collator.getInstance(new Locale("en"));
    sortShow("Sort en", txt, col1);
  }

}
</pre>
Program wyprowadzi na konsolê:<br>
<div class="listing100"><br>
Sort pol<br>
1<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
¹<br>
¹<br>
¥<br>
be<br>
Be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
myk<br>
Myk<br>
Sort en<br>
1<br>
¹<br>
¹<br>
¥<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
be<br>
Be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
myk<br>
Myk<br>
</div><br>
<br>
W jaki sposób (dla ró¿nych lokalizacji) uzyskujemy w³aœciwe porównania?<br>
Otó¿ konkretne kolatory s¹ obiektami klasy RuleBasedCollator, która jest podklas¹ klasy Collator.<br><br>
Uporz¹dkowanie za pomoc¹ kolatorów klasy RuleBasedCollator odbywa siê na
podstawie porównywanie znaków w oparciu o regu³y zapisane za pomoc¹ prostej
sk³adni. Regu³y te okreœlaj¹ cztery (a w pakieice ICU nawet piêæ) porz¹dki:<br>
<ul>
  <li>podstawowy (PRIMARY), w którym rozró¿niane s¹ (zdefiniowane w zestawie regu³  jako rozró¿nialne) znaki,</li>
  <li>drugorzêdny (SECONDARY) , który okreœla porz¹dek napisów identycznych
ze wzglêdu na porz¹dek podstawowy, ale ró¿ni¹cych siê akcentowanymi znakami
(to dotyczy np. jêzyków francuskiego, hiszpañskiego, angielskiego),</li>
  <li>trzeciorzêdny (TERTIARY), który napisy identyczne wedle dwóch poprzednich porz¹dków rozró¿nia na podstawie wielkoœci liter,</li>
  <li>identycznoœci (IDENTICAL): rozró¿niaj¹cy wszelkie znaki, nawet te uznane
za takie same wedle trzech poprzednicj porz¹dków (np. w wielu lokalizacjach
znaki \u0001 i \u0002 s¹ uznawane za takie same wedle trzech w/w porz¹dków,
natomiast porz¹dek identycznoœci bêdzie je rozró¿nia³)<br>
  </li>
</ul>
Stosowany dla danego kolatora porz¹dek nazywa siê <i><b>si³¹ kolatora</b></i>.<br>
Nawet nie znaj¹c regu³ danego kolatora mo¿emy ustalaæ jego si³ê (np. czy
napisy ró¿ni¹ce siê tylko wielkoœci¹ liter maj¹ byæ rozrózniane). S³u¿y temu
metoda setStrength(...) z argumentem okreœlaj¹cym si³ê kolatora (jedna ze
sta³ych statycznych  klasy Collator o nazwach PRIMARY, SECONDARY, TERTIARY,
IDENTICAL).<br>
<br><br><b>Mo¿emy sami definiowaæ regu³y dla obiektów klasy RuleBasedCollator.</b><br>
Regu³y s¹ zapisywane jak ³añcuchy znakowe w postaci:<br>
<br>
    &lt;relacja&gt; tekst &lt;relacja&gt; tekst ....<br>
<br>
gdzie relacja wprowadzana jest za pomoc¹ znaków:<br>
&lt;  - wiêksze wedle pierwszego porz¹dku (rozró¿niania liter)<br>
;  -  wiêksze wedle drugirgo porz¹dku (rozró¿niania akcentowanych liter),<br>
,   - wiêksze wedle trzeciego porz¹dku (wielkoœæ liter)<br>
= - równe<br>
a tekst jest dowolym ci¹giem znaków wy³¹czaj¹c znaki specjalne i znaki opisuj¹ce
w/w relacje (jeœli takie znaki chcemy w³¹czyæ do porównañ ujmujemy je w apostrofy).<br>
<br>
Na przyk³ad:<br>
<br>
9 &lt; a, A &lt; b, B &lt; c, C<br>
<br>
Mo¿emy te¿ u¿yæ znaku &amp;, który ³ogicznie ³¹czy  regu³y np:<br>
a &lt; b &amp; b &lt; c<br>
jest identyczne z :<br>
a &lt; b &lt; c<br>
<br>Stworzenie pe³nego zestawu regu³ dla kolatora mo¿e byæ doœæ pracoch³onne. trzeba bowiem uwzglêdniæ wiele mo¿liwych znaków.<br>
Zobaczmy najpierw jak wygl¹da fragment regu³ dla kolatora w lokalizacji polskiej. <br>
Regu³y te mo¿emy uzyskaæ za pomoc¹ odwo³ania:<br>
<pre>
    Collator col = Collator.getInstance();
    String rules = ((RuleBasedCollator) col).getRules();
</pre>
i pokazaæ np. w oknie:<br>
<br>
<img src="images/regulu.jpg" alt="r" width="491" height="174" border="1">
<br>
<br>
<br>
Spróbujmy teraz rozpatrzyæ uproszczony przyk³ad (abstrahuj¹c od wielu mo¿liwych
znaków). Przyk³ady sortowania pokaza³y nam, ¿e  rozró¿nienie pomiêdzy du¿ymi
i ma³ymi literami  nie jest pierwszorzêdne: tylko w przypadku gdy napisy
s¹ takie same kolator bierze pod uwagê tê ró¿nicê i ustawia wtedy ma³e litery
przed wielkimi. Widaæ to zreszt¹ w zestawie regu³ np. ... &lt; a, A &lt;
b, B  rozróznia najpierw litery a i b (bez uwzglêdneinia ich wielkoœci),
a dopiero gdy napisy (sk³adaj¹cy siê z tych liter) s¹ takie same bierze pod
uwagê<br>
 ich wielkoœæ.<br>
 Stworzymy wiêc przyk³adowy inny zestaw regu³, który (przy sortowaniu rosn¹cym)
ustawi wyraz  "Polska" na pocz¹tku, a inne napisy posortuje w porz¹dku -
najpierw du¿e litery, póŸniej ma³e (z uwzglêdnieniem polskich znaków i tego,
¿e polskie odpsoiedniki znaleŸc sie maj¹ po "normalnych" literach np. ¹ po
a).<br>
Obrazuje to poni¿szy program:<br>
<pre>
import java.util.*;
import java.text.*;

public class Kolator1 {

  static void sortShow(String msg, String[] txt, final Collator col) {
    String[] copyTxt = (String[]) txt.clone();
    Arrays.sort(copyTxt, col);
    System.out.println(msg);
    for (int i=0; i &lt; copyTxt.length; i++) {
      System.out.println(copyTxt[i]);
    }
  }


  public static void main(String[] args) {

    // Napisy do posortowania
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "Æwik³a", "æwik³a",
                     "æwikla", "Polska",
                     "My", "my", "Myk", "myk"  };

    // Domyœlny polski kolator
    Collator col = Collator.getInstance();
    sortShow("Default sort", txt, col);

    // Nowe regu³y
    String rules = " &lt; Polska &lt; A &lt; ¥ &lt; B &lt; C &lt; Æ &lt; D &lt; E &lt; Ê &lt; F &lt; G &lt; H" +
                  " &lt; I &lt; J &lt; K &lt; L &lt; £ &lt; M &lt; N &lt; Ñ &lt; O &lt; P &lt; Q &lt; R &lt; S &lt; Œ" +
                  " &lt; T &lt; U &lt; V &lt; W &lt; X &lt; Y &lt; Z &lt;  " +
                  " &lt; a &lt; ¹ &lt; b &lt; c &lt; æ &lt; d &lt; e &lt; ê &lt; f &lt; g &lt; h" +
                  " &lt; i &lt; j &lt; k &lt; l &lt; ³ &lt; m &lt; n &lt; ñ &lt; o &lt; p &lt; q &lt; r &lt; s &lt; œ" +
                  " &lt; t &lt; u &lt; v &lt; w &lt; x &lt; y &lt; z &lt; Ÿ";

    try {
      col = new RuleBasedCollator(rules);
    } catch (ParseException exc) {
        System.out.println("Wadliwa regu³a na pozycji " + exc.getErrorOffset());
        System.out.println(exc);
        System.exit(1);
    }

    sortShow("My new rules sort", txt, col);

  }

}
</pre>

który wyprowadzi:<br>
<div class="listing100"><br>
Default sort<br>
1<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
¹<br>
¹<br>
¥<br>
be<br>
Be<br>
Be<br>
bela<br>
æwikla<br>
æwik³a<br>
Æwik³a<br>
my<br>
My<br>
myk<br>
Myk<br>
Polska<br>
<br>
My new rules sort<br>
Polska<br>
Ala<br>
Ala<br>
¥<br>
Be<br>
Be<br>
Æwik³a<br>
My<br>
Myk<br>
ala<br>
alabama<br>
¹<br>
¹<br>
be<br>
bela<br>
æwikla<br>
æwik³a<br>
my<br>
myk<br>
1</div><br>
<br>
Je¿eli sortowanie jakiegoœ zestawu napisów ma siê powtarzaæ wielokrotnie,
to dla zwiêkszenia efektywnoœci dzia³ania mo¿na przyporz¹dkowaæ napisom klucze
i sortowaæ te klucze (klucze s¹ sortowane szybciej). <br>
Sposób postêpowania jest nastêpuj¹cy:<br>
<ul>
  <li>stworzyæ kolekcjê lub tablicê na przechowywanie kluczy (obiektów klasy CollationKeys),</li>
  <li>dla ka¿dego napisu, który ma podlegaæ porz¹dkowaniu (sortowaniu) uzysk¹c
klucz do kolatora za pomoc¹ wywo³ania metody getCollationKey(napis) z klasy
Collator,</li>
  <li>wstawiæ klucz do tablicy lub kolekcji,</li>
  <li>posortowaæ tablicê lub kolekcjê,</li>
  <li>teraz klucze w tablicy/kolekcji s¹ ustwaione w porz¹dku napisów, okreœlanym przez kolator</li>
  <li>¿eby pokazaæ wynik sortowania przebiegamy tablicê/kolekcjê kluczy i
od ka¿dgeo klucza za pomoc¹ odwo³ania getSourceString() uzyskujemy skojarzony
z nim napis.</li>
</ul>
Ilustruje to poni¿szy program.<br>
<pre>
import java.util.*;
import java.text.*;

public class Kolator2 {

  public static void main(String[] args) {

    // Napisy do posortowania
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "Æwik³a", "æwik³a",
                     "æwikla", "Polska",
                     "My", "my", "Myk", "myk"  };

    // Domyœlny polski kolator
    Collator col = Collator.getInstance();

    // Lista kluczy
    List keys = new ArrayList();

    // Uzyskanie kluczy dla napisów
    // wartoœci kluczy uzyskujemy od kolatora
    for (int i=0; i&lt;txt.length; i++) {
      CollationKey key = col.getCollationKey( txt[i] );
      keys.add(key);
    }

    // Sortowanie
    // porównywane mog¹ byæ tylko klucze uzyskane od tego samego kolatora!

    Collections.sort(keys);

    // Pokazanie wyniku
    // mamy klucze u³o¿one w okreœlonym porz¹dku napisów, które reprezentuj¹
    // musimy pobraæ napis skojarzony z kluczem

    for (Iterator it = keys.iterator(); it.hasNext(); ) {
      CollationKey key = (CollationKey) it.next();
      String napis = key.getSourceString();
      System.out.println(napis);
    }
  }

}
</pre>
<br>
<br>
<a name="W1.12"></a><a name="W1.12"></a><h2>Internacjonalizacja aplikacji i dodatkowe zasoby (resource bundle)</h2>
Nie tylka liczby, daty, czas powinny byæ w aplikacjach przygotowane do prezentacji
zgodnie z wymaganiami  danej lokalizacji. Równie¿ komunikacja aplikacji z
u¿ytkownikiem powinna przebiegaæ w jêzyku  u¿ytkownika.<br>
Wszelkiego rodzaju napisy i komunikaty dla u¿ytkownika powinny byæ lokalizacyjnie przygotowane.<br><br>
Generalnie aplikacja powinna byæ od pocz¹tku przygotowana na dzia³anie
w ró¿nych œrodowiskach jêzykowych. A to oznacza koniecznoœæ odseparowania
jêzykowych w³aœciwoœci apliakcji (takich jak jêzyk komunikatów) od samego
jej kodu.<br>
<br>
Mechanizmem umo¿liwiaj¹cycm takie odseparowanie w Javie s¹ tzw. dodatkowe zasobu (ResourceBundle).<br>
Istniej¹ dwa rodzaje dodatkowych zasobów: oparte na klasach (ListResourceBoundle)
i na czystych, tekstowych plikach w³aœciwoœci (PropertiesResourceBundle).<br>
<br>
Pliki w³aœciwoœci umo¿liwiaj¹ odseparowanie napisów, klasy ListResourceBundle - dowolnych obiektów.<br>
<br>Jako prosty przyk³ad stworzymy dwa pliki wartoœci klucz=napis: domyœlny i dla lokalizacji polskiej:<br>
<br>
Plik HelloMessages.properties<br>
# Komunikaty w aplikacji Hello - domyœlne przy braku pliku dla danej lokalizacji<br>
hello = Hello!<br>
bye = Good bye!<br>
<br>
Plik HelloMessages_pl.properties <br>
# Komunikaty w aplikacji Hello - po polsku<br>
hello = Dzieñ dobry!<br>
bye = Do widzenia.<br>
<br>
Uwaga: klucze (hello, bye) s¹ takie same.<br>
<br>
Plików tych i mechanizmu dodatkowych zasobów u¿yjemy w proœciutkiej aplikacji
Hello (dziêki czemu komunikacja z u¿ytkownikiem naprawdê bêdzie odseparowana
od kodu Ÿród³owego).
<pre>
import java.util.*;

public class Hello {

  static void sayHello() {
    Locale defLoc = Locale.getDefault();
    ResourceBundle msgs =
                   ResourceBundle.getBundle("HelloMessages", defLoc);
    String powitaj  = msgs.getString("hello");
    String pozegnaj = msgs.getString("bye");
    System.out.println(powitaj);
    System.out.println(pozegnaj);
 }


  public static void main(String[] args) {
    sayHello(); // tutaj dzia³a domyœlna lokalizacja pl_PL
    // zmieniamy domyœln¹ lokalizacjê
    Locale.setDefault(new Locale("en"));
    sayHello();
  }

}
</pre>
Wynik dzia³ania programu:<br>
<div class="listing100"><br>
Dzieñ dobry!<br>
Do widzenia.<br>
Hello!<br>
Good bye!<br>
</div><br>
Uwagi: <br>
<ul>
  <li>pierwsza para napisów powstaje, gdy¿ domyœln¹ lokalizacj¹ jest pl_PL,
getBundle(defLoc) nie znajduje pliku w³aœciwoœci o takim sufiksie, ale znajduje
bliski mu z sufiksem pl,  </li>
  <li>przy drugim odwo³aniu do sayHello poszukiwany jest plik HelloMessages_en.properties,
a poniewa¿ go nie ma - u¿ywany jest domyœlny HelloMessages.properties</li>
</ul>
Tak naprawdê ResourceBundle.getBundle(..) szuka najpierw klas dziedzicz¹cych
ListResourceBundle, a dopiero póŸniej plików w³aœciwoœci.<br>
<br>
U¿ycie ListResourceBundle wymaga od nas pisania kodu (i to jest wada w stosunku
do mechanizmu plików w³aœciwoœci), ale równoczeœnie pozwala na wprowadzenie
"pod kluczami" - innych obiektów ni¿ napisy (np. jakichœ liczb, obrazów,
dŸwiêków - oczywiœciê zlokalizowancyh).<br>
<br>
Nasze zlokalizowane listy zasobów s¹ klasami, które:<br>
<ul>
  <li>maj¹ nazwy zgodne z opisan¹ wczeœniej (przy okazji plików w³asciwoœci) konwencj¹  (sufiksy wskazuj¹ce na lokalizacjê)</li>
  <li>dziedzicz¹ klasêe ListResourceBundle,</li>
  <li>dostarczaj¹ publicznej metody Object[][] getContents() która zwraca
tablicê odpowiednioœci klucze - wartoœci, przy czym zaróno klucze jak i odpowiadaj¹ce
im wartoœci mog¹ byæ dowolnymi obiektami.</li>
</ul>
Przyk³ad:<br>
<pre>
public class CountryInfo_pl_PL extends ListResourceBundle {

   public Object[][] getContents() {
	return contents;
    }

    private Object[][] contents = {
	{ "name", "Polska" },
	{ "flag",  new ImageIcon("PolskaFlaga.gif" },
    };
}
</pre>
<br>
Uzyskiwanie wartoœci z takich zasobów odbywa siê w nastêpuj¹cy sposób:<br>
<br>
<pre>
ResourceBundle info =
		ResourceBundle.getBundle("CountryInfo", currentLocale);

String nazwaKraju = info.getString("name");
ImageIcon flaga = (ImageIcon) info.getObject("flag");
</pre>
Uwaga: je¿eli wartoœæ nie jest Stringiem nale¿y zastosowaæ metodê getObject()
i dokonaæ zawê¿aj¹cej konwersji do w³aœciwego typu.<br>
<br>
<br>
Dodatkowe zasoby (w specjalnej formie) razem z formatorem MessageFormat s¹
u¿ywane do generowania z³o¿onych komunikatów, które opisywane s¹ za pomoc¹
szablonu z wymiennymi parametrami. <br>
<br>Np.<br>
<br>
Number val;<br>
Object[] elts = { new Date(), val };<br>
<br>
String format = "Dnia {0,date} o godzinie {0,time}" +<br>
                       " wyp³acono {1,number,currency}" },<br>
    <br>
MessageFormat.format(format, elts);<br>
<br>
<br>
Przyk³ad: Msg.java<br>
<br>
<br>
<b><font color="#ff0000">Java 1.5 - metody ze zmienn¹ liczb¹ argumentów:</font></b><br>
<br>
  private void setBlue(Component ... comps) {<br>
    for (Component c : comps) c.setForeground(Color.blue);<br>
    println("Liczba przekazanych kompoenntów: " + comps.length);<br>
    println("Szerokoœæ pierwszego komponentu: " +<br>
                        comps[0].getWidth());<br>
    println("Szerokoœæ ostatniego komponentu: " +<br>
                        comps[comps.length-1]);<br>
  }<br>
<br>
i wywolanie:<br>
<br>
setBlue(lab1, lab2, lab3);<br>
<br>
setBlue(button1, button2);  // nie trzeba tablic !!!<br>
<br>
<br>
Statyczna metoda format z klasy MessagFormat jest zdefiniowana jako metoda ze zmienn¹ liczb¹ argiemnetów.<br>
<br>
Przyk³ad: Msg1.java<br>
<br>
</body></html>
