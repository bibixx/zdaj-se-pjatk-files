<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN"><html><head rel="stylesheet" type="text/css" href="../style/common.css">
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]"><title>MPR - wyk³ad 2</title>

  <link rel="stylesheet" type="text/css" href="../style/common.css">
  <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script></head><body bgcolor="#efefef"><div align="Center">

<a name="W2"></a><h1>2. Wyra¿enia regularne</h1>

</div>
<hr>
Wyra¿enia regularne stanowi¹ silne narzêdzie przetwarzania tekstów (wyszukiwania,
modyfikowania, analizy sk³adniowej). Oparte na matematecznej teorii zbiorów
i wyra¿eñ regularnych, wesz³y do szerszego zastosowania w informatyce u pocz¹tku
lat siedemdziesi¹tych wraz z narzêdziamu systemu Unix (np. grep). Znalaz³y
siê nastêpnie w arsenale wielu jêzyków programowania, wœród których na szczególn¹
wzmiankê zas³uguje Perl, który wzbogaci³ sk³adniê i mo¿liwoœci wyra¿eñ regularnych.
W Javie, poczynaj¹c od wersji 1.4, klasy i metody, umo¿liwiaj¹ce pos³ugiwanie
siê wyra¿eniami regularnymi s¹ dostêpne w ramach standardowego zestawu pakietów.<br>
<br>
<hr>
<a name="W2.1"></a><h2>2.1. Podstawowe zasady</h2><div class="def">Regularne wyra¿enie stanowi opis wspólnych cech (sk³adni) zbioru ³añcuchów znakowych</div><br>
<br>
Mo¿emy sobie wyobra¿aæ, ¿e regularne wyra¿enie jest pewnym wzorcem, który
opisuje jeden lub wiele napisów, pasuj¹cych do tego wzorca. Wzorzec taki
zapisujemy za pomoc¹ specjalnej sk³adni wyra¿eñ regularnych.<br>
<br>
Najprostszym wzorcem jest po prostu sekwencja znaków, które nie maj¹ specjalnego znaczenia (sekwencja <b>litera³ów</b>).<br>
Np. wyra¿enie regularne abc stanowi wzorzec opisuj¹cy trzy wystêpuj¹ce po
sobie znaki: a, b, i c. Wzorzec ten opisuje jeden napis "abc".<br>
<br>
We wzorcach mo¿emy stosowaæ znaki specjalne (tzw. <b>metaznaki</b>) oraz tworzone za ich pomoc¹ konstrukcje sk³adniowe. Do znaków specjalnych nale¿¹:<br>
<br>
<table cellpadding="4" width="300" border="1">
<tbody><tr><td>$</td><td>^</td><td>.</td><td>*</td><td valign="Top"><br>
      </td>
</tr><tr><td>+</td><td>?</td><td>[</td><td>]</td><td valign="Top"><br>
      </td>
</tr><tr><td>(<br>
</td><td>) </td><td>{ </td><td>}<br>
</td><td valign="Top">\<br>
      </td>
</tr></tbody>
</table>
Uwagi: <br>
<ol>
  <li>jesli chcemy traktowaæ znaki specjalne jako litera³y - poprzedzamy je odwrotnym ukoœnikiem \.</li>
  <li>w niektórych konstrukcjach sk³adniowych metaznaki trac¹ specjalne znaczenie i s¹ traktowane literalnie.</li>
</ol>


Za pomoc¹ znaków specjalnych i tworzonych za ich pomoc¹ bardziej rozbudowanych konstrukcji sk³adniowych opisujemy m.in.<br>
<ul>
  <li>wyst¹pienie jednego z wielu znaków - odpowiednie konstrukcje sk³adniowe nosz¹ nazwê <b>klasy znaków </b>(np. litery lub cyfry),</li>
  <li>pocz¹tek lub koniec ograniczonego ci¹gu znaków (np. wiersza lub s³owa) - <b>granice</b>,</li>
  <li>powtórzenia - w sk³adni wyra¿eñ regularnych opisywane przez tzw. <b>kwantyfikatory,</b></li>
  <li>logiczne kombinacje wyra¿eñ regularnych.<br>
  </li>
</ul>
Np. wyra¿enie regularne [0-9] stanowi wzorzec opisuj¹cy jeden znak, który
mo¿e byæ dowoln¹ cyfr¹ 0,1,2,... ,9. Wzorzec ten opisuje wszystkie napisy sk³adaj¹ce
siê z jednej cyfry.<br>
A wyra¿enie regularne a.*z (a, kropka, gwiazdka, z) opisuje dowoln¹ sekwencjê
znaków, zaczynaj¹cych siê od litery a i koñcz¹cych siê liter¹ z. Do wzorca
tego pasuj¹ np. nastêpuj¹ce napisy: "az", "abz", "a x y z".<br>
<br>
Sk³adniê wyra¿eñ regularnych bêdziemy omawiaæ bardziej szczegó³owo w nastêpnych punktach.<br>
<br>
Wyra¿eñ regularnych mo¿emy u¿yæ m.in. do: <br>
<ul>
  <li>stwierdzenia czy dany napis pasuje do podanego przez wyra¿enie wzorca,</li>
  <li>stwierdzenia czy dany napis zawiera pod³añcuch znakowy pasuj¹cy do
podanego wzorca i ew. uzyskania tego podnapisu i/lub jego pozycji w napisie,</li>
  <li>zamiany czêœci napisu, pasuj¹cych do wzorca na inne napisy,</li>
  <li>wyró¿niania czêœci napisu, które s¹ rozdzielane ciagami znaków posuj¹cymi do podanego wzorca. </li>
</ul>W Javie s³u¿¹ do tego klasy pakietu java.util.regex: <b>Pattern i Matcher</b>.<br>
<br>
Przed zastosowaniem wyra¿enia regularnego do sk³adniowej analizy jakiegoœ napisu musi ono byæ skompilowane. Obiekty klasy <b>Pattern</b> reprezentuj¹ skompilowane wyra¿enia regularne, a obiekty te uzyskujemy za pomoc¹ statycznych metod klasy Pattern - <b>compile(...)</b>, maj¹cych za argument wyra¿enie regularne.<br>
Obiekty klasy <b>Matcher</b> wykonuj¹ operacje wyszukiwania 
w tekœcie za pomoc¹ interpretacji skompilowanego wyra¿enia regularnego i
dopasowywania go do tekstu lub jego czêsci.<br>
Obiekt-matcher jest zawsze zwi¹zany z danym wzorcem. Zatem uzyskujemy go od obiektu-wzorca za pomoc¹ metody <b>matcher(...)</b>
 klasy Pattern, podaj¹c jako jej argument przeszukiwany tekst. Nastêpnie
mo¿emy dokonywaæ ró¿nych operacji przeszukiwania i zastêpowania tekstu poprzez
u¿ycie ró¿nych metod klasy Matcher. <br>
W szczególnoœci: <br>
<ul>
  <li>metoda <b>matches()</b> stara siê dopasowaæ do wzorca ca³y podany ³añcuch znakowy,</li>
  <li>metoda <b>find()</b>  przeszukuje wejœciowy ³añcuch znakowy i wyszukuje kolejne pasuj¹ce do wzorca jego pod³añcuchy.</li>
</ul>
Wszystkie metody dopasowania/wyszukiwania zwracaj¹ wartoœci typu boolean,
stwierdzaj¹ce dopasowanie (true) lub jego brak (false). Wiêcej informacji
o dopasowaniu (jaki konkretnie tekst  pasuje do wzorca, gdzie jest jego pocz¹tek,
a gdzie koniec itp.) mo¿na uzyskaæ odpytuj¹c matcher o aktualny jego stan
za pomoc¹ odpowiednich metod.<br>
Bêdziemy o tym mówiæ dok³adnie w dalszej czêœci rozdzia³u.<br>
<br>
Typow¹ sekwencjê operacji, potrzebnych do zastosowania 
wyra¿eñ regularnych mo¿na opisaæ w nastêpuj¹cy schematyczny sposób.<br>
<br>
<div class="syntax"><br>A. Tekst, podlegaj¹cy dopasowaniu mo¿e byæ reprezentowany przez obiekt dowolnej
klasy implementuj¹cej interfejs CharSequence (np. String, StringBuffer, CharBuffer
z pakietu java.nio) np:<br>
<br>
    String text = "ala-127"; <br>
<br>B. Tworzymy wyra¿enie regularne jako napis np.<br>
<br>
    String regexp = "[0-9]";   <br>
<br>C. Kompilujemy wyra¿enie regularne i uzyskujemy skompilowany wzorzec.<br>
<br>
    Pattern pattern = Pattern.compile(regexp);<br>
<br>D. Tworzymy obiekt-matcher zwi¹zany z danym wyra¿eniem, podaj¹c przy tym tekst do dopasowania:<br>
<br>
    Matcher matcher = pattern.matcher(text);<br>
<br>E. Szukamy dopasowania tekstu ( w tekœcie ) zgodnie ze wzorcem np.<br>
<br>
    boolean hasMatch = matcher.find();  <br>
    albo:<br>
    boolean isMatching = matcher.matches(); <br>
</div><br>
<br>Inne mo¿liwe sposoby postêpowania opisane zostan¹ w podpunkcie dotycz¹cym dopasowania i wyszukiwania.<br>
<br>
Przedtem zapoznamy siê nieco bli¿ej ze sk³adni¹ wyra¿eñ regularnych,<br>
Przy  prezentacji przyk³adów pokazane zostanie zarówno dzia³anie metody marches()
jak i find(). Wykorzystujemy przy tym nastêpuj¹c¹ metodê, która jako argumenty
otrzymuje wyra¿enie regularne oraz  analizowany za jego pomoc¹ tekst, a zwraca
opis wyników dzia³ania metod matches() i find().<br>
<pre>
  String report(String regex, String text) {
    String result = "Wzorzec: \"" + regex + "\"\n" +
                    "Tekst: \"" + text + "\"";
    // Kompilacja wzorca
    // Gdy wzorzec jest sk³adniowo b³êdny
    // wyst¹pi wyj¹tek PatternSyntaxException
    Pattern pattern = null;
    try {
      pattern = Pattern.compile(regex);
    } catch (Exception exc) {
        return result + "\n" + exc.getMessage(); // zwracamy komunikat o b³êdzie
    }

    // Uzyakanie matchera dla podanego tekstu
    Matcher matcher = pattern.matcher(text);

    // Próba dopasowania ca³ego tekstu do wzorca
    boolean isMatching = matcher.matches();
    result += "\nmatches(): Ca³y tekst" + (isMatching ? "" : " NIE") +
              " pasuje do wzorca.";

    matcher.reset(); // Przywrócenie pocz¹tkowej pozycji matchera

    // Teraz stosujemy metodê find()
    // Jej wywo³anie zwraca true po znalezieniu pierwszego
    // pasuj¹cego do wzorca pod³añcucha w tekœcie
    // Kolejne wywo³ania pozwalaj¹ wyszukiwaæ kolejne pasuj¹ce pod³añcuchy
    // wynik false oznacza, ¿e w tekœcie nie ma ju¿ pasuj¹cych pod³añcuchów
    boolean found = matcher.find();
    if (!found)
      result += "\nfind(): Nie znaleziono ¿adnego pod³añcucha " +
                "pasuj¹cego do wzorca";
    else
      do {
        result += "\nfind(): Dopasowano pod³añcuch \"" + matcher.group() +
                   "\" od pozycji " + matcher.start() +
                   " do pozycji " + matcher.end() + ".";
      } while(matcher.find());

    return result;
  }
</pre>
Uwaga: nie szkodzi jeœli kod tej metody nie jest teraz w pe³ni zrozumia³y,
wykorzystamy j¹ w nastêpnych punktach wy³¹cznie do prezentacji sk³adni i
efektów interpretacji wyra¿eñ regularnych. Szczegó³owe omówienie metod dopasowania
oraz metod uzyskiwania informacji o stanie matchera zawarto dalej.<br>
<br>
Sk³adnia wyra¿eñ regularnych i regu³y rz¹dz¹ce jej interpretacj¹ s¹ - abstrahuj¹c
od najprostszych przypadków - doœæ skomplikowane, a czasem ma³o intuicyjne.
<br> Tworzenie dobrych wyra¿eñ regularnych jest prawdziw¹ sztuk¹, a zagadnieniu
temu poœwiêcono wielosetstronicowe ksi¹¿ki. Do najlepszych (a zarazem doœæ
zaawansowanych) nale¿y "Mastering regular expressions" autorstwa Jeffreya
E. F. Friedla,  wydana przez O'Reilly w roku 1997 i 2003, jak równie¿ nie tak dawno
w t³umaczeniu polskim w Wydawnictwie Helion. Oczywiœcie, w tym rozdziale nie
sposób w tak dog³êbny i szczegó³owy sposób przedstawiæ sk³adni i mechanizmów
interpretacji wyra¿eñ regularnych. Maj¹c nadziejê, ¿e przedstawiony dalej
materia³ bêdzie wystarczaj¹cy dla codziennych potrzeb, Czytelnikom zainteresowanym
pog³ebieniem wiedzy o wyra¿eniach regularnych mo¿na poleciæ tê dodatkow¹ lekturê.
<br>

<a name="W2.2"></a><h2>
2.2. Litera³y</h2>

Litera³y u¿yte w wyra¿eniu regularnym s¹ dopasowywane po kolei.<br>
Na przyk³ad wyra¿enie regularne: <br>
<br>
    String regexp = "ala";<br>
<br>
jest interpretetewane w nastêpuj¹cy sposób: w podanym ³¹ñcuchu wejœciowym
wyszukiwane s¹ kolejno wystêpuj¹ce po sobie znaki 'a'. 'l' i 'a'.  Wynikiem
metody matches() jest true tylko wtedy, gdy ca³y tekst pasuje do tego wzorca
("ala"), metoda find() umo¿liwia znalezienie w tekœcie wielu pod³añcuchów
"ala".<br>
<br>
<div class="listing100"> Przyk³ad:<br>
Wzorzec: "ala"<br>
Tekst: "ala"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
<br>
Wzorzec: "ala"<br>
Tekst: "Ta ala ma kota i ala ma psa ala"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 3 do pozycji 6.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 17 do pozycji 20.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 28 do pozycji 31.<br>
</div><br>
<br>
Jak ju¿ wspomniano, jako litera³ów nie mo¿emy u¿ywaæ symboli maj¹cych specjalne
znaczenie w sk³adni wyra¿eñ regularnych. Powstanie wtedy b³¹d sk³adniowy
przy kompilacji wyra¿enia. B³êdy sk³adniowe (ró¿nego rodzaju) mo¿emy obs³ugiwaæ
przechwytuj¹c wyj¹tek PatternSyntaxException (jak pokazano na 
wydruku metody report(...)). <br>
<br>
Oto przyk³ad.<br>
<div class="listing100"><br>
Wzorzec: "(x"<br>
Tekst: "(x"<br>
Unclosed group near index 2<br>
(x<br>
  ^<br>
</div><br>
<br>
<br>
Warto zauwa¿yæ, ¿e u¿ycie znaków specjalnych (metaznaków) mo¿e nie powodowaæ
b³êdu sk³adniowego, ale inne od zamierzonych wyniki dopasowania.<br> WyobraŸmy
sobie, ¿e nie znamy znaczenia metaznaków '(' i ')' (no, rzeczywiœcie, na razie jeszcze nie znamy) i chcemy dopasowaæ/znaleŸæ
literalny tekst (x). Efekty bêd¹ inne od oczekiwanych:<br>
<div class="listing100"><br>
Wzorzec: "(x)"<br>
Tekst: "(x)"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "x" od pozycji 1 do pozycji 2.<br>
</div><br>
<br>
Jeœli chcemy wyszukiwaæ w tekœcie literalne znaki specjalne to w wyra¿eniu
regularnym powinniœmy je poprzedziæ odwrotnym ukoœnikiem (nie dotyczy to metaznaków
u¿ytych w definicji klas znaków - o czym w nastêpnym podpunkcie).<br>
<br>
<div class="listing100"><br>
Wzorzec: "\(x"<br>
Tekst: "(x"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "(x" od pozycji 0 do pozycji 2.<br></div><br>
<br>
U¿ywaj¹c odwrotnego ukoœnika mo¿emy tak¿e literalnie wprowadzaæ kody znaków oraz znaki kontrolne.<br>
Tabela poni¿ej przdestawia sposób literalnego zapisu pewnych specjalnych znaków w wyra¿eniu regularnym.<br>
<br>
<table border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td valign="Top">\0n</td><td>Znak o kodzie ósemkowym <i>n</i>
         (0 <tt>&lt;=</tt> <i>n</i> <tt>&lt;=</tt> 7)</td></tr><tr><td valign="Top">\0nn</td><td>Znak o kodzie ósemkowym <i>nn</i>
         (0 <tt>&lt;=</tt> <i>n</i> <tt>&lt;=</tt> 7)</td></tr><tr><td valign="Top">\0mnn</td><td>Znak o kodzie ósemkowym  <i>mnn</i>
         (0 <tt>&lt;=</tt> <i>m</i> <tt>&lt;=</tt> 3,
         0 <tt>&lt;=</tt> <i>n</i> <tt>&lt;=</tt> 7)</td></tr><tr><td valign="Top">\xhh</td><td>Znak o kodzie szesnastkowym <tt>x</tt><i>hh</i></td></tr><tr><td valign="Top">\uhhhh</td><td>Znak o kodzie szesnastkowym <tt>x</tt><i>hhhh</i></td></tr><tr><td valign="Top">\t</td><td>Znak tabulacji (<tt>'\u0009'</tt>)</td></tr><tr><td valign="Top">\n</td><td>Znak nowego wiersza (<tt>'\u000A'</tt>)</td></tr><tr><td valign="Top">\r</td><td>Powrót karetki (<tt>'\u000D'</tt>)</td></tr><tr><td valign="Top">\f</td><td
>Nowa strona (<tt>'\u000C'</tt>)</td></tr><tr><td valign="Top">\a</td><td>Alert (dzwonek) (<tt>'\u0007'</tt>)</td></tr><tr><td valign="Top">\e</td><td>Znak \  (<tt>'\u001B'</tt>), mo¿na napisac równie¿ \\</td></tr><tr><td valign="Top">\cx</td><td>Znbak steruj¹cy <i>x</i></td></tr></tbody>
</table>
<br>
<div class="listing100">Przyk³ad<br>
Wzorzec: "ala\nma\nkota"<br>
Tekst: "ala<br>
ma<br>
kota"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala<br>
ma<br>
kota" od pozycji 0 do pozycji 11.<br>
</div><br>
<br>
<br>
Wyra¿enia regularne (w tym te w postaci litera³ów) mo¿emy ze sob¹ logicznie
³¹czyæ. Tak naprawdê wyra¿enie regularne "abc" jest logiczn¹ koniunkcj¹ wyra¿eñ
"a", "b" i "c".<br>
Mamy te¿ logiczn¹ alternatywê wprowadzan¹ znakiem |.<br>
<br>
Jeœli np. chcemy dopasowaæ (lub znaleŸæ) tekst który jest napisem "ala" albo"kot",
albo "pies", mo¿emy zbudowaæ wyra¿enie regularne "ala|kot|pies"<br>
<br>
Oto przyklad jego dzialania:<br>
<div class="listing100"><br>
Wzorzec: "ala|kot|pies"<br>
Tekst: "ala"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
<br>
Wzorzec: "ala|kot|pies"<br>
Tekst: "pies"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "pies" od pozycji 0 do pozycji 4.<br>
<br>
Wzorzec: "ala|kot|pies"<br>
Tekst: "Loskotek, ala i kot i pies w jednym stali domu"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "kot" od pozycji 3 do pozycji 6.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 10 do pozycji 13.<br>
find(): Dopasowano pod³añcuch "kot" od pozycji 16 do pozycji 19.<br>
find(): Dopasowano pod³añcuch "pies" od pozycji 22 do pozycji 26.<br>
</div><br>
<br>
Zwrócmy szczególn¹ uwagê:<br>
<ul>
  <li>matcher przegl¹da tekst znak po znaku i za ka¿dym razem szuka dopasowania
ca³ego wyra¿enia regularnego; zatem o kolejnoœci odnalezionych pod³añcuchów
decyduje ca³e wyra¿enie, a nie kolejnoœæ jego alternatywnych czêœci - dlatego
w ostatnim przyk³adzie find() najpierw odnalazl ci¹g znaków "kot" w wyrazie
"Loskotek", a nie wyraz "ala" mimo, ¿e ci¹g "kot" wyst¹pi³ w wyra¿eniu regularnym
po ci¹gu "ala",</li>
  <li>no i oczywiœcie, wyszukiwane s¹ dowolne ci¹gi znaków, a nie s³owa (o
tym jak szukaæ ci¹gów znaków, które s¹ s³owami - dowiemy siê dalej).</li>
</ul>
<a name="W2.3"></a><h2>2.3. Klasy znaków </h2>

Stosuj¹c nawiasy kwadratowe mo¿emy wprowadzaæ w wyra¿eniu regularnym tzw. <b>klasy znaków</b>.<br>
<br>
<b>Prosta klasa znaków</b> stanowi ci¹g znaków ujêtych w nawiasy kwadratowe np.<br>
<br>
[123abc]<br>
<br>
Matcher dopasuje do takiego wzorca dowolny z wymienionych znaków. Jest to w istocie skrót zapisu 1|2|3|a|b|c. <br>
<br>
Jeœli pierwszym znakiem w nawiasach kwadratowych jest <b>^</b>, to dopasowanie nast¹pi dla ka¿dego znaku <b>oprócz</b> wymienionych na liœcie. Jest to swoista <b>negacja</b> klasy znaków.<br>
Np. do wzorca [^abc] bêdzie pasowa³ ka¿dy znak oprócz a, b i c.<br>
<br>
Mo¿liwe jest tak¿e formu³owanie <b>zakresów</b> znaków (co ju¿ znacznie u³atwia zapis). Przy formu³owaniu zakresów u¿ywamy naturalnego symbolu -. <br>
Przyk³adowe wzorce:<br>
[0-9] - dowolna cyfra,<br>
[a-zA-Z] - dowolna ma³a i du¿a litera alfabetu angielskiego.<br>
[a-zA-Z0-9] = dowolna cyfra lub litera<br>
<br>
i nieco bardziej skomplikowany przyk³ad, w którym po slowie Numer powinna
nastêpowaæ spacja, potem zaœ jedna z cyfr 1,2,3,7,8,9, nastêpnie dowolna
cyfra, ukoœnik i dowolny znak oprócz cyfr 0,1,2,3 oraz malej litery alfabetu
angielskiego.<br>
<br>
<div class="listing100"><br>
Wzorzec: "Numer [1-37-9][0-9]/[^0-3a-z]"<br>
<br>
Tekst: "Numer 11/9"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Numer 11/9" od pozycji 0 do pozycji 10.<br>
<br>
Tekst: "Numer 51/9"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
<br>
Tekst: "Numer 38/A"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Numer 38/A" od pozycji 0 do pozycji 10.<br>
<br>
Tekst: "Numer 38/a"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
<div class="important">Nale¿y pamiêtaæ, ¿e klasa znaków okreœla jeden znak nale¿¹cy (lub nie)
do podanego w nawiasach kwadratowych zestawu.  Kolejnoœæ znaków w zestawie
nie jest istotna, ale zakresy musz¹ byæ podawane w porz¹dku rosn¹cym.</div><br>
<br>
Ostatni¹ obserwacjê obrazuj¹ przyk³ady.<br>
<br>
<div class="listing100"><br>
Wzorzec: "[abc][0-9]"<br>
Tekst: "a1"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "a1" od pozycji 0 do pozycji 2.<br>
<br>
Wzorzec: "[abc][0-9]"<br>
Tekst: "c3"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "c3" od pozycji 0 do pozycji 2.<br>
<br>
Wzorzec: "[bca][0-9]"<br>
Tekst: "a1"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "a1" od pozycji 0 do pozycji 2.<br>
<br>
Wzorzec: "[bca][9-0]"<br>
Tekst: "a1"<br>
Illegal character range near index 8<br>
[bca][9-0]<br>
        ^<br>
</div><br>
<br>
U³atwieniem zapisu zakresów s¹ tzw. klasy predefiniowane. Podstawowe klasy predefiniowane pokazuje poni¿sza tabela.<br>
<br>
<table border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td valign="Top">.</td><td>Dowolny znak (w zale¿noœci od opcji kompilacji wzorca mo¿e pasowaæ lub nie do znaku koñca wiersza)</td></tr><tr><td valign="Top">\d</td><td>Cyfra: [0-9]</td></tr><tr><td valign="Top">\D</td><td>Nie-cyfra: [^0-9]</td></tr><tr><td valign="Top">\s</td><td>"Bia³y" znak: [ \t\n\x0B\f\r]</td></tr><tr><td valign="Top">\S</td><td>Ka¿dy znak, oprócz "bia³ego": [^\s]</td></tr><tr><td valign="Top">\w</td><td>Jeden ze znaków: [a-zA-Z0-9],  znak "dopuszczalny w s³owie"</td></tr><tr>
<td valign="Top">\W</td><td>Znak nie bêd¹cy liter¹ lub cyfr¹ [^\w]</td></tr></tbody>
</table>
Uwaga: ogólna regu³a - klasy wprowadzane przez du¿e litery stanowi¹ negacjê klas definiowanych przez ma³e litery.<br>
<br>
Bardzo wa¿n¹ predefiniowan¹ klas¹ jest "klasa wszystkich znaków", podawana
jako kropka. Za jej pomoc¹ mo¿emy dopasowaæ dowolny znak.<br>
<br>
Przyk³ad: wzorzec który dopasowuje teksty sk³adaj¹ce siê z trzech dowolnych
cyfr, nastêpuj¹cych po nich trzech dowolnych znaków i dwóch znaków, nie bêd¹cych
cyframi. <br>
<br>
<div class="listing100"><br>
Wzorzec: "\d\d\d...\D\D"<br>
<br>
Tekst: "123###a$"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "123###a$" od pozycji 0 do pozycji 8.<br>
<br>
Tekst: "123abc12"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
<br>
Tekst: "abc123xx"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Pewnym rozszerzeniem podstawowych predefiniowanych klas s¹ klasy znakowe,
zdefiniowane w standardzie POSIX. Pokazuje je poni¿sza tabela,<br>
<br>
<table border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td valign="Top">\p{Lower}</td><td>Ma³a litera: [a-z]</td></tr><tr><td valign="Top">\p{Upper}</td><td>Du¿a litera: [A-Z]</td></tr><tr><td valign="Top">\p{ASCII}</td><td>Dowolny znak ASCII :[\x00-\x7F]</td></tr><tr><td valign="Top">\p{Alpha}</td><td>Dowolna litera: [\p{Lower}\p{Upper}]</td></tr><tr><td valign="Top">\p{Digit}</td><td>Cyfra: [0-9]</td></tr><tr><td valign="Top">\p{Alnum}</td><td>Cyfra b¹dŸ litera: [\p{Alpha}\p{Digit}]</td></tr><tr><td valign="Top">\p{Punct}</td><td>Znak punktuacji: !
"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</td></tr><!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
          <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> --><tr><td valign="Top">\p{Graph}</td><td>Widzialny znak: [\p{Alnum}\p{Punct}]</td></tr><tr><td valign="Top">\p{Print}</td><td>Drukowalny znak: [\p{Graph}]</td></tr><tr><td valign="Top">\p{Blank}</td><td>Spacja lub tabulacja: [ \t]</td></tr><tr><td valign="Top">\p{Cntrl}</td><td>Znak steruj¹cy: [\x00-\x1F\x7F]</td></tr><tr><td valign="Top">\p{XDigit}</td><td>Cyfra szesnastkowa: [0-9a-fA-F]</td></tr><tr><td valign="Top">\p{Space}</td><td>Bia³y znak: [
 \t\n\x0B\f\r]</td></tr></tbody>
</table>
<br>
Wypróbujmy tê sk³adniê na przyk³adzie wzorca, który opisuje tekst zczynaj¹cy
siê od dowolnej litery, z nastêpuj¹cym po niej dowolnym znakiem punktuacji
i dowoln¹ cyfr¹.<br>
<br>
<div class="listing100"><br>
Wzorzec: "\p{Alpha}\p{Punct}\d"<br>
<br>
Tekst: "a,1"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "a,1" od pozycji 0 do pozycji 3.<br>
<br>
Tekst: "aa1"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Doœæ nieprecyzyjnie powiedzieliœmy: "zaczynaj¹cy siê od dowolnej litery".
Oczywiœcie (jak widaæ z tablicy) nie dotyczy to liter polskich (a tak¿e innych
- od angielskiego - jêzyków).<br>
Zobaczmy:<br>
<div class="listing100"><br>
Wzorzec: "\p{Alpha}\p{Punct}\d"<br>
Tekst: "æ,1"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Aha, potrzebny jest Unicode. Do "dopasowywania" znaków Unicodu s³u¿¹ odrêbne predefiniowane klasy, niektóre podane w tabeli:<br>
<br>
<table border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td valign="Top"><b>\p{L}</b></td><td>Dowolna litera (Unicode)</td></tr><tr><td valign="Top"><b>\p{Lu}</b></td><td>Dowolna du¿a litera (Unicode)<br>
</td></tr><tr>
      <td valign="Top"><b>\p{Ll}</b><br>
      </td>
      <td valign="Top">Dowolna ma³a litera<br>
      </td>
    </tr>
<tr><td valign="Top"><b>\p{Sc}</b></td><td>Symbol waluty</td></tr><tr>
      <td valign="Top"><b>\p{In<i>NazwaBlokuUnicode</i>}</b><br>
      </td>
      <td valign="Top">Znak nale¿¹cy do podanego bloku Unicode<br>
      </td>
    </tr>
</tbody>
</table>
<br>
Np. wzorzec \p{Ll} bêdzie pasowa³ do dowolnego znaku Unicode, który jest
ma³¹ liter¹, zatem np. do polskich znaków ¹, æ, œ itd. (ale oczywiœcie nie
tylko).<br>
<br>
Jeœli chodzi nam o znaki tylko z konkretnych bloków Unicode'u (np. alfabetu
greckiego, lub cyrylicy) stosujemy ostatni z podanych w tabeli wzorców, podaj¹c
po s³owie In (bez spacji) nazwê bloku np.<br>
\p{InGreek}<br>
\p{InCyrillic}<br>
<br>
Stosowane s¹ tutaj nazwy bloków standardu Unicode 3, które - dla ciekawoœci
podajê poni¿ej (zwróæmy uwagê, ¿e w Unicodzie mamy równie¿ najró¿niejsze
znaki specjalne, matematyczne itp.).<br>
<pre>
Bloki Unicode (wyci¹g)

0000; 007F; Basic Latin
0080; 00FF; Latin-1 Supplement
0100; 017F; Latin Extended-A
0180; 024F; Latin Extended-B
0250; 02AF; IPA Extensions
02B0; 02FF; Spacing Modifier Letters
0300; 036F; Combining Diacritical Marks
0370; 03FF; Greek
0400; 04FF; Cyrillic
0530; 058F; Armenian
0590; 05FF; Hebrew
0600; 06FF; Arabic
0700; 074F; Syriac
0780; 07BF; Thaana
0900; 097F; Devanagari
0980; 09FF; Bengali
...
1F00; 1FFF; Greek Extended
2000; 206F; General Punctuation
2070; 209F; Superscripts and Subscripts
20A0; 20CF; Currency Symbols
20D0; 20FF; Combining Marks for Symbols
2100; 214F; Letterlike Symbols
2150; 218F; Number Forms
2190; 21FF; Arrows
2200; 22FF; Mathematical Operators
2300; 23FF; Miscellaneous Technical
2400; 243F; Control Pictures
2440; 245F; Optical Character Recognition
2460; 24FF; Enclosed Alphanumerics
2500; 257F; Box Drawing
2580; 259F; Block Elements
25A0; 25FF; Geometric Shapes
2600; 26FF; Miscellaneous Symbols
2700; 27BF; Dingbats
2800; 28FF; Braille Patterns
...</pre>
Spróbujmy zatem "pasowaæ" tylko litery nale¿¹ce do bloku Latin Extended-A (gdzie znajduj¹ siê m.in. polskie znaki).<br>
<br>
<div class="listing100"><br>
Wzorzec: "\p{InLatinExtended-A}"<br>
Tekst: "a"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
<br>
Wzorzec: "\p{InLatinExtended-A}"<br>
Tekst: "¹"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "¹" od pozycji 0 do pozycji 1.<br>
</div><br>
<br>
<br>
Oczywiœcie, wszystkie predefiniowane klasy (poza klas¹ wszystkich znaków,
okreœlan¹ przez kropkê)  mo¿na w³¹czaæ do zestawu znaków na liœcie ujêtej
w nawiasach kwadratowych. W ten sposób mo¿emy za¿yczyæ sobie np. by by³ dopasowany
albo znak z bloku Latin Extended-A, albo symbol waluty, albo cyfra szesnastkowa:<br>
<br>
<div class="listing100"><br>
Wzorzec: "[\p{InLatinExtended-A}\p{Sc}\p{XDigit}]"<br>
<br>
Tekst: "Æ"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "9"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "$"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "k"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
</div><br>
<br>
Klasy znaków (które przecie¿ traktowane s¹ jak zbiory)  mo¿emy kombinowaæ
równie¿ w jeszcze bardziej elastyczny sposób. S³u¿¹ od tego operacje:<br>
<ul>
  <li>sumowania klas (zbiorów) - uzyskiwanego poprzez zagnie¿d¿enie dodatkowych nawiasów kwadratowych,</li>
  <li>wspólnej czêœci klas (zbiorów) - uzyskiwanej za pomoc¹ operatora &amp;&amp;</li>
  <li>ró¿nicy klas (zbiorów) - uzyskiwanej poprzez kombinacjê operacji &amp;&amp; i negacji.</li>
</ul>
<b>Suma klas</b> oznacza po³¹czenie zestawu znaków tych klas. Na przyk³ad:<br>
<br>
[a-c[1-3]] - pasuje do znaków a, b, c, 1, 2, 3 <br>
<br>
<b>Wspólna czêœæ klas </b>okreœla znaki, które wystêpuj¹ w obu klasach. Na
przyk³ad, wzorzec: [1-9&amp;&amp;3-7] pasuje do cyfr 3,4,5,6,7, które s¹
wspólne dla obu wymienionych zakresów.<br>
Ten sam wzorzec moglibyœmy zapisaæ i tak [1-9&amp;&amp;[3-7]].<br>
<br>
<b>Ró¿nica</b> klas tworzy klasê, która zawiera wszystkie znaki jednej z
podanych klas za wyj¹tkiem znaków drugiej z podanych klas. Aby uzyskaæ taki
efekt trzeba po³¹czyæ dzia³anie operatorów &amp;&amp; i negacji ^.<br>
<br>
Na przyk³ad, wzorzec  [\p{L}&amp;&amp;[^abc]] okreœla dowoln¹ literê Unicode
za wyj¹tkiem liter a, b i c o czym mo¿emy siê ³atwo przekonaæ:<br>
<div class="listing100"><br>
Wzorzec: "[\p{L}&amp;&amp;[^abc]]"<br>
<br>
Tekst: "¹"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "a"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
<br>
Tekst: "d"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
</div><br>
 <br>
Na koniec bardzo wa¿na informacja.<br>
Otó¿ u¿yte w zestawie znaków klasy (w nawiasach kwadratowych) metaznaki (oprócz
odwrotnego ukoœnika, symbolu ^ oraz -) trac¹ swoje specjalne znaczenie i
s¹ traktowane literalnie. W szczególnoœci, kropka traktowana jest literalnie
(poza nawiasami kwadratowymi oznacza dowolnyc znak). To samo z "zrezerwowanymi"
nawiasami okr¹g³ymi i klamrowymi.<br>
<br>
<div class="listing100">Przyk³ad:<br>
Wzorzec: "[({]x[})]"<br>
Tekst: "(x)"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "(x)" od pozycji 0 do pozycji 3.<br>
<br>
Tekst: "{x}"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "{x}" od pozycji 0 do pozycji 3.<br>
</div><br>
<br>
A jak dopasowaæ znak x okolony dowolnymi nawiasami lub znakami - ? Przecie¿
nawiasy kwadratowe oznaczaj¹ klasê, zaœ znaki '-' s³u¿¹ do definiowania zakresów.
<br>
Z symbolem zakresu (-) nie bêdzie k³opotu - trzeba go tylko podaæ w definicji
klasy albo na pocz¹tku, albo na koñcu (wredy oczywiœcie nie mo¿e s³u¿yæ do
oznaczania zakresów a machina przetwarzaj¹ca wyra¿enia regularne jest na
tyle inteligentna, ¿e w takim kontekœcie traktuje go literalnie). Z nawiasami
kwadratowymi nie mo¿emy tak postêpowaæ, szczególnie w Javie (która - np.
w przeciwieñstwie do Perla - pozwala na zagnie¿d¿anie nawiasów kwadratowych).
Musimy zatem u¿yæ symbolu "ucieczki" - odwrotnego ukoœnika dla wskazania,
¿e nawias kwadratowy chcemy potraktowac literalnie.<br>
<br>
<div class="listing100"><br>
Wzorzec: "[\[({-]x[-)}\]]"<br>
<br>
Tekst: "-x-"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "-x-" od pozycji 0 do pozycji 3.<br>
<br>
Tekst: "[x]"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "[x]" od pozycji 0 do pozycji 3.<br>
<br>
Tekst: "(x)"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "(x)" od pozycji 0 do pozycji 3.<br>
<br>
Tekst: "{x}"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "{x}" od pozycji 0 do pozycji 3.<br>
</div><br>
<br>
<br>
<a name="W2.4"></a><h2>
2.4. Kwantyfikatory</h2>Wyra¿enia regularne by³yby ca³kiem nieprzydatne,
gdyby nie mo¿na by³o za ich pomoc¹ dopasowywaæ powtarzaj¹cych siê sekwencji
znaków. Do specyfikacji powtórzeñ s³u¿¹ <b>kwantyfikatory</b>.<br>
<br>
Symbole kwantyfikatorów s¹ nastêpuj¹ce i oznaczaj¹:<br>
<br>
<table border="0" cellpadding="1" cellspacing="0">
<tbody><tr><td valign="Top">?</td><td>wyst¹pienie jeden raz lub wcale</td></tr><tr><td valign="Top">*</td><td>wyst¹pienie zero lub wiêcej razy</td></tr><tr><td valign="Top">+</td><td>wyst¹pienie raz lub wiêcej razy</td></tr><tr><td valign="Top">{n}</td><td>wyst¹pienie dok³adnie n razy</td></tr><tr><td valign="Top">{n,}</td><td>wyst¹pienie co najmniej n razy<br>
</td></tr><tr><td valign="Top">{n,m}</td><td>wyst¹pienie co najmniej  n ale nie wiêcej ni¿ m razy</td></tr></tbody>
</table>
<br>
Czego dotyczy s³owo "wyst¹pienie"? <br>
<br>
W przypadku gdy kwantyfikator nastêpuje po literale - wymagane jest wyst¹pienie
(liczba wyst¹pieñ zale¿y od kwantyfikatora, w szczególnoœci mo¿e byæ 0) tego
litera³u np. "12a+" oznacza 1, potem 2, nastêpnie wyst¹pienie znaku 'a' jeden
lub wiêcej razy.<br>
Uwaga: "12a+" nie oznacza wyst¹pienia ci¹gu znaków 12a jeden lub wiêcej razy!<br>
<br>
Gdy kwantyfikator wystêpuje po klasie znaków - dotyczy dowolnego znaku z
tej klasy. Np. [abc]+ oznacza wyst¹pienie jeden lub wiêcej razy znaku a,
lub znaku b, lub znaku c. Wzorzec ten pasuje do takich tekstów jak np.<br>
"abc"<br>
"bcaabc"<br>
"aaaaaaaaaa"<br>
<br>
Jeœli natomiast chcemy, by kwantyfikator dotyczy³ dowolnego wyra¿enia regularnego <b>X</b> -  to powinniœmy zastosowaæ jedn¹ z poni¿szych konstrukcji sk³adniowych:<br>
<br>
<b>(X)<i>symbol_kwantyfikatora</i><br>
(?:X)<i>symbol_kwantyfikatora</i></b><br>
<br>
Konstrukcje takie tworz¹ tzw. grupy. Grupy ujête w nawiasy okr¹g³e (pierwsza
z w/w form sk³adniowych) s³u¿¹ te¿ do zapamiêtywania tekstu pasuj¹cego
do wzorca podanego w nawiasach. Druga forma s³u¿y wy³¹cznie grupowaniu, bez
zapamiêtywania.  Wiêcej na ten temat powiemy za chwilê. Teraz spójrzmy na
kilka przyk³adów grupowania, s³u¿¹cego przede wszystkim zastosowaniu kwantyfikatorów,
ale równie¿ po to, by zmieniaæ porz¹dek interpretacji wyra¿enia.<br>
<br>
Pierwszy wzorzec opisuje jedno lub wiele wyst¹pieñ dowolnych ze s³ów pies, kot, krowa (nie rozdzielonych spacjami).<br>
<div class="listing100"><br>
Wzorzec: "(pies|kot|krowa)+"<br>
<br>
Tekst: "pieskot"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "piespiespies"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "kotkotkrowa"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "krowapiespies"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
</div><br>
<br>
Bardziej skomplikowany przypadek uzyskamy jeœli za¿yczymy sobie, by tekst:<br>
<ul>
  <li>móg³ sk³adaæ siê z dowolnego pojedynczego s³owa pies, kot, krowa (bez koñcz¹cej spacji),</li>
  <li>móg³ sk³adaæ siê z dowolnej liczby powtórzeñ tych s³ów, ale przy tym
rozdzielonych co najmniej jedn¹ i nie wiêcej ni¿ trzema spacjami.</li>
</ul>

Jednym z mo¿liwych wyra¿eñ regularnych opisuj¹cych tê sytuacjê jest nastêpuj¹cy wzorzec:<br>
<br>
<pre>
(pies|kot|krowa)( {1,3}(pies|kot|krowa))*</pre>
Czytamy go tak:<br>
<ul>
  <li>tekst zaczyna siê jednym ze s³ów pies, kot, krowa</li>
  <li>po czym nastêpuje <b>zero</b> lub wiêcej powtórzeñ (kwantyfikator *) tekstu opisywanego przez wyra¿enie w drugich nawiasach,</li>
  <li>wyra¿enie w drugich nawiasach stwierdza, ¿e opisywany przez nie tekst
ma zaczynaæ siê 1, 2 lub trzema spacjami (kwantyfikator {1,3}), po czym ma
nastêpowaæ jedno ze s³ów pies, kot, krowa.</li>
</ul>
Przetestujmy czy to dzia³a.<br>
<div class="listing100"><br>
Wzorzec: "(pies|kot|krowa)( {1,3}(pies|kot|krowa))*"<br>

Tekst: "pies"<br>

matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "krowa krowa pies pies"<br>

matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "pieskot"<br>

matches(): Ca³y tekst NIE pasuje do wzorca.<br>
ALE!!!:<br>
find(): Dopasowano pod³añcuch "pies" od pozycji 0 do pozycji 4.<br>

find(): Dopasowano pod³añcuch "kot" od pozycji 4 do pozycji 7.<br>
<br>
Tekst: "pies  pies   pies"<br>

matches(): Ca³y tekst pasuje do wzorca.<br>
<br>
Tekst: "pies     pies pies"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
ALE!!!:<br>

find(): Dopasowano pod³añcuch "pies" od pozycji 0 do pozycji 4.<br>

find(): Dopasowano pod³añcuch "pies pies" od pozycji 9 do pozycji 18.<br>
</div><br>
<br>
<br>
Zwróæmy najpierw szczególn¹ uwagê na zastosowanie nawiasów okr¹g³ych. S³u¿y
ono nie tylko do stosowania kwantyfikatorów, ale równie¿ do zmiany kolejnoœci
interpretacji wyra¿enia regularnego. Gdybyœmy pierwsz¹ aletnatywê pies|kot|krowa
nie ujêli w nawiasy, to interpretacja wyra¿enia pies|kot|krowa({1,3}(pies|kot|krowa))*
by³aby taka: albo pies, albo kot, albo krowa po której nastêpuje 0 lub wiêcej
powtórzeñ kombinacji pies, kot, krowa rozdzielonych spacjami (od jednej od
trzech). Zatem otrzymalibyœmy inne od oczekiwanych wyniki: <br>
<div class="listing100"><br>
Wzorzec: "pies|kot|krowa( {1,3}(pies|kot|krowa))*"<br>
Tekst: "pies kot"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
</div><br>
<br>
poprawne tylko wtedy, gdy tekst zawieraj¹cy wiêcej ni¿ jeden wyraz  zaczyna³by siê od s³owa "krowa" <br>
<br>
<div class="listing100"><br>
Tekst: "krowa pies krowa"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
</div><br>
<br>
Tak samo potrzebne sa u¿yte w wyra¿eniu ( {1,3}(pies|kot|krowa))* nawiasy
wokó³ alternatywy pies|kot|krowa, bez nich bowiem znaczenie tego wzorca by³oby
inne od oczekiwanego, mianowicie znaczy³by on od 1 do 3 spacji przed psem
(i sam pies oczywiœcie), albo sam kot (ju¿ bez spacji) albo sama krowa (te¿
bez spacji).  <br>
<br>
Warto te¿ zwróciæ baczn¹ uwagê na te kwantyfikatory, które dopuszczaj¹ brak wyst¹pieñ
ci¹gu znaków. Kwantyfikator ? wymaga jednego wyst¹pienia lub <b>braku</b> wyst¹pieñ, kwantyfikator * wymaga <b>zera</b>
 lub wiêcej wyst¹pieñ. Tutaj trzeba uwa¿aæ, bowiem matcher znajdzie (mo¿e
znaleŸæ) dopasowania i przy braku specyfikowanego ci¹gu znaków.  <br>
<br>
W³aœnie dlatego metoda find() przy zastosowaniu wzorca "(pies|kot|krowa)(
{1,3}(pies|kot|krowa))*" do tekstu "pieskot" znajdowa³a dopasowanie (tylko
na podstawie<br>
pierwszych nawiasów, czêœæ oznaczona kwantyfikatorem-gwiazdk¹ mog³a, ale nie musia³a wyst¹piæ).<br>
<br>
Przy tej okazji uwidacznia siê wspomniana wczeœniej ró¿nica pomiêdzy metod¹
matches() (szukaj¹cej dopasowania do wzorca ca³ego tekstu) i metod¹ find()
- która przeszukuje tekst sekwencyjnie. Zobaczmy to jeszcze raz  na przyk³adzie
tekstu "xxaxxaxx" i wzorca "x*" (0 lub wiêcej wyst¹pieñ znaku 'x'). <br>
<br>
<div class="listing100"><br>
Wzorzec: "x*"<br>
Tekst: "xxaxxaxx"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "xx" od pozycji 0 do pozycji 2.<br>
find(): Dopasowano pod³añcuch "" od pozycji 2 do pozycji 2.<br>
find(): Dopasowano pod³añcuch "xx" od pozycji 3 do pozycji 5.<br>
find(): Dopasowano pod³añcuch "" od pozycji 5 do pozycji 5.<br>
find(): Dopasowano pod³añcuch "xx" od pozycji 6 do pozycji 8.<br>
find(): Dopasowano pod³añcuch "" od pozycji 8 do pozycji 8.<br>
</div><br>
<br>
Oczywiœcie, nasz tekst wejœciowy nie jest ci¹giem 0 lub wiêkszej liczby znaków
x. Zatem matches() s³usznie powiada: "nie ma dopasowania". Ale metoda find()
stosuje nasz wzorzec kolejno przegl¹daj¹c tekst od pocz¹tku. Znajduje dwa
znaki x (od pozycji 0) - co spe³nia wymagania wzorca (uzyskujemy dopasowanie), po czym natrafia na znak 'a' na pozycji 2. To nie
jest 'x', ale wzorzec dopuszcza brak wyst¹pienia znaku 'x' - zatem find()
og³asza dopasowanie tekstu o zerowej d³ugoœci (co oznacza ni mniej ni wiêcej,
tylko to, ¿e tutaj x nie wystêpuje).<br>
Wrócimy jeszcze do tego zagadnienia przy okazji omawiania wyszukiwania.<br>
<br><div class="notel">W polskiej literaturze <b><i>greedy</i></b> t³umaczy siê zwykle jako zach³anny. Tutaj tego s³owa u¿yto do t³umaczenia terminu <b><i>possesive</i></b>, zatem trzeba by³o zmieniæ t³umaczenie terminu greedy</div> Opisywane dot¹d kwantyfikatory s¹ tzw. kwantyfikatorami <b>¿ar³ocznymi</b> (greedy).<br>
Matcher - przy ich zastosowaniu - jest "¿ar³oczny", bowiem najpierw konsumuje
ca³y tekst wejœciowy (i stara siê go dopasowaæ). Jeœli to siê nie uda, nastêpuje
cofanie znak po znaku, a¿ do uzyskania dopasowania lub jego braku. <br>
<br>
W Javie dostêpne s¹ te¿ dwa inne rodzaje kwantyfikatorów: <b>wstrzemiêŸliwe</b> lub leniwe (reluctant) i <b>zach³anne</b>
 (possesive). Kwantyfikatory wstrzemiêŸliwe - w przeciwieñstwie do ¿ar³ocznych
- rozpoczynaj¹ od pocz¹tku tekstu wejœciowego i pobieraj¹ znak po znaku szukaj¹c
dopasowania. Ewentualna próba dopasowanie ca³ego tekstu nastêpuje na samym
koñcu.<br>
Kwantyfikatory zach³anne (possesive) podobnie jak ¿ar³oczne konsumuj¹ ca³y
tekst i sprawdzaj¹ jego dopasowanie, jednak przy braku dopasowania - w przeciwieñstwie
do kwantyfikatorów ¿ar³ocznych - nie nastêpuje cofanie znak po znaku.<br>
<br>
Ka¿dy z omówionych wczeœniej kwantyfikatorów (które generalnie s¹ ¿ar³oczne
- "greedy") mo¿na uczyniæ wstrzemiê¿liwym lub zach³annym..<br>
W tym celu po kwantyfikatorze dodajemy odpowiednio znak ? lub +.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">
      <div align="Center">Aby uczyniæ <br>
¿ar³oczny (greedy)<br>
kwantyfikator: ?, *, +, (n), (n,), (n,m)<br>
      </div>
      </td>
      <td valign="Top">
      <div align="Center"><b>Wstrzemiê¿liwym</b><br>
      <b>(reluctant)</b><br>
      </div>
      </td>
      <td valign="Top">
      <div align="Center"><b>Zach³annnym</b><br>
      <b>(possesive)</b><br>
      </div>
      </td>
    </tr>
    <tr>
      <td valign="Top">Dodajemy po nim znak<br>
      </td>
      <td valign="Top">
      <div align="Center"><b>?</b><br>
      </div>
      </td>
      <td valign="Top">
      <div align="Center"><b>+</b><br>
      </div>
      </td>
    </tr>
    <tr>
      <td valign="Top">Czyli kwantyfikatory wygl¹daj¹ tak:<br>
      </td>
      <td valign="Top">??, *?, +?, (n)? ...<br>
      </td>
      <td valign="Top">?+, *+, ++, (n)+ ...<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
Ró¿nicê w dzia³aniu trzech rodzajów kwantyfikatoró pokazuje przyk³ad.<br>
<div class="listing100"><br>
Wzorzec: ".*ala"<br>
Tekst: "to jest ala i ma psa ala"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "to jest ala i ma psa ala" od pozycji 0 do pozycji 24.<br>
<br>
Wzorzec: ".*?ala"<br>
Tekst: "to jest ala i ma psa ala"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "to jest ala" od pozycji 0 do pozycji 11.<br>
find(): Dopasowano pod³añcuch " i ma psa ala" od pozycji 11 do pozycji 24.<br>
<br>
Wzorzec: ".*+ala"<br>
Tekst: "to jest ala i ma psa ala"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Kwantyfikator ¿ar³oczny (pierwszy przypadek) skonsumowa³ ca³y tekst, po czym
matcher wycofywa³ siê, a¿ znalaz³ dopasowanie (s³owa "ala" na koñcu). Na
tym matcher zakoñczy³ dzia³anie, co widac wyraŸnie z wyniku metody find().<br>
<br>
Kwantyfikator wstrzemiê¿liwy (drugi przypadek) zacz¹³ dzia³anie od pocz¹tku
tekstu, dziêki czemu metoda find() mia³a okazjê znaleŸæ w tekœcie dwa dopasowania
do wzorca.<br>
<br>
Kwantyfikator zach³anny (trzeci przypadek) skonsumowa³ ca³y tekst i nic ju¿
nie zosta³o do dopasowania do s³owa "ala" we wzorcu. Ten kwatyfikator nie
pozwala matcherowi cofaæ siê, zatem dostaliœmy brak dopasowania.  <br>
<br>
To, który z rodzajów kwantyfikatorów wybraæ zale¿y od kontekstu.<br>
<br>
Generalnie, ¿ar³ocznoœæ nie jest sama w sobie z³a (czêsto umo¿liwia uzyskanie
efektów, które nie by³yby mo¿liwe bez tej cechy kwantyfikatorów).<br>
Spójrzmy na przyk³ad: chcemy wyodrêbniæ z jakiegoœ tekstu <b>ostatnie</b> zawarte w nim trzy po sobie nastêpuj¹ce cyfry.<br>
Zastosowanie ¿ar³ocznego kwantyfikatora pozwoli na uzyskanie tego efektu: ".*(\d\d\d).*".<br>
Dla tekstu "a 123 b 456 cdefgh" zadzia³a on tak: .* skonsumuje ca³y tekst,
a matcher cofaj¹c siê napotka ostanie 3 cyfry, po czym nastêpuj¹cy .* pominie
wszystko do koñca. W wyniku grupa w nawiasach okr¹g³ych, bêdzie mia³a po¿¹dan¹
wartoœæ 456<br>
<br>
<div class="listing100"><br>
Wzorzec: ".*(\d\d\d).*"<br>
Tekst: "a 123 b 456 cdefgh"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
Wartoœæ grupy w nawiasach: "456" <br>
</div><br>
<br>
Gdyby w tym przyk³adzie pierwszy kwantyfikator by³ wstrzemiê¿liwy, uzyskalibyœmy inny efekt:<br>
<br>
<div class="listing100"><br>
Wzorzec: ".*?(\d\d\d).*"<br>
Tekst: "a 123 b 456 cdefgh"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
Wartoœæ grupy w nawiasach: "123" <br>
</div><br>
<br>
Oczywiœcie, nie zawsze ¿ar³ocznoœæ kwantyfikatorów bêdzie nam odpowiadaæ.
WyobraŸmy sobie, ¿e chcemy uzyskaæ ostatni¹ liczbê ca³kowit¹ w tekœcie, niezaleznie
do tego ile ma cyfr.<br>
Powiemy tak: dowolna liczba dowolnych znaków, po niej jedna lub wiêcej cyfr,
po czym dowolna liczba nie-cyfr (równie¿ brak znaków).<br>
<br>
<div class="listing100"><br>
Wzorzec: ".*(\d+)\D*"<br>
Tekst: "a 123 b 4567 cdefgh"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
Wartoœæ grupy w naiwasach: "7"<br>
</div><br>
<br>
Kwantyfikator po¿ar³ wszystko, a matcher cofaj¹c siê znalaz³ dopasowanie
do wzorca (\d+)\D* ju¿ przy ostatniej cyfrze (7) i tym siê zadowoli³. <br>
<br>
Natomiast zastosowanie kwantyfikora wstrzemiêŸliwego pozwoli na wyodrêbnienie
ca³ej liczby. Zapiszmy wzorzec: ".*?(\d+)\D*", co znowu oznacza: dowolne
znaki, jedna lub wiêcej cyfr, po których nastêpuje dowolna (równie¿ zerowa)
liczba znaków nie bêd¹cych cyframi. Tym razem jednak kwantyfikator jest wstrzemiê¿liwy.
Wynik:<br>
<div class="listing100"><br>
Wzorzec: ".*?(\d+)\D*"<br>
Tekst: "a 123 b 4567 cdefgh"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
Wartoœæ grupy w nawiasach: "4567"<br>
</div><br>
<br>
Mo¿na te¿ zauwa¿yæ, ¿e w wielu przypadkach wstrzemiêŸliwe kwantyfikatory dzia³aj¹ bardziej efektywnie. <br>
 Gdy natomiast nasze wyra¿enie jest dobrze skonstruowane i s³u¿y do sprawdzenia
czy ca³y tekst pasuje/nie pasuje do wzorca - poch³oniêcie tekstu przez kwantyfikator
bez cofania siê mo¿e okazaæ siê bardzo efektywne ni¿ przegl¹danie od pocz¹tku
czy te¿ dopuszczenie wycofywania siê znak po zbaku. Zastosujemy wtedy kwantyfikator
zach³anny, a nie  wstrzemiêŸliwy czy ¿ar³oczny. <br>
<br>
<a name="W2.5"></a><h2>
2.5. Granice</h2>


Je¿eli jesteœmy zainteresowani dopasowaniem wzorca w pewnym konkretnym miejscu tekstu stosujemy tzw. <b>granice</b>
 ("boundary matchers") inaczej zwane kotwicami ("anchors"). W szczególnoœci
mo¿emy ¿yczyæ sobie, by dopasowanie nastêpowa³o na pocz¹tku lub koñcu wiersza,
czy na granicy s³ów. <br>
Symbole s³u¿¹ce oznaczaniu granic s¹ nastêpuj¹ce.<br>
<br>
<table width="405" border="1" cellspacing="2" cellpadding="0" height="229">
<tbody><tr><td colspan="2" height="22"><center> Symbole granic</center></td></tr><tr><td width="11%" height="23">
     ^</td><td width="89%" height="23">
     Pocz¹tek linii</td></tr><tr><td width="11%" height="23">
     $</td><td width="89%" height="23">
     Koniec linii</td></tr><tr><td width="11%" height="23">
     \b</td><td width="89%" height="23">
     Na granicy s³owa</td></tr><tr><td width="11%" height="23">
     \B</td><td width="89%" height="23">
     Nie na granicy s³owa</td></tr><tr><td width="11%" height="23">
     \A</td><td width="89%" height="23">
     Pocz¹tek wejœcia</td></tr><tr><td width="11%" height="23">
     \G</td><td width="89%" height="23"> Koniec poprzedniego dopasowania</td></tr><tr><td width="11%" height="23">
     \Z</td><td width="89%" height="23"> Koniec wejœcia (bez terminatora)<br>
</td></tr><tr><td width="11%" height="23">
     \z</td><td width="89%" height="23"> Koniec wejœcia</td></tr></tbody>
</table>
Uwaga: metaznak ^ zyskuje tutaj nowe znaczenie (poprzednio stosowaliœmy go do negacji klas).<br>
<br>Rozwa¿my przyk³ady.<br>
<br>
Pierwszy dotyczy dopasowania linii, które zaczynaj¹ siê od jednej lub wiêcej cyfr.<br>
<br>
<div class="listing100"><br>
Wzorzec: "^\d+.*"<br>
Tekst: "123"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "123" od pozycji 0 do pozycji 3.<br>
<br>
Wzorzec: "^\d+.*"<br>
Tekst: "ala 123"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Zwrócmy uwagê na ró¿nicê: wzorzec "\d+.*" (czyli bez zaznaczenia, ¿e cyfry
maj¹ wyst¹piæ na pocz¹tku linii) pozwoli metodzie find() na dopasowanie czêœci
napisu "ala 123":<br>
<div class="listing100"><br>
Wzorzec: "\d+.*"<br>
Tekst: "ala 123"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "123" od pozycji 4 do pozycji 7.<br>
</div><br>
<br>
<br>
Mo¿emy te¿ sprawdziæ, czy linia zawiera na samym koñcu liczbê ca³kowit¹ (i wyodrêbniæ j¹ w grupie). <br>
<div class="listing100"><br>
Wzorzec: ".+?(\d+)$"<br>
<br>
Tekst: "a 123"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "a 123" od pozycji 0 do pozycji 5.<br>
Wartoœæ grupy w nawiasach: "123"<br>
<br>
Tekst: "a 123 a"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
<br>
Zauwa¿my, ¿e gdyby zrezygnowaæ z zaznaczenia koñca wiersza symbolem $, w
ostatnim przyk³adzie "a 123 a" metoda find() znalaz³a by dopasowanie:<br>
<br>
<div class="listing100"><br>
 Wzorzec: ".+?(\d+)"<br>
Tekst: "a 123 a"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "a 123" od pozycji 0 do pozycji 5.<br>
</div><br>
<br>
Normalnie, symbole ^ i $ ignoruj¹ znaki koñca wiersza i dopasowuj¹ pocz¹tek
i koniec ca³ej sekwencji wejœciowej (linia = String poddany analizie sk³adniowej
za pomoca wyra¿enia regularnego).  Zatem, poprzednie przyk³adowe wzorce nie
pozwol¹ metodzie find() znaleŸæ dopasowañ w wiêcej ni¿ w jednym wierszu. Mo¿na
to zmieniæ, stosuj¹c flagi - o czym dalej.<br>
 <br>
Spróbujmy teraz wyodrêbniaæ s³owa. Je¿eli zapiszemy wzorzec "sto", to odnalezione
zostan¹ wyst¹pienia tego ci¹gu znaków, niezale¿nie od tego, czy jest on s³owem,
czy te¿ stanowi czêœæ jakiegoœ s³owa. <br>
<br>
<div class="listing100"><br>
Wzorzec: "sto"<br>
Tekst: "sto podsto³ecznych autobusów stoi na postoju numer sto"<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 7 do pozycji 10.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 29 do pozycji 32.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 39 do pozycji 42.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 51 do pozycji 54.<br>
</div><br>
<br>
Jeœli chcemy znaleŸæ tylko ca³e s³owa "sto" zastosujemy symbole \b.<br>
<br>
<div class="listing100"><br>
Wzorzec: "\bsto\b"<br>
Tekst: "sto podsto³ecznych autobusów stoi na postoju numer sto"<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 51 do pozycji 54.<br>
</div><br>
<br>
Gdy chcemy znaleŸæ ci¹g "sto", rozpoczynaj¹cy s³owo (przy czym mog¹cy byæ, ale niekoniecznie bêd¹cy s³owem) napiszemy:<br>
<div class="listing100"><br>
Wzorzec: "\bsto"<br>
Tekst: "sto podsto³ecznych autobusów stoi na postoju numer sto"<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 29 do pozycji 32.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 51 do pozycji 54.<br>
</div><br>
<br>
Z kolei, jeœli chcemy znaleŸæ "sto" jako pocz¹tki s³ów (ale nie s³owa) mo¿emy napisaæ:<br>
<div class="listing100"><br>
Wzorzec: "\bsto\B"<br>
Tekst: "sto podsto³ecznych autobusów stoi na postoju numer sto"<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 29 do pozycji 32.<br>
</div><br>
<br>
I wreszcie, ci¹g "sto" w œrodku s³ów:<br>
<div class="listing100"><br>
Wzorzec: "\Bsto\B"<br>
Tekst: "sto podsto³ecznych autobusów stoi pusto na postoju numer sto"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 7 do pozycji 10.<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 45 do pozycji 48.<br>
</div><br>
<br>
i na koñcu s³ów (ale nie bêd¹cy s³owem):<br>
<br>
<div class="listing100"><br>
Wzorzec: "\Bsto\b"<br>
Tekst: "sto podsto³ecznych autobusów stoi pusto na postoju numer sto"<br>
find(): Dopasowano pod³añcuch "sto" od pozycji 36 do pozycji 39.<br>
</div><br>
<br>
<br>
Zastosowanie symbolu \G ("koniec ostatniego dopasowania") ilustruj¹ przyk³ady:<br>
<div class="listing100"><br>
Wzorzec: "ala"<br>
Tekst: "ala ala ala"<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 4 do pozycji 7.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 8 do pozycji 11.<br>
<br>
Wzorzec: "\Gala"<br>
Tekst: "ala ala ala"<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
<br>
Wzorzec: "\Gala"<br>
Tekst: "alaalaala"<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 3 do pozycji 6.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 6 do pozycji 9.<br>
</div><br>
<br>
<br>
Pierwszy przypadek jest naturalny: znajdowane jest ka¿de wyst¹pienie ci¹gu "ala".<br>
W przypadku drugim, ¿¹damy by kolejne wyst¹pienie zaczyna³o siê na koñcu
poprzedniego dopasowania. Dla tekstu "ala ala ala", find() nie dopasowuje
koejnych wyrazów, bowiem, nie zaczynaj¹ siê one na koñcu poprzedniego dopasowania
(spacja nie pasuje do wzorca). Trzeci przypadek - z usuniêtymi spacjami -
daje dopasowania "na koñcach popzrednich dopasowañ", zatem znowu odnajdywane
s¹ trzy wyst¹pienia ci¹gu "ala".<br>
<br>
<br>
<a name="W2.6"></a><h2>2.6. Flagi</h2>

Sposób interpretacji wyra¿enia regularnego mo¿na modyfikowaæ za pomoc¹ tzw. flag. Flagi podajemy:  <br>
<ul>
  <li>albo przy kompilacji wyra¿enia - jako drugi argument metody <b>compile(...)</b> z klasy <b>Pattern</b>,</li>
  <li>albo bezpoœrednio w wyra¿eniu regularnym stosuj¹c odpowiednie symbole.</li>
</ul>
Mamy do dyspozycji nastêpujace flagi.<br>
<br>
<table width="100%" border="1" cellspacing="2" cellpadding="0">
<tbody><tr><td width="30%">
      <div align="Center"> <b>Sta³a statyczna klasy<br>
      </b><b>Pattern<br>
      </b></div>
</td><td width="30%">
      <div align="Center"><b>Odpowiednik<br>
w wyra¿eniu regularnym<br>
      </b></div>
</td><td valign="Top" width="40%">
      <div align="Center"><b>Znaczenie <br>
      </b></div>
      </td>
</tr><tr><td width="30%">
     Pattern.CANON_EQ</td><td width="30%">
      <div align="Center">
     brak</div>
</td><td valign="Top" width="40%">Pozwala  na  pe³ne , kanoniczne porównywanie znaków i kodów znaków   (zmniejsza efektywnoœæ)<br>
      </td>
</tr><tr><td width="30%">
     Pattern.CASE_INSENSITIVE</td><td width="30%">
      <div align="Center">
     (?i)</div>
</td><td valign="Top" width="40%">Porównania liter bez uwzglêdnienia ich wielkoœci<br>
      </td>
</tr><tr><td width="30%">
     Pattern.COMMENTS</td><td width="30%">
      <div align="Center">
     (?x)</div>
</td><td valign="Top" width="40%">Pozwala na wstawianie komentarzy w wyra¿eniu<br>
      </td>
</tr><tr><td width="30%">
     Pattern.MULTILINE </td><td width="30%">
      <div align="Center">
     (?m)</div>
</td><td valign="Top" width="40%">Pozwala na dopasowanie ^ i $ na pocz¹tku i na koñcu wierszy (separowanych znakiem koñca wiersza) <br>
      </td>
</tr><tr><td width="30%">
     Pattern.DOTALL</td><td width="30%">
      <div align="Center">
     (?s)</div>
</td><td valign="Top" width="40%">Pozwala na dopasowanie metaznaku . (kropka) równie¿ do znaku koñca wiersza.<br>
      </td>
</tr><tr><td width="30%">
     Pattern.UNICODE_CASE</td><td width="30%">
      <div align="Center">
     (?u)</div>
</td><td valign="Top" width="40%">Przy ignorowaniu wielkoœci liter w porównaniach uwzglêdnia znaki Unicode<br>
      </td>
</tr><tr><td width="30%">
     Pattern.UNIX_LINES</td><td width="30%">
      <div align="Center">
     (?d)</div>
</td><td valign="Top" width="40%">Uniksowe separatory wierszy.<br>
      </td>
</tr></tbody>
</table>
<br>
Domyœlnie dzia³aj¹ce opcje (bez u¿ycia flag) s¹ przeciwstawne znaczeniom
podanym w tabeli (np. kropka nie dopasowuje znaków koñca wiersza, porównania
uwzglêdniaj¹ wielkoœæ liter itp.).<br>
<br>
Przy kompilacji wyra¿enia podajemy flagi jako bitow¹ sumê sta³ych o wy¿ej wymienionych nazwach np.<br>
<blockquote><pre>
String regex = "....";
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL;
Pattern pattern = Pattern.compile(regex, flags);
</pre></blockquote>
Dzia³aj¹ one wtedy dla ca³ego wyra¿enia.<br>
  <br>
Alternatywnie, mo¿emy podaæ flagi bezpoœrednio w wyra¿eniu regularnym - wtedy
(w przeciwieñstwie do Perla) bêd¹ one dzia³aæ od momentu wyst¹pienia w wyra¿eniu
regularnym.<br>
  <br>
Przyk³ad. <br>
Wyszukiwanie s³owa "Ala" (z uwzglêdnieniem wielkoœci liter),  po którym wystepuje
napis "ma kota", który mo¿e byæ pisany literami ma³ymi, du¿ymi, lub mieszanymi.<br>
  <br>
<div class="listing100"><br>
  <br>
Wzorzec: "Ala (?i)ma kota"<br>
  <br>
Tekst: "Ala ma kota"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Ala ma kota" od pozycji 0 do pozycji 11.<br>
  <br>
Tekst: "Ala MA KOTA"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Ala MA KOTA" od pozycji 0 do pozycji 11.<br>
  <br>
Tekst: "ALA MA KOTA"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
  <br>
Pamiêtajmy o tym, ¿e jeœli obojêtnoœæ na wielkoœæ liter chcemy rozci¹gn¹æ
na inne ni¿ angielski jêzyki, oprócz flagi CASE_INSENSITIVE (?i) musimy podaæ
flagê UNICODE_CASE (?u), co obrazuje poni¿szy przyk³ad.<br>
  <br>
<div class="listing100"><br>
Wzorzec: "Ala (?i)ma kota p¹czka"<br>
Tekst: "Ala ma kota P¹czka"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Ala ma kota P¹czka" od pozycji 0 do pozycji 18.<br>
  <br>
Wzorzec: "Ala (?i)ma kota p¹czka"<br>
Tekst: "Ala ma kota P¥CZKA"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Nie znaleziono ¿adnego pod³añcucha pasuj¹cego do wzorca<br>
  <br>
Wzorzec: "Ala (?i)(?u)ma kota p¹czka"<br>
Tekst: "Ala ma kota P¥CZKA"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "Ala ma kota P¥CZKA" od pozycji 0 do pozycji 18.<br>
</div><br>
  <br>
W pierwszym przypadku nie by³o k³opotu z sam¹ flag¹ (?i), bo zmieniliœmy
wielkoœæ litery 'p' (nale¿¹cej do alfabetu angielskiego). Gdy jednak - w
drugim przypadku - podaliœmy du¿e ¥, matcher nie znalaz³ dopasowania. Dopiero
dodatkowa specyfikacja flagi (?u) da³a prawid³owy wynik.<br>
  <br>
Przy przetwarzaniu tekstów, sk³adaj¹cyh siê z wielu wierszy istotne jest
czy metaznak . (kropka) bêdzie dopasowywa³ znaki koñca wiersza czy te¿ nie.
Domyœlny brak dopasowania mo¿na zmieniæ u¿ywaj¹c flagi DOTALL lub (?s) w
wyra¿eniu regularnym. <br>
  <br>
Poni¿szy przyk³ad pokazuje jak ró¿nie dzia³a matcher przy fladze DOTALL wy³¹czonej
(pierwszy przypadek) i w³¹czonej (drugi). Tekst zawiera trzy wiersze z cyframi
1,2, 3 na pocz¹tku ka¿dego z nich odpowiednio.<br>
<div class="listing100"><br>
Wzorzec: "\d.*"<br>
Tekst: "1 aaaa<br>
2 aaaa<br>
3 aaaa"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "1 aaaa" od pozycji 0 do pozycji 6.<br>
find(): Dopasowano pod³añcuch "2 aaaa" od pozycji 7 do pozycji 13.<br>
find(): Dopasowano pod³añcuch "3 aaaa" od pozycji 14 do pozycji 20.<br>
  <br>
Wzorzec: "(?s)\d.*"<br>
Tekst: "1 aaaa<br>
2 aaaa<br>
3 aaaa"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "1 aaaa<br>
2 aaaa<br>
3 aaaa" od pozycji 0 do pozycji 20.<br>
</div><br>
  <br>
Równie¿ znaki pocz¹tku (^) i koñca ($) wiersza domyœlnie nie uwzglêdniaj¹
rozbicia tekstu na wiersze znakami koñca wiersza (praktycznie oznaczaj¹ pocz¹tek
i koniec tekstu).<br> Ilustruj¹ to poni¿sze przyk³ady tekstu sk³adaj¹cego
siê z dwóch wierszy i stosuj¹cych wzorce najpiewr dopasowania "na pocz¹tku"
(^), a póŸniej "na koñcu" ($)<br>
  <br>
<div class="listing100"><br>
Wzorzec: "^\d+ a+"<br>
Tekst: "123 aaa<br>
456 aaaaa"<br>
find(): Dopasowano pod³añcuch "123 aaa" od pozycji 0 do pozycji 7.<br>
  <br>
Wzorzec: "\d+ a+$"<br>
Tekst: "123 aaa<br>
456 aaaaa"<br>
find(): Dopasowano pod³añcuch "456 aaaaa" od pozycji 8 do pozycji 17.<br>
</div><br>
  <br>
Dopiero w³¹czenie flagi MULTILINE czyli (?m) w wyra¿eniu regularnym zmienia tê sytuacjê:<br>
  <br>
<div class="listing100"><br>
Wzorzec: "(?m)^\d+ a+"<br>

Tekst: "123 aaa<br>

456 aaaaa"<br>
find(): Dopasowano pod³añcuch "123 aaa" od pozycji 0 do pozycji 7.<br>

find(): Dopasowano pod³añcuch "456 aaaaa" od pozycji 8 do pozycji 17.<br>
  <br>
Wzorzec: "(?m)\d+ a+$"<br>
Tekst: "123 aaa<br>
456 aaaaa"<br>
find(): Dopasowano pod³añcuch "123 aaa" od pozycji 0 do pozycji 7.<br>
find(): Dopasowano pod³añcuch "456 aaaaa" od pozycji 8 do pozycji 17.<br>
</div><br>
  <br>
  <br>
  <br>
  <a name="W2.7"></a><h2>
2.7. Grupy i odniesienia zwrotne</h2>
Jak ju¿ wiemy, u¿ycie nawiasów okr¹g³ych '('  i  ')'  pozwala zapamiêtywaæ
czêœci tekstu pasuj¹ce do wzorca podanego w nawiasach. Do takich <b>grup</b> mo¿emy siê nastêpnie odwo³ywac z poziomu jêzyka oraz w samym wyra¿eniu regularnym.<br>
  <br>
Grupy, które wprowadziliœmy w wyra¿eniu regularnym nawiasami (), s¹ kolejno
numerowane poczynaj¹c od 1. Mówi¹c œciœlej s¹ numerowane poprzez zliczanie
otwartych i zamkniêtych nawiasów (bowiem grupy mog¹ byæ zagnie¿d¿one).<br>
  <br>
Np. w wyra¿eniu (A) (B) (C) mamy trzy grupy o numerach:<br>
1 - grupa odpowiadaj¹ca wyra¿eniu A<br>
2 - grupa odpowiadaj¹ca wyra¿eniu B<br>
3 - grupa odpowiadaj¹ca wyra¿eniu C<br>
  <br>
a w wyra¿eniu ((A)((B)(C)))(D) mamy 6 grup o numerach<br>
1 - grupa odpowiadaj¹ca wyra¿eniu (A)((B)(C)<br>
2 - grupa odpowiadaj¹ca wyra¿eniu A<br>
3 - grupa odpowiadaj¹ca wyra¿eniu  (B)(C)<br>
4 - grupa odpowiadaj¹ca wyra¿eniu  B<br>
5 - grupa odpowiadaj¹ca wyra¿eniu C<br>
6 - grupa odpowiadaj¹ca wyra¿eniu  D<br>
  <br>
Liczbê grup mo¿emy uzyskaæ u¿ywaj¹c metody groupCount() wobec matchera (obiektu
klasy Matcher). Zawartoœæ ka¿dej z grup (tekst pasuj¹cy do wyra¿enia podanego
w jej nawiasach) - uzyskujemy za pomoc¹ odwo³ania group(numer_grupy).<br>
Tekst pasuj¹cy do ca³ego wyra¿enia dostêpny jest poprzez odwo³anie group() lub group(0).<br>
  <br>
  <b>Uwaga: maksymalnie dopuszczalna liczba grup wynosi 9.</b><br>
  <br>
Rozwa¿my przyk³ad. Z wprowadzanych (np. w dialogach wejœciowych) wierszy
tekstu, które zawieraj¹ na pocz¹tku jeden lub wiêcej znaków s³owa (w alfabecie
angielskim), nastêpnie 1 lub wiêcej "bia³ych znaków", po czym dowoln¹ liczbê
ca³kowit¹, chcemy wyodrêbniæ pocz¹tkowe s³owo i podan¹ liczbê. <br>
W tym celu zbudujemy wyra¿enie regularne, które grupuje znaki s³owa i cyfry:<br>
  <pre>
(\w+)\s+(\d+)
</pre>
W programie, który ma znajdowaæ dopasowania poka¿emy (tradycyjnie ju¿) dzia³anie
metod matches() oraz find(), a tak¿e sposób odwo³añ do zawartoœci grup i
raportowanie pozycji tekstu  na których wyst¹pi³o dopasowanie<br>
Zwróæmy uwagê: pozycje dopasowañ oraz zawartoœæ grup s¹ stanami matchera,
niezale¿nymi od tego czy u¿ywamy metody matches() czy find(), zatem uzyskiwanie
informacji o grupach i pozycjach dopasowania wyodrêbnimy w metodzie report(...),
która jest wo³ana zarówno po matches() jak i find().<br>
I istotna uwaga: przy braku dopasowania (albo gdy jeszcze nie próbowano dopasowywaæ
tekstu) odwo³ania do metod matchera, zwracaj¹cych jego stany (pozycje, grupy)
powoduj¹ powstanie wyj¹tku IllegalStateException. Wyj¹tek ten bêdziemy obs³ugiwaæ,
wyprowadzaj¹c komunikat o b³êdzie.<br>
  <pre>
import java.util.regex.*;
import javax.swing.*;

public class Grupy {

  public static void main(String[] args) {

    // Kompilacja wzorca
    // uwaga: odwrotne ukoœniki w tekœcie programu duplikujemy

    Pattern pattern = Pattern.compile("(\\w+)\\s+(\\d+)");

    String txt;  // przeszukiwany (dopasowywany) tekst
                 // pobierany w dialogach wejœciowych, w pêtli

    while((txt = JOptionPane.showInputDialog("Tekst")) != null) {

      Matcher matcher = pattern.matcher(txt); // uzyskanie matchera

      // Próba dopasowania ca³ego tekstu i pokazanie wyniku
      boolean res = matcher.matches();
      report(txt, "matches()", res, matcher);

      // odtworzenie pierwotnego stanu matchera (po matches)
      matcher.reset();

      // Sekwencyjne wyszukiwanie za pomoc¹ metody find
      while ((res = matcher.find()) != false) {
        report(txt, "find()", res, matcher);
      }
    }
    System.exit(0);
  }

  static void report(String txt, String who, boolean result, Matcher matcher) {

     System.out.println("Tekst: \"" + txt + "\"");

     int lgrup = matcher.groupCount(); // liczba grup
     System.out.println("Liczba grup w wyra¿eniu: " + lgrup);

     System.out.println(who + ": znalaz³ dopasowanie ? - " + result);

     try {

       // Ca³y dopasowany/wyszukany fragment
       String whatMatches = "\"" + matcher.group() + "\"";

       // Pozycja tekstu na której zaczyna siê dopasowanie
       int pos = matcher.start();
       System.out.println("Dopasowano co: " + whatMatches);
       System.out.println("Na pozycji   : " + pos);

       // Wyprowadzamy zwartoœæ wszystkich grup
       for (int i=1; i&lt;=lgrup; i++) {
         System.out.println("Grupa " + i + ": \"" + matcher.group(i) + "\"");
       }

     } catch (IllegalStateException exc) {  // wyj¹tek - gdy brak dopasowania
         System.out.println(exc.getMessage());
         return;
     }
  }

}
</pre>
Program po wprowadzeniu w dialogach dwóch tekstów:<br>
Java 1234<br>
Bali 3456 Kawa 245<br>
  <br>
wyprowadzi nastêpuj¹ce wyniki:<br>
<div class="listing100"><br>
Tekst: "Java 1234"<br>
Liczba grup w wyra¿eniu: 2<br>
matches(): znalaz³ dopasowanie ? - true<br>
Dopasowano co: "Java 1234"<br>
Na pozycji   : 0<br>
Grupa 1: "Java"<br>
Grupa 2: "1234"<br>
Tekst: "Java 1234"<br>
Liczba grup w wyra¿eniu: 2<br>
find(): znalaz³ dopasowanie ? - true<br>
Dopasowano co: "Java 1234"<br>
Na pozycji   : 0<br>
Grupa 1: "Java"<br>
Grupa 2: "1234"<br>
Tekst: "Bali 3456 Kawa 245"<br>
Liczba grup w wyra¿eniu: 2<br>
matches(): znalaz³ dopasowanie ? - false<br>
No match found<br>
Tekst: "Bali 3456 Kawa 245"<br>
Liczba grup w wyra¿eniu: 2<br>
find(): znalaz³ dopasowanie ? - true<br>
Dopasowano co: "Bali 3456"<br>
Na pozycji   : 0<br>
Grupa 1: "Bali"<br>
Grupa 2: "3456"<br>
Tekst: "Bali 3456 Kawa 245"<br>
Liczba grup w wyra¿eniu: 2<br>
find(): znalaz³ dopasowanie ? - true<br>
Dopasowano co: "Kawa 245"<br>
Na pozycji   : 10<br>
Grupa 1: "Kawa"<br>
Grupa 2: "245"<br>
</div><br>
  <br>
I znowu widzimy, ¿e find() dzia³a sekwencyjnie, przeszukuj¹c tekst wedle
wzorca, dziêki czemu w tekœcie "Bali 3456 Kawa 245" znaleziono dwa dopasawania
(i wyró¿niono po dwa s³owa i liczby), gdy matches() stwierdzi³ brak dopasowania
ca³ego tekstu do wzorca.<br>
  <br>
Odniesienie do zawartoœci grup mog¹ wyst¹piæ w samym wyra¿eniu regularnym.
Wprowadzamy je za pomoca odwrotnego ukoœnika z nastêpuj¹cym numerem grupy (od 1 do 9).
Taka konstrukcja oznacza, ¿e w tym miejscu wzorca powinien wyst¹piæ dok³adnie
taki sam ci¹g znaków, jaki zosta³ zapamiêtany w grupie o podanym numerze. Nazywa siê to <b>odniesieniem zwrotnym</b> (backreference).<br>
  <br>
Korzystaj¹c z tego mo¿emy np. zidentyfikowaæ wszystkie podwójne, takie same
po sobie nastêpuj¹ce s³owa (zapewne b³êdy) w tekœcie.<br>
Pos³u¿ymy siê w tym celu wzorcem:<br>
  <pre>
(\b\p{L}+)[\s\p{Punct}]+\1
</pre>
 który oznacza ci¹g dowolnych liter Unicode rozpoczynaj¹cy siê na granicy
s³owa (s³owo), jedn¹ lub wiêcej spacji lub znaków punktuacji, a nastêpnie
powtórzenie tego samego s³owa. Zuwa¿my: ci¹g liter od pocz¹tku s³owa \b\p{L}+
ujêliœmy w nawiasy okr¹g³e, tworz¹c grupê. Jest to grupa o numerze 1. W naszym
wzorcu mo¿emy siê odwo³aæ do jej zawartoœci poprzez \1 i dziêki temu wykryæ
powtórzenia s³ów.<br>
  <br>
Wykorzystajmy ten wzorzec w przyk³adowym programie, który czyta plik tekstowy
i raportuje powtarzaj¹ce siê s³owa oraz numery wierszy, w których wystêpuj¹.
Dodatkow skompilujemy wzorzec z flag¹ CASE_INSENSITIVE, by zapewniæ wykrywanie
duplikatów niezaleznie od wielkoœci liter.<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class DupWords {

  public static void main(String[] args) {

    Pattern pattern = Pattern.compile("(\\b\\p{L}+)[\\s\\p{Punct}]+\\1",
                                       Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher("");

    try {
      LineNumberReader lr = new LineNumberReader(
                                 new FileReader(args[0])
                              );
      String line;
      while ((line = lr.readLine()) != null) {
        int  lineNr = lr.getLineNumber();

        matcher.reset(line);  // matcher nastawiamy na nowy tekst

        while (matcher.find()) {
          System.out.println("Powtórzenie s³owa " + matcher.group(1) +
                             " w wierszu " + lineNr);
        }

      }
      lr.close();
    } catch(IOException exc) {
        System.out.println(exc);
        System.exit(1);
    }
  }

}
</pre>
W tym programie warto zwróciæ uwagê na wykorzystanie metody reset(...) matchera,
ustawiaj¹cego nowy tekst do przeszukiwania (podany jako argument). W ten
sposób unikamy tworzenia obiektów klasy Matcher przy ka¿dej przeczytanej
linii pliku: jeden obiekt-matcher, utworzony najpierw jako skojarzony z pustym
tekstem jest ponownie wykorzystywany dla kolejnych wierszy.<br>
  <br>
Przetwarzanie przyk³adowego pliku:<br>
<div class="listing100">Pocz¹tek pocz¹tek tekstu jest nie nie zbyt ciekawy. <br>
Potem nie jest jest lepiej.<br>
I i co co? Takie takie s³owa.<br>
Na przyk³ad, ala ala, Czy te¿ te¿ ala ala, ala, ala.<br>
I bez powtórzeñ.<br>
I z z powtórzeniami.<br>
Niestety to te¿ bêdzie powtórzenie: jejku, jejku!<br>
I takie te¿: Co? Co?! <br>
A na razie na granicy wierszy<br>
wierszy nie wykrywamy!</div><br>
  <br>
da w wyniku:<br>
<div class="listing100"><br>
Powtórzenie s³owa Pocz¹tek w wierszu 1<br>
Powtórzenie s³owa nie w wierszu 1<br>
Powtórzenie s³owa jest w wierszu 2<br>
Powtórzenie s³owa I w wierszu 3<br>
Powtórzenie s³owa co w wierszu 3<br>
Powtórzenie s³owa Takie w wierszu 3<br>
Powtórzenie s³owa ala w wierszu 4<br>
Powtórzenie s³owa te¿ w wierszu 4<br>
Powtórzenie s³owa ala w wierszu 4<br>
Powtórzenie s³owa ala w wierszu 4<br>
Powtórzenie s³owa z w wierszu 6<br>
Powtórzenie s³owa jejku w wierszu 7<br>
Powtórzenie s³owa Co w wierszu 8<br>
</div><br>
  <br>
Oczywiœcie,  program nie jest bardzo uniwersalny. Nie wykrywamy powtórzeñ
na granicach wierszy (³atwo to zrobiæ bez raportowania numerów wierszy, trudniej
gdy chcemy te numery w³aœciwie podawaæ). Równie¿, przyjêty "algorytm" decydowania
co jest a co nie jest powtórzeniem s³owa jest raczej bardzo ad hoc i w praktycznych
zastosowaniach wymaga³by gruntownego przemyœlenia. Jednak ten program, jak
równie¿ poprzedni przyk³adowy kod przybli¿aj¹ nas mocno do zagadnieñ zwi¹zanychy
 z zastosowaniem róznych metod klas Pattern i Matcher do wyszukiwania i dopasowywania
tekstów. <br>
Zanim jednak zajmiemy siê tym w sposób nieco bardziej usystematyzowany - ostatnia wa¿na uwaga, dotycz¹ca grup.<br>
  <br>
Otó¿, jak pamiêtamy, nawiasy okr¹g³e s³u¿¹ nie tylko grupowaniu w celu zapamiêtywania
zawartoœci grup, ale równie¿ po to by w³aœciwie ustalaæ sposób interpretacji
wyra¿enia (np. powtórzenia jakiegoœ wzorca albo zmianê kolejnoœci opracowania
wyra¿enia gdy stosujemy operator alternatywy). By³oby wielce niewygodne,
gdyby wszystkie takie zastosowania wi¹za³y siê z zapamiêtywaniem grup - musielibyœmy
wtedy bacznie œledziæ numery tych grup, których zawartoœæ nas interesuje,
a by³yby one zapewne nieci¹g³e.<br>
Dlatego mamy równie¿ do dyspozycji tzw. <b>grupy niezapamiêtywane</b> (non-capturing groups). Wprowadzamy je za pomoc¹ konstrukcji:<br>
  <br>
    <b>(?:<i>wyra¿enie</i>)</b><br>
  <br>
Takie grupy nie s¹ zapamiêtywane i nie s¹ numerowane. Mo¿emy wiêc oddzieliæ
to co chcemy zapamiêtaæ, od tego co chcemy tylko odpowiednio porz¹dkowac.<br>
Np. jeœli chcemy z tekstów w postaci:<br>
  <ul>
    <li>jedno lub wiêcej wyst¹pieñ tekstów Ax, Bx lub Cx,</li>
    <li>po którym nastêpuje dowolna liczba ca³kowita,</li>
    <li>po której nastêpuj¹ jedno lub wiêcej wyst¹pieñ litery x poprzedzonej
za ka¿dym razem dowolnym znakiem buia³ym lub nzakiem punktuacji,</li>
    <li>po czym nastêpuje cyfra</li>
  </ul>
wy³uskaæ pierwsz¹ liczbê i ostatni¹ cyfrê, to mo¿emy zbudowac nastêpuj¹ce wyra¿enie:<br>
  <pre>
 (?:[ABC]x)+(\d+)(?:[\s\p{Punct}-]x)+(\d)</pre>
zapewniaj¹c, ¿e interesuj¹ca nas zawartoœæ bêdzie dostêpna w grupach o numerach
1 i 2 (i ¿adna inna grupa nie bêdzie zapamiêtana, choæ musimy zastosowaæ
grupowanie dla dopasowania czêœci tekstu nie bêd¹cych cyframi).<br>
Przyk³adowy wynik dzia³ania tego wyra¿enia:<br>
<div class="listing100"><br>
Wzorzec: "(?:[ABC]x)+(\d+)(?:[\s\p{Punct}-]x)+(\d)"<br>
Tekst: "AxBxAx321-x-x-x:x:x:x7"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "AxBxAx321-x-x-x:x:x:x7" od pozycji 0 do pozycji 22.<br>
Grupy:<br>
1 "321"<br>
2 "7"<br>
</div><br>
  <br>
  <br>
<br>
  <a name="W2.8"></a><h2>
2.8. Dopasowanie i wyszukiwanie.</h2>

Wielokrotnie ju¿ widzieliœmy dzia³anie metod matches() i find() klasy Matcher.
Oprócz tego dostêpna jest metoda find z argumentem typu int, mamy te¿ do dyspozycji
jeszcze jedn¹, dot¹d nie omawian¹ metodê wyszukiwania: lookingAt(). Podsumujmy
ró¿nice pomiêdzy tymi metodami.<br>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%">boolean</td><td>find()<br>
          Przeszukuje ³añcuch wejœciowy poczynaj¹c od pocz¹tku (lub poprzedniego
dopasowania) w poszukiwaniu pod³añcucha pasuj¹cego do wzorca. Jeœli wzorzec
zosta³ dopasowany (wynik true), kolejne wywo³anie tej metody przeszukuje
³añcuch wejœciowy poczynaj¹c od znaku po ostatnim dopasowanym znaku. Jeœli
wzorzec nie zosta³ znaleziony  metoda zwraca wartoœæ false.</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> boolean</td><td>find(int start)<br>
           Resetuje matcher i przeszukuje ³añcuch wejœciowy poczynaj¹c od
podanej pozycji start w poszukiwaniu pod³añcucha pasuj¹cego do wzorca. Zwraca
true przy znalezieniu dopasowania. Kolejne find() bêdzie szukaæ pod³añcucha
poczynaj¹c od znaku po ostatnio dopasowanym znaku, a find(int start) - od
podanej pozycji. </td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> boolean</td><td>matches()<br>
           Sprawdza dopasowanie ca³ego ³añcucha wejœciowego do wzorca. Zwraca
true, jeœli takie dopasowanie wystêpuje i false w przeciwnym razie.</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> boolean</td><td>lookingAt()<br>
           Próbuje zmaleŸæ dopasowanie do wzorca dowolnego pdo³añcucha zaczynaj¹cego
siê od pocz¹tku ³añcucha wejœciowego. Zwraca true, jeœli takie dopasowanie
wystêpuje i false w przeciwnym razie. W przeciwieñstwie do metody matches()
mo¿e byæ dopasowana tylko czêœæ ³añcucha wejœciowego.</td></tr></tbody>
  </table>
  <br>
  <br>
Poni¿szy przyk³ad pokazuje ró¿nice pomiêdzy metodami matches(), lookingAt() i find().<br>
<div class="listing100"><br>
Wzorzec: "ala"<br>
Tekst: "ala"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
lookingAt(): Dopasowano pod³añcuch "ala" Od pocz¹tku do pozycji: 3.<br>
  <br>
Wzorzec: "ala"<br>
Tekst: "ala ala"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 0 do pozycji 3.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 4 do pozycji 7.<br>
lookingAt(): Dopasowano pod³añcuch "ala" Od pocz¹tku do pozycji: 3.<br>
  <br>
Wzorzec: "ala"<br>
Tekst: "bela ala ala"<br>
matches(): Ca³y tekst NIE pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 5 do pozycji 8.<br>
find(): Dopasowano pod³añcuch "ala" od pozycji 9 do pozycji 12.<br>
lookingAt(): Nie znaleziono pocz¹tkowego pod³añcucha pasuj¹cego do wzorca<br>
</div><br>
  <br>
W pierwszym przypadku (tekst "ala") ca³y tekst pasuje do wzorca i nie wystêpuj¹
¿adne ró¿nice w dzia³aniu metod. W drugim przypadku tekst "ala ala" nie pasuje
(w ca³oœci) do wzorca, ale metoda find(), sekwencyjnie przeszukuj¹c ³añcuch
wejœciowy, wyró¿nia w nim dwa pasuj¹ce pod³añcuchy, natomiast metoda lookingAt()
znajduje pasuj¹cy pod³añcuch pocz¹tkowy.<br>
W trzecim przypadku  (tekst "bela ala ala") tylko metoda find() znajdzie
dopasowania (kolejne pasuj¹ce pod³añcuchy). Metoda lookingAt() zawsze zaczyna
od pocz¹tku i nie znajduje - na pocz¹tku tekstu - pasuj¹cego pod³añcucha.<br>
  <br>
Zwróæmy jednak uwagê, ¿e jeœli wyra¿enie regularne koñczone jest kwantyfikatorem,
który nie ogranicza (z góry) liczby wyst¹pieñ znaków, to dzia³anie metod
find(...), matches() i lookingAt() jest identyczne.<br>
Np.<br>
<div class="listing100"><br>
Wzorzec: ".*\d+"<br>
Tekst: "    123"<br>
matches(): Ca³y tekst pasuje do wzorca.<br>
find(): Dopasowano pod³añcuch "    123" od pozycji 0 do pozycji 7.<br>
lookingAt(): Dopasowano pod³añcuch "    123" Od pocz¹tku do pozycji: 7.<br>
</div><br>
  <br>
Ka¿de wywo³anie metod matches(), find() i lookingAt() ustala nowy stan obiektu-matchera.<br>
Stan ten opisywany jest przez nastêpuj¹ce charakterystyki, które - jeœli
tylko dopasowanie zakoñczy³o siê sukcesem - mo¿emy odczytaæ za pomoc¹ podanych
ni¿ej metod.<br>
  <br>
  <table cellpadding="2" cellspacing="2" border="1" width="100%">
    <tbody>
      <tr>
        <td valign="Top">
        <div align="Center"><b>Charakterystyka stanu matchera</b><br>
        </div>
        </td>
        <td valign="Top">
        <div align="Center"><b>Metoda odczytu</b><br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="Top">Pocz¹tek dopasowania (pozycja, indeks)<br>
        </td>
        <td valign="Top"><b>int start()</b><br>
Uwaga: dla matches() i lookingAt() zawsze 0<br>
        </td>
      </tr>
      <tr>
        <td valign="Top">Koniec dopasowania<br>
Uwaga: jest to pozycja pierwszego znaku po dopasowanym tekœcie<br>
        </td>
        <td valign="Top"><b>int end()</b><br>
        </td>
      </tr>
      <tr>
        <td valign="Top">Dopasowany ³añcuch/pod³añcuch<br>
        </td>
        <td valign="Top"><b>String group()</b> lub <br>
        <b>String group(0)</b><br>
        </td>
      </tr>
      <tr>
        <td valign="Top">Zawartoœæ n-ej grupy. <br>
Uwaga: mo¿e siê zdarzyæ przy dopasowaniu, ¿e specyfikacja<br>
 grupy nie pasuje - wtedy group(n) zwraca null. Niektóre konstrukcje sk³adniowe
dopasowuj¹ puste ³añcuchy - wtedy zwracany jest pusty ³añcuch znakowy.<br>
        </td>
        <td valign="Top"><b>String group(int n)</b><br>
        </td>
      </tr>
      <tr>
        <td valign="Top">Pozycja pocz¹tku n-ej grupy<br>
(Pozycja pierwszego znaku dopasowanej n-ej grupy lub -1, jeœli ca³oœæ pasuje, a grupa nie).<br>
        </td>
        <td valign="Top"><b>int start(int grupa)  </b>   <br>
        </td>
      </tr>
      <tr>
        <td valign="Top">Pozycja koñca n-ej grupy<br>
Uwaga: jest to pozycja ostatniego dopasowanego znaku dla grupy + 1<br>
        </td>
        <td valign="Top"><b>int end(int grupa)</b><br>
        </td>
      </tr>
      <tr>
        <td valign="Top" rowspan="1" colspan="2">Je¿eli brak dopasowania
lub dla danego matchera jeszcze nie podjêto próby dopasowania (nie wywo³ano
¿adnej z metod find(), matches(), lookingAt()), to wywo³anie dowolnej z powy¿szych
metod spowoduje wyj¹tek IllegalStateException.<br>
        <br>
Uwaga: liczba grup w wyra¿eniu, zwracana przez metodê groupCount() jest niezalezna
od wyników dopasowania i tekstu wejœciowego i jest wy³¹cznie charakterystyk¹
samego wyra¿enia regularnego.<br>
        </td>
      </tr>
    </tbody>
  </table>
 <br>
Nale¿y zwróciæ szczególn¹ uwagê na to, ¿e metody end(..) zwracaj¹ indeks
koñca dopasowania, zwiêkszony o 1. D³ugoœæ dopasowanego pod³añcucha jest
zatem naturalnie okreœlana jako end()-start(). Jak ju¿ wspomniano, niektóre
konstrukcje sk³adniowe (np. x* - zero lub wiêcej wyst¹pieñ znaku x) mog¹
dopasowywaæ dowolne teksty np. brak litery x. Mamy wtedy do czynienia z dopasowaniami
zerowej d³ugoœci i indeks pocz¹tku i koñca dopasowania jest taki sam (np.
dla pustego tekstu bêdzie 0 i 0). <br>
  <br>
Pamiêtajmy te¿ o tym, ¿e w przeciwieñstwie do matches(), lookingAt() oraz
find(int) bezargumentowa metoda find() rozpoczyna poszukiwanie, korzystaj¹c
z zastanego stanu matchera. W szczególnoœci, pozycja od której metoda find()
bêdzie szukaæ dopasowania jest równa indeksowi ostatniego dopasowania + 1
(jest to wartoœæ zwracana przez end() dla ostatniego dopasowania). Jest to
oczywiœcie szczególnie wygodne w sekwencyjnym przeszukiwaniu tekstu wejœciowego
za pomoc¹ metody find(), wed³ug nastêpuj¹cego schematu:<br>
  <br>
<div class="syntax"><br>
Schemat odnajdywania wszystkich wyst¹pieñ wzorca regex w tekœcie wejœciowym txt<br>
  <br>
Pattern pattern = Pattern.compile(regex);<br>
Matcher matcher = pattern.matcher(txt);<br>
while (matcher.find()) {<br>
    System.out.println("Znaleziono tekst: " + matcher.group() +<br>
                                " zaczynaj¹cy siê na pozycji " + matcher.start() +<br>
                                " koñcz¹cy siê na pozycji " + (matcher.end() -1) );<br>
}<br>
</div><br>
  <br>
Ale, kiedy - po jakiejœ próbie dopasowania - metodê find() chcemy zastosowaæ
znowu od pocz¹tku tekstu wejœciowego, to nale¿y "zresetowaæ" matcher, tak
by jego poprzedni stan nie mia³ wp³ywu na nowe wyszukiwanie,<br>
S³u¿y temu metoda <b>reset()</b>. Jej wersja z argumentem klasy CharSequence
(który to interfejs - przypomnijmy - jest implementowany w klasach String,
StringBuffer oraz CharBuffer z pakietu NIO) pozwala jednoczeœnie ustaliæ
nowy tekst do przeszukiwania.<br>
  <br>
Rozwa¿my przyk³ad. W pliku tekstowym zapisane s¹ liczby ca³kowite. Niektóre
z nich wystêpuj¹ "samotnie" w wierszach tego pliku (byæ mo¿e okolone spacjami).
Inne mog¹ wystêpowaæ w wierszu  wraz z innymi liczbami lub s³owami. Chcemy
odrêbnie zsumowaæ liczby samotne i "niesamotne" i pokazaæ obie sumy. <br>
Pierwsze przychodz¹ce na myœl wyra¿enie regularne, które mo¿emy tu zastosowaæ
to dowolny ci¹g cyfr z poprzedzaj¹cym i/lub nastêpuj¹cym ci¹giem zera lub
wiêcej "bia³ych znaków". <br>
  <pre>
\s*\d+\s*
</pre>
Oczywiœcie, chcemy wyodrêbniaæ liczby ca³kowite, wobec tego uczynimy z nich grupê.<br>
  <pre>
\s*(\d+)\s*
</pre>
Metoda matches() zastosowana do tego wzorca dopasuje wszystkie samotnie wystêpuje
liczby. Metoda find() bêdzie znajdowac dopasowania sekwencyjnie, zatem -
przy braku dopasowania przez matches() uzyskamy od niej liczby wystêpuj¹ce
w wierszach w ramach tekstu (kilka liczb, liczby z tekstem itp.).<br>
  <br>
W programie zastosujemy te¿ metodê reset(..). Po pierwsze po to, by nie tworzyæ
przy ka¿dym wierszu nowego obiektu-matchera (gdy zajrzymy do Ÿróde³ klas
Pattern i Matcher, oka¿e siê, ¿e ka¿de odwo³anie pattern.matcher() zwraca
nowy obiekt). Po drugie, najpierw bêdziemy sprawdzaæ ca³kowite dopasowanie
wzorca (a wiêc wy³uskiwac samotne liczby), jeœli siê to nie powiedzie - w
wierszu mo¿e byæ wiêcej liczb lub liczba z tekstem -  bêdziemy chcieli u¿yæ
metody find(), a ta korzysta z bie¿¹cego stanu matchera, który mo¿e byæ zaburzony.
U¿yjemy wiêc reset() bez argumentów.<br>
  <br>
Oto program.<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class Sumowanie {

  public static void sumAndReport(String fileName) {

    try {
      BufferedReader in = new BufferedReader(
                           new FileReader(fileName)
                       );

      Pattern pattern = Pattern.compile("\\s*(\\d+)\\s*");


      Matcher matcher = pattern.matcher("");

      int suma1 = 0,   // suma liczb wystêpuj¹cych samotnie w wierszach
          suma2 = 0;   // suma liczb, które nie s¹ w wierszach samotne

      String input;
      while ((input = in.readLine()) != null) {

        matcher.reset(input);          // nowy tekst wejœciowy

        if (matcher.matches())         // czy mamy samotn¹ liczbê?
          suma1 += Integer.parseInt(matcher.group(1));

        else {                         // nie, mo¿e jest kilka, albo w tekœcie?

          matcher.reset();             // konieczne, by ew. poprzedni stan
                                       // nie mia³ wp³ywu na find()
          while (matcher.find())
            suma2 += Integer.parseInt(matcher.group(1));
        }
      }
      in.close();
      System.out.println("Suma samotnych liczb: " + suma1);
      System.out.println("Suma niesamotnych liczb: " + suma2);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

  }

  public static void main(String[] args) {
    sumAndReport(args[0]);
  }

}
</pre>
Przyk³adowe wyniki dzialania programu dla pliku wejœciowego:<br>
1<br>
2 ala 4<br>
   5<br>
10 20 30<br>
  <br>
<div class="listing100"><br>
Suma samotnych liczb: 6<br>
Suma niesamotnych liczb: 66<br>
</div><br>
  <br>
wydaj¹ siê zadowalaj¹ce.<br>
Ale ten wzorzec i ten program pozwalaj¹ na kilka ciekawych obserwacji.<br>
Obie zwi¹zane s¹ z zastosowanymi kwantyfikatorami.<br>
Pierwsza dotyczy efektywnoœci: we wzorcu zastosowaliœmy kwantyfikatory ¿ar³oczne <b>(greedy)</b>
, a jak pamiêtamy powoduj¹ one poch³oniêcie ca³ego wejœcia i dopasowanie
przy cofaniu siê znak po znaku. Przy du¿ych plikach lub du¿ej liczbie przetwarzanych
plików zaczyna to odgrywaæ istotn¹ rolê. Porównajmy czas dzia³ania tego samego
programu dla wiêkszego pliku raz przy zastosowaniu kwantyfikatorów "greedy"
(dotychczasowy wzorzec), a drugi raz przy kwantyfikatorach wstrzemiêŸliwych
(reluctant), wprowadzonych w nowym wzorcu:<br>
 <br>
  <pre>
\s*?(\d+?)\s*?</pre>
  Oto wynik porównania:<br>
<div class="listing100"><br>
Suma samotnych liczb: 6840<br>
Suma niesamotnych liczb: 1713600<br>
Czas greedy: 1430<br>
Suma samotnych liczb: 6840<br>
Suma niesamotnych liczb: 1713600<br>
Czas reluctant: 990<br>
</div><br>
  <br>
Zatem kwantyfikatory "reluctant" dzia³aj¹ w tym przypadku o ok. 40% szybciej
od kwantyfikatorów "greedy". To, oczywiœcie, zale¿y od wzorca i dopasowywanego
tekstu. Czasem "greedy" mog¹ byæ lepszym rozwi¹zaniem, a nawet - w sensie
koncepcyjnym - niezbêdnym. Warto jednak mieæ na uwadzê ró¿nice w dzia³aniu
obu typów kwantyfikatorów (o których zreszt¹ ju¿ by³a mowa w podrozdziale
o kwantyfikatorach i do których jeszcze wrócimy pod sam koniec tego podrozdzia³u).<br>
  <br>
Inny problem zwi¹zany jest z u¿yciem (bardzo wygodnego, ale doœæ niebezpiecznego)
kwantyfikatora, dopuszczaj¹cego brak wyst¹pieñ podawanych znaków (w naszym
przypadku 0 lub wiêcej spacji).<br>
  <br>
O ile w tym przyk³adzie na dzia³anie metody matches() (znajduj¹cej "samotne"
liczby) nie ma to wp³ywu, to metoda find() - jak ju¿ widzieliœmy - z przyjemnoœci¹
dopasuje do wzorca \s* ka¿dy inny znak oprócz spacji. W rezultacie bêdziemy
(jako niesamotne) sumowaæ równie¿ liczby, które s¹ czêœci¹ s³ów np. Nr1 (bez
spacji). Byæ mo¿e wcale tego  nie chcemy i chodzi nam tylko a takie liczby,
które nie s¹ czêœci¹ s³ów w tekœcie.<br>
  <br>
Prosty test poka¿e, ¿e nasz dotychczasowy wzorzec jest w tym przypadku ca³kiem niezadawalaj¹cy.<br>
Dla nastêpuj¹cego pliku wejœciowego:<br>
1<br>
   2   <br>
aa 5 b  5 5 5 c<br>
100b<br>
3<br>
x3000 <br>
y40000y 11<br>
Dostaniemy jako wynik:<br>
<div class="listing100"><br>
Suma samotnych liczb: 6<br>
Suma niesamotnych liczb: 43131<br>
</div><br>
  <br>
co oczywiœcie nie odpowiada naszym wymaganiom (zsumowane zosta³y liczby stanowi¹ce czeœæ s³ów).<br>
  <br>
Niew¹tpliwie, dla kogoœ kto zaczyna przygodê z wyra¿eniami regularnymi dobór
odpowiedniego wzorca nie jest ³atwy. Dla przyk³adu, poka¿ê najpierw niew³aœciwie
rozumowanie (przy okazji ilustruj¹c ciekawy przypadek, gdy wzorzec jest dopasowany,
a nie wszystkie grupy zyska³y zawartoœæ). <br>
Mo¿emy oto rozumowaæ nastêpuj¹co. Powodem naszych k³opotów by³ kwantyfikator
* (0 lub wiêcej wyst¹pieñ, konkretnie spacji). Spróbujmy siê wiêc ograniczyæ
i powiedzieæ, ¿e liczby maj¹ byæ okalane conajmniej przez jeden bia³y znak.
Ale to za ma³o. Mog¹ byæ przecie¿ przypadki, kiedy wiersz zaczyna siê od
liczby, a póŸniej dopiero nastêpuj¹ spacje (i ew. inne liczby w tekœcie),
albo kiedy wiersz koñczy siê liczb¹ (bez koñcowych spacji). Wydaje siê zatem,
¿e musimy przygotowaæ alternatywne przypadki:<br>
  <ul>
    <li>w wierszu jest tylko liczba i nic wiêcej - wzorzec: ^(\d+)$</li>
    <li>wiersz zaczyna siê od liczby, po czym nastêpuje 1 lub wiêcej spacji : ^(\d+)\s+</li>
    <li>wiersz koñczy siê liczb¹, poprzedzon¹ jedn¹ lub wiêcej spacjami:  \s+(\d+)$ </li>
    <li>w wierszu wystêpuj¹ liczby (lub liczba) okolona jedn¹ lub wiêcej spacjami: \s+(\d+)\s+</li>
  </ul>
Alternatywy musimy grupowaæ, ale poniewa¿ nie chcemy ich zapamiêtywaæ jako
grupy zastosujemy grupy niezpamiêtywane. Zapamiêtywac bêdziemy jednak grupy
okreœlaj¹ce liczby (wyst¹pienia cyfr). Dochodzimy wiêc do nastêpuj¹cego wzorca,
który wstawimy do poprzedniego programu (w metodzie kompilacji).<br>
  <br>
  <pre>
(?:^(\d+)\s+)|(?:^(\d+)$)|(?:\s+(\d+)$)|(?:\s+(\d+)\s+)
</pre>
W tym wzorcu mamy cztery grupy zapamiêtywane (okreœlane przez alternatywne
dopasowania liczb). Oczywiœcie, przy ka¿dym dopasowaniu ca³ego wzorca tak
naprawdê tylko jedna z grup mo¿e pasowaæ. Pozosta³e bêd¹ mia³y wartoœæ null.
W programie musimy wiêc odnajdywaæ tylko tê pasuj¹c¹ grupê i zrobimy to poprzez
dostarczenie w³asnej metody <br>
getMatchingGroupAsNumber(...). W metodzie tej bêdziemy te¿ chcieli zobaczyæ
co naprawdê siê dziej i jak s¹ dopasowywane konkretne grupy. Informacjê tê
poka¿emy na konsoli. <br>
Przyk³adowy program wygl¹da teraz tak:<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class Sumowanie2 {

  private Pattern pattern = Pattern.compile("(?:^(\\d+)\\s+)|" +
                                        "(?:^(\\d+)$)|" +
                                        "(?:\\s+(\\d+)$)|" +
                                        "(?:\\s+(\\d+)\\s+)"
                                       );

  private Matcher matcher = pattern.matcher("");

  private int lgroup = matcher.groupCount(); // liczba grup

  public void sumAndReport(String fileName) {

    try {
      BufferedReader in = new BufferedReader(
                           new FileReader(fileName)
                       );
      int suma1 = 0,   // suma liczb wystêpuj¹cych samotnie w wierszach
          suma2 = 0;   // suma liczb, które nie s¹ w wierszach samotne

      String input;
      while ((input = in.readLine()) != null) {

        matcher.reset(input);          // nowy tekst wejœciowy

        if (matcher.matches())         // czy mamy samotn¹ liczbê?
          suma1 += getMatchingGroupAsNumber("matches");

        else {                         // nie, mo¿e jest kilka, albo w tekœcie?
          matcher.reset();
          while (matcher.find())
            suma2 += getMatchingGroupAsNumber("find");
        }
      }
      in.close();
      System.out.println("Suma samotnych liczb: " + suma1);
      System.out.println("Suma niesamotnych liczb: " + suma2);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

  }

  // Metoda zwracaj¹ca dopasowan¹ grupê
  // przekszta³con¹ na liczbê

  private int getMatchingGroupAsNumber(String info)
              throws NumberFormatException
  {
    System.out.println(info + "\nDopasowanie: \"" + matcher.group() + "\"");
    int wynik = 0;
    for (int i=1; i &lt;= lgroup; i++) {
       System.out.println("Gr. " + i + " \"" + matcher.group(i) + "\"");
       if (matcher.group(i) != null) {
         wynik = Integer.parseInt(matcher.group(i));
       }
    }
    return wynik;
  }

  public static void main(String[] args) {
    new Sumowanie2().sumAndReport(args[0]);
  }

}
</pre>
a wyniki jego dzia³ania dla  pliku wejœciowego:<br>
1<br>

   2   <br>

aa 5 b  5 5 5 c<br>

100b<br>

3<br>

x3000 <br>

y40000y 11<br>
  <br>
s¹ nastêpuj¹ce:<br>
<div class="listing100"><br>
matches<br>
Dopasowanie: "1"<br>
Gr. 1 "null"<br>
Gr. 2 "1"<br>
Gr. 3 "null"<br>
Gr. 4 "null"<br>
matches<br>
Dopasowanie: "   2   "<br>
Gr. 1 "null"<br>
Gr. 2 "null"<br>
Gr. 3 "null"<br>
Gr. 4 "2"<br>
find<br>
Dopasowanie: " 5 "<br>
Gr. 1 "null"<br>
Gr. 2 "null"<br>
Gr. 3 "null"<br>
Gr. 4 "5"<br>
find<br>
Dopasowanie: "  5 "<br>
Gr. 1 "null"<br>
Gr. 2 "null"<br>
Gr. 3 "null"<br>
Gr. 4 "5"<br>
find<br>
Dopasowanie: " 5 "<br>
Gr. 1 "null"<br>
Gr. 2 "null"<br>
Gr. 3 "null"<br>
Gr. 4 "5"<br>
matches<br>
Dopasowanie: "3"<br>
Gr. 1 "null"<br>
Gr. 2 "3"<br>
Gr. 3 "null"<br>
Gr. 4 "null"<br>
find<br>
Dopasowanie: " 11"<br>
Gr. 1 "null"<br>
Gr. 2 "null"<br>
Gr. 3 "11"<br>
Gr. 4 "null"<br>
Suma samotnych liczb: 6<br>
Suma niesamotnych liczb: 26<br>
</div><br>
  <br>
  <b>Prawie</b> dobrze! Niestety, find() zgubi³ jedn¹ pi¹tkê z wiersza<br>

aa 5 b  5 5 5 c<br>
i - oczywiœcie - jest to wina Ÿle pomyœlanego wyra¿enia regularnego.<br>
Sposób dopasowania wiersza do wzorca mo¿emy przeœledziæ dok³adniej:<br>
<div class="listing100"><br>
Wzorzec: "(?:^(\d+)\s+)|(?:^(\d+)$)|(?:\s+(\d+)$)|(?:\s+?(\d+)\s+?)"<br>
Tekst: "aa 5 b  5 5 5 c"<br>
find(): Dopasowano pod³añcuch " 5 " od pozycji 2 do pozycji 5.<br>
find(): Dopasowano pod³añcuch "  5 " od pozycji 6 do pozycji 10.<br>
find(): Dopasowano pod³añcuch " 5 " od pozycji 11 do pozycji 14.<br>
</div><br>
  <br> Po dopasowaniu do wzorca drugiej pi¹tki z okalaj¹cymi spacjami pocz¹tek
nastêpnego wyszukiwania zaczyna siê na (trzecim) znaku '5' - niestety nie
pasuje on do ¿adnego z alternatywnych wzorców, zatem jest pomijany.<br>
  <br>
W tym przyk³adzie ³atwo jest znaleŸæ takie (proste) wyra¿enie regularne,
które rozwi¹zuje problem. Wystarczy przywróciæ (k³opotliwy poprzednio) kwantyfikator
* , ale przy tym skorzystaæ z symbolu granicy s³owa:<br>
  <pre>
\s*\b(\d+)\b\s*
</pre>
i wyniki (pierwotnego programu) bêd¹ nareszcie poprawne.<br>
Np. dla pokazanego przed chwil¹ pliku testowego otrzymamy:<br>
<div class="listing100"><br>
Suma samotnych liczb: 6<br>
Suma niesamotnych liczb: 31<br>
</div><br>
  <br>
Nie zawsze jednak uda siê skonstruowaæ dobry wzorzec. <br>
W Internecie, na ró¿nego rodzaju forum, w ró¿nego rodzaju podpowiedziach
itp. mo¿na znaleŸæ wzorce opisuj¹ce wydawa³oby siê doœæ oczywiste kwestie
(np. walidacjê adresu IP) zapisane w kilkunastu lub nawet kilkudziesiêciu
wierszach. Jest to oczywiœcie jak najbardziej niew³aœciwy sposób korzystania
z wyra¿eñ regularnych.  <br>
  <br>
Czasami trudno jest zbudowaæ w³aœciwy wzorzec. Czasami w³aœciwy wzorzec jest
na tyle skomplikowany i du¿y, ¿e zgo³a niebezpieczny (mo¿liwe b³êdy). Czasami
w ogóle nie mo¿na podaæ w³¹sciwego wyra¿enia regularnego, jak np. w przypadku
pe³nej sk³adniowej analizy wszystkich argumentów wywolania metody dla wszelkich
mo¿liwych wariantów zapisu tych argumentów (dowolny poziom zagnie¿d¿enia
nawiasów).<br>
  <br>
Warto wiêc chyba zauwazyæ, ¿e:<br>
  <ul>
    <li>wyra¿enia regularne nie s¹ lekiem dobrym na wszystko,</li>
    <li>czasem mniej wysi³ku kosztuje oprogramowanie od podstaw analizy sk³adniowej tekstu, ni¿ zbudowanie w³aœciwego wzorca,</li>
    <li>wiêksz¹ moc zyskuje siê przy po³¹czeniu wyra¿eñ regularnych z innymi
œrodkami programowania, m.in. metodami klasy Matcher, ale równie¿ z innymi
prostymi œrodkami przetwarzania ³añcuchów znakowych.</li>
  </ul>
  <br>
Jako przyk³ad po³¹czenia wyra¿eñ regularnych i dodatkowych œrodków programistycznych
poka¿ê w jaki sposób - pos³uguj¹c siê niespelniaj¹cym wszystkich wymagañ
wszorcem - mo¿na w omawianym przyk³adzie sumowania liczb uzyskaæ prawid³owy
wynik:<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class Sumowanie3 {

  public static void sumAndReport(String fileName) {

    try {
      BufferedReader in = new BufferedReader(
                           new FileReader(fileName)
                       );

      // Ten wzorzec nie sp³enia wszystkich wymagañ
      Pattern pattern = Pattern.compile("\\s*(\\d+)\\s*");

      Matcher matcher = pattern.matcher("");

      int suma1 = 0,   // suma liczb wystêpuj¹cych samotnie w wierszach
          suma2 = 0;   // suma liczb, które nie s¹ w wierszach samotne

      String input;
      while ((input = in.readLine()) != null) {

        int len = input.length();       // d³ugoœæ tekstu

        matcher.reset(input);

        if (matcher.matches())         // czy mamy samotn¹ liczbê?
          suma1 += Integer.parseInt(matcher.group(1));

        else {                         // nie, mo¿e jest kilka, albo w tekœcie?
          matcher.reset();
          while (matcher.find()) {

            // pozycja znaku tu¿ przed dopasowan¹ grup¹ cyfr
            int start = matcher.start(1) - 1;
            // pozycja znaku tu¿ po dopasowanej grupie cyfr
            int end = matcher.end(1);

            // je¿eli s¹ takie znaki i nie s¹ to spacje
            // - odrzucamy dopasowanie
            if (start == end ||
                (start &gt;= 0 &amp;&amp; !Character.isWhitespace(input.charAt(start))) ||
                (end &lt; len &amp;&amp; !Character.isWhitespace(input.charAt(end)))
               ) continue;

            // w przeciwnym razie mamy dopasowanie i sumujemy liczby
            suma2 += Integer.parseInt(matcher.group(1));
          }
        }
      }
      in.close();
      System.out.println("Suma samotnych liczb: " + suma1);
      System.out.println("Suma niesamotnych liczb: " + suma2);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

  }

  public static void main(String[] args) {
    sumAndReport(args[0]);
  }

}
</pre>
Wykorzystaliœmy tutaj niektóre metody klasy Matcher (mianowicie uzyskiwanie
informacji o pozycjach znaków, kstza³tuj¹cych grupy) i - wychodz¹c poza 
sferê najprostszego zastosowania wyra¿eñ regularnych - siêgneliœmy do informacji
o indeksach i znakach.<br>
Dziêki temu mogliœmy korygowaæ dzia³anie metody find().<br>
  <br>
I na koniec o pewnym uproszczeniu. W omawianych tu przyk³adach wielokrotnie stosowaliœmy ten sam wzorzec do
ró¿nych tesktów wejœciowych (wierszy pliku). W takich przypadkach ze wzglêdów
efektywnoœciowych nieodzowny jest znany nam schemat postêpowania, polegaj¹cy
na uprzedniej kompilacji wzorca, uzyskaniu matchera i wo³aniu jego metod.
  <br>
Wtedy jednak (i tylko wtedy), gdy chcemy dany wzorzec zastosowaæ jednorazowo i to wy³¹cznie
do stwierdzenia dopasowania ca³ego tekstu mo¿emy pos³u¿yæ siê metod¹ matches() klasy
Pattern.<br>
  <br>
<div class="syntax"><br>
Ma ona postaæ:<br>
  <br>
    boolean Pattern.matches(String regex,
        CharSequence input)<br>
  <br>
i powoduje - z naszego punktu widzenia w jednym kroku - kompilacjê wzorca
regex, utworzenie matchera i zastosowanie jego metody matches() wobec tekstu
wejœciowego input.</div><br>
  <br>
  <a name="W2.9"></a><h2>2.9. Rozbiór</h2>
Klasa Pattern zawiera wygodn¹ metodê split(...), która pozwala na dokonywanie
podzia³u tekstu wejœciowego na pod³añcuchy separowane innymi pod³añcuchami,
które pasuj¹ do podanego wyra¿enia regularnego.<br>
  <br> Jest to swego rodzaju odpowiednik StringTokenizera, z t¹ ró¿nic¹,
¿e separatorami wy³uskiwanych symboli mog¹ byæ dowolne napisy, pasuj¹ce do
wzorca.<br>
  <br>
Aby roz³o¿yæ tekst na symbole nale¿y najpierw skompilowaæ wzorzec, a nastêpnie
wobec uzyskanego obiektu klasy Pattern u¿yæ metody split(...).<br>
Wystêpuje ona w dwóch formach:<br>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String[]</td><td>split(CharSequence input)<br>
          </td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String[]</td><td>split(CharSequence input,
      int limit)<br>
          </td></tr></tbody>
  </table>
  <br>
Obie metody zwracaj¹ tablicê wyró¿nionych pod³añcuchów (symboli). Jeœli nie
uda³o siê znaleŸæ ¿adnego separatora pasuj¹cego do wzorca, to tablica ma
jeden element, który zawiera ca³y rozk³adany tekst (input).<br>
W przeciwnym razie, kolejne elementy tablicy zawieraj¹ wyró¿nione kolejne
pod³ancuchy, ka¿dy z których w sekwencji wejœciowej koñczy siê pod³añcuchem
pasuj¹cym do wzorca lub koñcem wejœcia.<br>
Argument limit okresla liczbê razy zastosowania wzorca do wy³uskiwania pod³ancuchów.<br>
Je¿eli limit równy jest n &gt;0, to wzorzec jest stosowany n-1 razy, wobec
czego liczba elementów w tablicy równa jest co najwy¿ej n, a ostatni element
stanowi pod³añcuch od ostatniego separatora do koñca tekstu wejœciowego.
Je¿eli limit jest mniejszy od 0, to wzorzec zostanie zastosowany tyle razy
ile mo¿na, a tablica bêdzie zawieraæ wszystkie mo¿liwe do wy³uskania pod³añcuchy.
To samo stosuje siê do sytuacji, gdy limit równy jest 0, tyle, ¿e <b>ostatnie
  puste</b> pod³añcuchy nie zostan¹ umieszczone w tablicy.<br>
Metoda split() bez parametru limit dzia³a tak samo jak split() z parametrem limit = 0.<br>
<br>
Poni¿szy program pokazuje przyk³adowe zastosowanie metody split() do rozbioru
zawartoœci pliku podanego jako argument programu wedle separatorów okreœlanych
przez wzorce podawane w dialogach wejœciowych. Przy okazji pokazano tutaj,
¿e - tak samo jak w przypadku matchera - wejœciowy tekst mo¿e byæ obiektem
dowolnej klasy implementuj¹cej interfejs CharSequence i dlatego np. ³atwo
mo¿na zastosowaæ machinê regularnych wyra¿eñ do buforów znakowych uzyskiwanych
poprzez kana³y plikowe. Oprócz tego warto zwróciæ uwagê na flagê kompilacji
DOTALL oraz na u¿ycie metody pattern(), która zwraca aktualny wzorzec danego
obiektu klasy Pattern.<br>
  <pre>
import java.util.regex.*;
import java.nio.*;
import java.io.*;
import java.nio.channels.*;
import java.nio.charset.*;
import javax.swing.*;


public class Parsing {

  private CharBuffer input;
  private Charset inCharset  = Charset.forName("Cp1250");


  public void readFile(String fname) throws IOException {

    // Wczytanie pliku
    FileInputStream instream = new FileInputStream(fname);
    FileChannel in = instream.getChannel();
    ByteBuffer buf = ByteBuffer.allocate((int) in.size());
    in.read(buf); in.close(); instream.close();

    // Dekodowanie
    buf.flip();
    input = inCharset.decode(buf);
  }

  public void reporter(Pattern pattern) {
    String[] subs = pattern.split(input);
    System.out.println("Rozbiór wg wzorca: \""+ pattern.pattern() + "\"");
    boolean isOk = subs.length &gt; 1;
    System.out.println( isOk ? " udany" : " nieudany");
    if (!isOk) return;
    System.out.println("Wyró¿nione pod³añcuchy:");
    for (int i=0; i &lt; subs.length; i++) {
      System.out.println("[ " + (i+1) + " ] \"" + subs[i] + "\"");
    }
  }


  public static void main(String[] args) throws Exception {

    Parsing parse = new Parsing();
    parse.readFile(args[0]);

    String regex = "";
    while ((regex = JOptionPane.showInputDialog("Wzorzec", regex)) != null) {
      Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);
      parse.reporter(pattern);
    }

  }

}
</pre>
Podaj¹c jako testowy plik o nastêpuj¹cej zawartoœci:<br>
2 + ( 3 + 4)*10 = nie wiem ile;<br>
ala + kot = ala ma kota;<br>
jeden = 1;<br>
dwa = 2;<br>
trzy = 3;  <br>
oraz stosuj¹c pokazane dalej wzorce, uzyskamy nastêpuj¹cy wynik:<br>
<div class="listing100"><br>
Rozbiór wg wzorca: "\r\n"<br>
 udany<br>
Wyró¿nione pod³añcuchy:<br>
[ 1 ] "2 + ( 3 + 4)*10 = nie wiem ile;"<br>
[ 2 ] "ala + kot = ala ma kota;"<br>
[ 3 ] "jeden = 1;"<br>
[ 4 ] "dwa = 2;"<br>
[ 5 ] "trzy = 3;  "<br>
Rozbiór wg wzorca: "([\r\n;])|( *= *)"<br>
 udany<br>
Wyró¿nione pod³añcuchy:<br>
[ 1 ] "2 + ( 3 + 4)*10"<br>
[ 2 ] "nie wiem ile"<br>
[ 3 ] ""<br>
[ 4 ] ""<br>
[ 5 ] "ala + kot"<br>
[ 6 ] "ala ma kota"<br>
[ 7 ] ""<br>
[ 8 ] ""<br>
[ 9 ] "jeden"<br>
[ 10 ] "1"<br>
[ 11 ] ""<br>
[ 12 ] ""<br>
[ 13 ] "dwa"<br>
[ 14 ] "2"<br>
[ 15 ] ""<br>
[ 16 ] ""<br>
[ 17 ] "trzy"<br>
[ 18 ] "3"<br>
[ 19 ] "  "<br>
Rozbiór wg wzorca: "[\r\n\p{Punct} ]+"<br>
 udany<br>
Wyró¿nione pod³añcuchy:<br>
[ 1 ] "2"<br>
[ 2 ] "3"<br>
[ 3 ] "4"<br>
[ 4 ] "10"<br>
[ 5 ] "nie"<br>
[ 6 ] "wiem"<br>
[ 7 ] "ile"<br>
[ 8 ] "ala"<br>
[ 9 ] "kot"<br>
[ 10 ] "ala"<br>
[ 11 ] "ma"<br>
[ 12 ] "kota"<br>
[ 13 ] "jeden"<br>
[ 14 ] "1"<br>
[ 15 ] "dwa"<br>
[ 16 ] "2"<br>
[ 17 ] "trzy"<br>
[ 18 ] "3"<br>
</div><br>
  <br>
  <a name="W2.10"></a><h2>2.10. Zastêpowanie</h2>
  Matcher umo¿liwia  zastêpowanie fragmentów tekstu wejœciowego pasuj¹cych
do wzorca podanymi napisami. S³u¿y do tego kilka metod klasy Matcher,<br>
Dwie najprostsze dzia³aj¹ w nastêpuj¹cy sposób:<br>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String</td><td>replaceAll(String replacement)<br>
           Zwraca ³añcuch znakowy, w którym zast¹piono ka¿dy fragment tekstu
wejœciowego, pasuj¹cy do wzorca napisem podanym jako argument replacement.</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String</td><td>replaceFirst(String replacement)<br>
           Zwraca ³añcuch znakowy, w którym zast¹piono pierwsze wyst¹pienie
fragmentu tekstu wejœciowego, pasuj¹cego do wzorca, napisem podanym jako
argument replacement.</td></tr></tbody>
  </table> Uwaga. Nale¿y baczn¹ uwagê zwróciæ na to, ¿e metody te nie zmieniaj¹
tekstu wejœciowego, ale zwracaj¹ nowy napis, w którym dokonano zmian.<br>
  <br>
Przyk³ad:<br>
Zamieniæ w pliku wejœciowym wielokrotne spacje - pojedynczymi.<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class Replace1 {

  public static void main(String[] args) {

    Matcher matcher = Pattern.compile(" +").matcher("");

    try {
      BufferedReader in = new BufferedReader(
                            new FileReader(args[0])
                          );
      String input;
      while ((input = in.readLine()) != null) {
        matcher.reset(input);
        input = matcher.replaceAll(" ");
        System.out.println(input);
      }
      in.close();
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

  }

}
</pre>
  <br>
Podaj¹c na wejœciu np. taki plik:<br>
To jest jakiœ tekst  gdzieniegdzie w nim jest   za du¿o spacji<br>
i     w tym wierszu te¿<br>
a w tym nie.<br>
  <br>
w wyniku otrzymamy:<br>
<div class="listing100"><br>
To jest jakiœ tekst gdzieniegdzie w nim jest za du¿o spacji<br>
i w tym wierszu te¿<br>
a w tym nie.<br>
</div><br>
  <br>
Inny zestaw metod  zastêpowania pozwala na bardziej wybiórcze, selektywne i elastyczne zamiany.<br>
S¹ to metody:<br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> Matcher</td><td>appendReplacement(StringBuffer sb,
                  String replacement)<br>
          </td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> StringBuffer</td><td>appendTail(StringBuffer sb)<br>
          </td></tr></tbody>
  </table>
  <br>
Metody te s¹ g³ównie przeznaczone do wspólnego wykorzystania z metod¹ find().<br>
  <br>
Metoda <b>appendReplacement(...)</b> pos³uguje siê specjalnym stanem matchera, który nazywa siê "pozycj¹ append" i  dzia³a w nastêpuj¹cy sposób:<br>
  <ol>
    <li>kopiuje do bufora StringBuffer wszystkie znaki  tekstu wejœciowego
od bie¿¹cej pozycji "append" (przy pierwszym u¿yciu jest to pocz¹tek tekstu
wejœciowego) do pozycji poprzedzaj¹cej ostatnie dopasowanie wzorca (czyli
start()-1),</li>
    <li>nastêpnie dopisuje do bufora tekst podany jako jej argument <i><b>replacement</b></i>,</li>
    <li>ustala bie¿¹c¹ pozycjê "append" na pierwszy znak po ostatnio dopasowanym wzorcu (czyli end())</li>
  </ol>
Metoda <b>appendTail(...)</b> - wywo³ywana  po u¿yciu metody appendReplacemnet()
- dopisuje do bufora pozosta³¹ czêœæ napisu wejœciowego (czyli od ostatniej
pozycji "append" do koñca tekstu).<br>
  <br>
Poprzedni przyk³ad zastêpowania spacji moglibyœmy za pomoc¹ tych metod zapisaæ tak:<br>
  <pre>
import java.util.regex.*;

public class Replace2 {

  public static void main(String[] args) {

    String input = "To jest   tekst  gdzie za du¿o  spacji";
    Matcher matcher = Pattern.compile(" +").matcher(input);
    StringBuffer nowyTekst = new StringBuffer();
    while (matcher.find()) {
      matcher.appendReplacement(nowyTekst, " ");
    }
    matcher.appendTail(nowyTekst);
    System.out.println("Tekst wejœciowy:");
    System.out.println(input);
    System.out.println("Tekst wyjœciowy:");
    System.out.println(nowyTekst.toString());
  }

}
</pre>
i otrzymaæ w wyniku:<br>
<div class="listing100"><br>
Tekst wejœciowy:<br>
To jest   tekst  gdzie za du¿o  spacji<br>
Tekst wyjœciowy:<br>
To jest tekst gdzie za du¿o spacji<br>
</div><br>
  <br>
Jako prosty przyk³ad zwiêkszonej elastycznoœci zastêpowania mo¿na podaæ zast¹peinie co drugiego wyst¹pienia cyfry 1 cyfr¹ 3:<br>
  <pre>
import java.util.regex.*;

public class Replace3 {

  public static void main(String[] args) {

    String input = "1111111111111";
    Matcher matcher = Pattern.compile("1").matcher(input);
    StringBuffer nowyTekst = new StringBuffer();
    while (matcher.find() &amp;&amp; matcher.find()) {
      matcher.appendReplacement(nowyTekst, "3");
    }
    matcher.appendTail(nowyTekst);
    System.out.println("Tekst wejœciowy:");
    System.out.println(input);
    System.out.println("Tekst wyjœciowy:");
    System.out.println(nowyTekst.toString());
  }

}
</pre>

  <div class="listing100"><br>
Tekst wejœciowy:<br>
1111111111111<br>
Tekst wyjœciowy:<br>
1313131313131<br>
</div><br>
  <br>
  <br>
Wa¿n¹ w³aœciwoœci¹ wszystkich metod zastêpowania jest to, ¿e w napisie stanowi¹cym
ich argument - tekst zastêpuj¹cy - mo¿emy odwo³ywaæ siê do zawartoœci grup
wzorca.<br>
Wtedy tekst zastêpuj¹cy bêdzie zawiera³ zawartoœæ grupy z wyra¿enia.<br>
Inaczej ni¿ w odniesieniach zwrotnych w wyra¿eniu regularnym przy zastêpowaniu
stosujemy znak $ z nastêpuj¹cym po nim numerem grupy.<br>
  <br>
Przyk³ad.<br>
  <br>
Plik zawiera listê studentów w postaci:<br>
sNumerIndeksu Imiê Nazwisko<br>
  <br>
np.<br>
s1111 Jan Kowalski<br>
  <br>
Chcemy tê liste zmiodyfikowaæ w taki sposób, by najpierw by³o naziwsko, póŸniej
imiê a na koñcu numer indeksu, ale bez popzredzaj¹cego s.<br>
  <br>
Zastosujemy metodê replaceFirst z argumentem zawieraj¹cym odniesienia do grup nastêpuj¹cego wyra¿enia:<br>
  <pre>
^s(\d+) +([\p{L}-]+) +([\p{L}-]+)$
</pre>
które oznacza:<br>
poczatek wiersza, s, nastêpnie jedna lub wiêcej cyfr, nastêpnie po spacji
lub spacjach ci¹g liter Unicode lub znaków -, znowu spacje i znowu ci¹g liter
Unicode lub znaków - tu¿ przed koñcem wiersza, Wyra¿enie to odpowiada struktorze
pocz¹tkowej listy studentów (aczkolwiek  nie jest doœæ uniwersalne ani odporne
na b³êdy). Numer indeksu jest tutaj grup¹ 1, imiê - grup¹ 2, a nazwisko -
grup¹ 3. W argumencie metody replaceFirst u¿yjemy odwo³añ do tych grup: "$3
$2 $1", co oznacza, ¿e dopasowany do wzorca tekst wejœciowy ma byæ zast¹piony
przez:  nazwisko, spacja, imiê, spacja, numer indeksu (bez s!).<br>
Poni¿szy program:<br>
  <pre>
import java.util.regex.*;
import java.io.*;

public class Replace4 {

  public static void main(String[] args) {

    Matcher matcher = Pattern.compile(
                        "^s(\\d+) +([\\p{L}-]+) +([\\p{L}-]+)$"
                      ).matcher("");

    try {
      BufferedReader in = new BufferedReader(
                            new FileReader(args[0])
                          );
      String input;
      while ((input = in.readLine()) != null) {
        matcher.reset(input);
        input = matcher.replaceFirst("$3 $2 $1");
        System.out.println(input);
      }
      in.close();
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

  }

}
</pre>
u¿yty wobec pliku przyk³adowego:<br>
  <br>
s1111 Jan Kowalski<br>
s3211 Micha³ Micha³owski<br>
s4235 Kazimierz Kazik-KaŸmierski<br>
  <br>
wyprowadzi:<br>
<div class="listing100"><br>
Kowalski Jan 1111<br>
Micha³owski Micha³ 3211<br>
Kazik-KaŸmierski Kazimierz 4235<br>
</div><br>
  <br>
  <br>
  <br>
  <a name="W2.11"></a><h2>
2.11. Metody klasy String zwi¹zane z wyra¿eniami regularnymi</h2>

Jako pewne uproszczenie, do zastosowañ ad hoc, znajdziemy w klasie String
metody, które odwzorowuj¹ niektore z omówionych metod klas Matcher i Pattern.<br>
S¹ one nastêpuj¹ce.<br>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> boolean</td><td>matches(String regex)<br>
          Czy <i><b>ten</b></i> napis pasuje do wzorca regex?</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String</td><td>replaceAll(String regex,
           String replacement)<br>
          Zastêpuje ka¿dy pasuj¹cy do regex pod³añcuch <i><b>tego</b></i> napisu podanym napisem replacement</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String</td><td>replaceFirst(String regex,
             String replacement)<br>
          Zastêpuje pierwszy pasuj¹cy do regex pod³añcuch <i><b>tego</b></i> napisu podanym napisem replacement</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String[]</td><td>split(String regex)<br>
          Rozklada ten napis wokó³ separatorów, które s¹ pod³ancuchami pasuj¹cymi do wzorca</td></tr><tr bgcolor="white" class="TableRowColor"><td align="Right" valign="Top" width="1%"> String[]</td><td>split(String regex,
      int limit)<br>          j.w., ale nie wiêcej ni¿ limit-1 razy<br>
        <br>
</td></tr></tbody>
  </table>
  <br>
Metody te s¹ œcis³ymi odpowiednikami odpowiednich metod klas Matcher i Pattern.
Faktycznie, "wewnêtrznie" wykorzystuj¹ one w³aœnie te klasy i ich metody.
Np. jeœli txt jest typu String, to<br>
txt.matches("[0-9]+");<br>
jest to¿same z :<br>
Pattern.compile("[0-9]+").matcher().matches();<br>
  <br>
Oznacza to, ¿e tych "skróconych" metod klasy String powinniœmy u¿ywaæ wy³¹cznie
wetdy, gdy dane wyra¿enie regularne i zwi¹zany z nim matcher u¿ywane s¹ jednokrotnie.
Przy wielokrotnym u¿yciu nalezy najpierw wyra¿enie skompilowaæ (raz), po
czym dopiero wielokrotnie u¿yæ, co oczywiœcie ju¿ wymaga wykorzystania klas
Pattern i Matcher.<br>
  <br>
  <br>
  <br>
  <a name="W2.12"></a><h2>2.12. Praktyczny przyk³ad</h2>
Na koniec rozwa¿my bardziej rozbudowany praktyczny przyk³ad, korzystaj¹cy
praktycznie ze wszystkich omówionych dot¹d narzêdzi wyra¿eñ regularanych,
jak równie¿ pokazuj¹cy w jaki sposób mo¿na wspieraæ ich moc dodatkowymi œrodkami
programistycznymi. Przy okazji jeszcze raz zwrócimy uwagê na pewne istotne
kwestie, zwi¹zane ze stosowaneim wyra¿eñ regularnych.<br>
  <br>
Chcemy oto zapisaæ do pliku wyjœciowego wszystkie nag³ówki (oznaczane znacznikami
&lt;h1&gt;, &lt;h2&gt; itd.) z jakiegoœ  pliku HTML, stworzyæ swoisty spis
treœci.<br>

Zadanie dobrania w³aœciwego wzorca wydaje siê trywialne. Nag³ówek jest tekstem
wystêpuj¹cym pomiêdzy otwieraj¹cym znacznikiem &lt;h<i>n</i>&gt; i zamykaj¹cym znacznikeim &lt;/h<i>n</i>&gt;, gidze n - poziom nag³ówka.<br>

Narzucaj¹cym siê wzorcem móg³by byæ:<br>
  <pre>
&lt;h[1-6]&gt;(.+)&lt;/h[1-6]&gt;
</pre>

Istotnie, dla pliku w postaci:<br>

&lt;h1&gt;Nag³ówek 1&lt;/h1&gt;<br>

&lt;h2&gt;Nag³ówek 1.1&lt;/h2&gt;<br>

&lt;h2&gt;Nag³ówek 1.2&lt;/h2&gt;<br>

uzyskamy w³aœciwe dopasowania i bêdziemy mogli wy³uskaæ zapamiêtane w grupach nag³ówki:<br>

<div class="listing100"><br>

find(): Dopasowano pod³añcuch "&lt;h1&gt;Nag³ówek 1&lt;/h1&gt;" od pozycji 0 do pozycji 19.<br>

find(): Dopasowano pod³añcuch "&lt;h2&gt;Nag³ówek 1.1&lt;/h2&gt;" od pozycji 20 do pozycji 41.<br>

find(): Dopasowano pod³añcuch "&lt;h2&gt;Nag³ówek 1.2&lt;/h2&gt;" od pozycji 42 do pozycji 63.<br>

</div><br>
  <br>

Jednak w plikach HTML nag³ówki mog¹ przecie¿ byæ dzielone na wiele wierszy. Dla pliku:<br>
  <br>

&lt;h1&gt;Nag³ówek 1<br>

        rozbity na wiersze&lt;/h1&gt;<br>

&lt;h2&gt;Nag³ówek 1.1&lt;/h2&gt;<br>

&lt;h2&gt;Nag³ówek 1.2&lt;/h2&gt;<br>

find() nie znajdzie dopasowania nag³ówka poziomu 1. Dlaczego? Bo metaznak
. domyœlnie pasuje do ka¿dego znaku oprócz znaku koñca wiersza. Powinniœmy
zatem zastosowaæ - albo przy kompilacji wzorca, albo w samym wyra¿eniu -
flagê DOTALL - ?s (powoduj¹ca pasowanie metaznaku . równie¿ do znaków koñca
wiersza). A jeœli ju¿, to uwzglêdnijmy te¿ fakt, ¿e znaczniki html mog¹ byc
pisane ma³¹ i du¿¹ liter¹ (zatem wprowadŸmy flagê CASE_INSENSITIVE - ?i).<br>

Nowy - teraz wydawa³oby siê prawid³owy - wzorzec wygl¹da³by tak (flagi wprowadzimy w samym wyra¿eniu).<br>
  <pre>
(?i)(?s)&lt;h[1-6]&gt;(.+)&lt;/h[1-6]&gt;
</pre>


  Czy teraz  find() znajdzie wszystkie trzy nag³ówki? Nic z tych rzeczy!<br>

Znajdzie tylko jeden du¿y tekst zaczynaj¹cy siê pierwszym znacznikiem &lt;h1&gt;
i koñcz¹cy siê ostatnim znacznikiem &lt;/h2&gt;. Znowu zwracam uwagê na ¿ar³ocznoœæ
(greediness) kwantyfikatorów, bowiem jest to temat doœæ nieintuicyjny.<br>

Zobaczmy: ¿ar³oczny .+ skonsumowa³ wszystkie znaki do koñca tekstu wejœciwoego
(móg³ to zrobiæ, bo teraz kropka pasuje do znaków koñca wiersza). Po czym
matcher cofaj¹c siê napotka³ dopasowanie &lt;/h2&gt; (ostatnie w tekœcie)
i to spe³ni³o wymagania wzorca dla metody find(), która w tym momencie zakoñczy³a
dzia³anie.<br>

Aha, zatem powinniœmy zastosowaæ kwantyfikator wstrzemiêŸliwy (reluctant).<br>
  <pre>
(?i)(?s)&lt;h[1-6]&gt;(.+?)&lt;/h[1-6]&gt;
</pre>
  <br>

W teœcie wygl¹da to teraz ca³kiem dobrze:<br>

<div class="listing100"><br>

Wzorzec: "(?i)(?s)&lt;h[1-6]&gt;(.+?)&lt;/h[1-6]&gt;"<br>

Tekst: "&lt;h1&gt;Nag³ówek 1<br>

   rozbity na wiersze&lt;/h1&gt;<br>

&lt;h2&gt;Nag³ówek 1.1&lt;/h2&gt;<br>

&lt;h2&gt;Nag³ówek 1.2&lt;/h2&gt;"<br>

find(): Dopasowano pod³añcuch "&lt;h1&gt;Nag³ówek 1<br>

   rozbity na wiersze&lt;/h1&gt;" od pozycji 0 do pozycji 41.<br>

find(): Dopasowano pod³añcuch "&lt;h2&gt;Nag³ówek 1.1&lt;/h2&gt;" od pozycji 42 do pozycji 63.<br>

find(): Dopasowano pod³añcuch "&lt;h2&gt;Nag³ówek 1.2&lt;/h2&gt;" od pozycji 64 do pozycji 85.<br>

</div><br>
  <br>

Spróbujmy wiêc zastosowaæ ten w³aœnie wzorzec w programie wypisuj¹cym "spis
treœci" pliku html. Zobaczymy jednak, ¿e sam wzorzec nie wystarcza. Musimy
rozstrzygn¹æ jeszcze kilka kwestii:<br>
  <ul>
<li>w jaki sposób przeczytaæ plik, tak by wielowierszowe nag³ówki da³y
siê przetwarzaæ przez wybrane wyra¿enie regularne? Na pewno nie mo¿emy stosowaæ
go do ka¿dego z wierszy pliku oddzielnie. </li><li>co zrobiæ ze znakami nowego wiersza umieszczonymi wewnêtrz nag³ówków?
Raczej chcielibyœmy wypisywaæ tytu³y w jednym wierszu, a nie zachowywaæ  -
czêsto przypadkowego, dokonanego np. przez jakieœ wizualne edytory HTML,
rozbicia.</li><li>co robiæ w przypadku b³êdów w pliku HTML - niesparowania znaczników
otwieraj¹cych i koñcz¹cych? Nasz wzorzec znajdzie (jakieœ) dopasowanie np.
w takim tekœcie, &lt;h1&gt;xxxx&lt;h2&gt;xxxx&lt;/h1&gt;xxx&lt;/h2&gt;, jak
równie¿ i w takim &lt;h1&gt;xxxx&lt;/h2&gt;. Czy warto szukaæ wzorca bardziej odpornego na b³êdy?</li>
  </ul>
  <br>

Przy wprowadzaniu pliku najprostsze wydaje siê wczytanie ca³ego pliku do
pamiêci i traktowanie go w ca³oœci jako tekstu wejœciowego matchera. Jak ju¿ widzieliœmy wygodnie
bêdzie zrobiæ to za pomoc¹ kana³u plikowego, jednoczeœnie jednak wymagaæ
to bêdzie odpowiedniego dekodowania bufora znakowego. 
Przy dekodowaniu trzeba wiedzieæ w jakiej stronie kodowej zapisany jest plik.
Ta informacja powinna byæ dostêpna w pliku html za pomoc¹ metatagu charset,
ale jeœli jej brak, to mo¿emy przyj¹æ jak¹œ domyœln¹ stronê kodow¹. Dla odnalezienia
opisu strony kodowej w pliku html zastosujemy (oczywiœcie) wyra¿enie regularne.
Musimy przy tym wiedzieæ, ¿e w metatagu charset=... po obu stronach znaku
= mog¹ wyst¹piæ (b¹dŸ nie) spacje, ¿e nazwa strony kodowej mo¿e sk³adaæ siê
z liter, cyfr, znaku podkreœlenia, myœlnika, kropki, dwukropka i ¿e wielkoœæ
liter w nazwie nie ma znaczenia. <br>

Prosty wzorzec (nie wykluczaj¹cy wadliwych metatagów charset) móg³by wygl¹daæ tak:<br>
  <pre>
(?i)charset *?= *?([\p{Alnum}.:_-]+)
</pre>
  <br>

Znaki nowego wiersza (wystêpuj¹ce wewn¹trz wypisywanych nag³ówków)  powinniœmy
zamieniæ na (jedn¹) spacjê. Ale "przejœcie do nowego wiersza" mo¿e byæ oznaczane
przez znaki \r\n (0d0a) jak w Windows lub przez sam znak \n - jak w Unixie.
Aktualny separator obowi¹zuj¹cy na danej platformie uzyskamy z w³aœciwoœci
systemowych. Gdyby nie metody replace... klasy matchera zamiana na (jedn¹!) spacjê wymaga³aby od nas trochê uci¹¿liwej pracy.<br>
  <br>

Mo¿liwe b³êdy w HTML nie dadz¹ siê opisaæ za pomoc¹ wyra¿eñ regularnych.
Musimy wiêc znowu zastosowaæ dodatkowe œrodki programistyczne, korzystaj¹ce
oczywiœcie z ró¿nych metod matchera. Mianowicie:<br>
  <ul>
    <li>
bêdziemy wykrywaæ otwarte znaczniki &lt;h wewn¹trz nag³ówków,</li>
    <li>
bêdziemy sprawdzaæ, czy nasze wyra¿enie spowodowa³o dopasowania znaczników
(otwieraj¹cego i zamykaj¹cego) nag³ówków ró¿nych poziomów.</li>
  </ul>
Te wskazówki wystarcz¹ do napisania programu. Zobaczymy poni¿ej, ¿e jego
kod korzysta z kilku ró¿nych wzorców i wielu metod klas Matcher i Pattern
(w tym split i replaceAll). Sczegó³owe wyj¹snienie znaleŸæ mo¿na w komentarzach.<br>
  <pre>
import java.util.regex.*;
import java.nio.*;
import java.io.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class Headers1 {

  // Matcher do wyszukiwania metatagu charset
  // i wy³uskania strony kodowej
  private Matcher charsetMatcher = Pattern.compile(
                                   "charset *?= *?([\\p{Alnum}.:_-]+)",
                                   Pattern.CASE_INSENSITIVE
                                   ).matcher("");

  // Matcher do wy³uskania tytu³u dokumentu
  private Matcher titleMatcher =  Pattern.compile(
                                  "&lt;title&gt;(.+?)&lt;/title&gt;",
                                  Pattern.CASE_INSENSITIVE |
                                  Pattern.DOTALL
                                  ).matcher("");

  // Matcher do wyszukiwania podtytu³ów (headingów)
  private Matcher headingMatcher = Pattern.compile(
                                    "&lt;h[1-6]&gt;(.+?)&lt;/h[1-6]&gt;",
                                    Pattern.CASE_INSENSITIVE |
                                    Pattern.DOTALL
                                    ).matcher("");

  // Matcher do zastêpowania domyœlnego dla danej platformy
  // zestawu znaków koñca wiersza jedn¹ spacj¹
  private Matcher replaceMatcher = Pattern.compile(
                                    System.getProperty("line.separator")//"\\r\\n"
                                   ).matcher("");

  // Wzorzec do podzia³u dokumentu na dwie czêœci: nag³ówek i cia³o
  private Pattern splitPattern = Pattern.compile("&lt;/head&gt;",
                                         Pattern.CASE_INSENSITIVE
                                 );


  // Domyœlna strona kodowa
  private Charset defaultCharset = Charset.forName("ISO-8859-2");

  ByteBuffer channelBuffer;   // bufor bajtowy kanalu
  CharBuffer input;           // bufor znakowy z wejœciem dla matcherów


  // G³ówna metoda
  // przetwarzaj¹ca dokument HTML
  // i wypisuj¹ca jego "spis treœci"

  public void processFile(String fname) {
    // Wczytanie pliku
    try {
      FileInputStream instream = new FileInputStream(fname);
      FileChannel in = instream.getChannel();
      channelBuffer = ByteBuffer.allocate((int) in.size());
      in.read(channelBuffer);
      in.close();
      instream.close();
    } catch (IOException exc) { errMsg(exc); }

    // Dekodowanie (na razie wedle domyœlnej strony)
    // Jeœli oka¿e siê, ¿e plik jest kodowany inaczej
    // - powtórzymy dekodowanie

    channelBuffer.flip();
    input = defaultCharset.decode(channelBuffer);

    // Teraz wyró¿niamy dwie czêœci pliku : nag³ówek pliku
    // i cia³o. W ten sposób matchery bêd¹ dzia³aæ szybciej
    // Uwaga: podzia³ nastêpuje na pierwszym &lt;/head&gt;
    // ew. nastêpne w tekœcie html (np. w &lt;pre&gt;...&lt;/pre&gt;
    // nie bêd¹ brane pod uwagê

    String[] part = splitPattern.split(input, 2);
    // je¿eli jest nag³ówek - szukamy w nim okreœlenia strony kodowej
    // i ew. ponawiamy dekodowanie za pomoc¹ w³asnej metody newDecode,
    // a tak¿e wyszukujemy tytu³

    String title = "Bez tytu³u";  // zak³adamy, ¿e nie ma tytu³u
    String body;                  // tu bêdzie cia³o, w nim bêdziemy szukaæ
                                  // headingów

    if (part.length == 2) {        // je¿eli jest nag³ówek
       if (newDecoding(part[0]))   // je¿eli ponowiono dekodowanie
          part = splitPattern.split(input, 2); // - nowy podzia³ na czêœci

       titleMatcher.reset(part[0]);  // szukamy tytu³u
       if (titleMatcher.find())
         title = titleMatcher.group(1);

       body = part[1];             // cia³em bêdzie druga czêœæ
    } else {                       // nie ma nag³ówka, wtedy
       body = part[0];             // cia³em bêdzie jedyna pierwsz czêœæ
    }

    System.out.println(title);     // wypisanie tytu³u

    // Teraz szukamy headingów
    headingMatcher.reset(body);
    while (headingMatcher.find()) {
      String heading = headingMatcher.group(1);
      replaceMatcher.reset(heading);  // zamiana znaku koñca wiersza
      heading = replaceMatcher.replaceAll(" "); // na jedn¹ spacjê

      // Sprawdzenie poprawnoœci
      boolean valid = true;

      // - czy nie ma &lt;h&gt;  w srodku?
      if (heading.indexOf("&lt;h") != -1) valid = false;

      // czy otwieraj¹cy i zamykaj¹cy numer poziomu jest zgodny?
      String match = headingMatcher.group();
      char level = match.charAt(2);
      if (level != match.charAt(match.length()-2)) valid = false;
      if (!valid)
        System.out.println("***** uwaga poni¿szy heading jest b³êdny!");
      else {
         int k = level - '0' - 1;
         while(k-- &gt; 0)                // poziomy wyró¿niamy tabulacjami
           System.out.print('\t');
      }
      System.out.println(heading);      // wypisanie podtytu³u
    }

  }

  // Metoda wyszukuje metatatg charset i ew. ponawia dekodowanie
  // Jeœli tagu nie ma, albo podany charset jest taki sam jak
  // domyœlny, albo jest wadliwy - nie ponawiamy dekodowania
  // Zwraca true, gdy zdekdodowano na nowa
  private boolean newDecoding(String header) {
    charsetMatcher.reset(header);
    if (charsetMatcher.find()) { // czy jest metatag charset?
       try {
           Charset fileCharset = Charset.forName(charsetMatcher.group(1));
           if (fileCharset.equals(defaultCharset)) // gdy taki sam jak domyœlny
              return false;                        // nie trzeba dekodowaæ
           channelBuffer.flip();                   // inny - ponowne dekodowanie
           input = fileCharset.decode(channelBuffer);
         } catch(Exception exc) {
             return false;
         }
       return true; // zdekodowany na nowo
    }
    return false;
  }

  private void errMsg(Exception exc) {
    exc.printStackTrace();
    System.exit(1);
  }

  public static void main(String[] args) {
     new Headers1().processFile(args[0]);
  }

}
</pre>

  <a name="W2.13"></a><h2>2.13. Zadania i æwiczenia</h2>
  <ol>
    <li>Zbudowaæ wyra¿enie regularne, które dopasowuje dowoln¹ liczbê - ca³kowit¹
lub rzeczywist¹. U¿yæ go w programie, który z pliku wejœciowego wybiera wszystkie
takie liczby i zastêpuje je ich dwukrotnoœci¹.</li>
    <li>Stworzyæ program do przetwarzania plików HTML, w taki sposób, by
zapisane w nich kody programów Javy, znajduj¹ce siê w znacznikach &lt;pre&gt;....
&lt;/pre&gt; by³y zapisowane jako pliki .java z nazw¹ wy³uskan¹ z kodu na
podstawie nazwy obecnej tam klasy publicznej.</li>
    <li>Napisaæ program, który  w pliku Ÿród³owym zmienia nazwy wybranych
metod. Uwaga: trzeba te¿ zmeiniæ identyfikatory w wyra¿eniach wywo³uj¹cych
metody.<br>
    </li>
  </ol>





</body></html>
