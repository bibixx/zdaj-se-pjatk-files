<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN">
<html lang="pl">
<head rel="stylesheet" type="text/css" href="../style/common.css">


  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">


  <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]">
  <title>Wyk≥ad 5</title>



  <link rel="stylesheet" type="text/css" href="../style/common.css">


  <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script>
</head>
<body bgcolor="#efefef">

<div align="center">
<a name="W5"></a></div>
<br>
<h1 style="text-align: center;">NIO</h1>
<h2>
  K.1. Nowe wejúcie-wyjúcie (NIO): przeglπd</h2>

Niewπtpliwie podstawowym motywem wprowadzenia nowych úrodk&oacute;w wejúcia-wyjúcia,
zawartych w pakicie java.nio i jego podpakietach by≥o zapewnienie zwiÍkszenia
efektywnoúci dzia≥ania program&oacute;w w wysokim stopniu obciπøonych operacjami
wejúcia-wyjúcia o duøej czÍstotliwoúci.<br>

  <br>

Tradycyjne wejúcie-wyjúcie w Javie jest <b>blokujπce</b>, tzn. wπtek, kt&oacute;ry
podejmuje pr&oacute;bÍ odczytania danych ze strumienia (metoda read()) jest blokowany,
jeúli danych w strumieniu (jeszcze) nie ma. Zatem obs≥uga strumieni po≥πczeÒ
sieciowych (przez serwer) musia≥a byÊ wykonywana poprzez wiele wπtk&oacute;w, kaødy
z kt&oacute;rych obs≥ugiwa≥ strumieÒ zwiπzany z jednym gniazdem (socket) i ew. by≥
blokowany na tym strumieniu, czekajπcy na dane. W takiej sytuacji przy duøej
liczbie po≥πczeÒ dzia≥a r&oacute;wnolegle duøo wπtk&oacute;w, a poniewaø liczba po≥aczeÒ
zmienia siÍ dynamicznie, to z duøπ czÍstotliwoúciπ wiele wπtk&oacute;w powstaje
i umiera (przechodzi do stanu Dead). W sumie prowadzi to do problem&oacute;w efektywnoúciowych,
a takøe jest trudne w programowaniu, gdyø:<br>


<ul>

    <li>tworzenie i prze≥πczanie wπtk&oacute;w (realizowane przez JVM) jest czasowo kosztowne,</li>

    <li>szybkie narastanie niepotrzebnych obiekt&oacute;w (zakoÒczonych wπtk&oacute;w)
powoduje zmniejszenie efektywnoúci dzialania programu ze wzglÍdu na zwiÍkszajπcπ
siÍ zajÍtoúc pamiÍci, bowiem standardowy odúmiecacz JVM nie &nbsp;jest odpowiednio
przystosowany do takiej sytuacji,</li>

    <li>synchronizowanie duøej liczby wπtk&oacute;w na wsp&oacute;ldzielonych zasobach
moøe byÊ trudne w programowaniu, zawodne i bardzo czasoch≥onna z punktu widzenia efektywnoúci
dzialania programu.&nbsp; </li>


</ul>

Podstawowym elementem nowego wejúcia-wyjúcia, odpowiadajπcym na te problemy,&nbsp; jest koncepcja <b>kana≥u</b>.<br>

  <br>

<div class="def"><b>Kana≥</b> reprezentuje otwarte po≥πczenie do obiektu, kt&oacute;ry wykonuje
jednπ lub wiele r&oacute;ønych operacji wejúcia-wyjúcia. Takim obiektem moøe byÊ
urzπdzenie sprzÍtowe, plik, gniazdo sieciowe, a nawet komponent programu.</div>
<br>

  <br>

<div class="notel"><b>Gniazdo sieciowe</b> (socket) jest punktem docelowym dwustronnej komunikacji
dw&oacute;ch program&oacute;w dzia≥ajπcych r&oacute;wnolegle w sieci</div>
Kana≥y pod≥πczone do gniazd
sieciowych (np. klasa SocketChannel)&nbsp; umoøliwiajπ <b>nieblokujπce</b> (asynchroniczne) wejúcie-wyjúcie.<br>

Przy czytaniu z takiego kana≥u za pomoca metody read(...), wπtek nie jest
blokowany, gdy brak danych. Metoda read(...) natychmiast zwraca wynik - liczbÍ
przeczytanych bajt&oacute;w (jeúli nie ma jeszcze danych - to 0).<br>

Umoøliwia to <b>odpytywanie</b> (polling) - sprawdzanie co jakiú czas czy dane nadesz≥y. Wπtek nie jest blokowany i moøe wykonywaÊ inne zadania.<br>

  <br>


<div align="center"><b>Schemat nieblokujπcego wejúcia</b><br>

  </div>

  <br>


<pre>
SocketChannel socketChannel = SocketChannel.open(); // otwarcie kana≥u
socketChanel.connect(...)                           // pod≥πczenie do gniazda
socketChannel.configureBlocking (false);            // tryb nieblokujπcy

...

while (true) {
   ...
   if (socketChannel.read (buffer) != 0) {  // czy sπ jakieú dane?
      processInput (buffer);                // tak - przetw&oacute;rz je
   }
   else {                                   // nie - wykonuj inne czynnoúci
     ...
   }
}
</pre>

Uwaga: co to jest buffer? O tym za chwilÍ.<br>

  <br>

Jasne jest, øe stanowi to alternatywÍ dla wielu wπtk&oacute;w, z kt&oacute;rych kaødy blokowany
jest na czytaniu danych z kana≥u. Teraz jeden wπtek moøe obs≥ugiwaÊ wiele
kana≥&oacute;w bez blokowania przy braku danych.<br>

Nazywa siÍ to <b>multipleksowaniem kana≥&oacute;w wejúcia/wyjúcia</b>. <br>

  <br>

Ale samo nieblokowane wejúcie-wyjúcie nie wystarcza jeszcze, by prawid≥owo
rozwiπzaÊ problem obs≥ugi wielu po≥πczeÒ. "RÍczne" odpytywanie wielu kana≥&oacute;w
ma wady:<br>


<ul>

    <li>trzeba je oprogramowaÊ (i moøna przy tym pope≥niÊ b≥Ídy),</li>

    <li>polega na wysy≥aniu instrukcji we/wy za poúrednictwem JVM (read(...)),
co jest czasowo kosztowne i w rezultacie - przy duøej liczbie po≥πczeÒ -&nbsp;
moøe niedopuszczalnie zmniejszaÊ czas reakcji na kaødym z po≥aczeÒ.</li>


</ul>

Dlatego w java.nio wprowadzono mechanizm <b>selektor&oacute;w</b>,
kt&oacute;ry ≥πczy ze sobπ zalety nieblokujπcego odpytywania oraz
natychmiastowej reakcji na dane po blokowaniu wπtku na odczycie.<br>

  <br>

DziÍki nieblokujπcemu we/wy, a szczeg&oacute;lnie <b>selektorom</b>:<br>


<ul>

    <li>jeden wπtek moøe ≥atwo monitorowaÊ duøπ liczbÍ gniazd sieciowych,</li>

    <li>wπtek ten moøe byÊ zablokowany dop&oacute;ki nie pojawiπ siÍ dane z <b>kt&oacute;regokolwiek</b> gniazda, a po ich pojawieniu siÍ natychmiast wznowiony,</li>

    <li>moøe przy tym dowiedzieÊ siÍ, kt&oacute;ry ze strumieni
danych jest gotowy do przetwarzania i natychmiast podjπc to
przetwarzanie.&nbsp; </li>


</ul>

Niewπtpliwie przy nieblokujπcym wejúciu-wyjúciu moøna by to oprogramowaÊ
w Javie i bez selektor&oacute;w, ale uøycie selektor&oacute;w ma dwie podstawowe zalety:<br>


<ul>

    <li>zwalnia nas od obowiπzku pisania trudnego kodu,</li>

    <li>jest efektywne, bowiem multipleksowanie i selekcja kana≥&oacute;w sπ zrealizowane
w duøej mierze przez odwolania do rodzimych funkcji platformy systemowej
i - wobec tego - omija JVM, pozostawiajπc ciÍøkπ pracÍ do wykonania procedurom
systemowym, kt&oacute;re robiπ to najsprawniej.</li>


</ul>

  <br>
<br>

"Nowe wejúcie-wyjúcie" ma rownieø szereg nie&nbsp; zwiπzanych z programowaniem
sieciowym, majπcych og&oacute;lniejsze znaczenie, w≥asciwoúci. <br>

  <br>

Obecnie w Javie kana≥y mogπ byÊ po≥πczone z gniazdami, plikami oraz dowolnymi
strumieniami klas InputStream, OutputStream (te ostatnie kana≥y nazwiemy
kana≥ami strumieniowymi).<br>

  <br>

Wszystkie takie kana≥y majπ jednπ wsp&oacute;lnπ w≥aúciwoúÊ: kana≥y wejúciowe wprowadzajπ dane do&nbsp; <b>buforow bajtowych</b>, a kana≥y wyjúciowe wyprowadzajπ dane z tych bufor&oacute;w. <br>

<div class="notel">Bufor bajtowy przypomina nieco tablicÍ bajt&oacute;w: jest to skoÒczona sekwencja
bajt&oacute;w, na kt&oacute;rej moøna wykonywaÊ pewne operacje (m.in. pobieranie i dodawanie);
od zwyk≥ej tablicy r&oacute;øni siÍ przede wszystkim tym, øe operacje na buforze
sπ dostosowane do potrzeb wejúcia-wyjúcia</div>
 Zatem zapoznanie siÍ z koncepcjπ
bufor&oacute;w -&nbsp; r&oacute;wnieø jednego z element&oacute;w "nowego wejúcia-wyjúcia" - jest nieodzowne
do korzystania z kana≥&oacute;w.<br>

Bufory mogπ byÊ teø stosowane samodzielnie i dostarczajπ pewnych nowych,
ciekawych moøliwoúci, kt&oacute;re mogπ byÊ wykorzystywane niezaleønie od kana≥owego
wejúcia-wyjúcia.<br>

  <br>

Zanim przejdziemy do bardziej konkretnego omawiania niekt&oacute;rych nowych moøliwoúci,
dostarczanych przez&nbsp; kana≥y i bufory, warto rzuciÊ okiem na syntezÍ tych
moøliwoúci (tablica).<br>

  <br>


<table border="1" cellpadding="2" cellspacing="2" width="100%">

    <tbody>

      <tr>

        <td rowspan="1" colspan="4" bgcolor="#ffffcc" valign="top">

      <div align="center"><b>KANA£Y</b><br>

        </div>

        </td>

      </tr>

      <tr>

        <td bgcolor="#ffcccc" valign="top"><br>

        </td>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Kana≥y gniazdowe</b><br>

        <br>

        </div>

        </td>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Kana≥y plikowe<br>

        </b></div>

        </td>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Kana≥y strumieniowe</b><br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top">uzyskanie kana≥u<br>

        </td>

        <td valign="top">metoda open() z klas SocketChannel,<br>

ServerSocketChannel,<br>

DatagramChannel<br>

+ connect<br>

        </td>

        <td valign="top">Metoda<br>

        <b>getChannel()</b><br>

z klas:<br>

FileInputStream<br>

FileOutputStream<br>

RandomAccessFile&nbsp; <br>

        </td>

        <td valign="top">Metody statyczne klasy<br>

Channels:<br>

newChannel(InputStream)<br>

newChannel(OutputStream)<br>

        </td>

      </tr>

      <tr>

        <td valign="top"><br>

        </td>

        <td rowspan="1" colspan="3" bgcolor="#ffcccc" valign="top">

      <div align="center">Moøliwoúci dostarczane przez kana≥y<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>nieblokujπce </b>wejúcie-wyjúcie<br>

i moøliwoúÊ stosowania <b>selektor&oacute;w</b><br>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top">atomistyczne czytanie rozprowadzajπce po wielu buforach (<b>scattering read</b>), atomistyczne pisanie gromadzπce z wielu bufor&oacute;w (<b>gathering write</b>)<br>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>mapowanie</b> plik&oacute;w na pamiÍÊ <br>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>bezpoúrednie transfery kana≥owe</b> (np. jedno wywo≥anie kopiuje ca≥y plik do innego w spos&oacute;b bardzo efektywny) <br>

        </td>

        <td valign="top">

      <div align="center">tak, jeúli jednym z kana≥&oacute;w jest kana≥ plikowy<br>

        </div>

        </td>

        <td valign="top">

      <div align="center">tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center">tak, jeúli jednym z kana≥&oacute;w jest kana≥ plikowy<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top">blokowanie (<b>lock</b>) dostÍpu do ca≥ego pliku&nbsp;&nbsp; lub jego czÍúci<br>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

nie<br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top">czytanie, pisanie do/z bufor&oacute;w <br>

(zob. moøliwoúci bufor&oacute;w)<br>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

        <td valign="top">

      <div align="center"><br>

tak<br>

        </div>

        </td>

      </tr>


  </tbody>

</table>

  <br>

  <br>

  <br>


<table border="1" cellpadding="2" cellspacing="2" width="100%">

    <tbody>

      <tr>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Moøliwoúci, dostarczane przez bufory</b><br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top">r&oacute;øne <b>widoki bufor&oacute;w</b> bajtowych (jako ciπgu bajt&oacute;w lub element&oacute;w wybranego typu pierwotnego)</td>

      </tr>

      <tr>

        <td valign="top"><b>przestawianie bajt&oacute;w</b> (moøliwoúÊ wyboru i/lub
≥atwej zmiany&nbsp; konwencj uporzπdkowania bajt&oacute;w danych binarnych - czy bardziej
znaczπce czÍsci danej majπ w pamiÍci mniejsze czy wiÍksze adresy)<br>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>kodowanie - dekodowanie</b> danych w buforach
znakowych przy uwzglÍdnieniu wybranej strony kodowej (klasy Charset, CharsetDecoder
i CharsetEncoder, operujπce na buforach) <br>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>bufory bezpoúednie</b> (bufory takie&nbsp; "opakowujπ"
pamiÍÊ alokowanπ poza JVM przez natywne úrodki platformy systemowej i umoøliwiajπ
m.in. wysokπ efektywnoúÊ operacji kana≥owych, a takøe dajπ programiúcie moøliwoúÊ
dostÍpu z poziomu programu Javy do dowolnego obszaru pamiÍci, alokowanego
w systemie - np. bezpoúredniej pamiÍci graficznej)<br>

        </td>

      </tr>


  </tbody>

</table>

  <br>

  <br>
 Zwr&oacute;Êmy na koniec jeszcze raz uwagÍ, øe "nowe wejúcie-wyjúcie" (NIO)
nie zastÍpuje "starego" (klas strumieniowych). Generalnie klasy strumieniowe
operujπ na wyøszym poziomie abstrakcji, kana≥y zaú przeznaczone sπ przede
wszystkim do zwiÍkszenia efektywnoúci operacji wejúcia-wyjúcia i ukierunkowane
sπ raczej na niskopoziomowe operowanie na sekwencjach bajt&oacute;w.<br>

  <a name="W5.17"></a>
<h2>
  K.2. NIO: bufory</h2>


<div class="def">Bufor jest ciπg≥π, skoÒczonπ sekwencjπ
element&oacute;w jednego z typ&oacute;w pierwotnych: byte, short, char,
long, float, double</div>
<br>

  <br>

Odpowiednio do tego mamy r&oacute;øne klasy opisujπce bufory np.<br>

  <br>
<span style="font-weight: bold;">
ByteBuffer</span> - bufor bajt&oacute;w (elementy typu byte),<br>
<span style="font-weight: bold;">
IntBuffer</span> &nbsp;- bufor zawierajπcy liczby calkowite typu int,<br>
<span style="font-weight: bold;">
DoubleBuffer</span> - bufor liczb typu double.<br>

  <br>

Opr&oacute;cz tych klas, odpowiadajπcych typom pierwotnym, istnieje rownieø klasa
<span style="font-weight: bold;">MappedBuffer</span>, za pomocπ kt&oacute;rej moøemy mieÊ dostÍp do pliku mapowanego na
pamiÍÊ.<br>

Og&oacute;lne charakterystyki i funkcjonalnoúÊ wszystkich klas buforowych okreúla klasa abstrakcyjna Buffer.<br>

  <br>

Rysunek przedstawia hierarchiÍ klas buforowych.<br>

  <br>

  <img src="images/Bufferclasses.jpg" alt="r" border="1" height="335" width="572">
  <br>

  <br>

èr&oacute;d≥o: &nbsp;Ron Hitchens, Java NIO, O'Reilly 2002<br>

  <b style="color: rgb(251, 75, 112);">UWAGA: Kana≥y operujπ wy≥πcznie na buforach bajtowych.</b><br>

  <br>
<div class="notel">Opakowanie danych tablicy przez bufor oznacza, øe dane sπ te same
- zar&oacute;wno w buforze jak i tablicy, a operacje na buforze, zmieniajπce dane
bufora zmieniajπ r&oacute;wnoczeúnie dane w tablicy i vice versa</div>
Bufory mogπ byÊ
tworzone poprzez:
<ul>

    <li>alokowanie prywatnej pamiÍci bufora - metody <b>allocate</b> i <b>allocateDirect</b> (ta ostatnia dla bufor&oacute;w bezposrednich),</li>

    <li><b>opakowanie</b> istniejπcej <b>tablicy element&oacute;w</b> wybranego typu pierwotnego - metoda <b>wrap</b>,</li>

    <li><b>mapowanie</b> plik&oacute;w lub ich czÍúci (metoda map(...) z klasy FileChanel)<br>

    </li>


</ul>

Dane do bufor&oacute;w mogπ byÊ zapisywane za pomoca metod <b>put(..)</b> z klas
buforowych oraz na skutek czytania z kana≥u (read(...) z klas kana≥owych).
Metody kana≥owe zapisujπ do bufora&nbsp; ca≥e sekwencje bajt&oacute;w.<br>

Dane z bufor&oacute;w mogπ byÊ pobierane za pomocπ metod <b>get(...)</b> &nbsp;z klas buforowych oraz zapisywane do kana≥u (write()...) z klas kana≥owych). <br>

  <br>

Metody put(...) i get(...) dzielπ siÍ na <b>relatywne</b> (zapisujπce lub odczytujπce bufor poczynajπc od jego bieøπcej pozycji) i <b>absolutne</b> (zapisujπce/odczytujπce element na podanej pozycji w buforze).<br>

Operacje relatywne mogπ dotyczyÊ pojedynczego elementu lub ich sekwencji
(zapisywanych do bufora z tablicy lub innego bufora, odczytywanych z bufora
do tablicy).<br>

  <br>
<br>


<table border="1" cellpadding="3" cellspacing="0" width="100%">

  <tbody>
    <tr>

        <td rowspan="1" colspan="2" valign="top">

      <div align="center"><b>
Metody get(...) z klas buforowych</b><br>


(<i><b>typ</b></i> oznacza byte, char, short, int, long, float, doble - w zaleønoúci od typu bufora).<br>

        </div>

        </td>

      </tr>

    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%">

      <div align="center"><code>&nbsp; <i>typ</i></code></div>

      </td>
      <td><code><b>get</b>()</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relatywna metoda get - zwraca bieøπcy element</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<b><i>typ</i></b>Buffer</code></td>
      <td><code><b>get</b>(<b>typ</b>[]&nbsp;dst)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna
metoda get - zapisuje tablicÍ dst elementami bufora, poczynajπc od jego
bieøacej pozycji.</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>get</b>(<b>typ</b>[]&nbsp;dst,
    int&nbsp;offset,
    int&nbsp;length)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. ale diotyczy czÍúci tablicy</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><i><code>typ</code></i></td>
      <td><code><b>get</b>(int&nbsp;index)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Absolutna metoda get - zwraca element na pozycji index.</td>
    </tr>
  </tbody>

</table>

  <br>


<table border="1" cellpadding="3" cellspacing="0" width="100%">

  <tbody>
    <tr>

        <td rowspan="1" colspan="2" valign="top">

      <div align="center"><b>
Metody put z klas buforowych</b><br>


(<i><b>typ</b></i> oznacza byte, char, short, int, long, float, doble - w zaleønoúci od typu bufora).<br>

        </div>

        </td>

      </tr>

    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>put</b>(<b><i>typ</i></b> b)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna metoda put - zapisuje element b&nbsp; na bieøπcej pozycji</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>put</b>(<b><i>typ</i></b>[]&nbsp;src)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna metoda put - zapisuje do bufora tablicÍ element&oacute;w</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>put</b>(<i><b>typ</b></i>[]&nbsp;src,
    int&nbsp;offset,
    int&nbsp;length)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. - czÍúÊ tablicy</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>put</b>(<b><i>typ</i></b>Buffer&nbsp;src)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relatywna metoda put - zapisuje zawartosc bufora src do bufora</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td>
      <td><code><b>put</b>(int&nbsp;index, <i><b>typ</b></i> b)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Absolutna metoda put, zapisuje b na pozycji index</td>
    </tr>
    <tr>

        <td rowspan="1" colspan="2" valign="top">Uwaga: jeøeli bufor jest tylko do odczytu (read-only), to uøycie metody put(...) spowodujπ powstanie wyjπtku <b>ReadOnlyBufferException</b>. Bufor moøemy uczyniÊ "tylko do odczytu" za pomocπ metod <b>asReadOnly()</b> z klas buforowych.<br>

        </td>

      </tr>

  </tbody>

</table>

  <br>

  <br>

<div class="syntax">Kaødy z bufor&oacute;w ma nastÍpujπce (<b>waøne</b>, a czasem nieintuicyjne) charakterystyki:

<ul>

    <li>pojemnoúÊ (<i>capacity</i>) - liczbÍ element&oacute;w bufora (niezmiennπ!),</li>

    <li>limit (<i>limit</i>) - indeks pierwszego elementu, kt&oacute;ry <b>nie moøe</b> byÊ czytany z bufora lub zapisany do bufora,</li>

    <li>pozycjÍ (<i>position</i>) - indeks kolejnego elementu, kt&oacute;ry bÍdzie odczytany lub zapisany (inaczej bieøπcπ pozycjÍ bufora).</li>


</ul>

Informacje o tych charakterystykach moøna uzyskac za pomocπ metod <b><br>

</b>

<ul>

    <li><b>int capacity() </b></li>

    <li><b>int limit() </b></li>

    <li><b>int position()</b> </li>


</ul>

PojemnoúÊ bufora nie moøe byÊ zmieniona, ale pozycjÍ i limit moøemy&nbsp;ustawiaÊ za pomocπ metod<br>


<ul>

    <li><b>Buffer position(int pos)</b> </li>

    <li><b>Buffer limit(int lim)</b></li>


</ul>

Metoda <b>remaining()</b> zwraca liczbÍ element&oacute;w znajdujπcych siÍ pomiÍdzy pozycjπ a limitem.<br>


Metoda <b>hasRemaining()</b> zwraca true, jeúli liczba ta jest wiÍksza od 0.</div>
 <br>

  <br>

Kaødy <b>relatywny</b> zapis do bufora zapisuje element bπdü elementy do
bufora poczynajπc od jego bieøπcej pozycji i zmienia pozycjÍ, tak by wskazywa≥a
na nastÍpny element (miejsce), kt&oacute;ry moøe byÊ zapisany.<br>

Kaøde <b>relatywne</b> czytanie z bufora czyta element bπdü elementy, poczynajac
od jego bieøπcej pozycji i zmienia pozycjÍ tak, by wskazywala na nastÍpny
jeszcze nie odczytany element.<br>
<br>

  <font color="#ff0000"><b>Uwaga:<br>

Operacje absolutne nie zmieniajπ pozycji bufora.<br>

  </b><b>Czytanie z bufora bπdü zapis do bufora nie zmieniajπ limitu bufora.<br>

  </b></font>

  <br>

Pr&oacute;ba odczytu danych <b>poza limitem</b> spowoduje powstanie wyjπtku <b>BufferUnderflowException
</b>(brak danych w buforze), natomiast pr&oacute;ba zapisu danych poza limit spoowoduje
wyjπtek <b>BufferOverflowException</b> (przepe≥nienie bufora). <br>

  <br>

<div class="notec">Po zapisaniu danych do bufora, po to by moøna by≥o je odczytaÊ naleøy bufor <b>przestawiÊ</b>.<br>

  <br>

  <b>Przestawienie bufora</b> polega na wywolaniu metody <b>flip()</b>, kt&oacute;ra ustawia <b>limit na bieøπcπ pozycjÍ</b>, po czym ustala <b>pozycjÍ na zero</b>.<br>

  <br>

Jeøeli &nbsp;po odczytaniu danych z bufora chcemy jeszcze raz przeczytaÊ je od poczπtku, powinniúmy bufor <b>przewinπÊ</b>. S≥uøy temu metoda <b>rewind()</b>, kt&oacute;ra ustala pozcycjÍ na zero, pozostawiajπc limit bez zmian</div>
<br>

  <br>
Zachowanie bufor&oacute;w i zmiany ich charakterystyk ilustruje poniøszy program.<br>

  <br>


<pre>
import java.nio.*;

class Buffers {

  static void say(String s) { System.out.println(s); }

  static void showParms(String msg, Buffer b) {
    say("Charakterystyki bufora - " + msg);
    say("capacity  :" + b.capacity());
    say("limit     :" + b.limit());
    say("position  :" + b.position());
    say("remaining :" + b.remaining());
  }

  public static void main(String args[]) {

    // alokacja bufora 10 bajtowego (inicjalnie waroúci element&oacute;w = 0)
    ByteBuffer b = ByteBuffer.allocate(10);
    showParms("Po utworzeniu", b);

    // Zapis dw&oacute;ch bajt&oacute;w do bufora
    b.put((byte) 7).put((byte) 9);
    showParms("Po dodaniu dw&oacute;ch element&oacute;w", b);

    // Przestawienie bufora
    b.flip();
    showParms("Po przestawieniu", b);

    // Teraz moøemy czytaÊ wpisane dane
    say("Czytamy pierwszy element: " + b.get());
    showParms("Po pobraniu pierwszego elementu", b);
    say("Czytamy drugi element: " + b.get());
    showParms("Po pobraniu drugiego elementu", b);

    say("Czy moøemy jeszcze czytaÊ?");
    try {
      byte x = b.get();
    } catch (BufferUnderflowException exc) {
       say("No, nie - proszÍ spojrzeÊ na ostatni limit!");
    }

    // Jeszcze raz odczytajmy dane z bufora
    // w tym celu musimy go przewinπÊ
    b.rewind();
    showParms("Po przewiniÍciu", b);

    say("Czytanie wszystkiego, co wpisaliúmy");
    while (b.hasRemaining())
      say("Jest: " + b.get());
  }
}
</pre>

kt&oacute;ry na wyjúciu da:<br>

<div class="listing100"><br>
Charakterystyki bufora - Po utworzeniu<br>

capacity: 10<br>

limit: 10<br>

position: 0<br>

remaining: 10<br>

Charakterystyki bufora - Po dodaniu dw&oacute;ch element&oacute;w<br>

capacity: 10<br>

limit: 10<br>

position: 2<br>

remaining: 8<br>

Charakterystyki bufora - Po przestawieniu<br>

capacity: 10<br>

limit: 2<br>

position: 0<br>

remaining: 2<br>

Czytamy pierwszy element: 7<br>

Charakterystyki bufora - Po pobraniu pierwszego elementu<br>

capacity: 10<br>

limit: 2<br>

position: 1<br>

remaining: 1<br>

Czytamy drugi element: 9<br>

Charakterystyki bufora - Po pobraniu drugiego elementu<br>

capacity: 10<br>

limit: 2<br>

position: 2<br>

remaining: 0<br>

Czy moøemy jeszcze czytaÊ?<br>

No, nie - proszÍ spojrzeÊ na ostatni limit!<br>

Charakterystyki bufora - Po przewiniÍciu<br>

capacity: 10<br>

limit: 2<br>

position: 0<br>

remaining: 2<br>

Czytanie wszystkiego, co wpisaliúmy<br>

Jest: 7<br>

Jest: 9<br>

</div>
<br>

  <br>

  <font color="#cc0000"><b>ProszÍ uwaønie przeanalizowaÊ dzia≥anie i wyniki tego programu.</b></font><br>

  <br>

  <br>

Warto podkreúliÊ, øe nawigacja "po buforze" zawsze odbywa siÍ w kontekúcie typu jego element&oacute;w.<br>

Np.&nbsp; w buforze typu IntBuffer&nbsp;elementami sπ liczby typu int, get zwraca element
typu int, a&nbsp; pozycja bÍdzie siÍ przesuwaÊ tak, by wskazywaÊ na nastÍpny element
typu int (4 bajty).<br>

Natomiast w buforze typu ByteBuffer pobieranie, zapisywanie i zmiany pozycji dotyczπ pojedynczych bajt&oacute;w.<br>

Naleøy zwr&oacute;ciÊ szczeg&oacute;lnπ uwagÍ na bufory bajtowe, bowiem<br>

  <br>

<div class="important">Bufory bajtpwe (typu ByteBuffer) odgrywajπ szczeg&oacute;lnπ rolÍ, bowiem tylko one sπ uøywane w operacjach na kanalach.</div>
<br>

  <br>

  <a name="W5.18"></a>
<h2>K.3 NIO: kana≥y i bufory</h2>

Aby uøywaÊ kanal&oacute;w musimy importowaÊ nazwy klas z pakietu java.nio.channels.<br>

Bufory wymagajπ importu java.nio.<br>

  <br>

Schematy uøycia kana≥&oacute;w w operacjach wejúcia-wyjúcia przedstaiwono poniøej.
Dla ustalenia uwagi pos≥ugujemy siÍ tu kana≥ami plikowymi.<br>

  <br>


<table bgcolor="#ffffcc" border="1" cellpadding="2" cellspacing="2" width="100%">

    <tbody>

      <tr>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Zapis do&nbsp; kana≥u</b><br>

        </div>

        </td>

      </tr>

      <tr>

        <td valign="top"><b>1. Alokacja bufora bajtowego</b><br>

        <br>

&nbsp; &nbsp; &nbsp;ByteBuffer buf = ByteBuffer.allocate(N); // N - rozmiar bufora<br>

        <br>

        <b>2. Zapis danych do bufora (</b>np. z uøyciem metod put...)<br>

        <br>

        <b>3. Uzyskanie kana≥u klasy FileChannel "do zapisu"</b><br>

        <br>

Moøemy go uzyskaÊ za pomocπ metod getChannel() z klas FileOutputStream oraz
&nbsp; RandomAccessFile (kana≥ "do zapisu i do odczytu", jeúli taki by≥ tryb otwarcia
pliku o dostÍpie swobodnym). Np.<br>

        <br>

&nbsp; &nbsp; FileOutputStream out &nbsp;= new FileOutputStream(...);<br>

&nbsp; &nbsp; FileChannel fc = out.getChannel();<br>

        <br>

        <b>4. Zapis bufora - uøycie metod write z klasy FileChannel. Np.</b><br>

        <br>

&nbsp; &nbsp;fc.write(buf);<br>

        <br>

        <b>5. ZamkniÍcie kana≥u:</b><br>

        <br>

&nbsp; &nbsp;fc.close();<br>

        <br>

ZamkniÍty kana≥ pozostaje zamkniÍty. Metoda isOpen() pozwala stwierdziÊ czy kana≥ jest otwarty.<br>

        <br>

        </td>

      </tr>


  </tbody>

</table>

  <br>

  <br>

  <br>


<table bgcolor="#ffffcc" border="1" cellpadding="2" cellspacing="2" width="100%">

  <tbody>
    <tr>
      <td bgcolor="#ffcccc" valign="top">
      <div align="center"><b>Czytanie z&nbsp; kana≥u</b><br>
      </div>
      </td>
    </tr>
    <tr>
      <td valign="top"><b>1. Alokacja bufora bajtowego</b><br>
      <br>

&nbsp; &nbsp; &nbsp;ByteBuffer buf = ByteBuffer.allocate(N); // N - rozmiar bufora<br>
      <br>
      <b>2. Uzyskanie kana≥u klasy FileChannel "do odczytu"</b><br>
      <br>

Moøemy go uzyskaÊ za pomocπ metod getChannel() z klas FileInputStream oraz
&nbsp; RandomAccessFile (kana≥ "do zapisu i do odczytu", jesli taki by≥ tryb otwarcia
pliku o dostÍpie swobodnym). Np.<br>
      <br>

&nbsp; &nbsp; FileInputStream out &nbsp;= new FileInputStream(...);<br>

&nbsp; &nbsp; FileChannel fc = out.getChannel();<br>
      <br>
      <b>3. Czytanie do bufora - uøycie metod read z klasy FileChannel. Np.</b><br>
      <br>

&nbsp; &nbsp;fc.read(buf);<br>

        <br>

        <b>4. ZamkniÍcie kana≥u:</b><br>

        <br>


&nbsp; &nbsp;fc.close();<br>

        <br>


ZamkniÍty kana≥ pozostaje zamkniÍty.<br>

        <br>

        <b>5. Okreúlenie w≥aúciwej pozycji i limitu bufora po wczytaniu do niego danych. </b><br>

&nbsp; &nbsp; Np. poprzez przestawienie bufora:<br>

        <br>

&nbsp; &nbsp; buf.flip();<br>

        <br>

        <b>6. Odczytanie danych z bufora za pomocπ metod get...</b><br>

        <br>

      </td>
    </tr>
  </tbody>

</table>

  <br>

  <br>

Poniøszy program ilustruje powyøszy schemat. Komentarze szczeg&oacute;≥owo omawiajπ uøyte w nim konstrukcje. <b><font color="#ff0000">ProszÍ zwr&oacute;ciÊ na nie bacznπ uwagÍ</font></b>.<br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class SimpleChannel {

  String fname = "test.tmp";
  byte[] data = {1,2,3,4,5 };

  SimpleChannel() {
    try {
      writeChannel(fname, data);
      byte[] wynik = readChannel(fname);
      for (int i=0; i &lt; wynik.length; i++) System.out.println(wynik[i]);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

  void writeChannel(String fname, byte[] data) throws Exception {

    // Moøemy utworzyÊ bufor przez opakowanie istniejπcej tablicy
    ByteBuffer buf = ByteBuffer.wrap(data);

    FileOutputStream out = new FileOutputStream(fname);

    // Uzyakanie kana≥u
    FileChannel fc = out.getChannel();

    //Zapis
    fc.write(buf);
    fc.close();
  }

  byte[] readChannel(String fname) throws Exception {


    // Stworzenie strumienia na podstawie obiektu klasy File
    FileInputStream in = new FileInputStream(fname;

    // Uzyskanie kana≥u
    FileChannel fc = in.getChannel();

    // Metoda size() z klasy FileChannel
    // zwraca long -rozmiar plku, do kt&oacute;rego podlπczony jest kana≥
    int size = (int) fc.size();

    // Utworzenie bufora
    ByteBuffer buf = ByteBuffer.allocate(size);

    // Czytanie do bufora
    // nbytes - liczba przeczytanych bajt&oacute;w
    int nbytes = fc.read(buf);
    fc.close();

    // Po przeczytaniu danych musimy bufor przestawiÊ
    buf.flip();

    // Stworzenie tablicy na wynik czytania
    // jej rozmiar bÍdzie okreúlony przez liczbÍ przeczytanuych bajt&oacute;w
    // kt&oacute;rπ moøemy podaÊ na dwa sposoby: poprzednie nbytes
    // lub uzyskujπc informacjÍ o liczbie jeszcze nieodczytanych bajt&oacute;w z bufora

    byte[] wynik = new byte[buf.remaining()];
    buf.get(wynik);
    return wynik;
  }

  public static void main(String args[]) {
   new SimpleChannel();
  }
}  &nbsp;
</pre>

  <br>

W klasie FileChannel zdefiniowano wiele metod pozwalajπcych na czytanie z
- zapis do kana≥&oacute;w oraz pozycjonowanie i przewijanie plik&oacute;w, do kt&oacute;rych te
kana≥y sπ podlπczone.<br>


  <a name="W5.19"></a>
<h2>K.4. Widoki bufor&oacute;w bajtowych</h2>

Jak juø wiemy, w operacjach kanalowych uøywa siÍ wy≥πcznie bufor&oacute;w bajtowych,.<br>

Zapewniajπ one ≥atwy dostÍp do element&oacute;w - bajt&oacute;w.<br>
Ale jak w &nbsp;takim razie przetwarzaÊ dane innych typ&oacute;w (niø
bajty) pobierane z kana≥&oacute;w lub zapisywaÊ takie dane do kana≥u?<br>

  <br>

Sπ po temu przynajmniej dwie moøliwoúci.<br>

  <br>

Pierwsza polega na uøyciu metod klasy ByteBuffer: <br>

  <br>

&nbsp;&nbsp;&nbsp; <i><b>ttt</b></i> elt = get<i><b>Ttt</b></i>() <br>

&nbsp;&nbsp;&nbsp; put<i><b>Ttt</b></i>(<i><b>Ttt</b></i> elt)<br>

  <br>

kt&oacute;re umoøliwajπ zapisywanie i pobieranie danych typu ttt (short, int, long, float, double, char).<br>

  <br>

Drugi spos&oacute;b - znacznie ciekawszy i przyjemniejszy - polega na uøyciu <b>widok&oacute;w</b> bufor&oacute;w bajtowych<br>

  <br>

<div class="syntax">Metoda klasy ByteBuffer:<br>

  <br>

&nbsp;&nbsp;&nbsp; <i><b>Ttt</b></i>Buffer as<i><b>Ttt</b></i>Buffer()<br>

  <br>

gdzie: <i><b>ttt</b></i> - jeden z typ&oacute;w short, int, long, float, double, char<br>

  <br>

uøyta wobec bufora bajtowego buf zwraca referencjÍ do bufora klasy <i><b>Ttt</b></i>Buffer, co pozwala na dzia≥anie na danych pierwotnego bufora bajtowego buf za pomocπ metod <b>get</b> i <b>put</b> klasy <i><b>Ttt</b></i>Buf czyli tak, jakby pierwotny bufor bajtowy zawiera≥ elementy typu <i><b>ttt</b></i>.<br>

  <br>

M&oacute;wimy, øe metoda ...asBuffer() zwraca <b>widok</b> bufora bajtowego jako bufora typu <i><b>Ttt</b></i>Buffer, gdyø nie nastÍpuej tu øadne kopiowanie danych i zmiany danych wykonywane
za poúrednictwem obu obiekt&oacute;w - bufora pierwotnego oraz jego widoku dotyczπ
tego samego bufora.</div>
<br>

  <br>

KoncepcjÍ widoku bufora bajtowego ilustruje poniøszy program.<br>

  <br>


<pre>
import java.nio.*;

class BufView1 {

  public static void main(String args[]) {

    final int SHORT_SIZE = 2;
    // Alokacja buforu bajtowego,
    // mogπcego przechowywaÊ do 10 liczb typu short
    ByteBuffer bb = ByteBuffer.allocate(10*SHORT_SIZE);

    // Widok na ten bofor jak na short-bufor
    <b>ShortBuffer sb = bb.asShortBuffer();</b>

    // Dodanie trzech liczb typu short
    short a = 1, b = 2, c = 3;
    sb.put(a).put(b).put(c);

    // Co wpisano do bufora? Na wydruku: 1, 2, 3
    sb.flip();
    while (sb.hasRemaining()) System.out.println(sb.get());

    // Operujemy teraz na nim za pomocπ bufora bajtowego
    // zmieniajπc bajty na pozycji 1, 3 i 5.
    byte  x = 4, y = 5, z = 6;
    bb.put(1, x).put(3, y).put(5, z);

    // Co pokaøe short-bufor? Na wydruku 4, 5, 6
    sb.rewind();
    while (sb.hasRemaining()) System.out.println(sb.get());
  }
}
</pre>

  <br>

Z widokami bufora bajtowego wiπøe siÍ jednak pewna pu≥apka.<br>

Ot&oacute;ø, mimo, øe bufor i jego widok dotyczπ tych samych danych to jednak mamy
dwa bufory (bufor bajtowy i jego widok jakiegoú wybranego typu - np. ShortBuffer
), a w tych buforach zmiany pozycji oraz limitu sπ niezalezne od siebie.<br>

  <br>

<div class="important">Pozycja i limit bufora bajtowego sπ <b>niezaleøne</b> od pozycji i limitu&nbsp; jego widoku.</div>
<br>

  <br>

Gdybyúmy np. chcieli w poprzendim przykladzie po wpisaniu liczb short do
bufora bajtowego (za pomocπ jego widoku) pokazaÊ kolejne bajty wszystkich
wpisanych liczb, to moglibyúmy pojúÊ b≥Ídnym tropem: po wpisaniu danych przestawiÊ
bufor short (flip) i sπdzπc, øe pierwotny bufor bajtowy takøe dostosuje swojπ
pozycjÍ i limit wypisywaÊ bajty w pÍtli dop&oacute;ki hasRemaining() nie zwr&oacute;ci
false.<br>
Ilustruje to poniøszy program (w kt&oacute;rym uøywamy metody showParms
zpoprzednich przyk≥ad&oacute;w dla pokazania charakterystyk bufora):<br>

  <br>


<pre>
  public static void main(String args[]) {

    final int SHORT_SIZE = 2;
    ByteBuffer bb = ByteBuffer.allocate(10*SHORT_SIZE);
    ShortBuffer sb = bb.asShortBuffer();
    short a = 1, b = 2, c = 3;
    sb.put(a).put(b).put(c);
    showParms("bufor short - po dodaniu liczb", sb);
    showParms("bufor bajtowy - po dodaniu liczb", bb);

    sb.flip();
    showParms("bufor short - po przestawieniu", sb);
    showParms("bufor bajtowy - po flip bufora short", bb);
    System.out.print("Dane");
    while (bb.hasRemaining()) System.out.print(" " + bb.get());
  }
}
</pre>

&nbsp;Wydruk.<br>

<div class="listing100"><br>

Charakterystyki bufora - bufor short - po dodaniu liczb<br>

capacity: 10<br>

limit: 10<br>

position: 3<br>

remaining: 7<br>

  <br>

Charakterystyki bufora - bufor bajtowy - po dodaniu liczb<br>

capacity: 20<br>

limit: 20<br>

position: 0<br>

remaining: 20<br>

  <br>

Charakterystyki bufora - bufor short - po przestawieniu<br>

capacity: 10<br>

limit: 3<br>

position: 0<br>

remaining: 3<br>

  <br>

Charakterystyki bufora - bufor bajtowy - po flip bufora short<br>

capacity: 20<br>

limit: 20<br>

position: 0<br>

remaining: 20<br>

Dane 0 1 0 2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div>
<br>

  <br>

Zwr&oacute;cmy uwagÍ: dodanie element&oacute;w do widoku bufora bajtowego nie zmienia jego
pozycji i limitu, zmienia tylko pozycjÍ i limit w widoku, Rownieø flip()
widoku nie ma wp≥ywu na te parametry bufora bajtowego. Program wypisuje ca≥y
bufor, bajt po bajcie, a nie bajty tych element&oacute;w, ktore zosta≥y dodane.<br>

  <br>

Aby w tym przyk≥adzie wypisac tylko bajty wpisanych danych, powinniúcmy po
przestawieniu widoku bufora zmieniÊ odpowiednio limit bufora bajtowego:

<pre>
    sb.flip();
    bb.limit(sb.limit()*SHORT_SIZE);
    System.out.print("Bajty wpisanych danych");
    while (bb.hasRemaining()) System.out.print(" " + bb.get());
</pre>

  <br>

Jednak przy czytaniu danych z kana≥&oacute;w nie ma takiej potrzeby. Dane sπ wczytywane
do bufora bajtowego, a nie do jego widoku. Zatem naleøy przestawiÊ bufor
bajtowy, a dopiero potem stworzyÊ i pos≥ugiwaÊ siÍ jego widokiem. <span style="font-weight: bold;">Jest to sensowne,
bowiem widok bierze pod uwagÍ pozycjÍ i limit bufora, na podstawie kt&oacute;rego
jest tworzony, odpowiednio ustawiajπc swojπ pozycjÍ i limit.</span><br>

  <br>

Co pokazuje poniøszy program.<br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class BuffChan {

  String fname = "testfile.tmp";

  // inicjacja danych testowych
  void init() throws Exception {
    double[] data = { 0.1, 0.2, 0.3 };
    DataOutputStream out = new DataOutputStream(
                             new FileOutputStream(fname)
                            );
    for (int i=0; i &lt; data.length; i++) out.writeDouble(data[i]);
    out.close();

  }

  BuffChan() throws Exception {

    // inicjalcja danych testowych
    init();

    // utworzenie bufora
    ByteBuffer buf = ByteBuffer.allocate(1000); // nie wiemy ile, maks 100B

    // uzyskanie kana≥u
    FileChannel fcin = new FileInputStream(fname).getChannel();

    // czytanie z kana≥u do bufora
    fcin.read(buf);
    fcin.close();

    // przestawienie bufora bajtowego
    buf.flip();

    // Utworzenie widoku bufora
    DoubleBuffer dbuf = buf.asDoubleBuffer();

    // Wypisanie odczytanych danych
    while (dbuf.hasRemaining()) System.out.println(dbuf.get());
  }

  public static void main(String args[]) throws Exception {
    new BuffChan();
  }
}
</pre>

  <br>

  <br>

  <a name="W5.20"></a>
<h2>K.5. NIO: bufory - uporzπdkowanie bajt&oacute;w (endianess)</h2>


  Przy czytaniu i zapisywaniu plik&oacute;w, tworzonych na r&oacute;ønych platformach
sprzÍtowych, &nbsp;powstaje problem uporzπdkowania (kolejnoúci wystÍpowania) bajt&oacute;w
danych binarnych,<br>

Wynika to z tego w jaki spos&oacute;b dane binarne przechowywane sπ w pamiÍci (i jak zapisywane w rejestrach procesora).<br>

  <br>

Porzπdek bajt&oacute;w w reprezentacji binarnej danych okreúla siÍ terminem <b><i>endianess</i></b>.<br>

  <br>

Istniejπ dwa r&oacute;øne porzπdki:<br>

  <br>


<ul>

    <li>
Porzπdek BIG ENDIAN oznacza, øe mniej znaczπce bajty danych sπ zapisywane
pod wiÍkszymi adresami pamiÍci (niejako od prawej do lewej) </li>

    <li>
Porzπdek LITLLE ENDIAN jest odwrotny: najpierw sπ zapisywane mniej znaczπce bajty, p&oacute;üniej bardziej (od lewej do prawej).</li>


</ul>
Ilustruje to rysunek, na kt&oacute;rym pokazano porzπdek bajt&oacute;w
liczby typu int r&oacute;wnej 1234567 (heksadecymalnie 0x12D687).<br>

  <br>

  <img src="images/Endianess.jpg" alt="r" border="1" height="299" width="363">
  <br>

  <br>

O tym jaki jest porzπdek bajt&oacute;w w buforach moøemy dowiedzieÊ siÍ za pomocπ
metody <b>order()</b>, kt&oacute;ra zwraca referencjÍ do obiektu klasy <b>ByteOrder</b>.<br>

W przypadku bufor&oacute;w bajtowych (i tylko dla nich) &nbsp;moøemy zmieniÊ porzπdek
za pomocπ wywo≥ania metody <b>order(ByteOrder)</b> z argumentem bÍdπcym sta≥π statycznπ
z klasy ByteOrder:<br>

  <br>


<ul>

    <li><b>
order (ByteOrder.BIG_ENDIAN) - zmienia porzπdek na BIG ENDIAN</b></li>

    <li><b>
order (ByteOrder.LITTLE_ENDIAN) - zmienia porzπdek na&nbsp;LITTLE ENDIAN</b></li>


</ul>



<div class="important"><b>Widoki</b> bufora bajtowego majπ ten porzπdek bajt&oacute;w, kt&oacute;ry wystÍpowa≥ dla
bufora bajtowego w momencie tworzenia widoku (moøemy powiedzieÊ, øe widok
dziedziczy porzπdek swojego bufora,&nbsp; bajtowego&nbsp;obowiπzujπcy w chwili tworzenia
widoku)</div>
<br>

  <br>

Ilustruje to poniøszy program:<br>

  <br>


<pre>
import java.nio.*;

class Endianness {

   static void show(int n) {
       String s = Integer.toHexString(n);
       int l = s.length();
       for (int i=l; i &lt; 8; i++) s = '0' + s;
       System.out.println("Liczba " + n + " hex -&gt; " + s.toUpperCase());
   }

   public static void main(String args[]) {
     int num = Integer.parseInt(args[0]);
     ByteBuffer buf = ByteBuffer.allocate(4);
     System.out.println(buf.order().toString());
     IntBuffer b1 = buf.asIntBuffer();
     System.out.println("Porzπdek b1 " + b1.order());
     b1.put(num);
     b1.flip();
     show(b1.get());
     buf.order(ByteOrder.LITTLE_ENDIAN);
     System.out.println("Porzπdek buf " + buf.order());
     System.out.println("Porzπdek b1 " + b1.order());
     b1.rewind();
     show(b1.get());
     System.out.println("Porzπdek buf " + buf.order());
     System.out.println("Porzπdek dziedzizcony " + buf.asIntBuffer().order());
     show(buf.asIntBuffer().get());
  }
}
</pre>

kt&oacute;ry dla podanej jako argument liczby 987654321 wyprowadzi nastÍpujπce wyniki:<br>

  <br>

<div class="listing100"><br>

BIG_ENDIAN<br>

Porzπdek b1 BIG_ENDIAN<br>

Liczba 987654321 hex -&gt; 3ADE68B1<br>

Porzπdek buf LITTLE_ENDIAN<br>

Porzπdek b1 BIG_ENDIAN<br>

Liczba 987654321 hex -&gt; 3ADE68B1<br>

Porzπdek buf LITTLE_ENDIAN<br>

Porzπdek dziedzizcony LITTLE_ENDIAN<br>

Liczba -1318527430 hex -&gt; B168DE3A<br>

</div>
<br>

  <br>

  <br>

<br>

  <a name="W5.21"></a>
<h2>
  K.6. NIO: bufory znakowe. Kodowanie i dekodowanie.&nbsp;</h2>

Bufory znakowe (klasa CharBuffer) reprezentujπ sekwencje element&oacute;w typu char (znaki unikodu).<br>
Majπ one wszystkie w≥aúciwoúci bufor&oacute;w (o kt&oacute;rych juø
by≥a mowa), ale dodatkowo zapewniajπ pewnπ specyficznπ funkcjonalnoúÊ.<br>

  <br>

Zauwaømy, øe sekwencje znak&oacute;w sπ reprezentowane r&oacute;wnieø przez obiekty klas String i StringBuffer. <br>

Od Javy 1.4 uog&oacute;lniono wiÍc pewne elementarne operacje na sekwencjach znak&oacute;w, wprowadzajπc interfejs <b>CharSequence</b>
. Interfej ten implementowany jest przez wszystkie klasy w/w klasy: String,
StringBuffer i CharBuffer, dziÍki czemu moøliwe jest (do pewnego stopnia)
uniwersalne operowanie na sekwencjach znak&oacute;w, niezaleznie od tego, czy sπ
one obiektami klas String, StringBuffer czy CharBuffer. <br>

  <br>

Metody interfejsu CharSequence podano w tablicy,<br>


<table border="1" cellpadding="3" cellspacing="0" width="100%">

  <tbody>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;char</code></td>
      <td><code><b>charAt</b>(int&nbsp;index)</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca znak na pozycji index</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;int</code></td>
      <td><code><b>length</b>()</code><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca d≥ugoúÊ sekwencji znak&oacute;w</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;CharSequence</code></td>
      <td><code><b>subSequence</b>(int&nbsp;start,
            int&nbsp;end)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
podsekwencjÍ od znaku na pozycji start do znaku na pozycji end
(wy≥acznie)</td>
    </tr>
    <tr class="TableRowColor" bgcolor="white">
      <td align="right" valign="top" width="1%"><code>&nbsp;String</code></td>
      <td><code><b>toString</b>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
referencjÍ do nowego obiektu klasy String, zawierajπcego tÍ sekwencjÍ
znak&oacute;w.</td>
    </tr>
  </tbody>

</table>

  <br>

Uøywajπc tych metod moøna napisac uniwersalnπ metodÍ operujπcπ na sekwencjach
znak&oacute;w, kt&oacute;ra jako argument moøe przyjmowaÊ referencjÍ do obiektu dowolnej
z klas: String, StringBUffer i CharBuffer (naleøy siÍ spodziewaÊ, øe zetsaw
metod interfejsu CharSequence zostanie w przysz≥oúci wzbogacony, co rozszerzy
moøliwoúci pisania uniwersalnych fragment&oacute;w kodu). Juø teraz zresztπ CharSequence
pe≥ni istotnπ uøytecznπ rolÍ, bowiem metody klas pakietu java.util.regex,
umozliwiajπce anlalizÍ ≥aÒcuch&oacute;w znakowych za pomocπ wyraøeÒ regularnych,
operujπ na obiektach typu CharSequence.<br>

  <br>

Z punktu widzenia bufor&oacute;w znakowych, wprowadzenie interfejsu CharSequence ma dwie waøne konsekwencje:<br>


<ul>

    <li>poza znanymi nam metodami buforowymi na buforach znakowych moøna operowac za pomocπ metod tego interfejsu, </li>

    <li>klasa CharBuffer dostarcza metody wrap opakowujπcej dowolnπ sekwencjÍ
znak&oacute;w (obiekt klasy implementujπcej interfejs CharSequence) i dziÍki temu
moøemy np. w nastÍpujπcy spos&oacute;b tworzyÊ bufory znakowe.:</li>


</ul>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String txt = editor.getText();<br>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer buf = CharBuffer.wrap(txt);<br>

  <br>

To mi≥e, øe mamy takie bufory znakowe, ale przecieø kana≥y mogπ operowac wy≥πcznie na buforach bajtowych.<br>

Przy kana≥owym czytaniu i zapisie strumieni tekstowych powstaje wiÍc problem kodowania i dekodowania informacji tekstowej. <br>

Znany nam spos&oacute;b kodowania-dekodowania za pomocπ klas InputStreamReader i
OutputStreamReader dotyczy tylko plik&oacute;w, a przy tym nie nadaje siÍ do zastosowania
przy polπczeniach kana≥owych, bowiem kana≥y plikowe moøna uzyskaÊ tylko od
obiekt&oacute;w klas FileInputStream, FileOutputStream i RandomAccessFile. <br>

  <br>

Dla rozwiπzania problemu dekodowania - kodowania moøna,&nbsp; co prawda, zastosowaÊ
klasÍ String, jak pokazuje poniøszy program (konwertujπcy pliki z jednej
strony kodowej na innπ).<br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class Ende1 {

  public static void main(String[] args) {

    if (args.length != 4) {
      System.out.println("Syntax: in in_enc out out_enc");
      System.exit(1);
    }

    String infile  = args[0],     // plik wejúciowy
           in_enc  = args[1],     // wejúciowa strona kodowa
           outfile = args[2],     // plik wyjúciowy
           out_enc = args[3];     // wyjúciowa strona kodowa

    try {
       FileChannel fcin = new FileInputStream(infile).getChannel();
       FileChannel fcout = new FileOutputStream(outfile).getChannel();
       ByteBuffer buf = ByteBuffer.allocate((int)fcin.size());

       // czytanie z kana≥u
       fcin.read(buf);

       // przeniesienie zawartoúci bufora do tablicy bytes
       buf.flip();
       byte[] bytes = new byte[buf.capacity()];
       buf.get(bytes);

       // dekodowanie - za pomocπ konstruktora klasy String
       String txt = new String(bytes, in_enc);

       // enkodowanie za pomocπ metody getBytes z klasy String
       // utworzenie nowego bufora dla kana≥u wyjúciowego
       // zapis do pliku poprzez kana≥
       bytes = txt.getBytes(out_enc);
       buf = ByteBuffer.wrap(bytes);
       fcout.write(buf);

       fcin.close();
       fcout.close();
    } catch (Exception e) {
        System.err.println(e);
        System.exit(1);
    }

  }
}&nbsp;</pre>

ale jest to rozwiπzanie dodatkowo obciπøajπce pamiÍÊ operacyjnπ oraz - jak widaÊ - ma≥o wygodne w programowaniu.<br>

  <br>

W NIO rozwiπzano problem kodowania-dekodowania za pomoca wprowadzenia nowych klas <b>Charset, CharsetDecoder, CharsetEncoder</b> w pakiecie java.nio.charset. <br>

  <br>


<ul>

    <li>Klasy CharsetDecoder i CharsetEncoder&nbsp; dostarczajπ
bogatych úrodk&oacute;w i pe≥nej kontroli nad procesem kodowania i
dekodowania. </li>


</ul>


<ul>

    <li>Klasa Charset dostarcza definicji stron kodowych, a takøe wygodnych
metod kodowania i dekodowania (kt&oacute;re sπ ≥atwiejsze w uøyciu niø zastosowanie
klas CharsetEncoder i CharsetDecoder).</li>


</ul>

<div class="syntax"><br>


<div align="center"><b>Dekodowanie-kodowanie za pomocπ Charset polega na:</b></div>


<ul>

    <li>utworzeniu obiektu klasy Charset, za pomocπ statycznej metody forName(String),
reprezentujπccgo stronÍ kodowπ, kt&oacute;rej nazwÍ podano jako argument np:</li>


</ul>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Charset charset = Charset.forName("ISO-8895-2");<br>

  <br>


<ul>

    <li><b>dekodowaniu</b> bajt&oacute;w z bufora bajtowego z danej strony kodowej
na sekwencjÍ znak&oacute;w Unicode, zapisanπ w buforze znakowym &nbsp;za pomocπ metody
decode(...):</li>


</ul>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ByteBuffer buf &nbsp;= ...<br>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer cbuf = charset.decode(buf);<br>

  <br>


<ul>

    <li>lub <b>kodowaniu</b> znak&oacute;w Unicodu z bufora znakowego
do bajt&oacute;w, reprezentujπcych tekst zakodowany wedle danej strony
kodowej w buforze bajtowym:</li>


</ul>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer cbuf&nbsp; = ...<br>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ByteBuffer buf = charset.encode(cbuf);<br>

</div>
<br>

&nbsp;<br>

InformacjÍ o nazwach dostÍpnych w danej implementacji JVM stron kodowych moøna
uzyskaÊ za pomocπ metody availCharsets() z klasy Charset.<br>

  <br>

Przyk≥adowy program pokazuje zastosowanie tej procedury do konwersji plik&oacute;w
z jednej strony kodowej na innπ (z wykorzystaniem kana≥&oacute;w).<br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;


class Ende2 {

  public static void main(String[] args) {

    if (args.length != 4) {
      System.out.println("Syntax: in in_enc out out_enc");
      System.exit(1);
    }

    String infile  = args[0],     // plik wejúciowy
           in_enc  = args[1],     // wejúciowa strona kodowa
           outfile = args[2],     // plik wyjúciowy
           out_enc = args[3];     // wyjúciowa strona kodowa

    try {
       FileChannel fcin = new FileInputStream(infile).getChannel();
       FileChannel fcout = new FileOutputStream(outfile).getChannel();
       ByteBuffer buf = ByteBuffer.allocate((int)fcin.size());

       // czytanie z kana≥u
       fcin.read(buf);

       // Strony kodowe
       Charset inCharset  = Charset.forName(in_enc),
               outCharset = Charset.forName(out_enc);

       // dekodowanie bufora bajtowego
       buf.flip();
       CharBuffer cbuf = inCharset.decode(buf);

       // enkodowanie bufora znakowego
       // i zapis do pliku poprzez kana≥

       buf = outCharset.encode(cbuf);
       fcout.write(buf);

       fcin.close();
       fcout.close();
    } catch (Exception e) {
        System.err.println(e);
        System.exit(1);
    }
  }
}
</pre>

  <br>

  <br>

  <a name="W5.22"></a>
<h2>K.7. NIO: operacje kana≥owe na wielu buforach (scattering i gathering)</h2>


  Kana≥y pozwalajπ za jednym odwo≥aniem czytaÊ dane do wielu bufor&oacute;w (<i><b>scatter read</b></i>) lub
zapisywaÊ dane z wielu bufor&oacute;w (<i><b>gather write</b></i>). <br>

S≥uøπ do tego metody read i write (z klas
kana≥owych), kt&oacute;re jako argument majπ <b>tablice bufor&oacute;w</b>.<br>

  <br>

  <br>

<br>

Jest to bardzo uøyteczna w≥aúciwoúÊ, pozwala bowiem w ≥atwiejszy spos&oacute;b &nbsp;programowaÊ
uzyskiwanie przez kana≥y danych, majπcych okreúlonπ strukturÍ, w kt&oacute;rej moøna
wyr&oacute;øniÊ jakieú czÍúci o okreúlonym rozmiarze.<br>

Przyk≥adem mogπ byÊ &nbsp;pliki graficzne lub dane z nag≥&oacute;wkami komunikacyjnymi.<br>

  <br>

Program testujπcy czytanie do wielu bufor&oacute;w.<br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class ScatteringTest {

  static final String fname = "scatter.tst";  // nazwa pliku testowego

  public static void main(String[] args) throws Exception {

    // Zapisywanie danych testowych

    DataOutputStream out = new DataOutputStream(
    	                       new FileOutputStream(fname) );
    short[]  dat1 = { 1, 2, 3, };
    double[] dat2 = { 10.1, 10.2, 10.3 };
    for (int i=0; i &lt; dat1.length; i++) out.writeShort(dat1[i]);
    for (int i=0; i &lt; dat2.length; i++) out.writeDouble(dat2[i]);
    out.close();

    //-----------------------------------------------------------+
    // Odczytywanie danych testowych                             |
    //-----------------------------------------------------------+

    FileInputStream in = new FileInputStream(fname);

    // Uzyskanie kana≥u
    FileChannel channel = in.getChannel();

    // Tablica bajt-bufor&oacute;w
    final int SHORT_SIZE  = 2,  // ile bajt&oacute;w ma short
              DOUBLE_SIZE = 8;  // ........... i double

    ByteBuffer[] buffers = { ByteBuffer.allocate(dat1.length*SHORT_SIZE),
                             ByteBuffer.allocate(dat2.length*DOUBLE_SIZE)
                           };
    <b>// jedno czytanie z kana≥u zapisuje kilka bufor&oacute;w !</b>
    long r = <b>channel.read(buffers)</b>;

    System.out.println("Liczba bajt&oacute;w przeczytanych do obu bufor&oacute;w: " + r);

    // Przed uzyskiwaniem danych z bufor&oacute;w - trzeba je przestawiÊ!
    buffers[0].flip();
    buffers[1].flip();

    // Pierwssy bufor
    // Widok na bufor jako na zawierajπcy liczby short
    ShortBuffer buf1 = buffers[0].asShortBuffer();
    System.out.println("Dane 1");
    while ( buf1.hasRemaining()) {
      short elt = buf1.get();
      System.out.println(elt);
    }

    // Drugi bufor
    // Widok na bufor jako na zawierajπcy liczby double
    DoubleBuffer buf2 = buffers[1].asDoubleBuffer();
    System.out.println("Dane 2");
    while ( buf2.hasRemaining()) System.out.println(buf2.get());
  }
}
</pre>

wyprowadzi nastÍpujπce wyniki:<br>

<div class="listing100">Liczba bajt&oacute;w przeczytanych do obu bufor&oacute;w: 30<br>

Dane 1<br>

1<br>

2<br>

3<br>

Dane 2<br>

10.1<br>

10.2<br>

10.3</div>
<br>

  <br>

R&oacute;wnieø przy zapisywaniu danych przez kana≥y, moøliwoúÊ jednorazowego zapisu
z wielu bufor&oacute;w moøe byÊ wielce wygodna. Np. w pewnych buforach moøemy przygotowaÊ
sta≥e fragmenty danych i juø ich nie zmieniaÊ, inne zaú bufory wype≥niaÊ
dynamicznie zmieniajπcπ siÍ treúciπ.<br>

Potrzebne bÍdzie tylko jedno wywo≥anie metody write, by zapisaÊ ca≥y zestaw
bufor&oacute;w (co opr&oacute;cz wygody programistycznej ma r&oacute;wnieø pozytywny wp≥yw na efektywnoúÊ
dzia≥ania naszego programu).<br>

  <br>

Przyk≥adowy program zapisuje kilka plik&oacute;w, kaødy z kt&oacute;rych ma taki sam nag≥&oacute;wek
i zakoÒczenie. CzÍsÊ úrodkowπ wype≥niajπ zmieniajπce siÍ - od pliku do pliku
- dane.<br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

class GatheringTest {

  public static void main(String[] args) throws Exception {

    // To bÍdπ sta≥e czÍúci kaødego pliku
    String sHeader = "To jest nag≥&oacute;wek. Moøe byÊ duøy";
    String sFooter = "To jest zakoÒczenie. Moøe byÊ duøe";

    // To bÍdπ dane, kt&oacute;re siÍ zmieniajπ od pliku do pliku
    byte[][] dane = { { 1, 2, 3},       // dane 1-go pliku
                     { 9, 10, 11, 12 }, // dane 2-go pliku
                     { 100, 101}        // dane 3-go pliku
                   };

    Charset charset = Charset.forName("windows-1250");
    ByteBuffer header = charset.encode(CharBuffer.wrap(sHeader)),
               footer = charset.encode(CharBuffer.wrap(sFooter));

    // Drugi element tablicy bufor&oacute;w bÍdzie dynamicznie siÍ zmienial
    // na razie = null
    ByteBuffer[] contents = { header, null, footer };
    for (int i = 0; i&lt;dane.length; i++) {
      FileChannel fc = new FileOutputStream("plik"+i).getChannel();
      contents[1] = ByteBuffer.wrap(dane[i]);  // podstawienie zmiennych danych
      <b>fc.write(contents);</b>                      // zapis danych ze wszystkich bufor&oacute;w!
      fc.close();
      header.rewind();
      footer.rewind();
    }
  }


}
</pre>

<br>

Czytanie i pisanie "po wielu buforach" od razu, nazywane takøe wektorowym wejúciem-wyjúciem (<i><b>vectored I/O</b></i>) jest <b>atomistyczne</b>
 nie tylko w tym sensie, øe realizowane jest przez jedno odwo≥anie z poziomu
programu. Na nowoczesnych platformach systemowych daje ono duøπ poprawÍ efektywnoúci,
bowiem nastÍpuje znaczna redukcja liczby niskopoziomowych (na poziomie jπdra
systemu) operacji we/wy oraz ich optymalizacja (w skrajnym przypadku do atomistycznej
- pojedynczej - calkowicie zoptymalizowanej niskopoziomowej operacji we/wy).<br>

  <br>

<br>

  <a name="W5.23"></a>
<h2>
K.8. NIO: mapowanie plik&oacute;w</h2>



<div class="def">Mapowanie pliku polega na odzwierciedleniu ca≥oúci lub czÍúci pliku w pamiÍci, bezpoúrednio dostÍpnej dla programu.</div>
<br>

  <br>

Mapowanie pliku w NIO uzyskujemy poprzez uzyskanie kana≥u pod≥πczonego do
pliku (niech oznacza go zmienna channel), a nastÍpnie uøycie metody map z
klasy FileChannel. Metoda ta zwraca referencjÍ do obiektu klasy MappedByteBuffer
(pochodnej od Buffer), kt&oacute;ry jest bajtowym buforem bezpoúrednim (direct),
zawierajπcym bajty pliku lub jego wybranego segmentu.<br>

  <br>

<div class="syntax"><br>


<div align="center"><b>Mapowanie pliku</b><br>


<div align="left"><br>

  </div>

  </div>

&nbsp;&nbsp;&nbsp; FileChannel channel = ....; // pod≥πczenie kana≥u do pliku<br>

&nbsp;&nbsp;&nbsp; MappedByteBuffer buf = channel.map( tryb, pozycja, rozmiar);<br>

  <br>

gdzie:<br>


<ul>

    <li>buf - bufor bajtowy, reprezentujπcy zwartoúÊ pliku lub jego segmentu<br>

    </li>

    <li>tryb - jedna z opcji bÍdπcych sta≥ymi statycznymi klasy FileChannel.MapMode o nazwach</li>


  <ul>

      <li>READ_ONLY - moøliwe tylko odczytywanie bufora</li>

      <li>READ_WRITE - moøliwe zmiany w buforze i ew. automatycznej propagacji
zmian do pliku i ew. widocznoúi tych zmian przez inne programy mapujπce ten
sam plik,</li>

      <li>PRIVATE - moøliwe zmiany w buforze, ale bez propagowania ich do
pliku (bÍdπ wiÍc niewidoczne dla innych program&oacute;w mapujπcych ten plik)</li>


  </ul>

    <li>pozycja - pzocucja pliku, od ktorej zaczyna siÍ mapowanie</li>

    <li>rozmiar - rozmiar mapowanego segmentu pliku<br>

    </li>


</ul>

</div>
<br>

  <br>

Po zmapowaniu pliku, na uzyskanym buforze bajtowym i jego widokach moøemy
wykonywaÊ operacje, znane nam z klas buforowych, a operacje te de-facto bÍdπ
operacjami na zawartoúci pliku. <br>

  <br>

DostÍpne tryby dzialania zaleøπ od tryb&oacute;w pod≥πczenia (otwarcia) kana≥u.<br>

Tryb READ_ONLY moøe byÊ uøyty tylko dla kana≥&oacute;w otwartych do czytania, natomiast
tryby READ_WRITE oraz PRIVATE wymagajπ kana≥&oacute;w otwartych w trybie odczytu-zapisu.<br>

  <br>

OdpowiednioúÊ miÍdzy trybami kana≥&oacute;w, a rodzajami plik&oacute;w/strumieni pokazuje poniøsza tablica.<br>

  <br>


<table border="1" cellpadding="2" cellspacing="2" width="100%">

    <tbody>

      <tr>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Tryb mapowania<br>

        </b></div>

        </td>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Tryb otwarcia kana≥u<br>

        </b></div>

        </td>

        <td bgcolor="#ffcccc" valign="top">

      <div align="center"><b>Rodzaj pliku, <br>

do kt&oacute;rego pod≥πczamy kana≥<br>

metodπ getChannel()<br>

        </b></div>

        </td>

      </tr>

      <tr>

        <td valign="top">READ_ONLY<br>

        </td>

        <td valign="top">tylko do odczytu<br>

        </td>

        <td valign="top">FileInputStream<br>

RandomAccesFile otwarty w trybie tylko do odczytu ("r")<br>

        </td>

      </tr>

      <tr>

        <td valign="top">READ_WRITE<br>

PRIVATE<br>

        </td>

        <td valign="top"><br>

do odczytu-zapisu <br>

        </td>

        <td valign="top"><br>

RandomAccesFile otwarty w trybie pisania-czytania ("rw")<br>

        </td>

      </tr>


  </tbody>

</table>

  <br>

  <br>

Mapowanie plik&oacute;w moøe byÊ wygodne z punktu widzenia programowania (dzia≥anie
na pliku jak na buforze i jego widokach - lub w niekt&oacute;rych przypadkach jak
na tablicy).<br>

  <br>

<div class="important">Ale nie tylko to jest zaletπ mapowania plik&oacute;w. <br>

Ot&oacute;ø uzyskiwany bufor mapujπcy (obiekt klasy MappedByteBuffer) &nbsp;jest <b>buforem bezpoúrednim</b>, czyli alokowanym poza przestrzeniπ adresowπ programu . <br>

W&nbsp;nowoczesnych systemach operacyjnych moøe on prawie w og&oacute;le nie zajmowaÊ
pamiÍci systemu! &nbsp;Oczywiúcie jakieú fragmenty pamiÍci sπ uøywane dla prowadzenia
odwzorowania, ale generalnie strony pamiÍci wirtualnej nie sπ zajÍte. Obszarem
stronicowanie jest sam plik!</div>
<br>

  <br>

Sprawia to, iø wiele program&oacute;w naraz moøe mapowaÊ ten sam duøy plik i dzia≥aÊ
na nim, nawet jeúli sumaryczna wielkoúÊ wszystkich odwzorowaÒ przekracza
wielkoúÊ dostÍpnej pamiÍci operacyjnej.<br>

Z drugiej strony, to øe bufory dla mapowanych plik&oacute;w sπ bezpoúrednie (czyli
alokowane gdzieú poza programami) sprawia, øe mapowane pliki mogπ stanowiÊ
wygodnπ realizacjÍ <b>pamiÍci dzielonej</b> (przez r&oacute;øne procesy) i sposobem na komunikwoanie siÍ tych proces&oacute;w.<br>

  <br>

Zobaczmy przyk≥ady.<br>

Pierwszy program ilustracyjny zapisuje najpierw plik testowy liczbami ca≥kowitymi,
nastÍpnie uzyskuje kana≥ i mapuje plik, po czym wykonuje zmiany w tym pliku,
operujπc wylπcznie na mapujπcym buforze. <br>

  <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class MapFiles1 {

  String fname = "test";

  public MapFiles1() throws Exception {
    init();         // inicjacja pliku testowego
    mapAndChange(); // mapowanie i zmiana danych pliku
    checkResult();  // sprawdzenie wynik&oacute;w
  }

  void init() throws IOException {
    int[] data = { 10, 11, 12, 13 };
    DataOutputStream out = new DataOutputStream(
                               new FileOutputStream(fname)
                            );
    for (int i=0; i&lt;data.length; i++) out.writeInt(data[i]);
    out.close();
  }

  void mapAndChange() throws IOException {

    // Aby dokonywaÊ zmian musimy przy≥πczyÊ kanal
    // do pliku otwartego w trybie "read-write"
    RandomAccessFile file =  new RandomAccessFile(fname, "rw");
    FileChannel channel = file.getChannel();

    // Mapowanie pliku
    MappedByteBuffer buf;
    buf  = channel.map(
                FileChannel.MapMode.READ_WRITE,  // tryb "odczyt-zapis"
                                             0,  // od poczπtku pliku
                            (int)channel.size()  // ca≥y plik
            );

    // Uzyskujemy widok na bufor = zmapowany plik
    IntBuffer ibuf = buf.asIntBuffer();

    // Dla ciekawoúci: jakie charakterystyki widoku
    System.out.println(ibuf + " --- Direct: " +  ibuf.isDirect());

    int i = 0;
    while (ibuf.hasRemaining()) {
      int num = ibuf.get();       // pobieramy kolejny element
      ibuf.put(i++, num * 10);    // zapisujemy jego wartoúÊ*10 na jego pozycji    }
    }

    // Zapewnia, øe zmiany na pewno zostanπ odzwierciedlone w pliku
    buf.force();

    channel.close();
  }

  void checkResult() throws IOException {
    DataInputStream in = null;
    try {
      in = new DataInputStream(new FileInputStream(fname));
      while(true) System.out.println(in.readInt());
    } catch(EOFException exc) {
        return;
    } finally {
        in.close();
    }
  }

  public static void main(String[] args) throws Exception  {
    new MapFiles1();
  }
}
</pre>

Program wyprowadzi:<br>

<div class="listing100">java.nio.DirectIntBufferS[pos=0 lim=4 cap=4] --- Direct: true<br>

100<br>

110<br>

120<br>

130</div>
<br>

  <br>

Na przyk≥adzie tego programu warto zwr&oacute;ciÊ uwagÍ na nastÍpujπce kwestie:<br>


<ul>

    <li>program praktycznie nie konsumuje pamiÍci dla przechowywania pliku
(zar&oacute;wno MappedByteBuffer, jak i jego widok jako IntBuffer sπ buforami bezpoúrednimi)</li>

    <li>po zmapowaniu pliku, pozycja bufora bajtowego jest ustawiona na
0, &nbsp;a jego pojemnoúÊ i limit na liczbÍ zmapowanych bajt&oacute;w; widoki "dziedziczπ"
te ustawienia, dokonujπc jedynie przeliczeÒ limitu i pojmenoúci z uwzglÍdnieniem
rozmiaru typu element&oacute;w,<br>

    </li>

    <li>uøycie metody <b>force()</b> z klasy MappedByteBuffer zapewnia fizyczny
zapis do pliku; spos&oacute;b i czÍstostliwoúÊ fizycznego zapisu zmienianych w buforze
danych zaleøy od systemu operacyjnego, moøe siÍ okazaÊ, øe nawet po zamkniÍciu
kana≥u, systemowe czy sprzÍtowe cache/bufory nie sπ wymiatane.</li>


</ul>

Drugi program ma trochÍ bardziej praktyczne zastosowanie. Pozwala on "w miejscu"
zmieniÊ kodowanie podanego jako argument pliku z Windows1250 na ISO-8859-2
jednoczeúnie zamieniajπc wszystkie litery na duøe.<br>

Przy okazji zobaczymy, øe:<br>


<ul>

    <li>dekodowanie bufora bajtowego tworzy nowy bufor znakowy, kt&oacute;ry opakowuje
tablicÍ element&oacute;w typu char[]. Ta tablica istnieje (ona w≥asnie, praktycznie,
jest tym buforem znakowym) i moøemy mieÊ do niej dostÍp poprzez odwo≥anie
      <b>array()</b> z klasy CharBuffer (dla wszystkich klas buforowych metoda array zwraca tablicÍ opakowanπ przez bufor, ale tylko wtedy, <b>gdy takie opakowanie mia≥o miejsce</b>),</li>

    <li>czasem potrzebne moøe byÊ zastosowanie klasy CharsetEncoder (jej
metody encode uøywamy po to by dokonaÊ kodowania do juø istniejπcego bufora
bajtowego, &nbsp;w naszym przypadku - mapujπcego plik). Analogicznie (ale niejako
w drugπ stronÍ)&nbsp; moøe byÊ zastosowana klasa CharsetDecoder.</li>


</ul>

Oto tekst programu. ProszÍ go przetestowac na jakimú samodzielnie utworzonym
pliku html, zapisanym w stronie kodowej Windows 1250). <br>


<pre>
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

class MapFiles2 {

  public static void main(String[] args) throws Exception  {
    Charset inCharset = Charset.forName("windows-1250"),
           outCharset = Charset.forName("ISO-8859-2");

    RandomAccessFile file = new RandomAccessFile(args[0], "rw");
    FileChannel fc = file.getChannel();

    // Mapowanie pliku
    MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE,
                                  0, (int) fc.size());

    // Utworzenia bufora znakowego ze zdekodowanymi znakami
    // z bufora bajtowego (mapujπce plik). Konwersja: win1250-&gt;unicode
    CharBuffer cbuf = inCharset.decode(mbb);

    // Okazuje siÍ, øe ten nowo utworzony bufor opakowuje tablicÍ
    // zatem moøemy jπ uzyskaÊ i dzia≥aÊ na jej elementach
    // to dzialanie oznacza dzialanie na elementach bufora
    char[] chArr = cbuf.array();
    for (int i=0; i &lt; chArr.length; i++)
      chArr[i] = Character.toUpperCase(chArr[i]);

    // Po dekodowaniu bufor bajtowy musi byÊ przewiniÍty do poczπtku
    // aby koder (zob. dalej) m&oacute;g≥ w nim zapisywaÊ kodowane dane
    mbb.rewind();

    // Utworzenie kodera, zamieniajπcego Unicode na wyjúciowπ stronÍ kodowπ
    CharsetEncoder encoder = outCharset.newEncoder();

    // Koder zapisuje istniejπcy bufor mbb (ten kt&oacute;ry mapuje plik)
    // ostatni argument - true oznacza zakoÒczenie pracy kodera na tym wywo≥aniu
    encoder.encode(cbuf, mbb, true);
    fc.close();
  }
}
</pre>

  <br>

  <br>

<br>

  <a name="W5.24"></a>
<h2>
K.9. NIO: bezpoúrednie transfery kana≥owe</h2>



<div class="def">Bezpoúredni transfer kana≥owy polega na przeslaniu wszystkich danych
jednego kana≥u do drugiego kana≥u za pomocπ jednego odwo≥ania z poziomu programu,
z moøliwym (w zaleønoúci od systemu operacyjnego i platformy sprzÍtowej)
pominiÍciem systemowych operacji wejúcia-wyjúcia, a zrealizowanym jako bardzo
szybki trarnsfer wykonywany przez sam sprzÍt ze wsparciem ze strony jπdra
systemu</div>
&nbsp; <br>

  <br>

Obecnie w NIO bezpoúrednie transfery kana≥owe dotyczπ tarnsfer&oacute;w do/z plik&oacute;w.<br>

Klasa FileChannel dostarcza dw&oacute;ch metod, kt&oacute;re pozwalajπ na:<br>

  <br>


<ul>

    <li>bezpoúredni transfer kana≥owy z dowolnego kanalu do kanalu plikowego (metoda <b>transferTo</b>)</li>

    <li>bezpoúredni transfer kanalowy z kanalu plikowego do dowlonego kana≥u (metoda <b>transferFrom</b>)</li>


</ul>

Bezpoúrednie transfery kana≥owe w systemach, kt&oacute;re w swoim jπdrze zapewniajπ
wsparcie takich transfer&oacute;w, mogπ byÊ bardzo szybkie i efektywne. <br>

W innych systemach (jak np. Windows), poprawa efektywnoúci (w por&oacute;wnaniu
z tradycyjnymi sposobami kopiowania danych) moøe byÊ r&oacute;øna, nawet doúÊ nieznaczna.<br>

  <br>

Zawsze jednak zaletπ stosowania metod <b>transfer...</b> &nbsp;z klasy FileChannel
pozostaje moøliwoúc unikniÍcia potrzeby programowania (w kliku wierszach,
ale zawsze to trochÍ pracy) procedur kopiowania danych z/do plik&oacute;w.<br>

  <br>

Oto przyk≥adowy program, por&oacute;wnujπcy dwa sposoby kopiowania plik&oacute;w: za pomocπ
bezpoúredniego transferu kana≥owego i poprzez buforowane strumienie.<br>


<pre>
import java.nio.*;
import java.nio.channels.*;
import java.io.*;

class DirectTransfer {

  String inFileName;
  String outFileName;

  DirectTransfer(String infn, String outfn) throws Exception {
    inFileName  = infn;
    outFileName = outfn;
    directTransfer();
    copyByStream();
  }


  void directTransfer() throws Exception {

    FileInputStream in = new FileInputStream(inFileName);
    FileOutputStream out =  new FileOutputStream(outFileName);
    FileChannel fcin = in.getChannel();
    FileChannel fcout = out.getChannel();
    long size = fcin.size();
    System.out.println("Copying file " + size + "B.");

    long start =  System.currentTimeMillis();

    // Bezpoúredni transfer
    fcout.transferFrom(fcin, 0, size);

    long end = System.currentTimeMillis();

    System.out.println("Direct transfer time " + (end - start));

   }


  final int BUFSIZE = 5000000;
  void copyByStream() throws Exception  {

    FileInputStream fin = new FileInputStream(inFileName);
    BufferedInputStream in = new BufferedInputStream(fin, BUFSIZE );
    FileOutputStream fout = new FileOutputStream(outFileName);
    BufferedOutputStream out = new BufferedOutputStream(fout, BUFSIZE);

    byte[] b = new byte[BUFSIZE];
    long start =  System.currentTimeMillis();
    while (true) {
      int n = in.read(b);
      if (n == -1) break;
      out.write(b, 0, n);
    }
    in.close();
    out.close();

    long end = System.currentTimeMillis();
    System.out.println("Stream time " + (end - start));
  }


   public static void main(String[] args) throws Exception {
     new DirectTransfer(args[0], args[1]);
   }
}
</pre>

Moøliwy wynik:<br>

<div class="listing100"><br>

Copying file 51793936B.<br>

Direct transfer time 2470<br>

Stream time 6150</div>
<br>

  <br>

  <br>

<br>

  <br>

</body>
</html>
