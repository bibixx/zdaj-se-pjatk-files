<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Podstawy programowania (Java)">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2008">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Aplikacje WEB</title></head>
<body>
<div align="center">
<a name="WebApps"></a><h1>Aplikacje WEB</h1>
</div>
<hr>
<span style="font-style: italic;">Aplikacje WEB stanowi¹ istotny element wspó³czesnych systemów informatycznych.
Umo¿liwiaj¹ one dostêp i interakcjê do rozlicznych serwisów i systemów informatycznych
w œrodowisku rozproszonym, sieciowym, przy wykorzystaniu&nbsp;prostych i
uniwersalnych protoko³ów. Temat jest niezwykle rozleg³y, móg³by stanowiæ
w³aœciwie treœæ odrêbnej, du¿ej monografii. Tutaj przedstawimy wprowadzenie
do tej tematyki, staraj¹c sie przy tym podaæ podstawy -&nbsp; niezbêdne i przydatne
do dalszego studiowania technologii programowania aplikacji WEB.</span><br>
<hr>
<a name="WebApps.1"></a><h2>1. Technologie programowania aplikacji WEB</h2>
Korzystaj¹c z Internetu na co dzieñ stykamy siê z aplikacjami WEB. <br>
<br>
<div class="def">Aplikacje WEB stanowi¹ zestaw komponentów programistycznych, dzia³aj¹cych
po stronie serwera i dynamicznie reaguj¹cych na zlecenia ze strony programów&nbsp;
klienckich, zg³aszane za poœrednictwem protoko³u sieciowego (w szczególnoœci
HTTP). </div><br>
<br>
Aplikacje WEB maj¹ szerokie zastosowania, g³ównie w Internecie i intranecie, obejmuj¹ce m.in.:<br>
<ul>
  <li>dynamiczne generowanie treœci stron WWW,</li>
  <li>proste, bezpoœrednie przetwarzanie zleceñ klienckich,</li>
  <li>kontrolowanie komunikacji z klientami - statystyki, zabezpieczenia, odtwarzanie informacji (sesje, cookies),</li>
  <li>dostarczanie informacji z baz danych,</li>
  <li>poœredniczenie pomiêdzy programami klienckimi, a systemami informacyjnymi
firmy w  wykonywaniu zadañ z zakresu z³o¿onej logiki biznesowej.</li>
</ul>
Wspomniane programy klienckie s¹ zazwyczaj przegl¹darkami stron WWW (ze wzglêdu
na uniwersalny, powszechnie dostêpny charakter tego interfejsu), ale mog¹
równie¿ obejmowaæ takie komponenty jak aplety, czy nawet stanowiæ wyspecjalizowane
"wolnostoj¹ce" programy. Takie programy i takie aplety bed¹ wtedy stanowiæ
"klienck¹" czêsæ aplikacji WEB. W ka¿dym przypadku jednak j¹drem aplikacji s¹ komponenty
dzia³aj¹ce po stronie serwera.<br>
<br>
Œrodowisko Javy doskonale nadaje siê do tworzenia aplikacji WEB, bowiem:<br>
<ul>
  <li>dostarcza wyspecjalizowanych technologii tworzenia tzw. web-komponentów,
czyli komponentów, które obs³uguj¹ zlecenia, a w szczególnoœci potrafi¹ reagowaæ
na nie dynamiczn¹ generacj¹ treœci,</li>
  <li>implementuje koncepcje programowania kompnentowego (JavaBeans), co
sprzyja nie tylko prostocie tworzenia aplikacji (np. w œrodowiskach programistycznych),
ale równie¿, czy mo¿e przede wszystkim, elastycznemu separowaniu treœci i
prezentacji,</li>
  <li>zapewnia uniwersalny, spójny z innymi œrodkami jêzyka, mechanizm dostêpu do baz danych (JDBC),</li>
  <li>wzmacnia to wszystko bogactwem standardowych pakietów Javy, które
-&nbsp; oczywiœcie - mo¿emy wykorzystywaæ na poziomie apliakacji WEB.</li>
</ul>
Przyk³adowy schemat dzia³ania aplikacji WEB pokazuje rysunek.<br>
<br>Rys. Dzia³anie aplikacji WEB<br><br><img style="border: 1px solid ; width: 605px; height: 393px;" alt="r" src="images/IntroIWAa.gif"><br><br>1 - zlecenie klienta<br>2 - odebrane przez kompoenn WEB<br>3 - odow³anie do klas realizuj¹cych logikê<br>4,5 - siêgniêcie po dane i ich odbiór<br>6&nbsp;- &nbsp;komponent WEB odbira wyniki pretwarzania,<br>7,8 - przekazanie wyników klientowi<br>
<br>
Podstawow¹ technologi¹, s³u¿¹c¹ w Javie do tworzenia aplikacji WEB jest technologia <b>serwletów</b> (<b>Java Servlet Technology</b>).<br>
<br>
<div class="def"><b>Serwlet</b> jest klas¹ Javy, rozszerzaj¹c¹ funkcjonalnoœæ serwerów
w przetwarzaniu zleceñ programów klienckich.<br>Przy programowaniu serwletów
wykorzystujemy klasy z pakietu &nbsp;javax.servlet - stanowi¹cego interfejs programistyczny
Servlet API. Klasy te i ich metody dostarczaj¹ ró¿norodnych œrodków odbierania
i reagowania na zlecenia klientów oraz przesy³ania im wyników (odpowiedzi).</div><br>
<br> Serwlet mo¿e (a nawet powinien) pelniæ rolê kontrolera w aplikacjach
WEB budowanych w oparciu o paradygmat "Model-View-Controller" i zajmowaæ
siê odbieraniem zleceñ, zarz¹dzaniem nimi, przekazywaniem ich innym komponentom
programowym, odbieraniem od nich wyników i przekazywaniem modu³om prezentacyjnym.
Wa¿ne jest przy tym, by w strukturze aplikacji WEB wystêpowa³a wyra¿na separacja
pomiêdzy danymi, a ich prezentacj¹.<br>
Technologia serwletów - jako najwczeœniejsza technologia programowania komponentów
Web w Javie - nie wymusza jednak spe³nienia tego wymagania. Nader czêsto
serwlety u¿ywane by³y (i s¹) do generowania dynamicznych stron WWW w taki
sposób, ¿e kod odpowiedzialny za prezentacjê (tworzenie wygl¹du strony) zmieszany
jest z kodem, odpowiedzialnyn za logikê przetwarzania danych. Niejednokrotnie
takiego pomieszania - w przypadku "czystych" serwletów trudno jest unikn¹æ.<br>
<br>
Technologia <b>Java Server Pages (JSP)</b> po czêœci odpowiada na to wyzwanie,
jednoczeœnie nieco upraszczaj¹c tworzenie czeœci aplikacji webowych, szczególnie
tych odpowiedzialnych za wygl¹d.&nbsp; Traktowana najpierw jako g³ównie swoisty
jêzyk skryptowy (strona JSP zawiera statyczn¹ treœæ np. w jêzyku HTML oraz
treœæ dynamiczn¹, generowan¹ przez elementy JSP), obecnie akcentuje deklaratywne
<b>znaczniki</b>, które - w trakcie interpretacji strony - "wywo³uj¹" okreœlone
procedury.&nbsp; Wprowadzeniu standardowej biblioteki znaczników <b>(Java Server Pages Standard Tag Library)</b>
 da³o twórcom aplikacji WEB uniwersalne i stosunkowo ³atwe (przede wszystkim
dla tych co nie znaj¹ Javy)&nbsp; sposoby uzyskiwania ró¿norodnej funckjonalnoœci.<br>
W pewnym sensie JSP jest "tylko" nak³adk¹ na serwlety: istotnie strony JSP
s¹ - przy pierwszym do nich odwo³aniu - t³umaczone na serwlety, a te ostatnie
sa kompilowane "w locie" i wykonywane przez serwer aplikacji.<br>
<br> I wreszcie, swoistym uzupe³nieniem do "czystych" serwletów i JSP jest&nbsp;technologia&nbsp;<b>Java Server Faces</b>
. przeznaczona do elastycznego generowania GUI aplikacji WEB po stronie serwera, ale przede
wszystkim umo¿liwiaj¹ca lepsz¹ separacjê modeli i widoków, której - mimo wszystko - JSP do koñca nie zapewnia.<br>
<br>
Relacje pomiêdzy podstawowymi technologiami Javy, s³u¿¹cymi tworzeniu aplikacji WEB przedstawia rysunek.<br><br><img style="border: 1px solid ; width: 528px; height: 248px;" alt="r" src="images/IntroIWAa2.gif"><br><br>Nowe
trendy w tworzeniu aplikacji WEB dotykaj¹ przede wszystkim u³atwionych
sposobów programowania (tutaj wymieniæ mo¿na œrodowisko Grails = Groovy
on Rails), a tak¿e zmian po stronie programowania klientów, zwi¹zanych
z zastosowaniem rozbudowanych bibliotek JavaScript i technologii (czy
raczej podejœcia) AJAX. AJAX (Asynchrounous Java Script and XML) polega
na &nbsp;asynchronicznym (nie wymagaj¹cym prze³adowania stron)
odbierania przez klienta danych od serwera, co umozliwia tworzenie
prawdziwie interaktywnych stron WEB.<br><br>
W niniejszym rozdziale omówimy zagadnienia zwi¹zane z konstrukcj¹, rozwijaniem
i wdra¿eniem aplikacji WEB, skupiaj¹c uwagê na serwletach. Niestety, ograniczona
objêtoœæ nie pozwala na pe³niejsze przedstawienie technologii JSP i Java Server Faces.
Ta pierwsza jest zreszt¹ technologi¹ raczej "nieprogramistyczn¹".&nbsp;<br>
Co wiêcej, w przypadku obu tych technologii mamy wyraŸne odniesienia do serwletów,
które stanowi¹ dla nich bazê. Dlatego opanowanie programowania aplikacji
WEB g³ównie pod k¹tem serwletów nie jest strat¹ czasu: bêdzie sprzyjaæ ³atwiejszemu
i pe³niejszemu rozumieniu rozszerzaj¹cych mechanizmów JSP i JSF. O nich powiemy tylko kilka s³ów w koñcowym podpunkcie.<br>Równie¿
AJAX dobrze wpisuje siê w zastosowania serwletów jako podstawoego
"budulaca"&nbsp; modu³ów dzialaj¹cych po stronie serwera.<br>
&nbsp;<hr style="width: 100%; height: 2px;"><a name="WebApps.2"></a><h2>2. Wdra¿anie i uruchamianie aplikacji WEB</h2>Aplikacje WEB wykonywane
s¹ w œrodowisku serwerów aplikacji. Serwery zarz¹dzaj¹ aplikacjami i ich wykonaniem
(np. w szczególnoœci ³adowaniem i wywo³ywaniem serwletów, przekazywaniem
zleceñ, polityk¹ bezpieczeñstwa itp.). Aby to robiæ, serwery musz¹ mieæ dostêp
do informacji o aplikacji, jej umiejscowieniu i pewnych w³aœciwoœciach. &nbsp;
Nie wystarczy zatem samo oprogramowanie i skompilowanie programów (klas),
trzeba jeszcze aplikacjê skonfigurowaæ, distarczyæ odpowiednich informacji
o niej oraz odpowiednio umiejscowiæ. Nazywa siê to <b>wdro¿eniem </b>(deployment) aplikacji.<br>
<br> Istnieje wiele ró¿nych <span style="font-weight: bold;">serwerów aplikacji</span> (np. IBM WebSphere, JBoss,
BEA WebLogic),&nbsp; które wraz z obs³ug¹ aplikacji WEB œwiadcz¹ us³ugi typu "middleware"
w oparciu o platformê Enterprise Java Beans (w ramach tych serwerów aplikacji
mo¿na wyró¿niæ serwer EJB i serwer WEB). &nbsp;Istniej¹ te¿ samodzielne serwery
WEB, które zajmuj¹ siê przede wszystkim obs³ug¹ aplikacji WEB (np. Tomcat), ew. dodatkowo umiej¹c ³¹czyæ sie z serwerami EJB.<br>
Proces wdra¿ania aplikacji WEB na wszystkich tych serwerach jest ideowo podobny i (ogólnie) polega na:<br>
<ul>
  <li>
stworzeniu pliku tzw. <b>deskryptora wdro¿enia</b> <b>(web deployment descriptor</b>) o nazwie <b>web.xml</b>,</li>
  <li>
ew. stworzenie dodatkowych specjalnych&nbsp; plików opisowych (np. dla bibliotek znaczników JSP),</li>
  <li>
umiejscowienie wszystkich komponentów aplikacji (klas, stron HTML, stron
JSP, plików graficznych i dŸwiêkowych) oraz pliku deskryptora wdro¿enia w
odpowiedniej, œciœle okreœlonej, strukturze katalogowej,</li>
  <li>
dostarczenie serwerowi &nbsp;œcie¿ki kontekstu aplikacji (<b>context-path</b>).</li>
</ul>
Zacznijmy od koñca. Ka¿da aplikacja WEB ma swój <b>kontekst&nbsp;</b> swoiste
œrodowisko izolowane od innych aplikacji dzia³aj¹cych na danym serwerze.
Kontekst umo¿liwia m.in wymianê i dzielenia informacji pomiêdzy komponentami
tej samej aplikacji (np. róznymi serwletami, które stanowia jej komponenty),
jak równie¿ komunikowanie siê aplikacji z serwerem. Serwer uruchamia aplikacjê
w jej kontekœcie (tworzy dla niej kontekst) i identyfikuje j¹ poprzez nazwê
kontekstu (œcie¿kê kontekstu). Aplikacja jest reprezentowana przez jej kontekst. Œcie¿ka kontekstu s³u¿y tak¿e do wywo³ywania
aplikacji lub jej czêœci z poziomu programów klienckich. Pomiêdzy œcie¿k¹
kontekstu a realnym umiejscowieniem&nbsp; struktury katalogowej aplikacji na fizycznej
maszynie musi byæ ustanowiona&nbsp; odpowiednioœæ (inaczej serwer nie odnalaz³by
komponentów aplikacji). <br>
<br>
<b>Struktura katalogowa aplikacji </b>jest œciœle okreœlona. Komponenty i deskryptory aplikacji musz¹ byæ ulokowane w nastêpuj¹cy sposób:<br>
<br>
<img src="images/StruktWebAp.jpg" alt="r" height="531" width="524">
<br>
<br>
G³ówny katalog aplikacji - MojaAp (1) zawiera katalog WEB-INF oraz mo¿e, ale nie musi zawieraæ strony
JSP, a tak¿e dowolne komponenty typu dokumenty HTML, XML. pliki graficzne
itp. (dostêpne dla u¿ytkownika).<br>
Kluczow¹ rolê spe³nia podkatalog WEB-INF (2). Zawiera on:<br>
<ul>
  <li>plik deskryptora wdro¿enia (<b>web.xml</b>) - <b>koniecznie!</b></li>
  <li>pliki deskryptorów znaczników bobliotek JSP (z rozszerzeniem *.tld) - o ile stosujemy biblioteki znaczników,</li>
  <li>plik konfiguracji Java Server Faces (faces-config.xml) - o ile stosujemy JSF,</li>
  <li>podkatalog lib (5), zawieraj¹cy dzielone biblioteki (pakiety) Javy
w postaci plików JAR - jeœli tylko nasze klasy tego wymagaj¹ ,</li>
  <li>podkatalog <b>classes</b> (4), który zawiera skompilowane klasy Javy
(m.in. serwlety, ale równie¿ inne); je¿eli klasy nale¿¹ do nazwanych pakietów,
to musz¹ byæ umieszczane w odpowiednich podkatalogach katalogu class.</li>
</ul>
Ta struktura katalogowa odwzorowywana jest na <b>œcie¿kê kontekstu</b> przy wdro¿eniu.<br>
<br>
W œrodowisku serwera Tomcat (<u>a bêdziemy pos³ugiwaæ siê i omawiaæ konkretne
przyk³ady w³aœnie dla Tomcata</u>)&nbsp; istniej¹ trzy sposoby <b>wdro¿enia</b> gotowej aplikacji, przygotowanej w pokazanej wy¿ej strukturze katalogowej:<br>
<ul>
  <li><b>skopiowanie</b> tej struktury do katalogu okreslanego przez w³aœciwoœæ <b>appbase</b> konfiguracji serwera; standardowo-&nbsp; katalogu <b>webapps</b>, znajduj¹cym
siê w katalogu instalacyjnym Tomcata - œcie¿k¹ kontekstu
dla schematu z rysunku bêdzie wtedy /MojaAp (lub - jeœli nie kopiujemy ca³ego katalogu
MojaAp, lecz tworzymy&nbsp; w webapps katalog o innej nazwie i kopiujemy do niego
ca³¹ zawartoœæ katalogu MojaAp - nazwa nowoutworzonego katalogu poprzedzona
ukoœnikiem).</li>
  <li><b>spakowanie</b> tej struktury do archiwum o nazwie, maj¹cej rozszerzenie <b>WAR</b> (od Web Application Archive) i skopiowaniu tego WAR-a do katalogu <b>webapps - </b>œcie¿k¹ kontekstu dla schematu z rysunku bêdzie /MojaAp,</li>
  <li>utworzenie <b>deskryptora kontekstu</b> aplikacji, w którym m.in podajemy
odwzorowanie pomiêdzy œcie¿k¹ kontekstu a katalogiem aplikacji; deskryptor
ten mo¿na wpisac do pliku konfiguracyjnego serwera conf/server.xml, albo
stworzyæ go w odrêbnym pliku XML o dowolnej nazwie i&nbsp; umieœciæ ten plik w
&nbsp;katalogu <b>webapps</b> - &nbsp;wtedy œcie¿ka kontekstu bêdzie pobrana z deskryptora kontekstu.</li>
</ul>
Na starcie Tomcat&nbsp; tworzy i uruchamia konteksty
aplikacji,&nbsp; zarejestrowanych w jeden z trzech w/w sposobów.<br>
<br>
Jak ju¿ wspomniano, kluczow¹ rolê dla aplikacji WEB odgrywa deskryptor wdro¿enia - plik web.xml.<br>
Jest to plik XML, którego elementy okreœlaj¹ wdro¿eniowe w³aœciwoœci aplikacji.<br>
Nale¿¹ do nich:<br>
<br>
<ul>
  <li>definicje filtrów (dodatkowo przetwarzaj¹cych, filtruj¹cyhc, zlecenia dla serwletów i ich odpowiedzi)</li>
  <li>definicje s³uchaczy (obs³uguj¹cych zdarzenia zwi¹zane z kontekstem i sesj¹),</li>
  <li>definicje serwletów (i ich parametrów inicjalnych) lub stron JSP sk³adaj¹cych siê na aplikacjê oraz tzw. ich mapowanie,&nbsp; </li>
  <li>konfiguracja sesji (czyli po³¹czenia lub takich sekwencji po³¹czeñ
u¿ykownika z aplikacj¹, które zachowuj¹ to¿samoœæ u¿ytkownika) </li>
  <li>parametry kontekstu (dostêpne dla wszystkich komponentów aplikacji),</li>
  <li>mapowanie typów MIME.</li>
  <li>strony powitalne, </li>
  <li>strony opisu b³êdów,</li>
  <li>lokalizacj deskryptorów bibliotek znaczników JSP (plików *.TLD) </li>
  <li>ograniczenia ze wzglêdu na bezpieczeñstwo.</li>
  <li>definicje odniesieñ do zasobów (np. baz danych),</li>
</ul>
W³aœciwoœci s¹ definiowane za pomoc¹ znaczników XML, okalaj¹cych wartoœæ
w³aœciwoœci. Znaczniki (otwieraj¹cy i zamykaj¹cy) wraz z umieszczonym pomiêdzy
nimi cia³em nazywane s¹ elementami. Elementy mog¹ byæ zagnie¿d¿one. Np. nastêpuj¹cy
element XML:<br>
<br>
&lt;session-config&gt; <br>
&nbsp;&nbsp;&nbsp; &lt;session-timeout&gt;30&lt;/session-timeout&gt; <br>
&lt;/session-config&gt; <br>
<br>
okreœla konfiguracjê sesji i zawiera element session-timeout, okreœlaj¹cy
ile czasu nieaktywne po³¹czenie ma zachowywaæ sesjê (tu 30 minut).&nbsp; <br>
<br>
Jak ka¿dy plik XML - deskryptor wdro¿enia rozpoczynamy znacznikiem:<br>
<br>
<b>&lt;?xml version="1.0" encoding=<i>charset</i>?&gt;</b><br>
<br>
gdzie jako charset podajemy konkretn¹ stronê kodowa.<br>
<br>
Nastêpnie otwieramy g³ówny element znacznikiem &lt;web-app .... &gt;,<br>
Dla wersji 2.4 Servlet API w otwieraj¹cym znaczniku &lt;web-app ... &gt;
&nbsp; podajemy lokalizacjê definicji formatu i znaczenia elementów deskryptora
- jak poni¿ej.<br>
W g³ównym elemencie umieszczone s¹ wszystkie inne elementy, opisuj¹ce w³asciwoœci aplikacji.<br>
Wygl¹da to w nastêpuj¹cy sposób:<br>
<br>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-app_2_4.xsd"&gt;
   ...
   ...  <i>inne elementy </i>
   ...
&lt;/web-app&gt;

</pre>Uwaga: obecnie dostêpna jest specyfikacja Servlet API 2.5, ale
nie wnosi ona zbyt wielu zmian i interesuj¹cych dodatków, mo¿emy wiêc
spokojnie pzostaæ przy 2.4.<br><br>Warto zauwa¿yæ, ¿e w niektórych przypadkach &nbsp;np. prostych stron JSP deskryptor
wdro¿enia mo¿e zawieraæ tylko g³ówny element (web-app), bez elementów zagnie¿d¿onych.<br>
Dobrym zwyczajem jest jednak dostarczenie wtedy przynajmniej &nbsp;krótkiej opisowej nazwy aplikacji (znacznik <b>&lt;display_name&gt;</b>
). Bêdzie ona widoczna w narzêdziach zarz¹dzania aplikacjami na serwerze,
dziêki temu bêdziemy siê mogli ³atwo przekonaæ czy aplikacja dzia³a, a tak¿e&nbsp;
koñczyæ i wznawiaæ jej dzia³anie. <br>Mamy np. do dyspozycji managera aplikacji Tomcata, który wygl¹da tak jak na rys.<br>
<br>
<img style="width: 715px; height: 608px;" src="images/AppManager.jpg" alt="r">
<br>
<br>
Podane œcie¿ki kontekstu jednoznacznie identyfikuj¹ aplikacjê, &lt;display_name&gt; daje dodatkowa informacjê.
<br>
<br>
No dobrze, stworzyliœmy deskryptor, mamy wymagan¹ strukturê katalogow¹ aplikacji,
stosuj¹c jeden z trzech omawianych wczeœniej sposobów wdro¿yliœmy j¹ w œrodowisku
serwera. Jak j¹ teraz wywo³aæ?<br>
<br>
Aplikacja WEB jest wywo³ywana za pomoc¹ jednego ze zleceñ (requests) HTTP
np. GET lub POST. Url, który poprzedza parametry lub strumieñ danych zlecenia
ma formê:<br>
<br>
<div class="syntax"> Wywo³anie aplikacji WEB<br>
<b>http://<i>url_serwera</i>/<i>kontekst</i> [ / {&nbsp; <i>strona_jsp</i> | &nbsp;<i>mapowanie_nazwy_serwletu</i> } ]</b><br>
<br>
&nbsp;[...] oznaczaj¹ opcjonalnoœæ,&nbsp; { x | y } oznacza "jedno z"<br>
Natomiast:<br>
<ul>
  <li><b><i>kontekst</i></b> - jest nazw¹ kontekstu aplikacji ( <i><b>/kontekst</b></i> jest œcie¿k¹ kontekstu)</li>
  <li><i><b>strona_jsp</b></i> - plik tekstowy w formacie HTML z elementami JSP (<i><b>nazwa.jsp</b></i>) </li>
  <li><b><i>mapowanie_nazwy_serwletu</i></b> - ustalona w pliku web.xml&nbsp;
nazwa lub szablon nazwy (stosuj¹cy tzw. "wildcards" i okreœlaj¹cy wiele nazw
pasuj¹cych do szablonu) za pomoc¹ której (lub których) mo¿e byæ wywo³any
serwlet &nbsp;</li>
</ul>

</div><br>
<br>
Je¿eli w odwo³aniu podano tylko <b>http://<i>url_serwera</i>/<i>kontekst</i></b>, to aplikacja zostanie uruchomiona w nastêpuj¹cych przypadkach:<br>
<ul>
  <li>gdy w g³ównym katalogu wdro¿onej aplikacji znajduje siê plik index.jsp,
to zostanie on wywo³any (ale to zale¿y od serwera i jego ustawieñ),</li>
  <li>gdy w pliku web.xml zdefiniowano listê plików powitalnych w nastêpuj¹cej postaci</li>
</ul>
<pre>   &lt;welcome-file-list&gt;
     &lt;welcome-file&gt;<i><b>plik1</b></i>.jsp&lt;/welcome-file&gt;
     &lt;welcome-file&gt;<i><b>plik2</b></i>.jsp&lt;/welcome-file&gt;
     ...
   &lt;/welcome-file-list&gt;

</pre>
<blockquote>a w g³ównym katalogu aplikacji znajduj¹ siê któreœ z tych plików,
to zostanie wywo³any pierwszy z listy, który jest w katalogu (jest to równie¿
sposób na dostarczenie u¿ytkownikowi zwyk³ego pliku html, z którego albo
mog¹ prowadziæ linki do róznych czêœci aplikacji, albo mo¿na dostarczyæ form
logowania, albo mo¿e on informowaæ u¿ytkownika, ¿e zapomnia³ dodaæ do adresu
zlecenia dodatkowej specyfikacji, np. zmapowanej nazwy serwletu i przez to
nie mo¿e uruchomiæ aplikacji),<br>
  </blockquote>
  <ul>
    <li>&nbsp;gdy mapowanie nazwy serwletu ma postaæ /*, oznaczaj¹c¹ dowoln¹ nazwê,
to zostanie wywo³any serwlet, którego nazwa zosta³a w pliku web.xml przyporz¹dkowana
tej formie odwo³ania.</li>
  </ul>
Zobaczmy przyk³ady wywo³ania aplikacji WEB w&nbsp; œrodowisku Tomcat. Domyœlna
instalacja&nbsp;udostêpnia serwer poprzez port 8080 lokalnego hosta: <b>http://localhost:8080</b>.<br>
WyobraŸmy sobie teraz nastêpuj¹ce przypadki:<br>
  <br>
A. Aplikacja, powiedzmy - "Sklep ogrodowy", napisana jako strona JSP (plik
run.jsp), odwo³uj¹ca siê do klasy GardenShop.class (JavaBean) i maj¹ca w
pliku web.xml jedynie element &lt;display-name&gt; zosta³a wdro¿ona poprzez
umieszczenie jej w podkatologu gs katalogu webapps:<br>
  <br>
  <span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
  <b>&nbsp; &nbsp; &nbsp; webapps</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gs</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WEB-INF<br>
  </b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>classes</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GardenShop.class<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; web.xml<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;run.jsp<br>
  <br>
Mo¿emy j¹ wtedy wywo³aæ poprzez podanie w przegl¹darce URL-a:<br>
  <b><br>
http://localhost:8080/gs/run.jsp</b><br>
  <br>
B. Aplikacja napisana jako strona JSP (w pliku index.jsp), odwo³uj¹ca siê do klasy GardenShop.class (JavaBean) i maj¹ca w
pliku web.xml jedynie element &lt;display-name&gt; zosta³a wdro¿ona poprzez
umieszczenie jej w podkatalugu gs katalogu webapps:<br>
  <br>
  <span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
  <b>&nbsp; &nbsp; &nbsp; webapps</b><br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gs</b><br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WEB-INF<br></b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>classes</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GardenShop.class<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; web.xml<br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;index.jsp<br>
  <br>
Mo¿emy j¹ wtedy wywo³aæ poprzez podanie w przegl¹darce URL-a:<br>
  <b><br>
http://localhost:8080/gs</b><br>
  <br>
C. Aplikacja napisana jako strona JSP (w pliku run.jsp), odwo³uj¹ca siê
do klasy GardenShop.class (JavaBean), maj¹ca plik web.xml w nastêpujacej
postaci:<br>
  <pre>&lt;?xml version="1.0"?&gt;
&lt;web-app version="2.4"
     xmlns="http://java.sun.com/xml/ns/j2ee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

   &lt;display-name&gt;Sklep ogrodniczy&lt;/display-name&gt;

   &lt;welcome-file-list&gt;
     &lt;welcome-file&gt;run.jsp&lt;/welcome-file&gt;
   &lt;/welcome-file-list&gt;

&lt;/web-app&gt;
</pre>
zosta³a wdro¿ona poprzez
umieszczenie jej w podkatalugu gs katalogu webapps:<br>
  <br>
  <span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
  <b>&nbsp; &nbsp; &nbsp; webapps</b><br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gs</b><br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WEB-INF<br></b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>classes</b><br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GardenShop.class<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;web.xml<br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;run.jsp<br>
  <br>

Mo¿emy j¹ wtedy wywo³aæ poprzez podanie w przegl¹darce URL-a:<br>
  <b><br>
http://localhost:8080/gs</b><br>
  <br>
<br>
D. Aplikacja "Sklep ogrodowy" zosta³a napisana jako serwlet GardenShopServlet.class.
W pliku web.xml okreœlono, ¿e mapowanie nazwy tego serwletu - &nbsp;to /run. Aplikacja
zosta³a wdro¿ona w nastêpuj¹cy sposób (uwaga nie ma tu ju¿ ¿adnych plików
JSP):<br>
  <b><br></b><span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
  <b>&nbsp; &nbsp; &nbsp; webapps</b><br>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gs</b><br>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WEB-INF<br></b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>classes</b><br>



&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GardenShopServlet.class<br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;web.xml<br>
  <br>
  <br>


Mo¿emy j¹ wtedy wywo³aæ poprzez podanie w przegl¹darce URL-a:<br>
  <b><br>
http://localhost:8080/gs</b>/<b>run</b><br>
  <br>
E. Aplikacja "Sklep ogrodowy" zosta³a napisana jako serwlet GardenShopServlet.class.
W pliku web.xml okreœlono, ¿e mapowanie nazwy tego serwletu&nbsp; to /*. Aplikacja
zosta³a wdro¿ona w nastêpuj¹cy sposób:<br>
  <b><br></b><span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
  <b>&nbsp; &nbsp; &nbsp; webapps</b><br>




&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>gs</b><br>




&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WEB-INF<br></b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>classes</b><br>




&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GardenShopServlet.class<br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;web.xml<br>
  <br>
  <br>



Mo¿emy j¹ wtedy wywo³aæ poprzez podanie w przegl¹darce dowolnych URLI o postaci:<br>
  <b><br>
http://localhost:8080/gs</b>/*<br>
  <br>
czyli np.<br>
  <b>
http://localhost:8080/gs</b><br>
  <b>
http://localhost:8080/gs/run</b><br>
  <b>
http://localhost:8080/gs/star</b>t<br>
  <b>
http://localhost:8080/gs/prosze_kwiatki</b><br>
  <br>
  <br>
Proces wdra¿ania aplikacji nie jest prosty. &nbsp;Pocz¹tkuj¹cym wiele problemów
sprawia zorientowanie siê w nowych pojêciach (np. co to jest ten "kontekst"?),
g¹szczu katalogów, wymagañ co do struktur, nazw. Omawiamy wdra¿anie na pocz¹tku,
bowiem bez tej wiedzy nie sposób naprawdê zrozumieæ dzia³ania aplikacji WEB,
ani te¿ - tym bardziej æwiczyæ ich tworzenia. Nieco abstrakcyjny na razie,
syntetyzuj¹cy opis powinien dawaæ ogóln¹, mo¿na by powiedzieæ, strukturaln¹
orientacjê (wa¿niejsz¹, myœlê, dla zrozumienia ni¿ bardzo konkretne instrukcje
"zrób to, potem to, potem to" - na jakichœ szczególnych przypadkach). <br>
<br> Ale oczywiœcie takie konkretne przyk³ady s¹ tak¿e niezbêdne dla zrozumienia
tego materia³u. Zajmiemy siê wiec teraz budow¹ i wdro¿eniem dwóch konkretnych
prostych serwletów. Ich rola polega g³ównie na pokazaniu w jaki sposób tworzy
siê (najprostsze) deskryptory wdro¿enia (web.xml) dla serwletów, sposobów
wdra¿ania aplikacji WEB i relacji pomiêdzy œcie¿k¹ kontekstu a fizyczn¹ lokalizacj¹
aplikacji na dysku.<br>
  <br>
Przyk³adowa aplilkacja WEB bêdzie sk³adaæ siê z dwóch (niezwi¹zanych ze sob¹)
serwletów. S¹ one nie tylko proste, ale w³aœciwie bezu¿yteczne. Ich g³ównym
zadaniem jest szczegó³owe pokazanie sposobów wdro¿enia aplikacji, sposobu
odwo³ywania siê z generowanych stron do zasobów aplikacji (takich jak pliki
graficzne czy HTML), oraz zwi¹zków pomiedzy œcie¿k¹ kontekstu a fizycznym
katalogiem aplikacji.<br>
<br>
Pierwszy serwlet, po wywo³aniu z przegl¹darki klienta generuje stronê HTML,
która zostaje zwrócona do przegladarki. T³o wygenerowanej strony bêdzie plikiem
graficznym o nazwie os2.jpg (musimy go jakoœ umieœciæ w strukturze katalogów
aplikacji i umieæ sie do niego odnieœæ z programu), na stronie bêdzie te¿
odnoœnik prowadz¹cy do jakiegoœ pliku HTML (te¿ znajduj¹cego siê w ramach
naszej aplikacji), o nazwie powiedzmy Bye.html.<br>
Serwlet zapiszemy w pliku Msg.java. Po kompilacji programu, zdefiniowaniu
deskryptora wdro¿enia (web.xml) i przygotowaniu zasobów (grafiki, HTML) powinniœmy
mieæ na dysku nastêpuj¹c¹ strukturê katalogow¹ (g³ówny katalog aplikacji
nazwiemy serwlety1).<br>
  <br>
serwlety1<br>
&nbsp; &nbsp; WEB-INF<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;classes<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Msg.class<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;web.xml<br>
&nbsp; &nbsp; images &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;---- pliki graficzne umieszczamy w podkatalogu<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; os2.jpg<br>
&nbsp; &nbsp; Bye.html<br>
&nbsp;<br>
No, ale najpierw musimy napisaæ serwlet. <br>
Ju¿ za chwilê, w dalszej czêœci wyk³adu, zajmiemy sie dok³adnie budow¹
i dzia³aniem serwletów; teraz dla zrozumienia dzia³ania przyk³adu wystarczy
wiedzieæ, ¿e:<br>
  <ul>
<li>aby byæ serwletem HTTP, klasa musi odziedziczyæ klasê HTTPServlet,</li><li>przedefiniowana metoda <span style="font-weight: bold; font-style: italic;">doGet(HTTPServletRequest zlecenie, HTTPServletResponse odpowiedz)</span>
obs³uguje zlecania GET (czyli np. "id¹ce" z&nbsp; paska adresów przegl¹darki),</li><li>odpowiedŸ generujemy w postaci strony HTML (lub zwyklego tekstu), pisz¹c
go do strumienia zwi¹zanego z obiektem HTTPServletResponse; w szczególnoœci mo¿emy
wykorzystaæ strumieñ PrintWriter.</li>
  </ul>
Oto kod.<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class Msg extends HttpServlet {

  // Pocz¹tek HTML i w³aœciwoœci &lt;body&gt; - t³o, kolor tekstu i linków
  private String prolog =
                 "&lt;html&gt;&lt;title&gt;Przyk³ad&lt;/title&gt;" +
                 "&lt;body background=\"images/os2.jpg\" text=\"antiquewhite\"" +
                 "link=\"white\" vlink=\"white\"&gt;";

  // Tagi zamykaj¹ce
  private String epilog = "&lt;/body&gt;&lt;/html&gt;";


  // Metoda obs³ugi zlecenia GET

  public void doGet(HttpServletRequest request,
                       HttpServletResponse response)
                 throws ServletException, IOException
  {
     // Mo¿emy w ten sposób ustaliæ typ treœci i stronê kodow¹
     // ³atwiej ni¿ przez generowanie metatagów HTML

     response.setContentType("text/html; charset=ISO-8859-2");

     // Strumieñ wyjœciowy, tu generowana treœæ strony HTML
     // PrintWriter umo¿liwia u¿ycie metod print i println

     PrintWriter out = response.getWriter();


     out.println(prolog);  // piszemy pocz¹tek html i tag &lt;body ... &gt;

     // Piszemy treœæ
     out.println("&lt;h1&gt;Dokument HTML&lt;br&gt;wygenerowany przez serwlet&lt;/h1&gt;");
     out.println("&lt;br&gt;&lt;br&gt;&lt;a href=\"Bye.html\"&gt;Po¿egnanie&lt;/a&gt;");

     // Znaczniki zamykaj¹ce
     out.println(epilog);
     out.close();
  }

}
</pre>

Wa¿ne jest w tym przyk³adzie, aby zauwa¿yæ sposób odwo³ania z generowanej
strony do zasobów aplikacji (plików os2.jpg i &nbsp;Bye.html). Klasa serwletu
znajduje siê w katalogu serwlety1/WEB-INF/classes. Odwo³ania do zasobów s¹
jednak zrelacjonowane wobec&nbsp; g³ównego katalogu aplikacji. Zatem odwo³anie
"images/os2.jpg" jest - gdy patrzymy na nasz¹ strukturê katalogow¹ - &nbsp;odwo³aniem "serwlety1/images/os2.jpg", a
odwo³anie "Bye.html" znaczy "serwlety1/Bye.html".<br>
  <br>
Przed wdro¿eniem aplikacji musimy stworzyæ deskryptor wdro¿enia (web.xml).
W przypadku serwletów podstawowe informacje, które trzeba podaæ to:<br>
  <ul>
    <li>nazwa identyfikuj¹ca serwlet.</li>
    <li>nazwa klasy serwletu,</li>
    <li>mapowanie nazwy sewrletu na nazwê, której u¿yje klient w specyfikacji URL zlecenia GET.</li>
  </ul>
Mamy tu dwa odwzorowania: nazwy i klasy, nazwy i mapowania.<br>
Do zwi¹zania nazwy i klasy serwletu stosuje siê podelemnt &lt;servlet_name&gt; elementu &lt;servlet&gt; np.<br>
  <pre>    &lt;servlet&gt;
       &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
       &lt;description&gt;Prosty napis&lt;/description&gt;
       &lt;servlet-class&gt;Msg&lt;/servlet-class&gt;
    &lt;/servlet&gt;
</pre>
Widzimy tu, ¿e:<br>
  <ul>
    <li>dla celów identyfikacyjnych nazwaliœmy nasz serwlet HTMLMsg (inaczej ni¿ nazwa klasy),</li>
    <li>mo¿emy podaæ (choæ niekoniecznie) krótki opis serwletu w &nbsp;znacznikach &lt;description&gt;</li>
    <li>nazwê klasy serwletu podajemy w znacznikach &lt;servlet-class&gt;;
nasza klasa Msg, zawarta w pliku Msg.java zosta³a skompilowana do pliku Msg.class
- podaliœmy zatem nazwê klasy Msg</li>
    <li>i - uwaga - gdy serwlet jest w nazwanym pakiecie (a zatem i w podkatalogu
katalogu classes) podajemy te¿ nazwê pakietu np. controller.Msg</li>
  </ul>
Mapowanie uzyskujemy dziêki elementowi &lt;servlet_mapping&gt;<br>
  <pre>    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/msg&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>
Przy tym:<br>
  <ul>
    <li>element <b>servlet </b>musi poprzedzaæ element <b>servlet-mapping</b>,</li>
    <li>dla danego serwletu &nbsp;jego nazwy w tagu &lt;servlet-name&gt; w obu elmentach musz¹ byc takie same,</li>
    <li>element <b>url-pattern</b> okreœla sposób odwo³ania do tego serwletu
(byæ mo¿e jednego z wielu w ramach aplikacji); u¿ywaj¹c przy tym gwiazdek
mo¿emy dostarczyæ wielu sposobów wywo³ania serwletu (np. podanie&nbsp; /*.html
bêdzie powodowaæ wywo³anie serwletu w sytuacji gdy u¿ytkownik wprowadzi dowoln¹
nazwê, zakoñczon¹ .html</li>
  </ul>
<br>
Ca³y plik deskryptora wdro¿enia (web.xml) dla naszej aplikacji (na razie zawieraj¹cej tylko jeden serwlet) wygl¹da tak:<br>
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;display-name&gt;Serwlety 1&lt;/display-name&gt;
    &lt;description&gt;Proste przykladowe serwlety&lt;/description&gt;

    &lt;servlet&gt;
       &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
       &lt;description&gt;Prosty serwlet&lt;/description&gt;
       &lt;servlet-class&gt;Msg&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/msg&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre>

<br>
Pozostaje nam teraz wdro¿enie.<br>
  <br>
Za³ó¿my,&nbsp; ¿e g³ówny katalog naszej aplikacji znajduje siê w katalogu G:\Programy\serwlety1.<br>
  <br>
Jak ju¿ mówiliœmy, dla wdro¿enia wystarczy go skopiowaæ do katalogu&nbsp;&lt;katalog_intalacyjny_Tomcata&gt;\webapps uzyskuj¹c:<br>
  <br><span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><br>
&nbsp; &nbsp; &nbsp;webapps<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .....<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serwlety1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ....<br>
  <br>
Mo¿emy te¿ spakowaæ go jarem do pliku o rozszerzeniu WAR i to archiwum przekopiowaæ do katalogu webapps.<br>
  <br><br>
Uruchomienie naszego serwletu (zgodnie z ogóln¹ regu³¹ podan¹ wczeœniej) uzyskamy przez:<br>
  <br>
  <img src="images/InvokeServl.jpg" alt="r" border="1" height="149" width="471">
  <br>
  <br>
Uruchomienie i dzialanie serwletu ilustruj¹ poni¿sze rysunki.<br>
  <br>
  <br>
Otwieramy przegl¹darkê i poprzez wpisaniu na pasku adresu odwo³ania do serwletu - przesy³amy mu
zlecenie GET, otrzymuj¹c w odpowiedzi wygenerowan¹ stronê:<br><br>
  <img style="border: 1px solid ; width: 601px; height: 408px;" src="images/MsgStart2.jpg" alt="r">
  <br>
  <br>
Trzeci sposób wdro¿enia - za pomoc¹ <b>deskryptora kontekstu</b> - ma pewne zalety wobec omówionych:<br>
  <ul>
    <li>nie wymaga kopiowania katalogów lub WARów,</li>
    
    <li>mo¿na za jego pomoc¹ ustaliæ dowoln¹ (ale jednoznaczn¹) nazwê kontekstu
i zwi¹zaæ j¹ z dowolnym fizycznym katalogiem, w którym rezyduje nasza apliakacja/<br></li>
  </ul>
Deskryptor kontekstu jest elementem XML o nazwie <b>Context</b>, w którym
opisujemy kontekst aplikacji. Mo¿emy wpisaæ ten deskryptor do pliku konfiguracyjnego
serwera (conf/server.xml) pod elementem Host. Lepiej jednak (i bezpieczniej
ze wzglêdu na mo¿liwoœæ przypadkowych modyfikacji pliku konfiguarcji serwera)&nbsp;
jest wpisac deskryptor kontekstu do pliku XML o dowolnej nazwie i umieœciæ
ten plik w katalogu webapps. To wystarczy dla wdro¿enia aplikacji (ale te¿ wymaga restartu Tomcata).<br>
  <br>
Element <b>Context</b> mo¿e zawieraæ szereg podelementów, m.in. takie, które
znajduj¹ siê równie¿ w pliku web.xml. Mo¿na te¿ w nim definiowaæ nazwy plików
logów dla aplikacji (do których to plików bêd¹ zapisywane ró¿ne informacje&nbsp;
np. o b³êdach, ostrze¿eniach, ale równie¿ dowolna treœæ - np. za pomoc¹ metody
log(..) z klas serwletowych). Bardzo wa¿nym zastosowaniem deskryptora kontekstu
jest ustanawianie powi¹zañ z zasobami zewnêtrznymi i podawanie parametrów
potrzebnych, by do takich zasobów (np. baz danych) móc siê odwo³ywaæ.<br>
  <br>
W tej chwili interesuj¹ nas jednak przede wszystkim te w³aœciwoœci deskryptora
kontekstu, które pozwalaj¹ wdro¿yæ aplikacjê bez umieszczania jej struktury
katalogowej (spakowanej lub nie) pod webapps. W tym wzglêdzie deskryptor kontekstu wygl¹da niezwykle
prosto:<br>
  <br>
<div class="syntax"> Najprostsza forma deskryptora kontekstu<br>
  <b>&lt;Context <br>
&nbsp; &nbsp; &nbsp;&nbsp; path="<i>œcie¿ka_kontekstu</i>"<br>
&nbsp; &nbsp; &nbsp; docBase="<i>œcie¿ka_do_katalogu_aplikacji</i>"<br>
&lt;/Context&gt;<br>
  <br>
  </b>gdzie: <br>
  <ul>
    <li><b><i>œcie¿ka_kontekstu</i></b> - œciezka kontekstu, np. /gs</li>
    <li><i><b>œcie¿ka_do_katalogu_aplikacji</b></i> &nbsp;- lokalizacja katalogu
aplikacji lub pliku WAR w systemie plikowym; œcie¿kê mo¿emy podac w postaci
absolutnej np. C:/przyklady/MojaAp, albo <b>relatywnie</b> w stosunku do tzw. "bazy aplikacji" hosta (standardowo katalogu&nbsp;<span style="font-weight: bold;">&lt;katalog_intalacyjny_Tomcata&gt;</span><b>/webapps</b>).</li>
  </ul>

</div><br>
  <br>
  Zobaczmy to na przyk³adzie naszej aplikacji (zawieraj¹cej na razie jeden serwlet - Msg.java).<br>
Jak pamiêtamy, jej komponenty znajdow¹³y siê w katalogu G:/Programy/serwlety1.<br>
Za³ó¿my, ¿e Tomcat jest zainstalowane w katalogu E:/Serwery/apache-tomcat-6.0.13. Przy wdro¿eniu skopiowaliœmy
katalog serwlety1 z G:/Programy do &nbsp;E:/Serwery/apache-tomcat-6.0.13/webapps. Œcie¿k¹ kontekstu aplikacji
by³a /serwlety1 i za jej pomoc¹ uruchamialiœmy tê aplikacjê.<br>
  <br>
Teraz wdro¿ymy tê sam¹ aplikacjê pod jeszcze dwoma ró¿nymi kontekstami.<br>
Skopiujemy najpierw jej komponenty do katalogu E:/WebAplikacja1 (oczywiœcie
struktura katalogowa jest zachowana, z tym, ¿e teraz g³ównym katalogiem aplikacji
jest F:/WebAplikacja1).<br>
  <br>
Przygotujmy dwa deskryptory kontekstu. Pierwszy wprowadzi kontekst o nazwie
Show zwi¹zany z aplikacj¹ umieszczon¹ w katalogu G:/Programy/serwlety1, drugi
- kontekst o nazwie wa1 zwi¹zany z aplikacj¹ z katalogu E:/WebAplikacja1.
Umieœcimy je w plikach XML o dowolnych nazwach np.<br>
  <br>
KontekstG.xml<br>
  <pre>&lt;Context  path="/Show"  docBase="G:/Programy/serwlety1/build"&gt;
&lt;/Context&gt;

</pre>
KontekstE.xml<br>
  <pre>&lt;Context  path="/wa1"   docBase="../../WebAplikacja1"&gt;
&lt;/Context&gt;
</pre>

  Tu zwrócmy uwagê na relatywn¹ œcie¿kê (zaczynamy z&nbsp; katalogu
aplikacji&nbsp;&nbsp;E:/Serwery/apache-tomcat-6.0.13/webapps, .. /.. przenosi nas do katalogu E:/ i st¹d wskazujemy
katalog WebAplikacja1.<br>
  <br>
Po skopiowaniu tych plików XML&nbsp; do katalogu webapps i uruchomieniu Tomcata
uzyskamy dostêp do trzech aplikacji (które robi¹ to samo, bo zosta³y skopiowane)
pod kontekstami:<br>
/serwlety1 &nbsp; (to jest nasze pocz¹tkowe wdro¿enie)<br>
/Show &nbsp; &nbsp; &nbsp; &nbsp; (to zapewni³ plik KontekstG.xml i zwarty w nim deskryptor kontekstu)<br>
/wa1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to za spraw¹ deskryptora kontekstu z pliku KontekstE<br>
  <br>
Ka¿de z wywo³añ <br>
http://localhost:8080/wa1/msg, <br>
http://localhost:8080/Show/msg<br>
  http://localhost:8080/serwlety1/msg<br>
  <br>
poka¿e nam znany ju¿ obrazek pochodz¹dzy z serwletu Msg.java.<br>
  <br>
Mo¿emy siê te¿ przekonaæ ³atwo, ¿e rzeczywiœcie&nbsp;konteksty odnosz¹ siê do konkretnych&nbsp;fizycznych katalogów.<br>
  <br>
W tym celu dodamy do naszej aplikacji serwlet Msg2.java, który bêdzie pokazywa³
ró¿ne informacje, m.in. o œcie¿kach. Przy okazji zilustruje on niektóre metody
klasy HTTPServlet, HTTPServletRequest oraz interfejsu ServletContext (który
"opisuje" kontekst aplikacji w ramach której dzia³a serwlet)..<br>
Od obiektu reprezenetuj¹cego zlecenie (HTTPServletRequest) mo¿emy dowiedzieæ siê m.in.<br>
  <ul>
    <li>jaki jest URL zlecenia (metoda getRequestURL()),</li>
    <li>jaka jest œcie¿ka kontekstu - metoda getContextPath(),</li>
    <li>jaka jest œcie¿ka uruchamiaj¹ca serwlet, który po raz pierwszy otrzyma³ to zlecenie - metoda getServletPath().</li>
  </ul>
Od samego serwletu mo¿emy pobraæ jego kontekst (typ ServletContext) za pomoc¹ metody getServletContext().<br>
Z kolei od kontekstu mo¿emy dowiedzieæ siê wielu ciekawych rzeczy, m.in.:<br>
  <ul>
    <li>informacji o serwerze (getServerInfo()),</li>
    <li>nazwy aplilkacji podanej w omawianiym wczeœniej tagu &lt;display-name&gt; pliku web.xml - metoda getServletContextName(),</li>
    <li>jaka jest prawdziwa (np. po czêœci fizyczna w systemie plikowym hosta)
œcie¿ka dla podanej œcie¿ki "wirtualnej" (takiej jak np. /serwlety1) - metoda
getRealPath(String),</li>
    <li>jakie komponenty (i zasoby) sk³adaj¹ siê na aplikacje (metoda&nbsp; getResourcePaths(String))</li>
  </ul>
  <br>
Zobaczmy kod nowego serwletu (warto zwróciæ uwagê, ¿e w zwracanej odpowiedzi
nie stosujemy ¿adnych konstrukcji HTML - przegl¹darka uzyska i poka¿e czysty
tekst).<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.net.*;

public class Msg2 extends HttpServlet {

  private ServletContext context;
  private PrintWriter out;

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
                       throws ServletException, IOException
  {
    out = resp.getWriter();
    out.println("To jest strona wygenerowana przez serwlet " +
                 this.getClass().getName()+ ".class");
    out.println("-------------------------------------------------------");

    // Jak wygladal URL z ktorego przyszlo zlecenie
    String requestURL = req.getRequestURL().toString();
    out.println("RequestURL: " + requestURL);

    // Uzyskujemy kontekst
    context = this.getServletContext();

    // Mo¿emy od niego pobraæ informacje o serwerze
    out.println("\nServer info\n" + context.getServerInfo() );

    // Mo¿emy dowiedzieæ siê jaka jest nazwa aplikacji
    // okreœlona w &lt;display-name&gt;
    out.println("\nAplikacja ma nazwe: " + context.getServletContextName() );

    // Informacje o œcie¿kach
    String contextPath = req.getContextPath();
    String servletPath = req.getServletPath();

    // Od kontekstu mo¿emy dowiedzieæ siê te¿ jakie s¹ fizyczne œcie¿ki
    // prowadzace do "wirtualnych" URLI
    out.println("\nInformacja o sciezkach");
    msg("ContextPath", contextPath);
    msg("ServletPath", servletPath);

    // I nasze pliki "zasobowe" (HTML, JPG)
    msg("Plik Bye.html", "Bye.html");
    msg("Plik os2.jpg", "images/os2.jpg");

    // Lista zasobów aplikacji
    out.println("\nLista zasobow aplikacji");
    listResources("/");

    // Mo¿emy na tych zasobach wykonywaæ op we-wy
    InputStream in = context.getResourceAsStream("/WEB-INF/web.xml");
    BufferedReader br = new BufferedReader( new InputStreamReader(in));
    out.println("\nPierwszy wiersz pliku web.xml");
    out.println(br.readLine());
    br.close();

    // W jakim katalogu dzia³a serwlet?
    File dir = new File(".");
    out.println("\nA serwlet dzialal w katalogu: " + dir.getAbsolutePath());


    out.close();
  }

   // Listuje zasoby aplikacji
  private void listResources(String path)  {
    if (path == null) return;
    Set res = context.getResourcePaths(path);
    for (Iterator iter = res.iterator(); iter.hasNext(); ) {
      String resItem = (String) iter.next();
      if (resItem.endsWith("/")) listResources(resItem);
      else out.println(resItem);
    }
  }

  private void msg(String info, String path) {
    out.println("------------------------------------------");
    out.println(info);
    String realPath = context.getRealPath(path);
    out.println("Virtual: " + path);
    out.println("Real   : " + realPath);
  }

}
</pre>
  <br>Niew¹tpliwie ciekawa jest tu metoda getResources() i jej rekurencyjne wykorzystanie
we w³asnej metodzie listResources(). Za chwilê - po obejrzeniu wyników dzialania
serwletu - powiemy o niej wiêcej. Przedtem jednak musimy nowy serwlet umiejscowiæ
w strukturze naszej aplikacji. <br>
W tym celu - po skompilowaniu serwletu do katalogu classes - musimy uzupelniæ
deskryptor wdro¿enia. Teraz aplikacja sk³ada siê z dwóch serwletów, zatem
opis nowego serwletu musi znaleŸæ siê w pliku web.xml. Ustalimy przy tym,
¿e do serwletu Msg2.java bêdzie mo¿na siê odwo³aæ podaj¹c po œcie¿ce kontekstu
mapowanie /paths.<br>
Nowy plik web.xml wygl¹da tak:<br>
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;display-name&gt;Serwlety 1&lt;/display-name&gt;
    &lt;description&gt;Proste przykladowe serwlety&lt;/description&gt;

    &lt;servlet&gt;
       &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
       &lt;description&gt;Prosty serwlet&lt;/description&gt;
       &lt;servlet-class&gt;Msg&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HTMLMsg&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/msg&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
       &lt;servlet-name&gt;Msg2&lt;/servlet-name&gt;
       &lt;description&gt;Info o sciezkach&lt;/description&gt;
       &lt;servlet-class&gt;Msg2&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Msg2&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/paths&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&lt;
</pre>
a struktura naszej aplikacji jest teraz taka:<br>
  <br>
&lt;g³ówny_katalog_aplikacji&gt;<br>

&nbsp; &nbsp; WEB-INF<br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;classes<br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Msg.class<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Msg2.class <br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;web.xml &nbsp; &nbsp; &nbsp;&nbsp; &lt;--- zawiera opis obu serwletów<br>

&nbsp; &nbsp; images &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;---- pliki graficzne umieszczamy w podkatalogu<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; os2.jpg &nbsp; &nbsp; &nbsp;
&nbsp; &lt;--- to jest t³o strony generowanej przez serwlet Msg<br>

&nbsp; &nbsp; Bye.html &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;--- a to strona do której prowadzi link z HTML-u z Msg<br>
  <br>
  <br>
Po wdro¿eniu w kontekœcie /serwlety1 (np. podkatalog serwlety1 w
katalogu webapps)&nbsp; bêdziemy ten serwlet uruchamiaæ poprzez <br><br>
http://localhost:8080/serwlety1/paths<br>
  <br>
i uzyskamy w przegl¹darce nastepuj¹ce wyniki:<br><br><br><div class="notec"><pre>To jest strona wygenerowana przez serwlet Msg2.class
-------------------------------------------------------
RequestURL: http://localhost:8080/serwlety1/paths

Server info
Apache Tomcat/6.0.13

Aplikacja ma nazwe: Serwlety 1

Informacja o sciezkach
------------------------------------------
ContextPath
Virtual: /serwlety1
Real   : E:\Serwery\apache-tomcat-6.0.13\webapps\serwlety1\serwlety1
------------------------------------------
ServletPath
Virtual: /paths
Real   : E:\Serwery\apache-tomcat-6.0.13\webapps\serwlety1\paths
------------------------------------------
Plik Bye.html
Virtual: Bye.html
Real   : E:\Serwery\apache-tomcat-6.0.13\webapps\serwlety1\Bye.html
------------------------------------------
Plik os2.jpg
Virtual: images/os2.jpg
Real   : E:\Serwery\apache-tomcat-6.0.13\webapps\serwlety1\images\os2.jpg

Lista zasobow aplikacji
/Bye.html
/images/os2.jpg
/WEB-INF/classes/Msg.class
/WEB-INF/classes/Msg2.class
/WEB-INF/web.xml

Pierwszy wiersz pliku web.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

A serwlet dzialal w katalogu: E:\Serwery\apache-tomcat-6.0.13\bin\.
</pre></div>
  <br>wróæmy
uwagê na pokazane fizyczne œcie¿ki (pamiêtamy, ¿e webapps znajduje siê
w tym przyk³adzie w katalogu&nbsp;E:/Serwery/apache-tomcat-6.0.13).<br>
No i na ciekaw¹ metodê gerResources(), która umo¿liwia dostep do zasobów aplikacji
z serwletu. Dzia³a ona podobnie do listowania katalogu - zwraca zbiór œcie¿ek,
które znajduj¹ siê "pod" podan¹ jako argument œcie¿k¹. Podaj¹c jako argument
"/" odwo³ujemy siê do g³ównej œcie¿ki aplikacji (inaczej zwanej <b>context root</b>
) i uzyskujemy wszystko co pod ni¹ sie znajduje. W naszym przypadku getResources("/")
zwróci: &nbsp;zbiór elementów "/images/", "/WEB-INF/", "/Bye.html". Elementy, które
mo¿na dalej rozwijaæ (stanowi¹ce podkatalogi) koñcz¹ siê ukoœnikiem. Wszystkie
elementy maj¹ na pocz¹tku ukoœnik (np. plik Bye.html - jest przedstawiony
jako "/Bye.html").<br>
  <br>
Na zasobach aplikacji mo¿emy wykonywaæ operacje wejœcia-wyjœcia &nbsp;poprzez
uzyskanie strumienia zwi¹zanego z zasobem za pomoc¹ metody getResourceAsStream(String
sciezkaZasobu). Pokazuje to przyk³ad czytania pliku web.xml, a podkreœlmy
¿e ten sposób dzia³ania jest wygodny, bowiem - jak widaæ - roboczym katalogiem
serwletu nie jest katalog naszej aplikacji, ale katalog serwera.<br>
  <br><hr style="width: 100%; height: 2px;"><a name="WebApps.3"></a><h2>3. Budowanie, rozwijanie i wdra¿anie aplikacji za pomoc¹ Ant-a.


</h2>Jak widaæ proces rozwijania aplikacji WEB jest doœæ pracoch³onny, ¿eby nie
powiedzieæ uci¹¿liwy. Samo ostateczne wdro¿enie (wymagaj¹ce rozlicznych zabiegów
konfiguracyjnych) - jako jednorazowe, przynajmniej na jakiœ czas - nie straszy
tak bardzo nak³adami pracy. Gorzej z kolejnymi fazami rozwijania i testowania
aplikacji. Je¿eli za ka¿dym razem, przy ka¿dej zmianie w procesie rozwoju
programu, nawet w najprostszym przypadku musimy wykonaæ wszystkie opisane
wczeœniej czynnoœci "rêcznie", to staje siê to bardzo uci¹¿liwe, a co gorsza
skupia uwage na arbitralnych, konwencjonalnych szczególach technicznych (a
jak <b>musi</b> siê nazywaæ katalog, a jaka <b>musi</b> byæ jego struktura, a jakie <b>musz¹</b> byæ elementy w pliku web.xml itp.), nie maj¹cych nic wspólnego z logik¹ aplikacji i sfer¹ rozwi¹zywanego przez ni¹ problemu.<br>
  <br>
Oczywiœcie - ze wzglêdu na naturê aplikacji WEB jest to nie do unikniêcia.
Mo¿na jednak unikn¹æ ca³kowicie "rêcznego" powtarzania niezbêdnych rutynowych
czynnoœci.<br> Istniej¹ œrodowiska wizualnego programowania, które u³atwiaj¹
te wszystkie sprawy (np. NetBeans, Eclipse).<br><br>
Tutaj powiemy parê s³ów o innej, uniwersalnej, mo¿liwoœci automatyzacji rutynowych
czynnoœci zwi¹zanych z rozwijaniem i wdra¿aniem aplikacji WEB - narzêdziu,
które nazywa siê Ant.<br>
  <br>
Ant pozwala zapisaæ sekwencjê wspólzale¿nych dzia³añ (zadañ), które nastêpnie wykonuje, co prowadzi
w efekcie do instalacji lub wdro¿enia aplikacji. Obejmuj¹ one m.in.:<br>
  <ul>
    <li>tworzenie niezbêdnych katalogów,</li>
    <li>kompilacjê kodów Ÿród³owych,</li>
    <li>kopiowanie plików do odpowiedniej struktury katalogowej,</li>
    <li>instalacjê lub wdro¿enie aplikacji za pomoc¹ specyficznych zadañ, kierowanyh do managera aplikacji Tomacta.</li>
  </ul>


  Sekwencje tych zadañ zapisujemy w specjalnym pliku XML, interpretowanym
przez Ant, który wykonuje opisane czynnoœci. Przy tym mo¿emy u¿ywaæ zmiennych i w ten sposób "parametryzowaæ"
dzia³anie Anta (w ³atwy sposób, w jednym miejscu, zmieniaæ nazwy aplikacji, umiejscowienie jej
struktur katalogowej itp.).<br>
  <br> Nie sposób w kilku s³owach opisaæ Anta (na ten temat s¹ ponad 500-stronicowe
ksi¹¿ki, np. œwietna "Java Development with Ant" Ericka Hatchera i Steve'a
Looghrana). <br>
  <br>
Przedstawimy raczej "techniczn¹" instrukcjê, dotycz¹c¹ ³atwego sposobu budowania
i instalowania aplikacji WEB za pomoc¹ Anta,<br>
  <br>
Po pierwsze, musimy stworzyæ okreslon¹ strukturê katalogow¹ rozwijanej apliakcji.<br>
Najwygodniej zrobiæ to w nastêpuj¹cej formie:<br>
  <br>
  <ul>
    <li>&lt;katalog_aplikacji&gt;</li>
    <ul>
      <li>&nbsp; &nbsp; &nbsp;src &nbsp; &nbsp; &nbsp;&lt;--- podkatalog z kodami ¿ród³owymi</li>
      <li>&nbsp; &nbsp; &nbsp;web &nbsp; &nbsp;&lt;--- podkatalog z komponentami WEB (np. strony powitalne itp, opisy znaczników.)</li>
      <ul>
        <li>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;WEB-INF &nbsp;&lt;--- w tym podkatalogi
umieœcimy deskryptor &nbsp;wdro¿enia web.xml&nbsp;&nbsp;</li>
      </ul>
    </ul>
    <li>build.xml &nbsp; &nbsp; &lt;--- to bêdzie zapis dzia³añ dla Anta</li><li>build.properties &lt;--- ew. definicje ró¿nych w³asciwoœci danej aplikacji<br>
    </li>

    <li>context.xml &nbsp;&lt;--- opcjonalny plik deskryptora kontekstu aplikacji. <br>
    </li>
  </ul>
&nbsp;<br>
Ant wykonuje swoje zadania tylko wtedy gdy istnieje taka potrzeba (np. kompilacja
jest wykonywana tylko jeœli ¿ród³a maj¹ nowsz¹ datê od dotychczasowych wyników kompilacji,
pliki s¹ kopiowane tylko wtedy, gdy s¹ nowsze od ju¿ obecnych), Rozpoczynaj¹c
opis zadañ anta (ich wykonanie umieszczamy w tagu target) poprosimy o ustalenie
bie¿¹cego czasu (tstamp):<br>
  <pre>&lt;project name="nazwa projektu" default="build" basedir="."&gt;
  &lt;target name="init"&gt;
      &lt;tstamp/&gt;
  &lt;/target&gt;

</pre>
Uwagi:<br>
  <ul>
    <li><b>default</b> - oznacza domyœlne zadanie, gdy anta wywo³amy bez argumentów (jako argument mo¿emy podaæ zadanie do wykonania),</li>
    <li><b>basedir</b> - oznacza katalog (tu bie¿¹cy) wobec którego "rozwi¹zywane" s¹ relatywne odniesienia do katalogów i plików</li>
  </ul>
Nastêpnie musimy ustaliæ specyficzne dla aplikacji w³aœciwoœci: katalog w
którym maj¹ byæ umieszczone&nbsp; elementy aplikacja gotowe do zainstalowania
lub wdro¿euia, nazwê kontekstu apliakcji.<br>
  <br>
Specyficzne w³aœciwoœci naszej apliakcji zapiszemy w pliku build.properties, np:<br>
  <pre>app=serwlety1
app.path=E:/webaps/SERWLETY
</pre>
i u¿yjemy ich w pliku ant-a build.xml jako wartoœci zmiennych (oznaczanych przez ${nazwa_zmiennej}:<br>
  <pre>  &lt;property file="build.properties"/&gt;
  &lt;property name="build" value="${app.path}/${app}/build" /&gt;
  &lt;property name="context.path" value="${app}" /&gt;
</pre>
Powy¿ej, uzyskaliœmy wartoœci z pliku build.properties, po czym u¿yliœmy
ich do ustalenia w³aœciwoœci build i context.path. Od tego momentu, zmienna
${build} ma wartoœæ<br>
e:/webaps/SERWLETY/serwlety1/build (to jest ten katalog, w którym umieszczone
zostan¹ gotowe do wdro¿enia czy instalacji komponenty), a zmienna ${context.path}
&nbsp;oznaczaj¹ca kontekst aplikacji ma wartoœæ serwlety1.<br>
  <br>
  Zadanie przygotowawcze polega na stworzeniu odpowiednich katalogów (jeœli jest taka potrzeba, jesli ich jeszcze nie ma).<br>
  <pre>  &lt;target name="prepare" depends="init"
   	description="Buduje katalogi build"&gt;
    &lt;mkdir dir="${build}" /&gt;
    &lt;mkdir dir="${build}/WEB-INF" /&gt;
    &lt;mkdir dir="${build}/WEB-INF/classes" /&gt;
    &lt;mkdir dir="${build}/WEB-INF/lib" /&gt;	
    &lt;mkdir dir="${build}/WEB-INF/tags" /&gt;			
  &lt;/target&gt;

</pre>
Uwagi:<br>
  <ul>
    <li>za pomoca <b>depends</b> ustalamy zale¿noœæ zadañ. Zadanie <b>prepare</b> bêdzie
wykonane tylko wtedy gdy zadanie init zakoñczy³o siê poprawnie,</li>
    <li>katalog tags jest przeznaczony na w³asne biblioteki znaczników JSP,
nie zawsze musi byæ potrzebny, tak samo jak lib (ogolne biblioteki klas dla
ca³ej apliakcji), ale tworzymy tu ogóln¹, przygotowan¹ na wszystkie przypadki
programowania serwletów i JSP strukturê katalogow¹.</li>
  </ul>
Podstawowe zadanie <b>build</b> polega na kompilacji klas i kopiowaniu komponentów do katalogu instalacyjnego (oznaczanego przez zmienn¹ ${build}).<br>Wczeœniej powinniœmy ustaliæ œcie¿k¹ classpath, na której znajd¹ siê niezbêdne w kompilacji pakiety (pliki JAR).<br>
  <pre>   &lt;!-- Sciezka klas dla kompilacji --&gt;

  &lt;path id="classpath"&gt;
    &lt;fileset dir="${catalina.home}/lib"&gt;
      &lt;include name="*.jar"/&gt;
    &lt;/fileset&gt;
  &lt;/path&gt;

</pre>


Uwaga:<br>
  <ul>
    <li>wygodn¹ intsrukcj¹ Anta jest <b>fileset</b>
- definiowanie zbiorów plików.
Tutaj mówimy, ¿e pod identyfikatorem classpath ma siê znaleŸæ zbiór
wszystkich
plików z rozszerzeniem jar z katalogu&nbsp;/lib katalogu instalacyjnego
Tomcata (podanego w pliku properties pod nazw¹ catalina.home); u¿ycie
&nbsp;include **/*.ext w³¹czy³oby do zbioru wszystkie pliki z
rozszerzeniem
ext z katalogu dir i ca³ego drzewa podkatalogów (rekursywnie)
zaczynaj¹cych
siê w katalogu dir.</li>
  </ul>
  <br>
Do tej œcie¿ki (identyfikowanej przez classpath) odwo³amy siê w zadaniu kompilacji (j<b>avac</b>), stanowi¹cego czeœc zadania build. Inne fragmenty tego zadania polegaj¹ na kopiowaniu plikó.<br>
  <br>
  <pre>  &lt;target name="build" depends="prepare"
     description="Kompilacja i kopiowanie" &gt;
    &lt;javac srcdir="src" destdir="${build}/WEB-INF/classes" debug="on"&gt;
    	&lt;include name="**/*.java" /&gt;
     	&lt;classpath refid="classpath"/&gt;
    &lt;/javac&gt;
    &lt;copy todir="${build}/WEB-INF"&gt;
      &lt;fileset dir="web/WEB-INF"    &gt;
        &lt;include name="**/*.xml" /&gt;
        &lt;include name="**/*.html" /&gt;
        &lt;include name="**/*.tld" /&gt;
        &lt;include name="**/*.properties" /&gt;
        &lt;include name="**/*.txt" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
    &lt;copy todir="${build}"&gt;
      &lt;fileset dir="web"&gt;
        &lt;include name="**/*.html" /&gt;
        &lt;include name="**/*.jsp" /&gt;
        &lt;include name="**/*.jspf" /&gt;
        &lt;include name="**/*.gif" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
    &lt;copy todir="${build}/WEB-INF/tags"&gt;
      &lt;fileset dir="web"&gt;
        &lt;include name="**/*.tag" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
  &lt;/target&gt;

</pre>
Kompilowane i kopiowane s¹ tylko te pliki, które zosta³y zmodyfikowane.<br>
Zauwa¿my, ¿e kopiowanie plików z rozszerzeniem
*.tag, potrzebne jest po to by u¿ywaæ na stronach JSP&nbsp; ew. w³asnych znaczników.<br><br>
Po wykonaniu zadania build w katalogu oznaczanym przez zmienn¹ ${build} znajduje
sie gotowa do instalacji lub wdro¿enia struktura katalogowa naszej aplikacji.<br>
  <br>
Bardzo mocn¹ w³aœciwoœci¹ Anta jest mo¿liwoœæ dowolnego rozszerzania jego
funkcjonalnoœci przez definiowanie i implementacjê dodatkowych, specyficznych
zadañ (jako klas Javy, zreszt¹ ca³y Ant napisany jest w Javie),<br>
  <br>
Takie specyficzne zadania zwi¹zane z komunikacj¹ z mened¿erem aplikacji Tomcata
zosta³y ju¿ dla nas przygotowane - musimy je tylko w³¹czyæ do pliku opisu
zadañ Anta (build.xml). S¹ to m.in. nastêpuj¹ce zadania:<br>
  <ul>
    <li><b>install</b> - instalacja aplikacji - bardzo wygodne przy rozwijaniu (w obecnych wersjach Tomcata install dzia³a jak deploy),</li>
    <li><b>reload</b> - prze³adowanie aplikacji (np, po zmianie kodu klas Javy; zmiana web.xml wymaga jednak ponownej instalacji),</li>
    <li><b>remove</b> - usuniêcie zainstalowanej aplikacji,</li>
    <li><b>deploy</b> - wdro¿enie aplikacji.</li>
  </ul>
Musimy te zadania najpierw zdefiniowaæ (bo wykorzystuj¹ zewnêtrzne wobec Anta klasy):<br>
  <pre>  &lt;!-- definiowane zadania Anta dla Tomcata --&gt;
  &lt;taskdef name="install" classname="org.apache.catalina.ant.InstallTask"/&gt;
  &lt;taskdef name="reload"  classname="org.apache.catalina.ant.ReloadTask"/&gt;
  &lt;taskdef name="remove"  classname="org.apache.catalina.ant.RemoveTask"/&gt;	
  &lt;taskdef name="deploy" classname="org.apache.catalina.ant.DeployTask"/&gt;	
  &lt;taskdef name="undeploy" classname="org.apache.catalina.ant.UndeployTask"/&gt;	

</pre>
Po czym mo¿emy ich u¿yæ np.:<br>
  <pre>  &lt;target name="install" description="Instaluje aplikacje"
          depends="build"&gt;
    &lt;install url="${url}" username="${username}" password="${password}"
          path="/${context.path}" war="file:${build}"/&gt;
  &lt;/target&gt;

  &lt;target name="install-config"
      description="Instaluje w oparciu o context.xml" depends="build"&gt;
     &lt;install url="${url}" path="niewazne"
      config="file:${app.path}/${app}/context.xml"
      username="${username}" password="${password}"/&gt;
  &lt;/target&gt;


  &lt;target name="reload" description="Przeladowuje  aplikacje"
          depends="build"&gt;
    &lt;reload  url="${url}" username="${username}" password="${password}"
          path="/${context.path}"/&gt;
  &lt;/target&gt;

  &lt;target name="remove" description="Usuwa aplikacje"&gt;
    &lt;remove url="${url}" username="${username}" password="${password}"
          path="/${context.path}"/&gt;
  &lt;/target&gt;

</pre>
Uwaga:<br>
  <ul>
    <li>zmienna url zawiera lokator mened¿era aplikacji, gdzieœ wczeœniej
mogliœmy zapisaæ &nbsp; &lt;property name="url"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value="http://localhost:8080/manager"/&gt;
lub pobraæ wartoœæ tej w³aœciowoœci z pliku .properties,</li>
    <li>zmienne username i password to nazwa u¿ytkownikia i has³o potrzebne
do dostêpu do mened¿era aplikacji (w Tomcacie specyfikujemy te
wartoœci w pliku conf/tomcat-users.xml), zapewne wpiszemy je do pliku build.properties,</li>
    <li>context.path - to okreœlona wczeœniej œcie¿ka kontekstu, </li>
    <li><b>war</b> - okreœla umiejscowienie aplikacji (w naszym przypadku jest
to niespakowana struktura katalogowa,&nbsp; znajduj¹ca
siê pod katalogiem ${build}</li>
  </ul>
  <br>
Pokazane fragmenty pliku build.xml s¹ na tyle ogólne, ¿e daj¹ siê zastosowaæ
wlaœciwie wobec ka¿dej aplikacji zawieraj¹cej serwlety lub strony JSP.<br>
Mo¿emy zatem taki plik umieœciæ w jakimœ ogólnie dostêpnym katalogu (np.
o nazwie common), nazwac np. <span style="font-weight: bold;">defbuild.xml</span> i wl¹czaæ go w ka¿dym konkretnym
pliku buld.xml dla konkretnych aplikacji.<br>
We wspólnym katalogu (common) umieœcimy te¿ plik wspó³nych w³aœciwoœci wszystkich
aplikacji (build.properties), w którym mo¿emy zapisaæ np. nazwê u¿ytkownika
i has³o dostêpu do mened¿era aplikacji oraz œcie¿kê do instalacji Tomcata, np:<br>
  <br>
  <pre>username=admin
password=admin
catalina.home=E:/Serwery/apache-tomcat-6.0.13

</pre>
  <br>
Teraz w ka¿dym konkretnym podkatalogu przeznaczonym dla konkretnej apliakcji
umieszczamy tylko opisu w³aœciwoœci tej aplikacji (nazwa aplikacji i œcie¿ka
dostêpu &nbsp;- widzieliœmy ju¿ ten plik build.properties) oraz&nbsp; plik buld.xml
w nastêpuj¹cej postaci:<br>
  <br>
  <pre>&lt;!--
    Projekt
--&gt;

&lt;!DOCTYPE project [
  &lt;!ENTITY defbuild SYSTEM "../../common/defbuild.xml"&gt;
]&gt;


&lt;project name="moja aplikacja" default="build" basedir="."&gt;
  &lt;target name="init"&gt;
      &lt;tstamp/&gt;
  &lt;/target&gt;

  &amp;defbuild;

&lt;/project&gt;

</pre>
Zapis &amp;defbuild w³¹cza zawartoœci pliku defbuild.xml z katalogu common.<br>
Dla porz¹dku przytoczê jeszcze pe³ny zapis tego pliku:<br>
  <pre>  &lt;!-- Wlasciwosci dla dostepu do Managera aplikacji --&gt;
  &lt;property name="url"      value="http://localhost:8080/manager"/&gt;

       &lt;!-- Konfiguracja wlasciwosci  --&gt; 
  &lt;property file="../../common/build.properties"/&gt;
  &lt;property file="build.properties"/&gt;
  &lt;property name="build" value="${app.path}/${app}/build" /&gt;
  &lt;property name="context.path" value="${app}" /&gt;


  &lt;!-- Sciezka klas dla kompilacji --&gt;

  &lt;path id="classpath"&gt;
    &lt;fileset dir="${catalina.home}/lib"&gt;
      &lt;include name="*.jar"/&gt;
    &lt;/fileset&gt;
  &lt;/path&gt;

  &lt;!-- definiowane zadania Anta dla Tomcata --&gt;
  &lt;taskdef name="install" classname="org.apache.catalina.ant.InstallTask"/&gt;
  &lt;taskdef name="reload"  classname="org.apache.catalina.ant.ReloadTask"/&gt;
  &lt;taskdef name="remove"  classname="org.apache.catalina.ant.RemoveTask"/&gt;	
  &lt;taskdef name="deploy" classname="org.apache.catalina.ant.DeployTask"/&gt;	
  &lt;taskdef name="undeploy" classname="org.apache.catalina.ant.UndeployTask"/&gt;	


  &lt;target name="prepare" depends="init"
   	description="Buduje katalogi build"&gt;
    &lt;mkdir dir="${build}" /&gt;
    &lt;mkdir dir="${build}/WEB-INF" /&gt;
    &lt;mkdir dir="${build}/WEB-INF/classes" /&gt;
    &lt;mkdir dir="${build}/WEB-INF/lib" /&gt;	
    &lt;mkdir dir="${build}/WEB-INF/tags" /&gt;			
  &lt;/target&gt;


  &lt;!-- wykonanie zadan --&gt;

  &lt;target name="install" description="Instaluje aplikacje"
          depends="build"&gt;
    &lt;install url="${url}" username="${username}" password="${password}"
          path="/${context.path}" war="file:${build}"/&gt;
  &lt;/target&gt;

  &lt;target name="install-config"  
      description="Instaluje w oparciu o context.xml" depends="build"&gt;
     &lt;install url="${url}" path="/${context.path}" war="file:${build}"
      config="file:${app.path}/${app}/context.xml"
      username="${username}" password="${password}"/&gt;
  &lt;/target&gt; 


  &lt;target name="reload" description="Przeladowuje  aplikacje"
          depends="build"&gt;
    &lt;reload  url="${url}" username="${username}" password="${password}"
          path="/${context.path}"/&gt;
  &lt;/target&gt;

  &lt;target name="remove" description="Usuwa aplikacje"&gt;
    &lt;remove url="${url}" username="${username}" password="${password}"
          path="/${context.path}"/&gt;
  &lt;/target&gt;


  &lt;target name="build" depends="prepare" 
     description="Kompilacja i kopiowanie" &gt;
    &lt;javac srcdir="src" destdir="${build}/WEB-INF/classes" debug="on"&gt;
    	&lt;include name="**/*.java" /&gt;
     	&lt;classpath refid="classpath"/&gt;
    &lt;/javac&gt;
    &lt;copy todir="${build}/WEB-INF"&gt;
      &lt;fileset dir="web/WEB-INF"    &gt;
        &lt;include name="**/*.xml" /&gt;
        &lt;include name="**/*.html" /&gt;
        &lt;include name="**/*.tld" /&gt;
        &lt;include name="**/*.properties" /&gt;
        &lt;include name="**/*.txt" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
    &lt;copy todir="${build}"&gt;
      &lt;fileset dir="web"&gt;
        &lt;include name="**/*.html" /&gt;
        &lt;include name="**/*.jsp" /&gt;
        &lt;include name="**/*.jspf" /&gt;
        &lt;include name="**/*.gif" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
    &lt;copy todir="${build}/WEB-INF/tags"&gt;
      &lt;fileset dir="web"&gt;
        &lt;include name="**/*.tag" /&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
  &lt;/target&gt;


</pre>
oraz przyk³adowy plik build.properties (konkretnej aplikacji), np rozwijanej w katalogu G:/webaps/SERWLETY/jsp-test<br>
  <br>
  <pre>app=jsp-test
app.path=G:/webaps/SERWLETY
</pre>
  <br>
Po wywo³aniu <b>ant install</b> &nbsp;w katalogu G:/webaps/SERWLETY/jsp-test zostanie
utworzony katalog build, skopiowane do niego odpowiednie pliki i struktury
katalogowe i aplikacja zostanie zainstalowana w kontekœcie jsp-test (œcie¿k¹
kontekstu aplikacji bedzie /jsp-test). Od tego momentu mo¿emy odowo³wyac
siê do tej aplikacji.<br>
  <br>
Jeœli chcemy zmieniæ plik web.xml (deskryptor wdro¿enia), to po zmianie - aplikacjê musimy przeinstalowaæ zatem:<br>
  <ul>
    <li>najpierw j¹ usun¹æ - <b>ant remove</b></li>
    <li>a poŸniej zainstalowaæ ponownie - <b>ant install</b></li>
  </ul>
Mo¿emy równie¿ zainstalowaæ aplikacjê u¿ywaj¹c pliku deskryptora kontekstu
(powiedzmy, ¿e nazywa siê on context.xml, tak zreszt¹ ustaliliœmy w pliku
defbuild.xml dla Anta).&nbsp; W tym przypadku wywo³ujemy anta do wykonania zadania
install-config:<br>
  <b>ant install-config </b>(zob. jego definicjê w pliku defbuild.xml)<br>
  <br>
Przy instalacjach jako umiejscowienie aplikacji mo¿emy podaæ zarowno niespakaowany
katalog aplikacji, jak i plik WAR (ze zpakowanym katalogiem aplikacji).<br>
  <br>
Zadanie wdro¿enia (<b>ant deploy</b>) wymaga natomiast u¿ycia wy³¹cznie pliku
WAR, do którego wczeœniej musimy spakowaæ strukturê katalogow¹ aplikacji.
Do tego te¿ mo¿emy zastosowac Anta, przez zdefiniowanie i wykonanie nastêpuj¹cego
zadania:<br>
  <br>
  <pre>  &lt;target name="package"
      description="Pakuje WAR"&gt;
      &lt;delete file="dist/${war.file}" /&gt;
      &lt;jar jarfile="dist/${war.file}" &gt;
        &lt;fileset dir="${build}" /&gt;
      &lt;/jar&gt;
  &lt;/target&gt;

</pre>
Katalog dist jest katalogiem "dystrybucji" i musi byæ oczywiœcie wczeœniej utworzony.<br>
  <br>
Tutaj raczej pozastawiamy etap wdro¿enia na boku (nie zdefiniowaliœmy
zadañ deploy i undeploy, zamaist nich u¿ywamy install i remove). Zale¿y
nam bowiem przede
wszystkim na narzêdziu, które umo¿liwi szybkie przeinstalowywanie
aplikacji
przy jej rozbudowie i testowaniau. Takie narzêdzie w³aœnie opisano, a
niezbêdne
pliki znajduj¹ sie w katalogu samples. Na koniec warto jeszcze tylko
powiedzieæ,
¿e proponowane rozwi¹zanie jest - naturalnie - jednym z mo¿liwych. Byæ
mo¿e ³atwiej jest u¿ywaæ œrodowisk w rodzaju NetBeans czy Ecliipse,
skonfigurowanego jako Eclipse for Java EE Developer. Ale stosuj¹c
w³asny skrypt Anta mo¿emy bardzo dok³adnie przeœledziæ co siê dziej,
gdzie i jak s¹ umieszczane rózne komponenty aplikacji itp. Przejœcie na
bardziej wizualne, "wyklikiwane" rozwi¹zania jest etapem, który raczej
powinien nastêpowac po zrzoumieniu mechanizmów dzialania. I dlatego na
Ancie tu &nbsp;poprzestaniemy.<br>
  <br>
<br>
  <a name="WebApps.4"></a><h2>

4. Serwlety - model dzia³ania i obs³uga zleceñ</h2>


Zajmiemy siê teraz bli¿ej serwletami HTTP, reprezentowanymi przez obiekty
klasy HTTPServlet.<br>
Najogólniejaza klasa serwletów GenericServlet implementuje interfejsy Servlet
(okreœlaj¹cy najogólniejsz¹ funkcjonalnoœæ serwletów) oraz ServletConfig
(obiekt tego typu s¹ przekazywane serwletom przy ich&nbsp; inicjacji przez serwer
i zawiera&nbsp; kontekst aplikacji WEB - czyli znany nam ju¿ ServletContext).
  <br>
  <br>
GenericServlet okreœla serwlety bez ustalonego protoko³u sieciowego, dziedzicz¹ca
j¹ klasa HTTPServlet s³u¿y do tworzenia serwletów obs³uguj¹cych protokó³
HTTP.<br>
  <br>
  <img style="border: 1px solid ; width: 336px; height: 342px;" src="images/servlet-classes.gif" alt="r1">
<br>
  <br>
  <br>
<div class="important">Aby stworzyæ serwlet HTTP dziedziczymy klasê HTTPServlet i przedefiniowujemy wybrane jej metody</div><br>
  <br>
Serwlety s¹ tworzone i inicjowane przy pierwszym wywo³aniu (lub na starcie
serwera - w zale¿nosci od opcji). Proces obejmuje kolejno:<br>
  <ul>
    <li>za³adowanie klasy serwletu,</li>
    <li>utworzenie obiektu,</li>
    <li>inicjacjê.</li>
  </ul>
Dopiero w fazie inicjacji tworzony jest obiekt typu ServletConfig i dopiero
od tego momentu dostêpny jest kontekst serwletu. Jest to wa¿na obserwacja,
bowiem oznacza ona, ¿e w konstruktorze &nbsp;nie mamy dostêpu do kontekstu aplikacji,
a zatem&nbsp; œcie¿ek i zasobów.<br>
Przy inicjacji serwletu wywo³ywana jest metoda init(ServletConfig) z obiektem
typu ServletConfig przekazanym jako argument, która z kolei wywo³uje bezparametrowa
metode init().&nbsp; <br>
Dla wykonania jakichs jednorazowych prac inicjacyjnych (np. l¹czenia z baz¹ danych) przedefiniowujemy zwykle&nbsp; <b>bezparametrow¹ metodê&nbsp; init(), </b>
&nbsp;bo jest to wygodniejsze (przedefiniowanie init(ServletConfig) wymaga³oby
- zgodnie z modelem dzia³ania serwletów - odwo³ania super.init()).<br>
Po inicjacji serwlet jest gotowy do obs³ugi zleceñ klientów.<br><br>
Ka¿de zlecenie przechodzi przez metodê service(...), która z kolei wywo³uje
odpowiedni¹ dla danego rodzaju zlecenia (GET,POST,PUT, itd) <br>
  <br>
Ilustruje to wszystko poni¿szy przyk³adowy serwlet:<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

public class Test extends HttpServlet {

  static String loadMsg = "Klasa zaladowana " + new Date();
  String createMsg = "\nSerwlet utworzony  " + new Date();
  String initMsg;
  String config1Msg = "\nW konstruktorze ServletConfig ",
         config2Msg = "\nW metodzie init ServletConfig ";

  public Test() {
    ServletConfig conf = getServletConfig();
    if (conf == null)
      config1Msg += "nie istnieje,\n" +
         "zatem nie ma dostepu do kontekstu i inicjalnych parametrów";
    else config1Msg +=  " istnieje !!??";
  }

  public void init() {
    initMsg  = "\nSerwlet zainicjowany " + new Date();
    ServletConfig conf = getServletConfig();
    if (conf == null) config2Msg +=  "nie istnieje !!??";
    else {
      config2Msg += "istnieje.\nMozemy odwolac sie do kontekstu" +
                     " i inicjalnych parametrów:\n";

    // Uzyskanie kontekstu i dostêp do niego - dwa równowa¿ne sposoby
    ServletContext context1 = conf.getServletContext();
          // poni¿sze odwolanie oznacza getConfig().getServletContext()
    ServletContext context2 = getServletContext();
    String name = context2.getServletContextName();
    }
  }

  PrintWriter out;

  public void service(HttpServletRequest req, HttpServletResponse resp)
         throws ServletException, IOException
  {
     out = resp.getWriter();
     out.println(loadMsg);
     out.println(createMsg);
     out.println(config1Msg);
     out.println(config2Msg);
     out.println("obsluga zlecenia przez metode service " + new Date());

     // Jezeli przedefinujemy metodê servis
     // zazwyczaj bêdziemy wo³aæ super.service(...)
     // by przekazaæ zlecenie do obs³ugi przez konkretne metody
     // np. doGet lub doPost

     super.service(req, resp);
     out.close();
  }


  public void doGet(HttpServletRequest req, HttpServletResponse resp)
                 throws ServletException, IOException
  {

    out.println("\nWywolana metoda doGet " + new Date());
    out.close();
  }


}
</pre>
który wywo³any z paska adresu przegl¹darki (co jest równowa¿ne zleceniu GET)
utworzy i zwróci przegl¹darce&nbsp; stronê rekstow¹ o nastêpuj¹cej zawartoœci:<br>
  <pre>Klasa zaladowana Mon Sep 01 01:59:04 CEST 2008

Serwlet utworzony  Mon Sep 01 01:59:04 CEST 2008

W konstruktorze ServletConfig nie istnieje,
zatem nie ma dostepu do kontekstu i inicjalnych parametrów

W metodzie init ServletConfig istnieje.
Mozemy odwolac sie do kontekstu i inicjalnych parametrów:

obsluga zlecenia przez metode service Mon Sep 01 01:59:04 CEST 2008

Wywolana metoda doGet Mon Sep 01 01:59:04 CEST 2008

</pre>
  Na ¿yczenie administratora serwera lub gdy aplikacja jest nieaktywna przez
okreœlony czas (ustalony przez odpowiednie opcje serwera) - serwlet jest
usuwany. Wtedy wywo³ywana jest jego metoda destroy(). Mo¿emy j¹ przedefiniowaæ,
szczególnie w tym celu, by uporz¹dkowaæ œrodowisko (np. zamkn¹æ po³¹czenia
z bazami danych, usun¹c jakieœ niepotrzebne zasoby itp.). <br>
  <br>
Serwlety HTTP obsluguj¹ zlecenia HTTP.<br>
  <br>
Zlecenie HTTP sk³ada siê m.in. z:<br>
  <ul>
    <li>nazwy metody zlecenia,</li>
    <li>URL-a&nbsp; zlecenia,</li>
    <li>nag³ówków HTTP zlecenia,</li>
    <li>treœci zlecenia (inaczej: cia³a)</li>
  </ul>
  <br>
Serwlety HTTP obs³uguj¹ nastêpuj¹ce rodzaje (metody) zleceñ HTTP.<br>
  <br>
  <table border="1" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr>
        <td valign="top" width="20%"><b>Zlecenie (metoda)<br>
        </b></td>
        <td valign="top" width="60%"><b>Znaczenie<br>
        </b></td>
        <td valign="top" width="20%"><b>Metoda klasy<br>
HTTPServlet</b><br>
        </td>
      </tr>
<tr><td valign="top" width="20%">GET&nbsp;</td><td valign="top" width="60%">uzyskanie zasobu identyfikowanego przez URL<br>
        </td>
        <td valign="top" width="20%">doGet<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">HEAD&nbsp;</td><td valign="top" width="60%">Uzyskanie nag³ówków <br>
        </td>
        <td valign="top" width="20%">doHead<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">POST&nbsp;</td><td valign="top" width="60%">Wys³anie danych o nielimiotowanej d³ugoœci<br>
        </td>
        <td valign="top" width="20%">doPost<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">PUT&nbsp;</td><td valign="top" width="60%">Zapisanie zasobu <br>
        </td>
        <td valign="top" width="20%">doPut<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">DELETE&nbsp;</td><td valign="top" width="60%">Usuniêcie zasobu<br>
        </td>
        <td valign="top" width="20%">doDelete<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">OPTIONS&nbsp;</td><td valign="top" width="60%">Zwrcaa metody HTTP podtrzymywane przez serwer<br>
        </td>
        <td valign="top" width="20%">doOptions<br>
        </td>
</tr><!--msthemelist--><tr><td valign="top" width="20%">TRACE</td><td valign="top" width="60%">Zwraca nag³ówki wys³ane zleceniem TRACE (do celów testowania_<br>
        </td>
        <td valign="top" width="20%">doTrace<br>
        </td>
</tr></tbody>
  </table>
  <br>
Wymienione metody klasy HTTPServlet sa wywo³ywane, gdy przyjdzie odpowiednie
zlecenie. Dlatego dla obs³ugi odpowiedniego rodzaju zlecenia przedefiniowujemy
odpowiednie metody.<br>
Wszystkie w/w metody maj¹ takie same sygnatury oraz &nbsp;(standardowo)
mog¹ generowaæ wyj¹tki klas ServletException i IOException<br>
  <br>
<div class="syntax"> <br>
  <div align="center">Sygnatury i wyj¹tki kontrolowane metod obs³ugi zleceñ HTTP <br>
z klasy HTTPServlet<br>
  <br>
  </div>
  <b>protected void do<i>NNN</i>( HttpServletRequest req,&nbsp; HttpServletResponse resp)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
throws ServletException,&nbsp; java.io.IOException<br>
  </b>
  <br>
gdzie <b><i>NNN</i></b> - zlecenie (GET,POST, HEAD, itd).<br>
</div><br>
  <br>
Zlecenia do obs³ugi przekazywane s¹ jako obiekty klasy implementuj¹cej interfejs
HTTPServletRequest (który z kolei rozszerza ogólniejszy interfejs ServletRequest)<br>
Przygotowana standardowa implementacja tego interfejsu w klasie HTTPServletRequestWrapper
s³u¿y do wygodnego budowania w³asnych klas zleceñ (poprzez odziedziczenie
gotowej implementacji, dziêki czemu unikamy koniecznoœci definiowania metod
interfejsu, a mo¿emy je przedefiniowaæ lub dodaæ jakieœ nowe).<br>
Wygl¹da to mniej wiêcej tak:<br>
  <br>
  <img style="border: 1px solid ; width: 560px; height: 205px;" src="images/servletRequest-classes.gif" alt="r">
  <br>
  <br>
Obiekt-zlecenie mo¿emy wykorzystaæ m.in. do:<br>
  <ul>
    <li>pobrania œeie¿ek i dodatkowych informacji zawartych w URLu zlecenia (widzieliœmy ju¿ to na przyk³adach poprzednio),<br>
    </li>
    <li>pobrania nag³ówków HTTP zlecenia (ogólne metody: getHeaders(), getHeaderNames()
getHeader(String) oraz przygotowane na czêsto u¿ywane nag³ówki np:&nbsp; getLocale(),
getContentType(), getCharacterEncoding(), getContentLength()),</li>
    <li>pobrania parametrów zlecenia (metody getParameterMap(), getParameterNames(),
getParameterValues(), getParameter(String) - o parametrach bêdziemy mówiæ
za chwilê</li>
    <li>pobrania lub ustalenia atrybutów zlecenia - czyli zwi¹zancyh ze zleceniem
obiektów, które mog¹ byæ tworzone przez serwer lub ustalane programistycznie
przy przekazywaniu zlecenia do obs³ugi dalej, np. do innego serwletu (metody
getAttributeNames(), getAttribute(), setAttribute(), removeAttribute()),</li>
    <li>pobrania strumiena wejœciowego (bajtowego - getInputStream() lub
znakowego - getReader()) poprzez który mo¿na przeczytaæ treœæ (cia³o) zlecenia.</li>
  </ul>
Zwykle po interpretacji zlecenia i przeprowadzeniu odpowiednich dzia³añ,
serwlet konstruuje odpowiedŸ, która ma byæ przes³ana klientowi.<br>
Odpowiedzi s¹ obiektami klas implementuj¹cych interfejs HTTPServletResponse.
Podobnie jak przy zleceniacj mamy tu odpowiedni "wrapper" u³atwiaj¹cy tworzenie
w³asnych klas iodpowiedzi.<br>
  <br>
  <img style="border: 1px solid ; width: 647px; height: 236px;" src="images/servletResponse-classes.gif" alt="r">
  <br>
  <br>
Odpowiedzi sk³adaj¹ siê m.in. z :<br>
  <ul>
    <li>kodu wyniku (np. 200 - wszystko OK, 404 - zasób nie znaleziony),</li>
    <li>nag³ówków HTTP,</li>
    <li>treœæ (cia³o) odpowiedzi.</li>
  </ul>
Buduj¹c odpowiedŸ mo¿emy wykorzystaæ metody ustalania i dodawania nag³ówków:<br>
ogólne - setHeader(...), addHeader(...) oraz specjalnie przygotowane na czêsto
u¿ywane przypadki np. setCharacterEncoding(...) czy setContentType(...).<br>
  <br>
Serwlet zapisuje treœæ odpowiedzi&nbsp; do strumienia (znakowego lub bajtowego)
zwi¹zanego z obiektem-odpowiedzi¹. Strumienie te pobieramy od obiektu-odpowiedzi
za pomoc¹ metod getWriter() (strumieñ znakowy) lub getOutputStream() (strumieñ
bajtowy, binarny).<br>
  <br>
W przypadku wyst¹pienia&nbsp; b³êdu - zamiast cia³a odpowiedzi &nbsp;mo¿emy pos³aæ kod b³êdu z ew. dodatkow¹ informacj¹ (metody <b>sendError</b>). Metody te mog¹ byæ uzyte tylko wtedy gdy odpowiedŸ nie zosta³ dot¹d zatwierdzona.<br>
Odpowied¿ jest <b>zatwierdzona</b> (<b>commited</b>), gdy bufor strumienia odpowiedzi
jest wymiatany (wielkoœæ bufora mo¿emy ustaliæ za pomoca metody setBuffer).
To wa¿na informacja, bowiem po zatwierdzeniu odpowiedzi pewne akcje ze strony
serwletu s¹ niedozwolone np. ustalanie nag³ówków czy - w³asnie
wspomniane przed chwil¹ u¿ycie metod sendErroe).<br>
  <br>
Serwlet mo¿e równie¿ zamiast generowania treœci:<br>
  <ul>
    <li>zwróciæ tzw. <b>przekierowanie</b> adresu (redirected URL) za pomoc¹&nbsp;metody
sendRedirect(...) - serwer HTTP przekieruje klienta na podany jako argument
metody adres; u¿yæ metody mo¿na tylko wtedy, gdy odpowiedŸ nie zosta³a zatwierdzona;
po przekierowaniu nie wolno ju¿ nic pisaæ do strumienia wyjœciwego,</li>
    <li>przekazaæ obs³ugê zlecenia do innego komponentu WEB&nbsp; (serwletu, strony JSP) u¿ywaj¹c obiektu RequestDispatcher.</li>
  </ul>
Pora teraz na praktyczne przyk³¹dy, dziêki którym bêdziemy mogli bli¿ej omówiæ
niektóre szczegó³y przedtsaiwonego tu "modelu" dzia³ania serwletów.<br>
  <br>
Zacznijmy od serwletu witaj¹cego u¿ytkownika i pokazuj¹cego aktualn¹ datê i czas.<br>
Oczywiœcie, musimy uwzglêdniæ wymagania internacjonalizacji: serwlet powinien
przywitaæ u¿ytkownika w jego jêzyku (œciœlej jêzyku ustalonym w przegl¹darce)
i odpowiednio sformatowaæ datê i czas. Wymaga to:<br>
  <ul>
    <li>przygotowania zlokalizowanych tekstów w ResourceBundle,</li>
    <li>odczytania z nag³ówków zlecenia preferowanego jêzyka u¿ytkownika
(nag³ówek accept-language, dostarczany te¿ przez metodê getLocale()),</li>
    <li>wybrania tekstu odpowiedzi z odpowiedniego ResourceBundle,</li>
    <li>ustalenie typu treœci i kodowanie odpowiedzi,</li>
    <li>(opcjonalnie, w zaleznoœci od œrdowiska kodowania tej odpowiedzi w odpowiedniej stronie kodowej.</li>
  </ul>
Klasy zasobów lokaloizacyjnych przygotujemy i umieœcimy w pakiecie international (zatem w
naszym katalogu WEB-INF\classes musi znaleŸæ siê odpowiedni podkatalog).
Przyk³adowo mo¿e:my mieæ m.in. takie klasy<br>
  <br>
  <pre>package international;
import java.util.*;

public class Messages_en extends ListResourceBundle {
     public Object[][] getContents() {
         return contents;
     }

    static final Object[][] contents = {
       { "hello", "Hello!" },
       { "now", "Now is: " },
       { "charset", "ISO-8859-1" }
    };
}
</pre>
  <pre>package international;
import java.util.*;

public class Messages_pl extends ListResourceBundle {
     public Object[][] getContents() {
         return contents;
     }

    static final Object[][] contents = {
       { "hello", "Dzieñ dobry!" },
       { "now", "Teraz bêdzie, a w³aœciwie ju¿ jest" },
       { "charset", "ISO-8859-2" }
    };
}
</pre>
Uwagi: <br>
  <ol>
    <li>W zasobach dla danego jêzyka okreœlimy w³aœciw¹ stronê kodow¹, nie
polegaj¹c na kodowaniu, które ew. moglibyœmy odczytaæ z nag³ówka zlecenia
(getCharacterEncoding()), bo mog³oby okazaæ siê fa³szywe.</li>
    <li>Zasoby zlokalizowane przygotowujemy jako klasy ListResourceBundle,
bowiem - z niejasnych&nbsp; powodów - serwlety nie umiej¹ w³aœciwie przekodowaæ
do Unicode'u tekstów zapisanych w plikach .properties (PropertiesBundle).</li>
    <li>Musimy dostarczyæ wszystkich klas z odpowiednimi przyrostkami lokalizacyjnymi
(Messages_pl, Messages_en). Inaczej bowiem ni¿ w normalnych apliakcjach w
serwletach przy braku klasy dla danej lokalizacji nie jest ³adowany domyœlny
zasób (Messages) o ile tylko nie zrestartowano serwera. Ma to zapewne zwi¹zek
z obs³ug¹ ³adowania klas przez Tomcat.<br>
    </li>
  </ol>
  <br>
Nasz serwlet mo¿e wygl¹dac tak.<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.text.*;

public class Time1 extends HttpServlet {

  public void doGet(HttpServletRequest request,
                       HttpServletResponse response)
                 throws ServletException, java.io.IOException
  {
     // Jaki jest preferowany jêzyk klienta?
     Locale locale = request.getLocale();

     // Uzyskanie odpowiedniego zlokalizowanego zasobu
     ResourceBundle msg = ResourceBundle.getBundle(
                             "international.Messages", locale);

     // Zlokalizowane komunikaty i odpowiednia strona kodowa
     String hello = msg.getString("hello");
     String now = msg.getString("now");
     String charset = msg.getString("charset");

     // Ustalenie typu i kodowania odpowiedzi
     // Musi byæ ustalone przed uzyskaniem strumienia wyjœciowego
     response.setContentType("text/html; charset=" + charset);

     // Pobranie strumienia wyjœciowego
     // z zapewnieniem w³asciwego kodowania
     // czasami wystarcza samo: PrintWriter out = response.getWriter()

     PrintWriter out = new PrintWriter(
        new OutputStreamWriter(response.getOutputStream(), charset),
        true);



     out.println("&lt;h2&gt;" + hello + "&lt;br&gt;" + now + "&lt;br&gt;" );
     out.println(getDate(locale) + "&lt;/h2&gt;");
     out.close();
  }


  private String getDate(Locale loc) {
    Date data = new Date();
    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG,
                                                   DateFormat.MEDIUM,
                                                   loc);
    return df.format(data);
  }


}
</pre>
a wynik jego dzia³ania bêdzie zale¿a³ nie tylko od aktualnej daty i czasu,
ale równie¿ od ustawieñ jêzykowych przegl¹darki klienta.<br>
Tutaj mamy bardzo wyraŸny, prosty przyk³ad prawdziwie dynamicznej generacji treœci.<br>
W przegl¹darce ustawionej na jêzyk polski uzyskamy:<br>
  <br>
  <img style="border: 1px solid ; width: 602px; height: 361px;" src="images/Time1-1.jpg" alt="r">
  <br>
  <br>
a w ustawionej na jêzyk angielski:<br>
  <br>
  <img style="border: 1px solid ; width: 602px; height: 361px;" src="images/Time1-2.jpg" alt="r">
  <br>
  <br>
  <br>
Z tym przyk³adowym serwletem mamy jednak przynajmniej dwa k³opoty.<br>
  <ul>
    <li>po pierwsze, przedefiniowaliœmy tylko metodê doGet(...) i powstaje
pytanie czy to wystarczy aby serwlet dzia³al w &nbsp;ka¿dych okolicznoœciach?
Musimy chyba bli¿ej przyjrzeæ siê metodom zleceñ HTTP i zaraza to zrobimy.</li>
    <li>po drugie, pobieranie zasobów lokalizacyjnych umieszczone jest w
metodzie doGet() i jest wykonywane za ka¿dym po³¹czeniem. Byæ mo¿e warto
zoptymalizowac nieco kod pod k¹tem wielokrotnego ³¹czenia siê tego samego
u¿ytkownika (który normalnie nie zmienia przy ka¿dym po³¹czeniu jêzyka przegl¹darki).
Tu na pomoc przyjdzie nam pojêcie sesji i metody zwi¹zane z zarz¹dzaniem
sesjami. O tym bêdziemy mówiæ nieco poŸniej.</li>
  </ul>Zacznijmy od zlecñ. Dwa najbardziej popularne rodzaje zleceñ HTTP to GET i POST.<br>
Zlecenie GET jest generowane, gdy:<br>
  <ul>
    <li>u¿ytkownik wypelni informacje &nbsp;na pasku adresu i &nbsp;naciœnie ENTER,</li>
    <li>kliknie w link z adresem,</li>
    <li>wyœle formularz (np. przez klikniêcie w przycisk "Wyœlij"), który
albo nie specyfikuje metody (brak paarmetru METHOD, alb specyfikuje jako
metodê - GET).</li>
  </ul>
Zlecenie POST - s³u¿¹ce g³ównie przesy³aniu przez klienta wiêkszej liczby
informacji - jest generowane, gdy uzytkownik wysy³a formularz z wyspecyfikowan¹
metod¹ POST (METHOD="POST"). <br>
  <br>
Oczywiœcie, ka¿de z tych rodzajów zleceñ mo¿e te¿ byæ wys³ane przez dowolnych
klientów HTTP (nie tylko przegl¹darki), którzy wyspecyfikuj¹ jako metodê zlecenia GET lub POST.<br>
  <br>
Okazuje siê wiêc, ¿e oba rodzaje zleceñ mog¹ dotyczyæ naszego pokazywacza czasu.<br>
Np. z takiej strony WWW:<br>
  <img style="border: 1px solid ; width: 427px; height: 242px;" src="images/ExtPage1.jpg" alt="r">
  <br>
  <br>
której kod HTML wygl¹da tak:<br>
  <pre>&lt;<span class="start-tag">html</span>&gt;
&lt;<span class="start-tag">head</span>&gt;
 &lt;<span class="start-tag">meta</span><span class="attribute-name"> http-equiv</span>=<span class="attribute-value">"Content-Type" </span><span class="attribute-name">content</span>=<span class="attribute-value">"text/html; charset=windows-1250"</span>&gt;
 &lt;<span class="start-tag">title</span>&gt;Pokazuje date i czas&lt;/<span class="end-tag">title</span>&gt;
&lt;/<span class="end-tag">head</span>&gt;

&lt;<span class="start-tag">body</span>&gt;
&lt;<span class="start-tag">center</span>&gt;&lt;<span class="start-tag">h2</span>&gt;Data i czas&lt;/<span class="end-tag">h2</span>&gt;&lt;/<span class="end-tag">center</span>&gt;
&lt;<span class="start-tag">hr</span>&gt;
&lt;<span class="start-tag">form</span><span class="attribute-name"> method</span>=<span class="attribute-value">"post" </span><span class="attribute-name">action </span>=<span class="attribute-value">"http://localhost:8080/serwlety1/Time"</span>&gt;
Aby zobaczyæ datê i czas wciœnij przycisk&amp;<span class="entity">nbsp</span>&amp;<span class="entity">nbsp</span>
&lt;<span class="start-tag">input</span><span class="attribute-name"> type</span>=<span class="attribute-value">"submit" </span><span class="attribute-name">value</span>=<span class="attribute-value">"Data i czas"</span>&gt;
&lt;/<span class="end-tag">form</span>&gt;
&lt;/<span class="end-tag">body</span>&gt;
&lt;/<span class="end-tag">html</span>&gt;

</pre>
mo¿emy wywo³aæ nasz serwlet (jako czêœæ aplikacji o kontekœcie serwlety1 z mapowaniem nazwy serwletu na odwo³anie /Time)<br>
  <br>
Oczywiœcie, w tym przypadku metoda doGet nie zostanie wywo³ana, a doPost nie jest przedefiniowana. Otrzymamy w wyniku:<br><br>
  <img style="border: 1px solid ; width: 427px; height: 345px;" src="images/NoPost.jpg" alt="r">
  <br>
Je¿eli zatem mamy serwlety, do których mo¿na odwo³ywaæ siê zarówno za pomoc¹
metody GET jak i POST powinniœmy kontruowaæ je w taki sposób, by obs³uga
zlecenia by³a wykonywana niezale¿nie od tego czy jest to zlecenie GET czy
POST.<br>
W tym celu mo¿na np. wprowadziæ ogóln¹ metodê serviceRequest i wywo³ywac
j¹ zarówno z doPost, jak i doGet. W tej konwencji nasz przyk³adowy serwlet,
pokazuj¹cy datê i czas wygl¹da³by tak.<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.text.*;

public class ShowTime0 extends HttpServlet {

  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
     Locale locale = req.getLocale();
      // ...
      out.close();
  }

// ...

//--- Stanadardowa czêœæ serwletu -----------------------------------
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

  public void doPost(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

}
</pre>
Oczywiœcie, w tym przyk³adzie nie ma ¿adnego sensu (choæ jest mo¿liwe) posy³anie
zlecenia POST, bo jak wspomniano s³u¿y ono g³ównie do przekazywania informacji
zawartych w formularzach (a tu ¿adnej informacji u¿ytkownik nie dostarcza).
Ale równie¿ zlecenie GET mo¿e byæ u¿yte w tym samym celu. <br>
Pora wiêc na przyjrzenie siê parametrom zleceñ.<br>
  <br>
  <a name="WebApps.5"></a><h2>5. Parametry zleceñ</h2>

  <br>
Sk¹d siê bior¹ parametry? Zazwyczaj z formularzy, ale - jak zobaczymy - niekoniecznie.<br>

Utwórzmy stronê z formularzem:<br>
  <pre>&lt;html&gt;
&lt;head&gt;
 &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1250"&gt;
 &lt;title&gt;Testowanie&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h2&gt;Testowanie parametrów&lt;/h2&gt;&lt;/center&gt;
&lt;hr&gt;
&lt;form method="get" action="http://localhost:8080/serwlety1/params1"&gt;
id&lt;input type="text" size="50" name="ident"&gt;&lt;br&gt;
p1&lt;input type="text" size="50" name="p1"&gt;&lt;br&gt;
p2&lt;input type="text" size="50" name="p2"&gt;&lt;br&gt;
p3&lt;input type="text" size="50" name="p3"&gt;&lt;br&gt;
p4&lt;input type="text" size="50" name="p4"&gt;&lt;br&gt;
p5&lt;input type="text" size="50" name="p5"&gt;&lt;br&gt;
p6&lt;input type="text" size="50" name="p6"&gt;&lt;br&gt;
 _
&lt;br&gt;&lt;input type="submit" value="Wyœlij formularz"&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
</pre>
Mamy tu 7 pól tekstowych, ka¿de z nich ma nadan¹ nazwê (ident, p1, ...p6).<br>
Te nazwy bêd¹ nazwami parametrów, do których bêdziemy mogli siê odwo³aæ w serwlecie.<br>
Po klikniêcu w przycisk "Wyœlij formularz" formularz jest posy³any za pomoc¹ metody GET do serwletu oznaczonego /params1.<br>
  <br>
PrzeœledŸmy najpierw dzialanie. Na stronie WWW wpisujemy jakieœ wartoœci do pól tekstowych i - wysy³amy:<br>
  <img style="width: 380px; height: 554px;" src="images/ParamForm1.jpg" alt="r">
  <br>
  <br>
Po klikniêciu w "Wyœlij..." URI zlecenia GET zostanie uzupe³nione o wartoœci
parametrów -&nbsp; bêdziemy mogli to zobaczyæ na pasku adresu przegl¹darki:<br>
  <br>
http://localhost:8080/serwlety1/params1?ident=Pies&amp;p1=a&amp;p2=b&amp;p3=c&amp;p4=d&amp;p5=e&amp;p6=f<br>
  <br>
co spowoduje przekazanie zlecenia do serwletu<br>
  <br>
Serwlet mo¿e odczytaæ&nbsp; tzw. queryString (czyli czêœæ URLa zlecenia GET zawieraj¹c¹
parametry), bêdzie te¿ móg³ przejrzeæ wszystkie parametry, odwo³ywaæ siê
do ich wartoœci po nazwach, uzyskaæ mapê tych parametrów z kluczami = ich
nazwom itp.<br>
  <br>
Jego metoda serviceRequest (któr¹, jak wczeœniej, wywo³ujemy z metody doGet i doPost) wygl¹da tak:<br>
  <pre>public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
      PrintWriter out = resp.getWriter();
      out.println("Metoda: " + req.getMethod());

      out.println("Query : " + req.getQueryString());
      out.println("Parametry:");
      Enumeration pnams = req.getParameterNames();
      while (pnams.hasMoreElements()) {
        String name = (String) pnams.nextElement();
        String value = req.getParameter(name);
        out.println(name + " = "  + value);
      }
      out.println("Dostêp przez mapê");
      Map map = req.getParameterMap();
      String[] val = (String[]) map.get("ident");
      out.println("Parametr o nazwie ident");
      out.println("- z mapy uzyskujemy tablice String[]");
      out.println("- jej rozmiar " + val.length );
      out.println("- jej elementy:" );
      for (int i=0; i&lt;val.length; i++) out.println(val[i]);

     out.close();
  }
</pre>

Widzimy tu ró¿ne sposoby uzyskiwania wartoœci parametrów. Warte szczególnej
uwagi jest to, ¿e wartoœci mapy parametrów s¹ tablicami typu String[] (oczywiœcie klucze
to nazwy parametrów).<br>
  <br>
Ten serwlet (przy podanym formularzu) wygeneruje stronê o nastêpuj¹cej treœci:<br>
  <pre>Metoda: GET
Query : ident=Pies&amp;p1=a&amp;p2=b&amp;p3=c&amp;p4=d&amp;p5=e&amp;p6=f
Parametry:
p6 = f
p5 = e
p4 = d
p3 = c
ident = Pies
p2 = b
p1 = a
Dostep przez mape
Parametr o nazwie ident
- z mapy uzyskujemy tablice String[]
- jej rozmiar 1
- jej elementy:
Pies</pre>
  <br>
Zwykle metodê GET stosuje siê, gdy sumaryczna d³ugoœæ przekazywanej informacji
nie jest zbyt du¿a (np. mniejsza od 256 znaków, choæ obecnie przegl¹darki
dopuszczaj¹ du¿e zlecenia GET). Podkreœlmy jeszcze raz, ¿e - w zleceniu GET - pary nazwy-wartoœci
parametrów sa do³¹czane do URLa zlecenia, a wobec tego cia³o (treœæ) zlecenia
jest puste.<br>
  <br>
Kiedy chcemy dostarczyæ serwletowi informacji o nielimitowanych rozmiarach
(jako parametrów lub jako dowolnej treœci - cia³a zlecenia) stososujemy metodê
POST.<br>
Przy tym parametry nie sa ju¿ do³¹czane do URLa zlecenia i getQueryString()
da w serwlecie null, mog¹ natomiast byæ odczytane przez metody uzyskiwania
parametrów, albo (ale nie równoczeœnie) - przez odczytanie treœci zlecenia
z jego strumienia wejœciowego.<br>
  <br>
Gdy zmienimy nag³ówek formularza w naszym pliku HTML<br>
  <pre>...
&lt;form method="post" action="http://localhost:8080/serwlety1/params1"&gt;
...
</pre>
i znowy poœlemy go do przyk³adowego serwletu uzyskamy nieco inny wynik:<br>
  <pre>Metoda: POST
Query : null
// ... dalej jak w metodzie GET
</pre>
Ale mo¿emy równie¿ bezpoœrednio odczytaæ treœæ zlecenia ze strumienia zwi¹zanego z obiektem zlecenia:<br>
  <pre>  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
    PrintWriter out = resp.getWriter();
    out.println("Metoda: " + req.getMethod());

    // Przy zleceniu POST
    // Albo uzyskujemy parametry przez metody getParameter...
    // albo czytamy je ze strumienia jako "cia³o" zlecenia
    // ale nie równoczeœnie i to i to

    boolean readBodyStream = true;  // czytamy ze strumienia

    if (!readBodyStream) {
       // ... poprzedni kod
    }
    else {
      out.println("Czytanie tresci (cia³a) zlecenia ze strumienia:");

      BufferedReader br = req.getReader();
      String line;
      while ((line = br.readLine()) != null) out.println(line);
      br.close();
    }

    out.close();
  }
</pre>
co da w wyniku:<br>
  <pre>Metoda: POST
Czytanie tresci (ciala) zlecenia ze strumienia:
ident=Pies&amp;p1=a&amp;p2=b&amp;p3=c&amp;p4=d&amp;p5=e&amp;p6=f
</pre>
Oczywiœcie, treœæ zlecenia nie musi mieæ nic wspólnego z formularzami i parametrami.
Klient HTTP mo¿e pos³aæ za pomoc¹ metody POST dowoln¹ informacjê, o dowolnym
rozmiarze <br>
Dlatego nale¿y uwa¿aæ przy obs³udze zlecenia POST (sprawdzaæ wielkoœæ przesy³anej
informacji), bez tego bowiem ktoœ mo¿e pos³ac naszemu serwletowi miliony
megabajtów, co oczywiœcie bêdzie stanowiæ problem.<br>
  <br>
Przy przesy³aniu parametrów z formularzy zetkniemy siê z problemem kodowania.<br>
Otó¿ dane z pól tekstowych formularza przy przes³aniu s¹ przez przegl¹darkê
kodowane w taki sposób, by zast¹piæ "niebezpieczne bajty" specjalnie kodowanymi
sekwencjami bajtów. Jest to tzw. URL-kodowanie (URLencoding). Gdybyœmy np.
w naszym przyk³adowym serwlecie odczytuj¹cym parametry wprowadzili w polu
id napis "To jest ident", a w polu p1 napis 2 &gt; 3 (pozostawiaj¹c pola
p2-p6 puste), niebezpieczne znaki spacji i &gt; zosta³uby URL-zakodowane,
a parametry zlecenia wygl¹da³yby nastêpuj¹co:<br>
ident=To+jest+ident+&amp;p1=2+%3E+3&amp;p2=&amp;p3=&amp;p4=&amp;p5=&amp;p6= &nbsp;<br>
  <br>
Metody pobierania parametrów z klasy HttpServletRequest (m.in. getParameter())
automatycznie dokonuj¹ dekodowania paranetrów. Przy tym jednak pojawia sie
powa¿ny problem internacjonalizacji. Przegl¹darka posy³aj¹c url-kodowane
dane ustala nag³ówek Content-Type jako application/x-www-form-urlencoded
i <b>nie przesy³a</b> ¿adnych danych o stronie kodowej (czy to jest np. ISO-8859-2
czy Windows-1250). Metody pobierania parametrów po stronie serwletu przyjmuj¹
przy dekodowaniu stronê ISO-8859-1, co oczywiœcie prowadzi do b³êdów, gdy
dane w formularzu wymagaj¹ innej strony kodowej (np. polskie znaki w formacie
ISO-8859-2).&nbsp; <br>
  <br>
Trzeba zatem jakoœ powiadomiæ metody pobierania parametrów, by przyjê³y w³aœciw¹ stronê kodow¹.<br>
  <br>
<div class="important">Dla w³aœciwego pobierania paranetrów zlecenia przed u¿yciem metod pobierania
lub czytaniem parametrów ze strumienia wejœciowego nale¿y ustaliæ stronê
kodow¹ zlecenia za pomoc¹ metdosy setCharacterEncoding(...) z klasy HttpServletRequest.</div><br>
  <br>
Rozwa¿my teraz inny przyk³ad - serwlet do testowania wyra¿eñ regularnych.<br>
Stosuj¹c metodê find() ma on znaleŸæ w tekœcie (dostarczonym przez u¿ytkownika)
wszystkie pod³añcuchy pasuj¹ce do wzorca (dostarczonego przez u¿ytkownika)
i przekazaæ u¿ytkownikowi wyniki wyszukiwania.<br>
  <br>
Pierwsza przymiarka do rozwi¹zania tego zadania polega na dostarczeniu u¿ytkownikowi
strony, na której móg³by on wpisaæ potrzebne dane, przeprowadzeniu wyszukiwania,
a nastêpnie wygenerowaniu strony wynikowej.<br>
  <br>
Serwlet (niech bêdzie dostêpny w kontekœcie serwlety1 jako regex1) pobierze parametry z nastêpuj¹cej strony HTML<br>
  <pre>&lt;<span class="start-tag">html</span>&gt;
&lt;<span class="start-tag">head</span>&gt;
 &lt;<span class="start-tag">meta</span><span class="attribute-name"> http-equiv</span>=<span class="attribute-value">"Content-Type" </span><span class="attribute-name">content</span>=<span class="attribute-value">"text/html; charset=windows-1250"</span>&gt;
 &lt;<span class="start-tag">title</span>&gt;Testowanie&lt;/<span class="end-tag">title</span>&gt;
&lt;/<span class="end-tag">head</span>&gt;
&lt;<span class="start-tag">body</span>&gt;
&lt;<span class="start-tag">center</span>&gt;&lt;<span class="start-tag">h2</span>&gt;Testowanie wyra¿eñ regularnych&lt;/<span class="end-tag">h2</span>&gt;&lt;/<span class="end-tag">center</span>&gt;
&lt;<span class="start-tag">hr</span>&gt;
&lt;<span class="start-tag">form</span><span class="attribute-name"> method</span>=<span class="attribute-value">"post" </span><span class="attribute-name">action</span>=<span class="attribute-value">"http://localhost:8080/serwlety1/regex1"</span>&gt;
Wzorzec: &lt;<span class="start-tag">br</span>&gt;
&lt;<span class="start-tag">input</span><span class="attribute-name"> type</span>=<span class="attribute-value">"text" </span><span class="attribute-name">size</span>=<span class="attribute-value">"30" </span><span class="attribute-name">name</span>=<span class="attribute-value">"regex"</span>&gt;&lt;<span class="start-tag">br</span>&gt;
Tekst:&lt;<span class="start-tag">br</span>&gt;
&lt;<span class="start-tag">input</span><span class="attribute-name"> type</span>=<span class="attribute-value">"text" </span><span class="attribute-name">size</span>=<span class="attribute-value">"50" </span><span class="attribute-name">name</span>=<span class="attribute-value">"input"</span>&gt;&lt;<span class="start-tag">br</span>&gt;&lt;<span class="start-tag">br</span>&gt; &nbsp;
&lt;<span class="start-tag">input</span><span class="attribute-name"> type</span>=<span class="attribute-value">"submit" </span><span class="attribute-name">value</span>=<span class="attribute-value">"Poka¿ wynik wyszukiwania"</span>&gt;
&lt;/<span class="end-tag">form</span>&gt;
&lt;/<span class="end-tag">body</span>&gt;&lt;/<span class="end-tag">html</span>&gt;
</pre>
   
i wygeneruje stronê wynikow¹. Metoda serviceRequest (ju¿ tradycyjnie bêdziemy
j¹ stosowac jako cel odwo³añ zarówno z doGet jak i doPost) wygl¹da nastêpuj¹co:<br>
  <br>
  <pre>  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {

    String charset = "windows-1250";

    // Uwaga. Nale¿y ustaliæ w³aœciw¹ stronê kodow¹ zlecenia
    // bez tego parametry nie bêd¹ w³aœciwie odczytane
    // Tu - ustalamy stronê windows-1250, bo nasz formularz
    // jest zapisany w takim w³aœnie kodowaniu

    req.setCharacterEncoding(charset);

    resp.setContentType("text/html; charset=" + charset);

    PrintWriter out = resp.getWriter();

    String regex = req.getParameter("regex");
    String input = req.getParameter("input");

    if (regex == null || input == null) {
      out.println("&lt;h2&gt;Wadliwe argumenty wywo³ania&lt;/h2&gt;");
      out.close();
      return;
    }

    out.println("&lt;h3&gt;Wyra¿enie:&lt;br&gt;\"" + regex + "\"&lt;/h3&gt;");
    out.println("&lt;h3&gt;Tekst:&lt;br&gt;\"" + input + "\"&lt;/h3&gt;");
    out.println("&lt;hr&gt;");

    try {
      Pattern pattern = Pattern.compile(regex);
      Matcher matcher = pattern.matcher(input);
      boolean found = matcher.find();
      if (!found)
         out.println("&lt;h3&gt;Nie znaleziono ¿adnego pod³añcucha " +
                      "pasuj¹cego do wzorca&lt;/h3&gt;");
      else {
          out.println("&lt;h3&gt;Dopasowano:&lt;/h3&gt;");
          out.println("&lt;ol&gt;");
        do {
          out.println("&lt;li&gt;pod³añcuch \"" + matcher.group() +
                   "\" od pozycji " + matcher.start() +
                   " do pozycji " + (matcher.end()-1) + "&lt;/li&gt;");
        } while(matcher.find());
        out.println("&lt;/ol&gt;");
      }
    } catch (PatternSyntaxException exc) {
        out.println("&lt;h2&gt;B³¹d w wyra¿eniu&lt;/h2&gt;");
    } finally {
        out.close();
    }
  }

</pre>
a dzia³anie &nbsp;serwletu ilustruj¹ rysunki:<br>
  <br>
- wprowadzanie danych<br>
  <img style="width: 615px; height: 452px;" src="images/regex1-1.jpg" alt="r">
  <br>
  <br>
  <br>
- po klikniêciu "Poka¿" (strona wygenerowana przez serwlet)<br>
  <img src="images/regex1-2.jpg" alt="r" height="452" width="615">
  <br>
  <br>
  <br>
To rozwi¹zanie dzia³a, ale&nbsp; ma dwie wady. Pierwsza jest natury funkcjonalnej:
u¿ytkownik dla wprowadzenia nowego wyszukiwania zmuszony jest cofaæ siê (za
pomoc¹ przycisku Back) do poprzedniej strony, Duga jest znacznie powa¿niejsza,
dotyczy konstrukcyjnej natury rozwi¹zania - zajmiemy siê tym w nastêpnym
punkcie.<br>
  <br>
Aby poprawiæ funkcjonalnoœæ mo¿emy skorzystaæ z nastêpuj¹cej w³aœciwoœci
formularzy HTML: je¿eli w formularzu nie podano parametru ACTION, to domyœlnie
wynikiem pos³ania formularz jest "zwrócenie" tej samej strony na której by³
formulraz. Bardzo czêsto korzysta siê z tego np. przy walidacji jakichœ danych
rejestracyjnych.<br>
  <br>
Dla naszego serwletu wyra¿eñ regularnych oznacza to, ¿e musi on generowaæ
stronê z formularzem, a je¿eli w formularzu wprowadzono parametry - uzupe³ni¹æ
j¹ &nbsp;o wyniki wyszukiwania.<br>
  <br>
Moglibyœmy to zrobiæ tak:<br>
  <ul>
    <li>przygotowaæ czêœæ pliku HTML z formularzem w postaci (swoisty szablon) </li>
  </ul>
  <pre>&lt;center&gt;&lt;h2&gt;Testowanie wyra¿eñ regularnych&lt;/h2&gt;&lt;/center&gt;
&lt;hr&gt;
&lt;form method="post"&gt;
Wzorzec: &lt;br&gt;
&lt;input type="text" size="30" name="regex"&gt;&lt;br&gt;
Tekst:&lt;br&gt;
&lt;input type="text" size="50" name="input"&gt;&lt;br&gt;&lt;br&gt;
&lt;input type="submit" value="Poka¿ wynik wyszukiwania"&gt;
&lt;/form&gt;
</pre>
  <ul>
    <li>w serwlecie odczytaæ ten plik i wpisaæ jego zawartoœæ na generowan¹ stronê,</li>
    <li>je¿eli serwlet nie mo¿e uzyskaæ parametrów (pierwsze odwo³anie do serwletu) poprzestajemy na wygenerowaniu strony z formularzem,</li>
    <li>je¿eli s¹ parametry - serwlet &nbsp;przetwarza wyra¿enie regularne i dopisuje do generowanej strony wyniki wyszukiwania.</li>
  </ul>
Plik z szablonem formularza nie powinien byæ dostêpny dla u¿ytkownika (umieœcimy
go w katalogu WEB-INF). Mo¿emy go ³atwo wczytaæ do serwletu, korzystaj¹c
ze znanej nam metody kontekstu aplikacji getResourceAsStream (zob. podpunkt
2). Nazwy tego pliku nie warto jednak statycznie wpisywaæ w kodzie serwletu
(mo¿emy miec ró¿ne warianty takich plików, a ka¿da zmiana wariantu wymaga³aby
rekompilacji serwletu). Dostarczymy wiêc jej jako inicjalny parametr serwletu.<br>
  <br>
<div class="syntax">Ka¿dy z <b>inicjalnycch parametów</b> serwletu specyfikujemy jako element <b>init-param</b> zagnie¿d¿ony w elemencie <b>servlet</b> w pliku deskryptora wdro¿enia web.xml <br>
Ma on nastêpuj¹c¹ postaæ:<br>
  <br>
  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;init-param&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;param-name&gt;<i>nazwaParametru</i>&lt;/param-name&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;param-value&gt;<i>wartoœæParametru</i>&lt;/param-value&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/init-param&gt;<br>
  </b><br>
Wartoœci parametrów inicjalnych mo¿emy uzyskaæ stosuj¹c metodê klasy
serwletu (œciœlej &nbsp;dziedziczon¹ z klasy GenericServlet):<br>
  <br>
&nbsp;&nbsp;&nbsp; <b>String getInitParameteter(<i>nazwaParametru</i>)</b><br>
  <br>
Mo¿emy te¿ uzyskaæ nazwy wszystkich parametrów inicjalnych za pomoc¹ metody:<br>
  <br>
&nbsp;&nbsp;&nbsp; <b>Enumeration getInitParameterNames()</b><br>
  <br>
Uwaga: nale¿y odró¿niaæ parametry inicjalne konkretnego serwletu od inicjalnych
parametrów kontekstu (czyli ca³ej) aplikacji (na któr¹ mo¿e sk³adaæ siê wiele
serwletów i innych komponentów WEB).<br>
</div><br>
  <br>
Powiedzmy, ¿e nasz szablon formularza umieœciliœmy w pliku regexform.html
w katalogu WEB-APP. Udostêpnimy nazwê tego pliku jako parametr o nazwie regexFormFile,
zatem w definicji serwletu w pliku web.xml dodamy odpowiedni element:<br>
  <br>
  <pre>    &lt;servlet&gt;
       &lt;servlet-name&gt;RegexTest&lt;/servlet-name&gt;
       &lt;description&gt;Regularne wyrazenia 1&lt;/description&gt;
       &lt;servlet-class&gt;RegexTest&lt;/servlet-class&gt;
       &lt;init-param&gt;
          &lt;param-name&gt;regexFormFile&lt;/param-name&gt;
          &lt;param-value&gt;regexform.html&lt;/param-value&gt;
       &lt;/init-param&gt;
    &lt;/servlet&gt;

   &nbsp;&lt;servlet-mapping&gt;
        &lt;servlet-name&gt;RegexTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/regex1&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</pre>
Nowy kod serwletu wygl¹da w nastêpuj¹cy sposób:<br>
  <br>
  <pre>public class RegexTest extends HttpServlet {

  private PrintWriter out;
  private void printEndTag() { out.println("&lt;/body&gt;&lt;/html&gt;"); }

  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {

    String charset = "ISO8859-2";
    req.setCharacterEncoding(charset);
    resp.setContentType("text/html; charset=" + charset);
    out = resp.getWriter();
    out.println("&lt;html&gt;");
    out.println("&lt;head&gt;&lt;title&gt;Testowanie&lt;/title&gt;&lt;/head&gt;");
    out.println("&lt;body&gt;");

    // Nazwê pliku z formularzem dostarczymy
    // jako parametr inicjalny serwletu
    String formFile = getInitParameter("regexFormFile");

    // Przeczytamy go i wpiszemy na generowan¹ stronê

    ServletContext context = getServletContext();
    InputStream in = context.getResourceAsStream("/WEB-INF/"+formFile);
    BufferedReader br = new BufferedReader( new InputStreamReader(in));
    String line;
    while ((line = br.readLine()) != null) out.println(line);

    // Pobieramy parametry formularza
    String regex = req.getParameter("regex");
    String input = req.getParameter("input");

    // Przy pierwszym odwo³aniu do serwletu - parametrów nie ma
    // zatem poprzestajemy na wygenerowaniu formularza

    if (regex == null || input == null) {
      printEndTag();
      out.close();
      return;
    }

    // W przeciwnym razie jakieœ parametry (chcoæby puste) ju¿ s¹
    // Przetwarzamy je i uzupe³niamy stronê z formularzem

    out.println("&lt;hr&gt;");
    out.println("Wzorzec: \"" + regex + "\"&lt;br&gt;");
    out.println("Tekst  : \"" + input + "\"&lt;br&gt;");

    try {
      Pattern pattern = Pattern.compile(regex);
      Matcher matcher = pattern.matcher(input);
      boolean found = matcher.find();
      if (!found)
         out.println("&lt;h3&gt;Nie znaleziono ¿adnego pod³añcucha " +
                      "pasuj¹cego do wzorca&lt;/h3&gt;");
      else {
          out.println("&lt;h3&gt;Dopasowano:&lt;/h3&gt;");
          out.println("&lt;ol&gt;");
        do {
          out.println("&lt;li&gt;pod³añcuch \"" + matcher.group() +
                   "\" od pozycji " + matcher.start() +
                   " do pozycji " + (matcher.end()-1) + "&lt;/li&gt;");
        } while(matcher.find());
        out.println("&lt;/ol&gt;");
      }
    } catch (PatternSyntaxException exc) {
        out.println("&lt;h2&gt;B³¹d w wyra¿eniu&lt;/h2&gt;");
    } finally {
        printEndTag();
        out.close();
    }
  }

// ... metody doGet o doPost wo³aj¹ce serviceRequest

}
</pre>
Teraz wywo³ujemy serwlet bezpoœrednio (proszê zwróciæ uwagê na pasek adresu na poni¿szym rysunku) i wpisujemy dane:<br>
  <img style="width: 584px; height: 501px;" src="images/regex2-1.jpg" alt="r">
  <br>
<br> Po wys³aniu formularza&nbsp; uzyskamy nie tylko wyniki, ale
poprzedzaj¹cy je formularz przygotowany do wpisywania nowych danych:<br>
  <br>
  <img style="width: 584px; height: 501px;" src="images/regex2-2.jpg" alt="r">
  <br>
  <br>
  <br>
Oczywiœcie, tê aplikacjê mo¿na funkcjonalnie rozwijaæ. Np. zapewniaj¹c zachowanie
wprowadzanych tekstów w polach tekstowych, albo ich przywo³ywanie (byæ mo¿e
z ca³¹ histori¹). To wszystko bêdzie coraz bardziej komplikowac kod naszego
serwletu.<br>
Tymczasem ju¿ teraz - jak przed chwil¹ wspomniano - ten prosty programik ma
powa¿n¹ konstrukcyjn¹ usterkê: miesza ze sob¹ fragmenty kodu zajmuj¹cego
siê prezentacj¹ i &nbsp;fragmenty odpowiedzialne za czyst¹ logikê (w tym przypadku
wyszukiwania), Taka architektura prowadzi do serwletów du¿ych, zawik³anych,
trudnych w modyfikacjach, nieelastycznych.<br>
Trzeba coœ z tym zrobiæ.<br>
  <br>
<br>
  <a name="WebApps.6"></a><h2>
6.&nbsp; Serwlety i architektura MVC</h2>


<br>
Programistycznu interfejs Servlet API nie jest dobrze przygotowany na <u>³atw¹</u>
 separacjê modeli i widoków. Jak ju¿ mówiliœmy na samym pocz¹tku rozdzia³u
by³o to jednym z powodów pojawienia siê technologii JSP i Java Server Faces.<br>
 Zanim jednak przyjrzymy sie tym technologiom, warto na prostym przyk³adzie
zobaczyæ i poczuæ na czym taka separacja mo¿e polegaæ, bo - jednak -= nawet
na poziomie Servlet API mamy mo¿liwoœci jej dokonania.<br>
  <br>
Wróæmy do kodu serwletu wyra¿eñ regularnych, choæby jego nastêpuj¹cego fragmentu,
zaznaczaj¹c przez Logika lub L - fragmenty odpowiedizalne za logikê przetwarzania
danych, a przez Prezentacja lub P - za prezentacjê.<br>
  <br>
  <pre>    try {
      Pattern pattern = Pattern.compile(regex);                   // Logika
      Matcher matcher = pattern.matcher(input);                   // Logika
      boolean found = matcher.find();                             // Logika
      if (!found)                                                 // Logika
         out.println("&lt;h3&gt;Nie znaleziono ¿adnego pod³añcucha " +  // Prezentacja
                      "pasuj¹cego do wzorca&lt;/h3&gt;");
      else {                                                      // Logika
          out.println("&lt;h3&gt;Dopasowano:&lt;/h3&gt;");                    // Prezentacja
          out.println("&lt;ol&gt;");                                    // Prezentacja
        do {
          out.println("&lt;li&gt;pod³añcuch \"" + matcher.group() +&nbsp;    // L + P
                   "\" od pozycji " + matcher.start() +           // L + P
                   " do pozycji " + (matcher.end()-1) + "&lt;/li&gt;"); // L + P
        } while(matcher.find());
        out.println("&lt;/ol&gt;");                                     // Prezentacja
      }
    } catch (PatternSyntaxException exc) {&nbsp;                       // Logika
        out.println("&lt;h2&gt;B³¹d w wyra¿eniu&lt;/h2&gt;");                 // Prezentacja
    } finally {                                                   // Logika
        printEndTag();                                            // Prezentacja
        out.close();                                              // Prezentacja
    }
</pre>
  <br>
Widzimy jak bardzo zmieszane ze sob¹ s¹ fragmenty odpowiedzialne za logikê i prezentacjê. <br>
Co siê stanie, gdy bêdziemy chcieli dokonaæ prezentacji w innej formie?<br>
 Co siê stanie, gdy np. wyniki wyszukiwania w ogóle nie powinny podlegaæ
prezentacji bezpoœredniej, lecz raczej winny byæ przekazywane jako strumieñ
do jakiegoœ klienta HTTP? <br>
Takie zmiany bêda wymaga³y pisania ca³ego kodu od pocz¹tku.<br>
  <br>
Zanim jednak spróbujemy stworzyæ bardziej elastyczne i uniwersalen rozwi¹zanie,
oparte na separacji kodu odpowiedzialnego za&nbsp; wygl¹d i kodu odpowiedzialnego
za logikê dzia³ania potrzebne nam bêd¹ pewne dodatkowe informacje o mo¿liwoœciach
wspó³dzia³ania serwletów.<br>
  <br>
Mianowicie:<br>
  <ul>
    <li>dla ka¿dej aplikacji mo¿emy ustaliæ <b>inicjalne parametry kontekstu</b>
 (element context-param w pliku web.xml); parametry te bêd¹ dostêpne dla
wszystkich serwletów w aplikacji poprzez metodê getInitParameter klasy ServletContext,</li>
    <li>dla ca³ej aplikacji mo¿na dynamicznie ustalaæ <b>atrybuty kontekstu</b>
, zawieraj¹ce referencje do dowolnych obiektów; ustalaæ, odczytywac i usuwaæ
atrybuty mo¿e ka¿dy z serwletów aplikacji za pomoc¹ metod setAttribute(Object),
Object getAttribute(), removeAttribute(Object) klasy ServletContext,</li>
    <li>serwlety mog¹ tworzyæ <b>sesje </b>i poslugiwac siê atrybutami sesji;
sesja identyfikuje po³¹czenie z danym klientem (które mo¿e byæ przez jakiœ,
ustalony czas nieaktywne); bie¿¹c¹ sesjê uzyskujemy jako obiekt klasy HttpSession
za pomoc¹ metody getSession() z klasy HttpServletRequest()</li>
    <li><b>atrybuty sesji </b>pozwalaj¹ zapisywac i wynieniaæ informacje
dotycz¹ce danej sesji - tu równie¿ mamy metody setAttribute(..), getAttribute,
removeAttribute() tym razem z klasy HttpSession, które to metody mo¿e wywo³ywac
ka¿dy z serwletów aplikacji.&nbsp;</li>
    <li>zlecenie mo¿e byæ przekazane przez serwlet do obs³ugi (ca³kowitej lub czêœciowej) innemu serwletowi; s³u¿y temu obiekt <b>RequestDispatcher</b>, uzyskiwany od aktualnego zlecenia (lub kontekstu).<br>
    </li>
  </ul>
  <br>
Poni¿sze tabele zawiaraj¹ syntetyczn¹ informacjê o w/w cechach Servlet API.<br>
  <br>
  <table style="background-color: rgb(255, 255, 255); width: 75%; text-align: left; margin-left: auto; margin-right: auto;" bordercolordark="#000000" bordercolorlight="#999933" border="1">
<tbody><tr>
        <td rowspan="1" colspan="2" valign="top">
        <div align="center">Ró¿nica pomiêdzy parametrami i atrybutami kontekstu<br>
        </div>
        </td>
      </tr>
<tr><th align="left" valign="top" width="50%">
        <div align="center">Parametry</div>
</th><th align="left" valign="top" width="50%">
        <div align="center">Atrybuty</div>
</th></tr><tr><td align="left" valign="top" width="50%">Parametry mog¹ byæ ustalone wy³acznie w pliku web.xml &nbsp;za pomoc¹ elementu context-param&nbsp;</td><td align="left" valign="top" width="50%">Atrybuty mog¹ byæ ustalane dynamicznie przez serwlety (albo przez serwer).&nbsp;&nbsp;</td></tr><tr><td style="width: 50%; vertical-align: top; text-align: left;">Wartoœci s¹ typu String.&nbsp;</td><td align="left" valign="top" width="50%">Wartoœci s¹ referencjami do dowolnych obiektów (ogólnie klasy Object), klucze (nazwy atrybutów) s¹ typu String.&nbsp;</td></tr></tbody>
  </table>
  <br>
  <br>
  <table style="background-color: rgb(255, 255, 255); width: 75%; text-align: left; margin-left: auto; margin-right: auto;" bordercolordark="#000000" bordercolorlight="#999933" border="1">
<tbody><tr>
        <td rowspan="1" colspan="2" valign="top">
        <div align="center"><span style="font-weight: bold;">Metody dotycz¹ce atrybutów</span><br>
        </div>
        </td>
      </tr>
<tr><td align="left" valign="top" width="20%">void</td><td align="left" valign="top" width="60%">setAttribute(String name, Object value)</td></tr><tr><td align="left" valign="top" width="20%">Object</td><td style="width: 60%; vertical-align: top; text-align: left;">getAttribute(String
            name)</td></tr><tr><td align="left" valign="top" width="20%">Enumeration</td><td align="left" valign="top" width="60%">getAttributeNames()</td></tr><tr>
        <td valign="top">void<br>
        </td>
        <td valign="top">removeAttribute(String name)<br>
        </td>
      </tr>
      <tr>
        <td rowspan="1" colspan="2" valign="top">W klasach:<br>
ServletRequest &nbsp;- dotycz¹ danego zlecenia<br>

HttpSession
            &nbsp;- dotycz¹ danej sesji (tego samego klienta)<br>
&nbsp;ServletContext - dotycz¹ ca³ej aplikacji (wszystkich sesji i klientów)<br>
        </td>
      </tr>
</tbody>
  </table>
  <br>
  <br>
  <table style="background-color: rgb(255, 255, 255); width: 75%; text-align: left; margin-left: auto; margin-right: auto;" bordercolordark="#000000" bordercolorlight="#999933" border="1">
<tbody><tr><th colspan="3" style="width: 100%; vertical-align: top; text-align: left; background-color: rgb(255, 255, 255);">
        <div align="center">Przekazywanie zleceñ <br>
RequestDispatcher<br>
        </div>
        <br><b>
Uzyskujemy od kontekstu (ServletContext) lub zlecania (ServletRequest) za
pomoc¹ metody getRequestDispatcher(), podaj¹c odniesienie do zasobu (np.
innego serwletu, który ma przej¹æ obs³ugê zlecenia)</b><br>
</th></tr><tr><td rowspan="1" colspan="3" align="left" valign="top" width="20%"><br>
&nbsp;<b>void forward(ServletRequest, ServletResponse)</b><br>
        <br>
Przekazuje zlecenie do obs³ugi przez inny aktywny komponent (serwlet). OdpowiedŸ nie mo¿e byæ zatwierdzona (commited).<br>
Sterowanie nie wraca do "wywo³uj¹cego" serwletu.<br>
        <br>
<br></td></tr><tr><td rowspan="1" colspan="3" align="left" valign="top" width="20%"><b>&nbsp;void include(ServletRequest, ServletResponse)</b><br>
        <br>
Przekazuje zlecenie do obs³ugi &nbsp;tymczasowo, po czym mo¿na
kontynuowaæ dalsz¹ obs³ugê tego zlecenia w "wywo³uj¹cym" serwlecie. <br>
Równie¿ pozwala na w³¹czanie statycznych zasobów (np. stron HTML).<br>
</td></tr></tbody>
  </table>
  <br>
Przyk³ady zastosowania w/w konstrukcji zostan¹ pokazane przy
przebudowie aplikacji "testowania wyra¿eñ regularnych" zgodnie z wymogami
architektury MVC. <br>
  <br>
Aplikacjê podzielimy na cztery zasadnicze czêœci:<br>
  <ul>
    <li>
klasê odpowiedzialn¹ za wykonanie pracy (nazwiemy j¹ klas¹ dzia³ania); zbudujemy j¹ przy tym w ogólny sposób,
tak ¿e bêdzie mog³a byæ wykorzystana i w innych sytuacjach, niekoniecznie
w œrodowisku aplikacji WEB,</li>
    <li>
klasê GetParamServ - serwlet pobieraj¹cy wartoœci parametrów (np. z formularza HTML), </li>
    <li>
klasê ResultPresent - serwlet prezentacji wyników</li>
    <li>
klasê ControllerServ, która bedzie stanowiæ serwlet-kontroler, przyjmuj¹cy
zlecenie i uaktywniaj¹cy inne komponenty (w tym pobieranie parametrów, wykonanie
pracy, prezentacjê). </li>
  </ul>
Chcielibyœmy przy tym zapewniæ, aby:<br>
  <ol>
    <li>serwlet-kontroler móg³ bez rekompilacji obs³ugiwaæ dowolne klasy
dzia³añ (!) oraz przekazywaæ zadania pobierania parametrów i prezentacji
wyników dowolnym serwletom pobierania parametrów i pokazywania wyników,</li>
    <li>serwlet pobierania parametrów nie by³ zale¿ny od nazw i opisu parametrów (w szczególnoœci ich zlokalizowanych opisów),</li>
    <li>serwlet prezentacji móg³ byæ wykorzystywany do prezentacji dowolnych wyników.</li>
  </ol> Zacznijmy od trudnego (wydawa³oby siê) zadania uniezaleznienia kontrolera
od rodzaju wykonywanych dzia³añ. W tym celu wykorzystamy znany z literatury
wzorzec projektowy Command (m.in. przedstawiany przez Bruce'a Tate w ciekawej
ksi¹¿ce "Bitter Java"; tutaj zdecydowanie jednak rozbudujemy zawarte tam
sugestie). Mianowicie, wprowadzimy interfejs Command, który opisuje funkcjonalnoœæ
szerokiej klasy (ró¿norodnych) dzia³añ.<br>
  <br>
  <pre>import java.util.*;

public interface Command {
   void init();
   void setParameter(String name, Object value);
   Object getParameter(String name);
   void execute();
   List getResults();
   void setStatusCode(int code);
   int getStatusCode();
}
</pre>
Zatem ka¿da klasa dzialania powinna implementowaæ metody inicjacji, ustalania
i pobierania ew. parametrów, wykonania dzia³ania, ustalenia i pobrania kodu
wyniku, pobrania wyniko dzia³ania. Umówimy siê, ¿e wyniki bêd¹ dostêpne jako
lista.<br>
  <br>
Dla u³atwienia implementacji tych metod w konkretnych klasach dostarczymy
ich standardowej implementacji, która m.in. zawiera&nbsp; mapê parametrów i listê
wyników i dostarcza gotowych i wystarczaj¹cych definicji metod ustalania,
pobierania parametrów i wyników, a tak¿e dodatkowych metod pozwalaj¹cych
tworzyæ elementy listy&nbsp; wyników. Przyjmieny, ¿e w tej standardowej implementacji
ka¿dy element wyników stanowi tablicê dowolnych obiektów, uwzglêdniaj¹c przy
tym, ¿e czêstym przypadkiem elementu wyników bêdzie zwyk³y napis (st¹d przeci¹¿ana
metoda addResult). Klasê moglibyœmy uczyniæ abstrakcyjn¹, bowiem nieznane
s¹ jeszcze metody inicjacji (init()) oraz&nbsp; wykonania dzia³añ (execute()),
ale wygodnie bêdzie potraktowac j¹ raczej jako adapter, dostarczaj¹c pustych
definicji tych metod.<br>
  <br>
  <pre>import java.util.*;
import java.io.*;

public class CommandImpl implements Serializable, Command {

  private Map parameterMap = new HashMap();
  private List resultList = new ArrayList();

  private int statusCode;

  public CommandImpl() {}

  public void init() {}

  public void setParameter(String name, Object value) {
    parameterMap.put(name, value);
  }

  public Object getParameter(String name) {
    return parameterMap.get(name);
  }

  public void execute() {}

  public List getResults() {
    return resultList;
  }

  public void addResult(Object o) {
    resultList.add(o);
  }

  public void addResult(String s) {
    addResult(new Object[] { s } );
  }


  public void clearResult() {
    resultList.clear();
  }

  public void setStatusCode(int code) {
    statusCode = code;
  }

  public int getStatusCode() {
    return statusCode;
  }

}
</pre>
  <br>
Tak¹ standardow¹ implementacjê interfejsu Command mo¿e teraz odziedziczyæ
nasza konkretna klasa wyszukiwania wyra¿eñ regularnych. <br>
  <br> Dzia³anie które wykonuje obiekt tej klasy ma (niew¹tpliwie) dwa parametry:
regularne wyra¿enia i przeszukiwany tekst. Wyniki wyszukiwania bêd¹ przedstawiane
na liœcie, której kolejne elementy to tablice trzyelementowe, zawieraj¹ce
kolejny znaleziony pod³añcuch, pozycjê na której siê on zaczyna i pozycjê
na której siê koñczy. Ustalimy równie¿ kody wyniku: 0 - znaleziono jedno
lub wiêcej dopasowañ, 1 - &nbsp;brak parametrów, 2 - b³¹d w wyra¿eniu, 3 - brak
dopasowania.<br>
  <pre>import java.util.*;
import java.io.*;
import java.util.regex.*;

public class FindCommand extends CommandImpl implements Serializable {

  public FindCommand() {}

  public void execute() {
    clearResult();
    String regex = (String) getParameter("regex");
    String input = (String) getParameter("input");
    if (regex == null || input == null) {
      setStatusCode(1);
      return;
    }
    Pattern pattern;
    try {
      pattern = Pattern.compile(regex);
    } catch (PatternSyntaxException exc) {
       setStatusCode(2);
       return;
    }
    Matcher matcher = pattern.matcher(input);
    boolean found = matcher.find();
    if (!found) setStatusCode(3);
    else {
      setStatusCode(0);
      do {
        addResult( new Object[] { "\"" + matcher.group() + "\"",
                                  new Integer(matcher.start()),
                                  new Integer(matcher.end()-1)
                                });

      } while(matcher.find());
    }
  }

}
</pre>
Tê klasê mo¿emy wykorzystaæ w najprzeróŸniejszy sposób. Teraz zastosujemy j¹ jako element aplikacji WEB. <br>
Dzialaniem aplikacji bêdzie zarz¹dza³ serwlet-kontroler, przy czym - jak
wspomniano - jego kod uczynimy niezale¿nym od sposobu pobierania parametrów
(serwletu pobierania parametrów), wykonywanych dzia³añ (klasy dzia³ania)
oraz sposobu prezentacji wyników (serwletu-prezentacji). Niezale¿noœæ tê
uzyskamy dostarczaj¹c inicjalnych parametrów kontekstu w deskryptorze wdro¿enia
(web.xml):<br>
  <br>
  <pre>     .....
    &lt;context-param&gt;
       &lt;param-name&gt;presentationServ&lt;/param-name&gt;
       &lt;param-value&gt;/presentation&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
       &lt;param-name&gt;getParamsServ&lt;/param-name&gt;
       &lt;param-value&gt;/getparams&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
       &lt;param-name&gt;commandClassName&lt;/param-name&gt;
       &lt;param-value&gt;FindCommand&lt;/param-value&gt;
    &lt;/context-param&gt;
    .....
</pre>
&nbsp;i pobieraj¹c je przy inicjacji serwletu<br>
  <br>
  <pre>public class ControllerServ extends HttpServlet {

  private ServletContext context;
  private Command command;            // obiekt klasy dzialania
  private String presentationServ;    // nazwa serwlet prezentacji
  private String getParamsServ;       // mazwa serwletu pobierania parametrów
  private Object lock = new Object(); // semafor dla synchronizacji
                                      // odwo³añ wielu w¹tków
  public void init() {

    context = getServletContext();

    presentationServ = context.getInitParameter("presentationServ");
    getParamsServ = context.getInitParameter("getParamsServ");
    String commandClassName = context.getInitParameter("commandClassName");

    // Za³adowanie klasy Command i utworzenie jej egzemplarza
    // który bêdzie wykonywa³ pracê
    try {
      Class commandClass = Class.forName(commandClassName);
      command = (Command) commandClass.newInstance();
    } catch (Exception exc) {
        throw new NoCommandException("Nie mogê stworzyæ obiektu klasy " +
                                      commandClassName);
    }
  }

// ...

</pre>
 Zwróæmy uwagê, ¿e piszemy ten kod w kategoriach interfejsu Command. Dynamicznie
³adujemy klasê podan¹ jako parametr kontekstu (tu FindCommand) i tworzymy
jej obiekt. Zmiana wykonywanego dzia³ania (np. zamiast wyszukiwania jakieœ
obliczenia matematyczne) wymaga tylko podania innej wartoœci parametru kontekstu
commandClassName. Mo¿e siê okazaæ, ¿e podamy niew³aœciw¹ nazwê klasy lub
bêdzie ona Ÿle zbudowana (np. brak konstruktora bezparaemtrowego). Wtedy
- jak ju¿ wiemy - wyst¹pi wyj¹tek ClassNotFoundException lub InstantiantionException.
Obs³ugujemy oba te wyj¹tki poprzez zg³oszenie w³asnego wyj¹tku NoComamndException.<br>
  <pre>public class NoCommandException extends RuntimeException {
  public NoCommandException() { super(); }
  public NoCommandException(String msg) { super(msg); }
}
</pre>

  Jak widaæ, klasê wyj¹tku uczyniliœmy pochodn¹ od RunTimeException, dziêki
czemu nie musimy go ani obs³ugiwaæ w tym miejscu ani zg³aszaæ w klauzuli
throws metody init(), co by³oby niedozowolone (bowiem metoda init() w klasie
GenericServlet deklaruje mo¿liwoœæ zg³aszania wyj¹tku klasy ServletException,
a jej przedefiniowanie nie mo¿e tego zmieniæ). Ten sposób oprogramowania
umo¿liwia np. przygotowanie strony HTML z komunikatem o przyczynach b³êdu,
która bêdzie automatycznie ³adowana jeœli u¿yjemy elementu error-pages w
pliku deskryptora wdro¿enia.<br>
<br>
Obs³uga przychodz¹cych zleceñ polega na wywo³aniu serwletu pobierania parametrów,
ustaleniu tych parametrów dla obiektu typu Command, wykonaniu dzia³añ (metoda
execute() z Command), pobraniu wyników i udostêpnieniu ich serwletowi prezentacji,
któremu na samym koñcu przeka¿emy sterowanie. Parametry bêd¹ zapisywane przez
serwlet pobierania parametrów jako atrybuty sesji z przedrostkiem param_.&nbsp;
Uniezale¿nimy kody serwletów od nazw parametrów: wygodnym rozwi¹zaniem bêdzie
zastosowanie ResourceBundle, bo przy okazji zinternacjonalizujemy ca³¹ aplikacjê.
Po to by wygodnie siêgaæ po zlokalizowan¹ i sparametryzowan¹ informacjê z
ró¿nych serwletów naszej aplikacji przygotowano w³asn¹ klasê BundleInfo,
która tê informacjê porz¹dkuje (wiêcej o tym za chwilê). Wreszcie serwlet-kontroler
musi udostêpniæ listê wyników serwletowi prezentacji. Tu równie¿ zastosujemy
atrybut sesji (naturalnie - parametry i wyniki s¹ zwi¹zane ze zleceniami
od jednego i tego samego klienta). <br>
Kod obs³ugi zleceñ w serwlecie-kontrolerze wygl¹da wiêc w nastêpuj¹cy sposób.<br>
  <pre>public class ControllerServ extends HttpServlet {

  private ServletContext context;
  private Command command;            // obiekt klasy wykonawczej
  private String presentationServ;    // nazwa serwlet prezentacji
  private String getParamsServ;       // mazwa serwletu pobierania parametrów
  private Object lock = new Object(); // semafor dla synchronizacji
                                      // odwo³añ wielu w¹tków
  public void init() {

    context = getServletContext();

    presentationServ = context.getInitParameter("presentationServ");
    getParamsServ = context.getInitParameter("getParamsServ");
    String commandClassName = context.getInitParameter("commandClassName");

    // Za³adowanie klasy Command i utworzenie jej egzemplarza
    // który bêdzie wykonywa³ pracê
    try {
      Class commandClass = Class.forName(commandClassName);
      command = (Command) commandClass.newInstance();
    } catch (Exception exc) {
        throw new NoCommandException("Couldn't find or instantiate " +
                                      commandClassName);
    }
  }

  // Obs³uga zleceñ
  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {

    resp.setContentType("text/html");

    // Wywolanie serwletu pobierania parametrów
    RequestDispatcher disp = context.getRequestDispatcher(getParamsServ);
    disp.include(req,resp);

    // Pobranie bie¿¹cej sesji
    // i z jej atrybutów - wartoœci parametrów
    // ustalonych przez servlet pobierania parametrów
    // Ró¿ne informacje o aplikacji (np. nazwy parametrów)
    // s¹ wygodnie dostêpne poprzez w³asn¹ klasê BundleInfo

    HttpSession ses = req.getSession();

    String[] pnames = BundleInfo.getCommandParamNames();
    for (int i=0; i&lt;pnames.length; i++) {

      String pval = (String) ses.getAttribute("param_"+pnames[i]);

      if (pval == null) return;  // jeszcze nie ma parametrów

      // Ustalenie tych parametrów dla Command
      command.setParameter(pnames[i], pval);
    }

    // Wykonanie dzia³añ definiowanych przez Command
    // i pobranie wyników
    // Poniewa¿ do serwletu mo¿e naraz odwo³ywaæ sie wielu klientów
    // (wiele watków) - potrzebna jest synchronizacja
    // przy czym rrygiel zamkniemy tutaj, a otworzymy w innym fragmnencie kodu
    // - w serwlecie przentacji (ca³y cykl od wykonania cmd do poazania wyników jest sekcj¹ krytyczn¹)&nbsp;

    Lock mainLock = new ReentrantLock();

    mainLock.lock();
      // wykonanie
      command.execute();

      // pobranie wyników
      List results = (List) command.getResults();

      // Pobranie i zapamiêtanie kodu wyniku (dla servletu prezentacji)
      ses.setAttribute("StatusCode", new Integer(command.getStatusCode()));

      // Wyniki - bêd¹ dostêpne jako atrybut sesji
      ses.setAttribute("Results", results);
      ses.setAttribute("Lock", mainLock);    // zapiszmy lock, aby mozna go by³o otworzyæ póŸniej


    // Wywo³anie serwletu prezentacji
    disp = context.getRequestDispatcher(presentationServ);
    disp.forward(req, resp);
  }


  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

  public void doPost(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

}
</pre>
Widzimy, ¿e opisuje on wy³¹cznie logikê dzia³ania, bez elementów prezentacji
(drobnym, niestety nieuniknionym wyj¹tkiem jest ustalenie content-type odpowiedzi
na "text/html"; w przeciwnym razie metoda include RequestDispatchera w³¹czy
Ÿrólo generowanej przez serwlet pobierania parametrów strony, a nie zinterpertowany
HTML). <br>
Praktycznie ten serwlet-kontroler jest na tyle niezale¿ny od konkretów, ¿e
nadaje siê do zastosowania w niemal dowolnych sytuacjach pobierania danych
wejœciowych, wykonania na nich jakichœ dzia³an i prezentacji ich wyników.<br>
  <br>
Serwlety pobierania parametrów i&nbsp; prezentacji wyników s¹ ju¿ &nbsp;bardziej skonkretyzowane.<br>
Zak³adamy, ¿e parametry bêd¹ pobierane z formularza, a wyniki prezentowane
po tym formularzu jako lista. Bêdziemy jednak chcieli uniezale¿niæ oba serwlety
od liczby, nazw, opisów pobieranych parametrów oraz liczby, rodzaju i opisów
wyników.<br>
Tak¹ sparametryzowan¹ informacjê dostarczymy poprzez ResourceBundle, który
- dla danej lokalizacji (jêzyka) zlecenia &nbsp;bêdzie odczytywany (tylko przy
zmianie sesji) przez dodatkowy serwlet. Przy okazji odczytan¹ informacjê
zapiszemy w obiekcie klasy BundleInfo, przez co bêdziemy mieli wygodny do
niej dostêp z innych serwletów.<br>
  <br>
Oczywiœcie, trzeba przyj¹æ jak¹œ konwencje opisu aplikacji w ResourceBundle.<br>
Wyró¿nimy nastêpuj¹ce elementy:<br>
  <ul>
    <li>strona kodowa w³aœciwa dla danej lokalizacji (klucz "charset").</li>
    <li>napisy nag³ówkowe, które maj¹ sie pojiwiæ na generowanej przez serwlet pobierania parametrów stronie (klucz "headers"),</li>
    <li>parametry - ich nazwy i opisy (ka¿dy parametr jest dany przez klucz
param_nazwaparametru, a wartoœæ zapisana pod ty kluczen bêdzie stanowiæ opsi
parametru, pojawiaj¹cy siê np. w formulrazu),</li>
    <li>napis na przycisku wysy³ania formularza (klucz "submit"),</li>
    <li>ew. napisy pojawiaj¹ce siê na koñcu generowanej strony z formularzem (klucz "footers"),</li>
    <li>kounikaty zwi¹zane z kodami wyniku (klucz "resCode"),</li>
    <li>dodatkowe lementy opisowe dla wyników (klucz "resDescr").</li>
  </ul>
Przygotowana zgdnie z t¹ konwencj¹ dla lokalizacji polskiej klasa zasobowa wygl¹da nastêpuj¹co:<br>
  <br>
  <pre>public class RegexParamsDef_pl extends ListResourceBundle {
     public Object[][] getContents() {
         return contents;
     }

    static final Object[][] contents = {
       { "charset", "ISO-8859-2" },
       { "header", new String[] { "Testowanie wyra¿eñ regularnych" } },
       { "param_regex", "Wzorzec:" },
       { "param_input", "Tekst:" },
       { "submit", "Poka¿ wyniki wyszukiwania" },
       { "footer", new String[] { } },
       { "resCode", new String[]
                    { "Dopasowano", "Brak danych",
                      "Wadliwy wzorzec", "Nie znaleziono dopasowania" }
                    },
       { "resDescr",
            new String[] { "pod³añcuch", "od poz.", "do poz.", "" } },
    };
}
</pre>
  <br>
a serwlet czytaj¹cy ResourceBundle i gromadz¹cy informacjê w klasie pomocniczej BundleInfo przedstawia poni¿szy fragmeny:<br>
  <br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;


class BundleInfo {

  static private String[] commandParamNames;
  static private String[] commandParamDescr;
  static private String[] statusMsg;
  static private String[] headers;
  static private String[] footers;
  static private String[] resultDescr;
  static private String charset;
  static private String submitMsg;

  static void generateInfo(ResourceBundle rb) {

    synchronized (BundleInfo.class) {  // konieczne ze wzglêdu
                                       // na mo¿liwoœæ odwo³añ
      List cpn = new ArrayList();      // z wielu egzemplarzy serwletów
      List cpv = new ArrayList();
      Enumeration keys = rb.getKeys();
      while (keys.hasMoreElements()) {
        String key = (String) keys.nextElement();
        if (key.startsWith("param_")) {
          cpn.add(key.substring(6));
          cpv.add(rb.getString(key));
        }
        else if (key.equals("header")) headers = rb.getStringArray(key);
        else if (key.equals("footer")) footers = rb.getStringArray(key);
        else if (key.equals("resCode")) statusMsg = rb.getStringArray(key);
        else if (key.equals("resDescr")) resultDescr = rb.getStringArray(key);
        else if (key.equals("charset")) charset = rb.getString(key);
        else if (key.equals("submit")) submitMsg = rb.getString(key);
      }
      commandParamNames = (String[]) cpn.toArray(new String[0]);
      commandParamDescr = (String[]) cpv.toArray(new String[0]);
    }
  }

  public static String getCharset() {
    return charset;
  }

  public static String getSubmitMsg() {
    return submitMsg;
  }

    public static String[] getCommandParamNames() {
    return commandParamNames;
  }

  public static String[] getCommandParamDescr() {
    return commandParamDescr;
  }

  public static String[] getStatusMsg() {
    return statusMsg;
  }

  public static String[] getHeaders() {
    return headers;
  }

  public static String[] getFooters() {
    return footers;
  }

  public static String[] getResultDescr() {
    return resultDescr;
  }

}


// Serwlet w³¹czany wy³¹cznie z serwletu pobierania parametrów
// £aduje  ResourceBundle i przekazuje go klasie BundleInfo,
// która odczytuje info i daje wygodn¹ formê jej pobierania
// w innych serwletach.
// £adowanie zasobów i ich przygotowanie przez klasê BundleInfo
// nastêpuje tylko raz na sesjê.


public class ResourceBundleServ extends HttpServlet {

  private String resBundleName;

  public void init() {
    resBundleName = getServletContext().getInitParameter("resBundleName");
  }

  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
    HttpSession ses = req.getSession();
    ResourceBundle paramsRes = (ResourceBundle) ses.getAttribute("resBundle");

    // W tej sesji jeszcze nie odczytaliœmy zasobów
    if (paramsRes == null) {
       Locale loc = req.getLocale();
       paramsRes = ResourceBundle.getBundle(resBundleName, loc);
       ses.setAttribute("resBundle", paramsRes);

       // Przygotowanie zasobów w wygodnej do odczytu formie
       BundleInfo.generateInfo(paramsRes);
    }

    // ... a jeœli sesja siê nie zmieni³a - to nie mamy nic do roboty
  }
//...
}
</pre>
  <br>
Serwlet ten zostanie uruchomiony na wstêpie serwletu pobierania parametrów.
Przygotowana informacja pos³u¿y do wygenerowania strony z formularzem.<br>
  <br>
  <pre>// SERWLET POBIERANIA PARAMETRÓW

public class GetParamsServ extends HttpServlet {

  private ServletContext context;
  private String resBundleServ;    // nazwa serwletu przygotowuj¹cego
                                   // sparametryzowan¹ informacje


  // Inicjacja
  public void init() {
    context = getServletContext();
    resBundleServ = context.getInitParameter("resBundleServ");
  }

  // Obs³uga zleceñ
  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {


    // W³¹czenie serwletu przygotowuj¹cego informacje z z zasobów
    // (ResourceBundle). Informacja bêdzie dostêpna poprzez
    // statyczne metody klasy BundleInfo

    RequestDispatcher disp = context.getRequestDispatcher(resBundleServ);
    disp.include(req, resp);

    // Pobranie potrzebnej informacji
    // ktora zosta³a wczesniej przygotowana
    // przez klasê BundleInfo na podstawie zlokalizowanych zasobów

    // Zlokalizowana strona kodowa
    String charset = BundleInfo.getCharset();

    // Napisy nag³ówkowe
    String[] headers = BundleInfo.getHeaders();

    // Nazwy parametrów (pojawi¹ siê w formularzu,
    // ale równie¿ s¹ to nazwy parametrów dla Command)
    String[] pnames = BundleInfo.getCommandParamNames();

    // Opisy parametrów - aby by³o wiadomo co w formularzu wpisywaæ
    String[] pdes   = BundleInfo.getCommandParamDescr();

    // Napis na przycisku
    String submitMsg = BundleInfo.getSubmitMsg();

    // Ew. koñcowe napisy na stronie
    String[] footers = BundleInfo.getFooters();

    // Ustalenie w³aœciwego kodowania zlecenia
    // - bez tego nie bêdzie mo¿na w³asciwie odczytaæ parametrów
    req.setCharacterEncoding(charset);

    // Pobranie aktualnej sesji
    // w jej atrybutach s¹/bêd¹ przechowywane
    // wartoœci parametrów

    HttpSession session = req.getSession();

    // Generowanie strony

    resp.setCharacterEncoding(charset);
    PrintWriter out = resp.getWriter();

    out.println("&lt;center&gt;&lt;h2&gt;");
    for (int i=0; i&lt;headers.length; i++)
       out.println(headers[i]);
    out.println("&lt;/center&gt;&lt;/h2&gt;&lt;hr&gt;");

       // formularz
    out.println("&lt;form method=\"post\"&gt;");
    for (int i=0; i&lt;pnames.length; i++) {
     out.println(pdes[i] + "&lt;br&gt;");
     out.print("&lt;input type=\"text\" size=\"30\" name=\"" +
                   pnames[i] +  "\"");

       // Jezeli s¹ ju¿ wartoœci parametrów - poka¿emy je w formularzu
      String pval = (String) session.getAttribute("param_"+pnames[i]);
      if (pval != null) out.print(" value=\"" + pval + "\"");
      out.println("&gt;&lt;br&gt;");
    }
    out.println("&lt;br&gt;&lt;input type=\"submit\" value=\"" + submitMsg + "\"&gt;");
    out.println("&lt;/form&gt;");

    // Pobieranie parametrów z formularza

    for (int i=0; i&lt;pnames.length; i++) {
      String paramVal = req.getParameter(pnames[i]);
         // Je¿eli brak parametru (ów) - konczymy
      if (paramVal == null) return;

      // Jest parametr - zapiszmy jego wartoœæ jako atrybut sesji.
      // Zostanie on pobrany przez Controller
      // który ustali te wartoœci dla wykonania Command

      session.setAttribute("param_" + pnames[i], paramVal);

    }
  }

  //..metody doGet i doPost - wywo³uj¹ serviceRequest
}
</pre>
  <br>
Serwlet przentacji najpierw przekazuje zadanie wygenrowania formularza serwletowi
pobierania parametrów, po czym prezentuje wyniki zapisane w atrybutach sesji
przez serwer-kontroler.<br>
  <pre>public class ResultPresent extends HttpServlet {


  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
    ServletContext context = getServletContext();

    // W³¹czenie strony generowanej przez serwlet pobierania parametrów
    // (formularz)
    String getParamsServ = context.getInitParameter("getParamsServ");
    RequestDispatcher disp = context.getRequestDispatcher(getParamsServ);
    disp.include(req,resp);

    // Uzyskanie wyników i wyprowadzenie ich
    // Controller po wykonaniu Command zapisa³ w atrybutach sesji
    // - referencje do listy wyników jako atrybut "Results"
    // - wartoœc kodu wyniku wykonania jako atrybut "StatusCode"

    HttpSession ses = req.getSession();
    Lock mainLock = (Lock) ses.getAttribute("Lock");
    mainLock.unlock();
    List results = (List) ses.getAttribute("Results");
    Integer code = (Integer) ses.getAttribute("StatusCode");


    PrintWriter out = resp.getWriter();
    out.println("&lt;hr&gt;");

    // Uzyskanie napisu w³aœciwego dla danego "statusCode"
    String msg = BundleInfo.getStatusMsg()[code.intValue()];
    out.println("&lt;h2&gt;" + msg + "&lt;/h2&gt;");

    // Elementy danych wyjœciowych (wyników) mog¹ byæ
    // poprzedzane jakimiœ opisami (zdefiniowanymi w ResourceBundle)
    String[] dopiski = BundleInfo.getResultDescr();

    // Generujemy raport z wyników
    out.println("&lt;ul&gt;");
    for (Iterator iter = results.iterator(); iter.hasNext(); ) {
      out.println("&lt;li&gt;");

      int dlen = dopiski.length;  // d³ugoœæ tablicy dopisków
      Object res = iter.next();
      if (res.getClass().isArray()) {  // jezeli element wyniku jest tablic¹
        Object[] res1 = (Object[]) res;
        int i;
        for (i=0; i &lt; res1.length; i++) {
          String dopisek = (i &lt; dlen ? dopiski[i] + " " : "");
          out.print(dopisek + res1[i] + " ");
        }
        if (dlen &gt; res1.length) out.println(dopiski[i]);
      }
      else {                                      // mo¿e nie byæ tablic¹
        if (dlen &gt; 0) out.print(dopiski[0] + " ");
        out.print(res);
        if (dlen &gt; 1) out.println(" " + dopiski[1]);
      }
      out.println("&lt;/li&gt;");
    }
    out.println("&lt;/ul&gt;");
  }


  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

  public void doPost(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

}
</pre>
Uruchamiaj¹c tê aplikacjê uzyskamy znany nam ju¿ obraz&nbsp; dzialania (stronê
z formy\ularzem , która po wpisaniu regularnego wyra¿enia i przeszukiwanego
tekstu zostanie uzupe³niona o listê komunikatów o odnalezionych dopasowaniach).<br>
  <img style="width: 617px; height: 501px;" src="images/regex3.jpg" alt="r">
  <br>
  <br>
&nbsp;Oczywiœcie, ca³a aplikacja jest teraz doœæ rozbudowana, a nawet skomplikowana.
Jednak dziêki&nbsp; dodatkowemu wysi³kowi wlo¿onemu w separacje logiki dzia³ania,
prezentacji oraz elementów opisowych zmiany jej funkcjonalnoœci s¹ obecnie
bardzo ³atwe, Wyniki mo¿emy np. prezentowaæ w tabeli (co wymaga tylko niewielkich
modyfikacji kodu serwletu prezentacji, inne komponenty nie ulegaj¹ zmianom).
Mo¿emy inaczej pobieraæ parametry (co wymaga zmian tylko w serwlecie GetParamServ).
Nawet ca³kowita zmiana wykonywanego przez aplikacjê zadania jest niezwykle
prosta i nie zabierze wiêcej ni¿ kilka minut. Zobaczmy to na przyk³adzie
zadania wykonywania kilku operacji na wprowadzanych tekstach (powiedzmy po³¹czenie
dwóch tekstów i wykonaniu wybranej operacji - zmiany wielkoœci liter lub
wyodrêbnienia s³ów).<br>
Kody wszystkich serwletów pozostaj¹ bez zmian. Musimy jedynie dostarczyæ
nowej implementacji interfejsu Command &nbsp;(klasê nazwiemy StringComamnd i podamy
te nazwê w parametrze kontekstu) oraz pliku zasobowego z opisem aplikacji
(dla lokalizacji polskiej - StringCmdDef_pl).<br>
  <br>
  <pre>import java.util.*;

public class StringCmdDef_pl extends ListResourceBundle {
     public Object[][] getContents() {
         return contents;
     }

    static final Object[][] contents = {
       { "charset", "ISO-8859-2" },
       { "header", new String[] { "Dzia³ania na Stringach" } },
       { "param_input1", "Tekst 1:" },
       { "param_input2", "Tekst 2:" },
       { "param_cmd", "Polecenie:" },
       { "submit", "Wykonaj" },
       { "footer", new String[] { } },
       { "resCode", new String[]
                    { "Wynik:", "Brak danych",
                      "Wadliwe polecenie, dostêpne: upper, lower, words" }
                    },
       { "resDescr",
            new String[] { "" } },
    };
}
</pre>
  <br>
  <pre>import java.io.*;
import java.util.*;

public class StringCommand extends CommandImpl implements Serializable {

  public StringCommand() {}

  public void execute() {
    clearResult();
    String input1 = (String) getParameter("input1");
    String input2 = (String) getParameter("input2");
    String cmd =   (String) getParameter("cmd");
    if (input1 == null || input2 == null || cmd == null) {
      setStatusCode(1);
      return;
    }


   String input = input1 + " " + input2;


   setStatusCode(0);
   if (cmd.equals("upper")) addResult(input.toUpperCase());
   else if (cmd.equals("lower")) addResult(input.toLowerCase());
   else if (cmd.equals("words")) {
     StringTokenizer st = new StringTokenizer(input);
     while (st.hasMoreTokens())  addResult(st.nextToken());
   }
   else setStatusCode(2);
 }

}
</pre>
  <br>
Nasza aplikacje bedzie teraz dzia³aæ tak:<br>
  <br>
  <img style="width: 680px; height: 612px;" src="images/StringCmd.jpg" alt="r">
  <br>
  <br>
<br>
  Naturalnie ten sposób programowania (separuj¹cego dzia³anie i prezentacjê)
nie jest w przypadku "czystego" Servlet API bardzo ³atwy. Dlatego w³aœnie
pojawi³y siê technologie JSP, a szczególnie Java Server Faces. Powiemy o
nich kilka s³ów ju¿ za chwilê. <br>
<hr style="width: 100%; height: 2px;"><br>
  <a name="WebApps.7"></a><h2>
7. Serwlety i bazy danych</h2>
  Aplikacje WEB mog¹ ³¹czyæ siê z bazami danych, pobieraæ i prezentowaæ
informacje bazodanowe, udostêpniac interfejsy modyfikacji baz. Jest to bardzo
naturalne zastosowanie aplikacji WEB. <br>
Przy programowaniu webowych aplikacji bazodanowych nale¿y jednak zwróciæ uwagê na pewne specyficzne cechy ich dzialania.<br>
Zobaczmy najpierw jak <b>nie nale¿y</b> takich aplikacji programowaæ.<br>
  <br>
Bêdziemy korzystaæ ze znanej ju¿ nam bazy danych ksi¹¿ek (dostêp przez jdbc/ksidb
- zob. rozdzia³ o JDBC) i bazy Derby w trybie klient serwer.<br>
Uwaga: aby mieæ dostêp z poziomu aplikacji WEB w œrodowisku Tomcata pakiet
sterownika (np.&nbsp; derbyclient.jar) nale¿y umieœciæ
w katalogu&nbsp;lib Tomcata.<br>
  <br>
Przeniesiony z jakichœ prostych, niesieciowych doœwiadczeñ dostêpu do baz
danych sposób programowania móg³by opieraæ sie na kolejnych krokach: w trakcie
inicjacji serwletu za³adowaæ sterownik JDBC i uzyskaæ po³¹czenie, przy obs³udze
zleceñ generowaæ zapytania i pokazywaæ wyniki, przy usuniêciu serwletu -
zamkn¹æ po³aczenie.<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.sql.*;
import javax.sql.*;

public class DbServlet1 extends HttpServlet {

  String url = "jdbc:derby://localhost/ksidb";
  String uid = "APP";
  String pwd = "APP";
  Connection con;


  public void init() throws ServletException {
    try {
     con = DriverManager.getConnection(url, uid, pwd);  //  JDBC 4.0 - dostêp przez SPI
    } catch (Exception exc) {
        throw new ServletException("Nie ustanowiono po³aczenia z baz¹", exc);
    }
  }


  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
   resp.setContentType("text/html; charset=windows-1250");
   PrintWriter out = resp.getWriter();
   out.println("&lt;h2&gt;Lista dostêpnych ksi¹¿ek&lt;/h2&gt;");
   String sel = "select * from pozycje";
   out.println("&lt;ol&gt;");
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      while (rs.next())  {
        String tytul = rs.getString("tytul");
        float cena  = rs.getFloat("cena");
        out.println("&lt;li&gt;" + tytul + " - cena: " + cena + "&lt;/li&gt;");
      }
      rs.close();
      stmt.close();
    } catch (SQLException exc)  {
       out.println(exc.getMessage());
    }
    out.close();
  }

   public void destroy() {
     try {
       con.close();
     } catch (Exception exc) {}
   }


  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

  public void doPost(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

}
</pre>

<br>
To rozwi¹zanie jest wadliwe, gdy¿:<br>
  <ul>
    <li>obiekt Connection&nbsp; mo¿e byæ wspó³dzielony przez wiele w¹tków, a nasz
program nie jest na to przygotowany (dostêp do Connection nie jest wielow¹tkowo
bezpieczny); w œrodowisku WEB aplikacji jest to szczególnie wa¿ne, bo aplikacja
powinna móc obs³ugiwaæ równoczeœnie du¿¹ liczbê po³¹czeñ,</li>
    <li>po³aczenie z baz¹ danych jest otwierane przy inicjacji serwletu i
utrzymywane przez ca³y czas ¿ycia serwletu (co oczywiœcie wcale nie jest
potrzebne i prowadzi do zmniejszenia efektywnoœci w œrodowiskach, gdzie dzia³a
wiele serwletów bazodanowych),</li>
    <li>po³¹czenie mo¿e wygasn¹æ z jakichœ powodów (np. serwer bazodanowy
zamknie je ze wzglêdu na d³ug¹ nieaktywnoœæ), a nasz serwlet nie jest przygotowany
do odtworzenia po³¹czenia przy ew. kolejnym zleceniu,</li>
    <li>wreszcie, w tym programiku wystêpuje znany nam ju¿ problem zmieszania
kodu odpowiedzialnego za pracê i kodu prezentacji (na razie pominiemy to
zagadnienie, aby by³o widaæ wyraŸniej ca³oœciowe kody programów; póŸniej
zajmiemy siê przebudow¹ w³aœciwej aplikacji&nbsp; w konwencji MVC),</li>
  </ul>
Zatem na pewno potrzebne jest inne podejœcie: otwieranie po³¹czenia bazodanowego
przy ka¿dym zleceniu, wykonanie zlecenia (dostêp do BD), zamkniêcia po³¹czenia.<br>
  <br>
  <pre><b> // Drugie wadliwe rozwi¹zanie</b>
&nbsp;
 public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
   resp.setContentType("text/html; charset=windows-1250");
   PrintWriter out = resp.getWriter();
   out.println("&lt;h2&gt;Lista dostêpnych ksi¹¿ek&lt;/h2&gt;");

   Connection con;
   String sel = "select * from pozycje";
   try  {
      con = DriverManager.getConnection(...);

      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      out.println("&lt;ol&gt;");
      while (rs.next())  {
        String tytul = rs.getString("tytul");
        float cena  = rs.getFloat("cena");
        out.println("&lt;li&gt;" + tytul + " - cena: " + cena + "&lt;/li&gt;");
      }
      rs.close();
      stmt.close();
      con.close();
    } catch (Exception exc)  {
       out.println(exc.getMessage());
    }
    out.close();
  }

</pre>
To rozwi¹zanie jest jednak równie¿ niew³aœciwe. Nie tylko dlatego, ¿e (tak
jak poprzednio) zawiera statycznie zapisane w kodzie nazwy zasobów i nie
przestrzega regu³ architektury MVC (z tym umiemy sobie ju¿ radziæ), ale przede
wszystkim dlatego, ¿e jest niefektywne i nieskalowalne. Uzyskanie po³¹czenia
z baz¹ danych jest bowiem operacj¹ relatywnie kosztown¹ czasowo, zatem przy
du¿ej, rosn¹cej liczbie zleceñ ta aplikacja bêdzie znacz¹co traciæ na efektywnoœci
dzia³ania.<br>
  <br>W³aœciwym rozwi¹zaniem problemu <b>jednak</b> jest uzyskiwania po³aczeñ przy
ka¿dym zleceniu, a po jego obs³udze "zamykanie" po³¹czenia, ale bez strat
efektywnoœci. Mo¿na to osi¹gn¹æ poprzez dynamiczne prowadzenie puli po³¹czeñ
i ponowne wykorzystanie po³¹czeñ z puli. Fizyczne &nbsp;(czasowo kosztowne) ³¹czenie
jest przy tym minimalizowane: uzyskane po³¹czenia znajduj¹ siê w puli po³¹czeñ
i mog¹ byæ ponownie wykorzystane, jeœli s¹ akurat wolne. Zamkniêcie po³aczenie
(z perspektywy serwletu) jest tak naprawdê zwróceniem po³¹czenia do puli.<br>
  <br>
Mo¿na oczywiœcie samodzielnie napisaæ "broker" obs³uguj¹cy pulê po³aczeñ
i dostarczaj¹cy ich serwletom. S¹ jednak ju¿ gotowe, ogólniedostêpne rozwi¹zania,
np.DbConnectionBroker, który mo¿na pobraæ z http://www.javaexchange.com (godny
polecenia, szczególnie ze wzglêdu na mo¿liwoœæ przyjrzenia siê kodowi tego
programu, który odznacza siê prostot¹ i funkcjonalnoœci¹).<br>
  <br>
Jest te¿ inny sposób. Mianowicie JDBC daje mo¿liwoœæ
uzyskiwania po³aczeñ z BD poprzez tzw. Ÿród³o danych (obiekt typu <span style="font-weight: bold;">DataSource</span>).
S³u¿y to z jednej strony separacji &nbsp;parametrów po³¹czeñ od kodu interfejsu
bazodanowego, z drugiej odpowiednie implementacje <span style="font-weight: bold;">DataSource</span> zapewniaj¹ automatyczny
pooling po³¹czeñ.<br>
  <br>
Takie implementacje s¹ dostarczane praktycznie przez wszystkie serwery aplikacji.&nbsp;
Równie¿ Tomcat w wersji5 daje nam mo¿liwoœæ korzystania z dynamicznej puli
po³¹czeñ. Wymaga to jednak pewnych zabiegów konfiguracyjnych - i oczywiœcie
- ju¿ innego kodu uzyskania po³aczenia.<br>
  <br>
Przede wszystkim Ÿród³a danych musz¹ byæ odpowiednio zdefiniowane i opisane
w plikach konfiguracyjnych. W szczególnoœci mo¿na to zrobiæ dostarczaj¹c
odpowiednich elementów w pliku-deskryptorze kontekstu.<br>
Co musimy podaæ:<br>
  <ul>
    <li>w ramach elementu Resource: nazwê zasobu (tu nasza baza identyfikowana
przez jdbc/ksidb), jego autoryzacjê - czyli kto bêdzie odpowiada³ za rejestracjê
zasobu u manad¿era zasobów (podaj¹c "Container" powiemy, ¿e kontener serwletów,
czyli czêœæ serwera, zajmuj¹cego siê obs³ug¹ serwletów) , typ zasobu - czyli
klasê jego obiektów - tu bêdzie to DataSource),</li>
    <li>w ramach elementu ResourceParams - paranetry tworzenia zasobu (w
naszym przypadku - klasê sterownika JDBC, url zasobu, nazwê u¿ytkownika,
has³o).</li>
  </ul>
Odpowiedni plik deskryptora kontekstu (który mo¿e pos³u¿yc do instalacji aplikacji
za pomoc¹ zadania Anta install-config lub jej wdro¿enia, chocia¿by poprzez
umieszczenie deksryptora kontekstu w katalogu webapps) wygl¹da nastêpuj¹co
(aplikacja rezyduje &nbsp;w katalogu E:/Programming/webaps/SERWLETY/db/build i bêdzie dostêpna
w kontekœcie /db):<br>
  <pre>&lt;Context path="/db" docBase="E:/Programming/webaps/SERWLETY/db/build"&gt;

  &lt;Resource name="jdbc/ksidb" auth="Container" 
            type="javax.sql.DataSource"
            description="Baza danych ksiazek" 
            driverClassName="org.apache.derby.jdbc.ClientDriver"
            url="jdbc:derby://localhost/ksidb"
            username="APP"
            password="APP"
            maxActive="20" /&gt; 
&lt;/Context&gt;


</pre>
Dostêp do ¿ród³a danych z poziomu aplikacji uzyskujemy za pomoc¹ <b>JNDI (java naming and directory interface).</b> <br>
Jest to technologia, która pozwala na poziomie logicznym, odseparowanym od
fizycznych obiektów, identyfikowaæ i uzyskiwac dostêp do ró¿norodnych zasobów
(komputerów, u¿ytkowników, baz danych, serwisów, systemów plikowych, aplikacji).
  <br>
  <br>
Zasoby s¹ identyfikowane przez nazwy, te zaœ s¹ wi¹zane z konkretnymi obiektami poprzez tzw. <b>konteksty JNDI</b>. <br>
  <br>
Odnalezienie zasobu polega na wywo³aniu metody <b>lookup()</b> w danym kontekœcie JNDI. <br>
  <br>
Wa¿nym kontekstem jest <b>kontekst inicjalny</b> (initial context), który pozwala odnajdywaæ inne konteksty. <br>
W szczególnoœci w œrodowisku Tomcat istnieje specjalny kontekst JNDI, który stanowi <b>zbiór powi¹zañ pomiedzy nazwami zasobów a odpowiadaj¹cymi im konkretnymi obiektami.</b> <br>
Kontekst ten nazywa siê <b>java:comp/env</b> .<br>
To w³aœnie "pod" tym kontekstem znajdowaæ bêd¹ siê ¿ród³a danych zwi¹zane z bazami. <br><br>
<div class="important">Uwaga: oczywiœcie nie nale¿y myliæ kontekstów JNDI z kontektsami aplikacji WEB</div><br>
  <br> Zatem najpierw musimy uzyskaæ inicjalny kontekst, od niego - kontekst
java:comp/env, i w tym kontekœcie odszukaæ powi¹zanie naszej bazy danych i uzyskaæ w³aœciwy dla niej DataSource:&nbsp; <br>
  <pre>      Context init = new InitialContext();
      Context contx = (Context) init.lookup("java:comp/env");
      DataSource dataSource = (DataSource) contx.lookup("jdbc/ksidb");
</pre>
  <br>
Te dzialania (relatywnie kosztowne
czasowo) wykonamy w czêœci inicjacyjnej serwletu.<br>
  <br>
Uzyskany DataSource zapewnia automatyczny pooling po³aczeñ, zatem ³¹czenia
z baz¹ bêdziemy spokojnie dokonywaæ przy ka¿dym zleceniu, a po jego obs³udze
- po³¹czenie zamykaæ.<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import javax.naming.*;
import java.sql.*;
import javax.sql.*;

public class DbServlet3 extends HttpServlet {

  DataSource dataSource;  // Ÿrod³o danych

  public void init() throws ServletException {
    try {
      Context init = new InitialContext();
      Context contx = (Context) init.lookup("java:comp/env");
      dataSource = (DataSource) contx.lookup("jdbc/ksidb");
     } catch (NamingException exc) {
        throw new ServletException(
          "Nie mogê uzyskaæ Ÿród³a java:comp/env/jdbc/ksidb", exc);
     }
  }

  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
    resp.setContentType("text/html; charset=windows-1250");
    PrintWriter out = resp.getWriter();
    out.println("&lt;h2&gt;Lista dostêpnych ksi¹¿ek&lt;/h2&gt;");

    Connection con = null;
    try {
      synchronized (dataSource) {
        con = dataSource.getConnection();
      }
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery("select * from pozycje");
      out.println("&lt;ol&gt;");
      while (rs.next())  {
        String tytul = rs.getString("tytul");
        float cena  = rs.getFloat("cena");
        out.println("&lt;li&gt;" + tytul + " - cena: " + cena + "&lt;/li&gt;");
      }
      rs.close();
      stmt.close();
    } catch (Exception exc)  {
       out.println(exc.getMessage());
    } finally {
        try { con.close(); } catch (Exception exc) {}
    }

    out.close();


  }


  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

  public void doPost(HttpServletRequest request,
                    HttpServletResponse response)
                 throws ServletException, IOException
  {
      serviceRequest(request, response);
  }

}
</pre>
W powy¿szym kodzie zwróæmy uwagê na potrzebê synchronizacji: obiekt DataSource
mo¿e byæ wspóldzielony przez wiele w¹tków, zatem musimy synchroniziwaæ odwo³ania
do niego.<br>
  <br>
Mo¿emy siê przekonaæ, ¿e ta aplikacja dziala - po wywo³aniu serwletu uzyskamy nastêpuj¹cy wynik:<br>
  <img style="border: 1px solid ; width: 680px; height: 341px;" src="images/Db3.jpg" alt="r">
  <br>
  <br>
  <br>
  Bardzo ³atwo mo¿emy u¿yæ przedstawionego w poprzednim punkcie szablonu "serwletów
MVC" w zastosowaniach bazodanowych. Trzeba tylko dostarczyæ odpowiedniej
implementacji interfejsu Command. Za³ó¿my, ¿e nasza klasa dzia³ania na BD
mo¿e wykonywaæ polecenia select i insert przekazane przez parametr "command".
Wybrane dzialanie bêdzie wykonywane przy wywo³aniu metody execute() na skutek
obs³ugi zlecenia. W metodzie init () - która powinna byæ z serwletu-kontrolera
wo³ana jeden tylko raz - uzyskamy Ÿród³o danych (obiekt DataSource) na podstawie
parametru, spect\yfikuj¹cego nazwê bazy. <br>
  <br>
Klasê dzia³añ na bazie danych przedstawia poni¿szy wydruk (kod klasy CommandImpl
oraz ca³y schemat separacji przedstawiono w poprzednim podrozdziale).<br>
  <pre>import java.io.*;
import java.util.*;
import javax.naming.*;
import java.sql.*;
import javax.sql.*;

public class DbAccess extends CommandImpl {

  private DataSource dataSource;

  public void init() {
    try {
      Context init = new InitialContext();
      Context jndiCtx = (Context) init.lookup("java:comp/env");
      String dbName = (String) getParameter("dbName");
      dataSource = (DataSource) jndiCtx.lookup(dbName);
     } catch (NamingException exc) {
         setStatusCode(1);
     }
  }

  public void execute() {
    clearResult();
    setStatusCode(0);
    Connection con = null;
    try {
      synchronized(this) {
        con = dataSource.getConnection();
      }

      Statement stmt = con.createStatement();

      String cmd =  (String) getParameter("command");

      if (cmd.startsWith("select")) {
        ResultSet rs = stmt.executeQuery(cmd);

        // Bêdziemy&nbsp;zapisywaæ wynik jako skonkatenowane
        // wartoœci&nbsp;z kolumn ResultSetu
        // Oczywiœcie, w ró¿nych kwerendach bêd¹ ró¿ne kolumny
        // zatem korzystamy z ResultSetMetaData, by do nich dotrzeæ
&nbsp;
        ResultSetMetaData rsmd = rs.getMetaData();
        int cols = rsmd.getColumnCount();
        while (rs.next()) {
          String wynik = "";
          for (int i=1; i&lt;=cols; i++)
             wynik += rs.getObject(i) + " ";
          addResult(wynik);
        }
        rs.close();
      }
      else if (cmd.startsWith("insert")) {
        int upd = stmt.executeUpdate(cmd);
        addResult("Dopisano " + upd + " rekordów");
        }
      else setStatusCode(3);
    } catch (SQLException exc) {
          setStatusCode(2);
          throw new DbAccessException("B³¹d w dostêpie do bazy lub w SQL", exc);
    } finally {
        try {
          con.close();
        } catch (Exception exc) {}
    }
  }

}
</pre>

  Serwlet-kontroler w znany nam ju¿ sposób odczytuje wyniki i przekazuje
do prezentacji. Ze wzglêdu na naturê dostêpu przez DataSource musieliœmy
jednak poczyniæ drobn¹ zmianê w metodzie inicjacji serwletu-kontrolera, a
mianowicie - ustaliæ nazwê bazy danych (pobran¹ z parametrów kontekstu) jako
parametr dla klasy dzia³ania i zainicjowaæ jej obiekt. Te dodatki s¹ na poni¿szym
wydruku zaznaczone pogrubionym tekstem..<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.text.*;

public class ControllerServ extends HttpServlet {

  private ServletContext context;
  private Command command;            // obiekt klasy dzialania (wykonawczej)
  private String presentationServ;    // nazwa serwlet prezentacji
  private String getParamsServ;       // mazwa serwletu pobierania parametrów

  public void init() {

    context = getServletContext();

    presentationServ = context.getInitParameter("presentationServ");
    getParamsServ = context.getInitParameter("getParamsServ");
    String commandClassName = context.getInitParameter("commandClassName");
    <b>String dbName = context.getInitParameter("dbName");</b>

    // Za³adowanie klasy Command i utworzenie jej egzemplarza
    // który bêdzie wykonywa³ pracê
    try {
      Class commandClass = Class.forName(commandClassName);
      command = (Command) commandClass.newInstance();
      // ustalamy, na jakiej bazie ma dzia³aæ Command i inicjujemy obiekt
<b>      command.setParameter("dbName", dbName);
      command.init();
</b>    } catch (Exception exc) {
        throw new NoCommandException("Couldn't find or instantiate " +
                                      commandClassName);
    }
  }

  // ... dalej znany ju¿ kod obs³ugi zleceñ

</pre>

  Przygotujemy oczywiœcie zasoby definicyjne:<br>
  <pre>import java.util.*;

public class DbAccessDef_pl extends ListResourceBundle {
     public Object[][] getContents() {
         return contents;
     }

    static final Object[][] contents = {
       { "charset", "ISO-8859-2" },
       { "header", new String[] { "Baza danych ksi¹¿ek" } },
       { "param_command", "Polecenie (select lub insert):" },
       { "submit", "Wykonaj" },
       { "footer", new String[] { } },
       { "resCode", new String[]
                    { "Wynik:", "Brak bazy", "B³¹d SQL",
                      "Wadliwe polecenie; musi zaczynaæ siê od select lub insert" }
                    },
       { "resDescr",
            new String[] { "" } },
    };
}
</pre>

  a w serwletach pobierania parametrów i prezentacji zmienimy szerokoœæ
pola tekstowego oraz rodzaj listy (niech teraz bêdzie numerowana). W sumie
10 minut pracy i mamy doœæ uniwersaln¹ i elastyczn¹ aplikaacjê bazodanow¹
(zob. rys).<br>
  <br>
  <img style="width: 680px; height: 491px;" src="images/dbAccess1.jpg" alt="r">
  <br>
  <br>
  <br>
Przy okazji tej aplikacji przyjrzymy sie kwestiom zwi¹zanym z obs³ug¹ b³êdów.
Zauwa¿my, ¿e wprowadzone kody i opisy b³êdów s¹ ma³o precyzyjne. Gdy otrzymamy
"B³¹d SQL" - chcielibyœmy wiedzieæ jaki to b³¹d.<br>
  <br>
W tym celu wprowadzamy w³asn¹ klasê wyj¹tków DBAccessException,<br>
  <pre>public class DbAccessException extends RuntimeException {
  public DbAccessException(String msg, Throwable cause) {
     super(msg, cause);
   }
}&nbsp;</pre>

  Wyj¹tki tej klasy bêdziemy zg³aszaæ w reakcji na wyst¹pienie wyj¹tku SQLException,
przy czym zastosujemy ³añcuchowanie wyj¹tków: przyczyna powstania naszego
wyj¹tku - czyli wyj¹tek SQLExecption zostanie dowi¹zany do naszego wyj¹tku:<br>
  <br>
  <pre> public void execute() {
   //....
   try {

     // ³¹czenie z baz¹ i operacje na niej
     // ...
   } catch (SQLException exc) {
          setStatusCode(2);
          throw new DbAccessException("B³¹d w dostêpie do bazy lub w SQL", exc);
    } finally {
        try {
          con.close();
        } catch (Exception exc) {}
    }
  }</pre>
Zatem oprócz enigmatycznego "statusCode" 2 ( opisanego jako "B³¹d w SQL")
mamy zg³oszony wyj¹tek, precyzyjnie opisuj¹cy przyczyny b³êdu. Ale jak go
obs³u¿yæ? Przecie¿ serwlet-kontroler, który wywo³uje execute(...) nie bêdzie
zajmowa³ siê prezentacj¹ opisów b³êdów.<br>
Oczywiœcie, móg³by on obs³ugiwaæ ten wyj¹tek i zapisaæ informacje o b³êdach
do wykorzystania w serwlecie prezentacji. By³oby to nawet doœæ eleganckie.<br>
  <br>
Istnieje jednak i inne rozwi¹zanie - strony opisów b³êdów deklarowane w pliku web.xml.<br>
Element opisuj¹cy stronê b³êdu (&lt;error-page&gt;) definiuje typ b³êdu (klasê
wyj¹tku) oraz lokalizacjê strony, która na skutek b³êdu ma byæ "za³adowana".<br>
  <br>
Mog¹ to byæ strony statyczne, ale równie¿ odniesienia do serwletów (czy JSP),
które dynamicznie wygeneruj¹ treœæ. Takim serwletom przekazywane jest zlecenie,
dla którego ustalono atrybuty, opisuj¹ce sytuacjê. W szczegónoœci dostêpne
s¹ nastêpuj¹ce atrybuty:<br>
  <br>
  <table style="font-size: 80%; background-color: rgb(255, 255, 255); width: 616px; height: 96px;" border="1" cellpadding="1" cellspacing="0">
<tbody><tr bgcolor="#ccffff"><td>javax.servlet.error.message</td><td>Komunikat o b³êdzie (String)<br>
        </td></tr><tr bgcolor="#66ffcc"><td>javax.servlet.error.servlet_name</td><td>Nazwa serwletu, w którym powsta³ b³ad<br>
        </td></tr><tr bgcolor="#ccffff"><td>javax.servlet.error.exception_type</td><td>Klasa wyj¹tku (Class)</td></tr><tr bgcolor="#66ffcc"><td>javax.servlet.error.exception</td><td>Obiekt wyj¹tku (ogólnie klasy Throwable)<br>
        </td></tr></tbody>
  </table><br>Uwaga: strony opisu b³êdów mog¹ byæ stosowane równie¿ do obs³ugi b³êdów HTTP
oraz powstaj¹cych po stronie samego serwera (a nie tylko naszych klas, generuj¹cych
jakieœ wyj¹tki).<br>
  <br>
Utwórzmy wiêc serwlet generacji stron opisu b³êdów SQL:<br>
  <pre>public class ErrorHandler extends HttpServlet {

  public void serviceRequest(HttpServletRequest req,
                             HttpServletResponse resp)
                             throws ServletException, IOException
  {
    String charset = BundleInfo.getCharset();
    resp.setContentType("text/html; charset=" + charset);
    Throwable exc = (Throwable)
                     req.getAttribute("javax.servlet.error.exception");

    if (exc != null) {
      PrintWriter out = resp.getWriter();
      out.println("&lt;h2&gt;" + exc.getMessage() + "&lt;/h2&gt;&lt;hr&gt;");
      Throwable cause = exc.getCause();
      if (cause instanceof SQLException) {
        SQLException sqlexc = (SQLException) cause;
        out.println(sqlexc.getMessage() + "&lt;br&gt;&lt;br&gt;");
        out.println("Error code: " + sqlexc.getErrorCode() + "&lt;br&gt;");
        out.println("SQL state : " + sqlexc.getSQLState() + "&lt;br&gt;");
      }
      out.close();
    }

  }
//... metody doGet i doPost wo³aj¹ serviceRequest
</pre>
a w deskryptorze wdro¿enia zaznaczmy, ¿e to w³aœnie on powinien otrzymaæ
sterowanie, gdy wyst¹pi nasz wyj¹tek DbAccessException:<br>
  <br>
  <pre>   // ...
   &lt;servlet&gt;
       &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;
       &lt;servlet-class&gt;ErrorHandler&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/errorhandler&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

   &lt;error-page&gt;
     &lt;exception-type&gt;DbAccessException&lt;/exception-type&gt;
     &lt;location&gt;/errorhandler&lt;/location&gt;
   &lt;/error-page&gt;
   //..

</pre>
  <br>
Teraz po wprowadzeniu w przyk³adowej aplikacji polecenia: select * from
poz mo¿emy uzyskac&nbsp;nastêpuj¹cy wynik (numery b³êdów s¹ zale¿ne od
bazy):<br>
  <img src="images/dbAccess2.jpg" alt="r" height="317" width="552">
  <br>
&nbsp;<br>
  <br>
Pokazany sposób oprogramowania WEB-aplikacji bazodanowej z uwzglêdnieniem
separacji dzia³añ na bazie, czêœci interakcyjnej oraz prezentacyjnej jest
elastyczny i uniwersalny. Choæ daje ³atwe mo¿liwoœci modyfikacji treœci i
funkcjonalnoœci, to jednak mo¿e nieco "straszyæ"&nbsp; doœæ rozbudowan¹ architektur¹
(mamy tu 5 serwletów: kontroler, pobieracz parametrów, prezenter, zbieracz
informacji z klas zasobowych oraz serwlet obs³ugi b³êdów SQL, a do tego klasy
interfejsu bazodanowego oraz w³asnych wyj¹tków).<br>
<br>
Z tego te¿ powodu pojawi³y siê technologie JSP i - szczególnie - Java Server
Faces. Pozwalaj¹ one nieco uproœciæ budowanie aplikacji WEB zgodnie z regu³ami
architektury MVC, ale z kolei same wprowadzaj¹ du¿¹ liczbê nowych pojêæ i
elementów, które trzeba opanowaæ. <br><br>
  <a name="WebApps.8"></a><h2>
8. Cookies</h2>Serwer HTTP mo¿e posy³aæ klientowi (przegl¹darce) tzw.
cookies - dowolne fragmenty informacji, zazwyczaj identyfikuj¹ce stany transakcji
z klientem (np. autoryzacjê u¿ytkownika, jego preferencje co do treœci i
wygl¹du prezentowanego serwisu WWW). Te kawa³ki informacji s¹ przechowywane
przez przegl¹darke i zwracane serwerowi HTTP przy kolejnych po³¹czeniach.
W ten sposób informacja jest odtwarzana (i mo¿na np. dokonywaæ odpowiedniej
personalizacji stron, czy te¿ kontynuowaæ zakupy w sklepie internetowym).<br>
  <br>
Mechanizm cookies jest dostêpny z&nbsp; poziomu serwletów za pomoc¹ klasy&nbsp; Cookie. <br>
Aby stworzyæ "cookie" &nbsp;wywo³ujemy konstruktor tej klasy:<br>
  <br>
&nbsp;&nbsp;&nbsp; Cookie(String name, String value) <br>
  <br>
Stworzone "cookie" przesy³amy klientowi za pomoc¹ metody&nbsp;addCookie(Cookie c) z klasy&nbsp; HTTPServletResponse.<br>
  <br>
<div class="notel">"Cookies" s¹ jednym ze sposobów rejestrowania i prowadzenia sesji. Czyni
to niewidocznie dla nas tzw. "session tracking API", na które sk³ada sie
klasa HttpSession oraz metody getSession() z klasy HttpRequest. Przy wy³¹czonych
w przegl¹darce cookies stosowane s¹ inne sposoby rejestracji i prowadzenia
sesji, np. tzw. url-rewriting.</div> Odczytujemy przeslane uprzednio cookies
(przy nowej transakcji, zleceniu) za pomoc¹ metody getCookies() z klasy&nbsp;HttpServletRequest.
Metoda zwraca tablicê Cookie[]. Ka¿de "cookie" z tej tablicy mo¿emy odpytaæ
o jego nazwê (getName()), wartoœæ (getValue()) oraz "maksymlany wiek" (getMaxAge()).
Maksymalny wiek "cookie" mo¿emy ustaliæ wczœsniej za pomoc¹ metody setMaxAge(...)
- po wygaœniêciu podanego jako argument czasu serwer przestaje posy³aæ dane
cookie do klienta.<br>
  <br>
Poni¿szy przyk³adowy program posluguje sie cookie o nazwie "count", zliczaj¹c w ten sposób kolejne po³¹czenia klienta. <br>
  <pre>public class CookieAndSess extends HttpServlet {

  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {

      resp.setContentType("text/html");
      PrintWriter out = resp.getWriter();

      Cookie[] cookies = req.getCookies();
      Cookie countCookie = null;
      HttpSession session = null;

      if (cookies != null) {
        for (int i=0; i&lt;cookies.length; i++) {
          String name = cookies[i].getName();
          String value = cookies[i].getValue();
          out.println("&lt;br&gt;" + name + " " + value);
          if (name.equals("count")) {
            countCookie = cookies[i];
            int count = Integer.parseInt(countCookie.getValue()) + 1;
            countCookie.setValue(String.valueOf(count));
            if (count &gt; 3) session = req.getSession();
            }
          }
        }
      if (session != null) {
        out.println("&lt;hr&gt;");
        out.println("Sesja: " + session.getId());
      }
      if (countCookie == null) countCookie = new Cookie("count", "1");
      resp.addCookie(countCookie);
      out.close();
  }

}
</pre>
Przy trzecim pol¹czeniu tworzona jest sesja (metoda getSession() tworzy sesje,
jeœli jeszcze nie zosta³a utworzona) &nbsp;i od tego momentu widzimy, ¿e wraz
z naszym cookie-licznikiem przychodzi te¿ cookie (o nazwie JSESSIONID) z
identyfikatorem sesji:<br>
  <br>
  <img src="images/Cookies.jpg" alt="r" height="277" width="485">
  <br>
  <br>

  <a name="WebApps.9"></a><h2>9. S³uchacze i filtry</h2>
Java Servlet API definiuje kilka rodzajów zdarzeñ oraz interfejsów ich obs³ugi.<br>
Mo¿na tu wyró¿niæ:<br>
  <br>
  <table border="1" cellpadding="2" cellspacing="2" width="100%">

  </table>
Uwagi:
  <table bgcolor="#ffffff" border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td valign="top"><div align="center"><b>Zdarzenie</b><br></div></td><td valign="top"><div align="center"><b>Klasa zdarzenia</b><br></div></td><td valign="top"><div align="center"><b>Interfejs obs³ugi</b><br></div></td><td valign="top"><div align="center"><b>Metody obs³ugi</b><br></div></td></tr><tr><td width="20%">inicjacja i usuwanie kontekstu aplikacji</td><td width="20%">ServletContextEvent</td><td>ServletContextListener</td><td>contextInitialized<br>
contextDestroyed<br></td></tr><tr><td width="20%">zapis, zmiana i usuwanie atrybutów kontekstu</td><td width="20%">ServletContextAttributeEvent</td><td>ServletContextAtrributeListener</td><td>attributeAdded<br>
attributeRemoved<br>
attributeReplaced<br></td></tr><tr><td width="20%">inicjacja i zakoñczenie obs³ugi zlecenia </td><td width="20%">ServletRequestEvent</td><td>ServletRequestListener</td><td>requestInitialized<br>
requestDestroyed<br></td></tr><tr><td width="20%">zapis, zmiana i usuwanie atrybutów zlecenia</td><td width="20%">ServletRequestAttributeEvent</td><td>ServletRequestAttributeListener</td><td>atrributeAdded<br>
attributeRemoved<br>

attributeReplaced<br></td></tr><tr><td valign="top">utworzenie<br>
i zamkniêcie<br>
sesji<br></td><td valign="top"><br>
HttpSessionEvent<br></td><td valign="top"><br>
HttpSestionActivationListener<br></td><td valign="top">sessionCreated<br>
sessionDestroyed<br></td></tr><tr><td width="20%">aktywacja i pasywacja sesji</td><td width="20%">HttpSessionEvent</td><td>HttpSestionActivationListener</td><td>sessionDidActive<br>
sessionWillPassivated<br></td></tr><tr><td width="20%">zapis, zmiana i usuwanie atrybutów sesji</td><td bgcolor="#ffffff" width="20%">HttpSessionBindingEvent</td><td>HttpSessionAttributeListener</td><td>attributeAdded<br>
attributeRemoved<br>


attributeReplaced<br></td></tr><tr><td width="20%">zmiana dowi¹zania obiektu do sesji</td><td width="20%">HttpSessionBindingEvent</td><td>HttpSessionBindingListener</td><td>valueBound<br>
valueUnbound<br></td></tr></tbody>
  </table>
<br>
  <ol>
    <li>wszystkie metody reaguj¹ce na inicjacjê (kontekstu, zlecenia, sesji)
otrzymuj¹ sterowanie po inicjacji; wszystkie metody reaguj¹ce na deaktywacjê&nbsp;(kontekstu,
zlecenia, sesji) otrzymuj¹ sterowanie <b>tu¿ przed </b>deaktywacj¹,</li><li>aktywacja/deaktywacja sesji oznacza
 przesuniêcie jej do innej maszyny wirtualnej lub jej serializacjê/deserializacjê.
HttpSessionActivationListener nie obs³uguje zdarzeñ tworzenia lub zamykania
sesji.<br>
    </li>

    <li>zdarzenie HttpSessionBindingEvent jest posy³ane do obs³ugi s³uchaczowi HttpSessionAttributeListener, gdy <b>jakikolwiek</b>
 atrybut sesji ulega zmianie, natomiast do obs³ugi przez obiekt implementuj¹cy
HttpSessionBindingListener gdy <b>ten w³aœnie</b> obiekt jest dowi¹zywany do sesji
(metod¹ setAttribute) lub odwi¹zywany -&nbsp; metod¹ removeAttribute()</li>
  </ol>
  <br><div class="important">W przypadku serwletów programowanie obs³ugi zdarzeñ wygl¹da zupelnie inaczej ni¿ np.&nbsp; w aplikacjach GUI. Mianowicie:<br>
  <ul>
    <li>dostarczamy definicji klas s³uchaczy (a w nich metod obs³ugi zdarzeñ), ale w naszych programach <b>nie tworzymy obiektów</b> tych klas; to zadanie pozostawiamy serwerowi podaj¹c w elemencie <i><b>listeners</b></i> pliku deskryptora wdro¿enia (web.xml) jakie klasy ma za³adowaæ i jakie obiekty stworzyæ,</li>
    <li>w naszych programach <b>nie dodajemy s³uchaczy do Ÿróde³</b> zdarzeñ
metodami addXXXLIstener; to zadanie równie¿ spe³ina serwer, bowiem dostarczone
definicje klas &nbsp;- poprzez implementacjê odpowiedniego interfejsu nas³uchu
- jednoznacznie okreœlaj¹ jakich ¿róde³ dotyczy nas³uch zdarzeñ, a przy tym
serwer dba o dynamiczne zmiany przy³¹czeñ (np. przy zmianach sesji),</li>
  </ul>
</div><br>
  <br>
Zapewnienie obs³ugi w/w zdarzeñ wymaga stworzenia klas implementuj¹cych odpowiednie
interfejsy, skompilowania ich i umieszczenia w strukturze katalogowej apliakacji
(tam gdzie klasy lub pakiety klas - czyli w WEB-INF/classes lub WEB-INF/classes/nazwa_pakietu.<br>
Wymaga tak¿e dodania do deskryptora wdro¿enia przed definicjami serwletów,
a po definicjach inicjalnych parametrów konteksu (i&nbsp; filtrów) elementu <i><b>listener</b></i>.<br>
Element ten ma postaæ:<br>
  <pre><b>    &lt;listener&gt;
        &lt;listener-class&gt;<i>[nazwa_pakietu.]nazwa_klasy_s³uchacza</i>&lt;/listener-class&gt;
    &lt;/listener&gt;
</b>
</pre>
Mo¿na równie¿ definiowaæ s³uchaczy w deskryptorze kontekstu, dodaj¹c element Listener:<br>
  <br>
  <pre><b>&lt;Context path="/jakas" ...&gt;
  ...
  &lt;Listener className="</b><b><i>[nazwa_pakietu.]nazwa_klasy_s³uchacza</i>" ... &gt;
  ...
&lt;/Context&gt;
</b></pre>
W tym elemencie mo¿na umieœciæ dodatkowe definicje w³aœciwoœci JavaBeans
(oczywiœcie klasa s³uchacza musi spe³niaæ protokó³ JavaBeans), podaj¹c nazwy
w³aœciwoœci i ich wartoœci.<br>
  <br>
Przetestujmy dzialanie s³uchaczy. Zbudujemy trzy klasy s³uchaczy: kontekstu,
strybutów kontekstu i atrybutów sesji. Przy obs³udze poszczególnych zdarzeñ
bêdziemy dodawaæ komunikaty do listy, prowadzonej w klasie Report. Wszystkie te klasy umieœcimy w pakiecie listeners.<br>
  <pre>package listeners;
import java.util.*;

public class Report {
   private static List rep = new ArrayList();

   public static void add(String s) {
     rep.add(s);
   }

   public static List get() { return rep; }
}
</pre>
  <pre>package listeners;
import javax.servlet.*;

public class TestContextListener implements ServletContextListener{


  public void contextInitialized(ServletContextEvent p0) {
     Report.add("Kontekst utworzony");
     ServletContext context = p0.getServletContext();
     context.setAttribute("Liczba", new Integer(1));
  }

  public void contextDestroyed(ServletContextEvent p0) {
  }
}
</pre>
  <pre>import javax.servlet.*;

public class TestContextAttributeListener implements ServletContextAttributeListener{

  public void attributeAdded(ServletContextAttributeEvent p0) {
    Report.add("Do kontekstu dodano atrybut " + p0.getName() +
    " = " + p0.getValue());
  }

  public void attributeRemoved(ServletContextAttributeEvent p0) {
    Report.add("Z kontekstu usuniêto atrybut " + p0.getName() +
    " = " + p0.getValue());
  }

  public void attributeReplaced(ServletContextAttributeEvent p0) {
    Report.add("W kontekœcie zmieniono atrybut " + p0.getName() +
    " = " + p0.getValue());
  }

}
</pre>
  <pre>package listeners;
import javax.servlet.http.*;

public class TestSesAttrListener implements HttpSessionAttributeListener{



  public void attributeAdded(HttpSessionBindingEvent p0) {
    Report.add("Do sesji dodany atrybut " + p0.getName() + " = " + p0.getValue());
  }

  public void attributeRemoved(HttpSessionBindingEvent p0) {
    Report.add("Z sesji usuniêty atrybut " + p0.getName() + " = " + p0.getValue());
  }

  public void attributeReplaced(HttpSessionBindingEvent p0) {
    Report.add("Zmieniony sesji atrybut " + p0.getName() + " = " + p0.getValue());
  }
}
</pre>
Zauwa¿my, ¿e od przekazanych zdarzeñ, za pomoca metod ich klas uzyskujemy niezbêdne informacje:<br>
  <ul>
    <li>getServletContext() z klasy ServletContextEvent zwraca kontekst aplikacji,</li>
    <li>getName() i getValue() z klas ServletContextAttributeEvent i HttpSessionBindingEvent
zwracaj¹ nazwê i wartoœæ atrybutu, którego dotyczy zdarzenie.</li>
  </ul>
Aby klasy s³uchaczy zosta³y za³adowane, ich obiekty utworzone i powi¹zane
z w³¹œciwymi Ÿród³ami w pliku web.xml umieszczamy odpowiednie&nbsp; elementy listener
(podelementy elementuw web-app)<br>
  <br>
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-app_2_4.xsd"&gt;

    &lt;display-name&gt;Adds&lt;/display-name&gt;
    &lt;description&gt;Dodatkowi s³uchacze&lt;/description&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestContextListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestContextAttributeListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestSesAttrListener&lt;/listener-class&gt;
    &lt;/listener&gt;


    &lt;servlet&gt;
       &lt;servlet-name&gt;ListenersTest&lt;/servlet-name&gt;
       &lt;description&gt;&lt;/description&gt;
       &lt;servlet-class&gt;ListenersTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ListenersTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/listen&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre>
Zdefiniowany w deskryptorze serwlet ListenersTest s³u¿y do testowania w/w
s³uchaczy (jego kod zobaczymy za chwilê). Oprócz testowania dzia³ania wy¿ej
wymienionych s³uchaczy zilustrujemy te¿ ciekaw¹ w³aœciwoœæ: obiekty klas
implementuj¹cych interfejs HttpSessionBindingListener uzyskuj¹ swoist¹ samowiedzê
o tym kiedy s¹&nbsp; ustalane jako atrybuty sesji i kiedy s¹ - jako atrybuty -
z sesji usuwane. Takie "œwiadome" obiekty staj¹ siê s³uchaczami w³asnego
losu (jako atrybutów sesji).<br>
Dla przykladu dostarczymy nastêpuj¹cej klasy (równie¿ w pakiecie listeners). <br>
  <pre>package listeners;
import javax.servlet.http.*;

public class SwiadomyAtrybut  implements HttpSessionBindingListener{

  private String val;

  public SwiadomyAtrybut(String val) {
    this.val = val;
  }


  public void valueBound(HttpSessionBindingEvent p0) {
    Report.add("Jestem \"œwiadomym\" atrybutem " +
         p0.getName() + " i wiem, ¿e w³asnie zosta³em dodany do sesji");
  }

  public void valueUnbound(HttpSessionBindingEvent p0) {
    Report.add("Jestem \"œwiadomym\" atrybutem " +
         p0.getName() + " i wiem, ¿e w³asnie zosta³em usuniêty z sesji");

  }

  public String toString() { return val; }
}
</pre>
Obiekt klasy SwiadomyAtrybut bêdzie dopisywa³ do listy raportowej &nbsp;(klasa
Report) komunikaty o tym, ¿e zosta³ ustalony jako atrybut sesji (gdy wyst¹pi
takie zdarzenie), jak równie¿ informacjê o swoim usuniêciu z atrybutów sesji.<br>
  <br>
Serwlet testuj¹cy w³¹cza formularz (zapisany w pliku html) za pomoc¹ ktorego, bêdziemy mogli wykonywaæ nastêpuj¹ce dzia³ania:<br>
  <ul>
    <li>ustalenie atrybutu do sesji.</li>
    <li>usuniêcie atrybutu z sesji,</li>
    <li>ustalenie obiektu klasy SwiadomyAtrybut jakio atrybutu sesji,</li>
    <li>usuniecie go z zestawu atrybutów sesji,</li>
    <li>zmianê atrybutu kontekstu (ma ona nazwê "Liczba", jest ustalony na
1 przy tworzeniu kontekstu przez s³uchacza kontekstu, po czym ka¿dy wybór
opcji "zmiana atrybutu" powoduje zwiêkszenie tej liczby o 1).</li>
  </ul>
Na szybko sporz¹dzony formularz wygl¹da nastêpuj¹co:<br>
  <pre>&lt;form&gt;
&lt;p&gt;&lt;input type="submit" name="setsesatt1" value="Normalny atrybut sesji (set)" style="background: white"&gt;
&lt;p&gt;&lt;input type="submit" name="remsesatt1" value="Usu½ normalny atrybut sesji " style="background: white"&gt;
&lt;p&gt;&lt;input type="submit" name="setsesatt2" value="îwiadomy atrybut sesji (set)" style="background: white"&gt;
&lt;p&gt;&lt;input type="submit" name="remsesatt2" value="Usu½ wiadomy atrybut sesji" style="background: white"&gt;
&lt;p&gt;&lt;input type="submit" name="chgatt" value="Zmien atrybut kontekstu" style="background: white"&gt;
&lt;/form&gt;
</pre>
&nbsp;a jego w³¹czenie (za pomoc¹ include z klasy RequestDispatcher) wyœwietli:<br>
  <br>
<img src="images/Listeners1.jpg" alt="r" height="443" width="410">
<br>
  <br><br>
Kod sewletu testuj¹cego wygl¹da nastêpuj¹co:<br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import listeners.Report;
import listeners.SwiadomyAtrybut;

public class ListenersTest extends HttpServlet {

  static int count = 0;  // dla zmian "Liczby" - atrybutu kontekstu


  SwiadomyAtrybut sa = new SwiadomyAtrybut(
                       "jestem atrybutem, co wie kiedy go dodaj¹ lub usuwaj¹"
                       );


  public void init() {
    Report.add("Inicjacja serwletu");
  }

  public void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
      resp.setContentType("text/html; charset=windows-1250");
      PrintWriter out = resp.getWriter();
      out.println("&lt;center&gt;&lt;h2&gt;Testowanie s³uchaczy&lt;/h2&gt;&lt;/center&gt;");
      req.getRequestDispatcher("form.html").include(req,resp);

      HttpSession ses = req.getSession();
      if (req.getParameter("setsesatt1") != null) {
          Report.add("&lt;b&gt;&lt;i&gt;--- wybrano 'Normalny atrybut sesji (set)'&lt;/b&gt;&lt;/i&gt;");
          ses.setAttribute("atr_ses1", "jestem zwyk³ym atrybutem sesji");
      }
      else if (req.getParameter("remsesatt1") != null) {
        Report.add("&lt;b&gt;&lt;i&gt;--- wybrano 'Usuñ normalny atrybut sesji'&lt;/b&gt;&lt;/i&gt;");
          ses.removeAttribute("atr_ses1");
      }
      else if (req.getParameter("setsesatt2") != null) {
        Report.add("&lt;b&gt;&lt;i&gt;--- wybrano 'Œwiadomy atrybut sesji (set)'&lt;/b&gt;&lt;/i&gt;");
        ses.setAttribute("atr_ses2", sa);
      }
      else if (req.getParameter("remsesatt2") != null) {
        Report.add("&lt;b&gt;&lt;i&gt;--- wybrano 'Usuñ œwiadomy atrybut sesji'&lt;/b&gt;&lt;/i&gt;");
        ses.removeAttribute("atr_ses2");
      }
      else if (req.getParameter("chgatt") != null) {
        count++;
        if (count &gt; 1) {
           Report.add("&lt;b&gt;&lt;i&gt;--- wybrano 'Zmieñ atrybut kontekstu'&lt;/b&gt;&lt;/i&gt;");
           getServletContext().setAttribute("Liczba", new Integer(count));
        }
      }

      out.println("&lt;hr&gt;");
      out.println("&lt;u&gt;Co siê dzia³o ?&lt;/u&gt;");
      List list = Report.get();
      out.println("&lt;ol&gt;");
      for (Iterator it = list.iterator(); it.hasNext(); ) {
        out.println("&lt;li&gt;" + it.next() + "&lt;/li&gt;");
      }
      out.println("&lt;/ol&gt;");
      out.close();
  }
}
</pre>
Gdy serwer tworzy obiekt-serwlet tworzony jest jednoczeœnie obiekt SwiadomyAtrybut (bo zapisaliœmy to w definicji pola <i><b>sa</b></i>
 klasy serwletu). Okazuje siê, ¿e to wystarcza (bez podawania definicji tego
s³uchacza w deskryptorze wdro¿enia) do obs³ugi przez HttpSessionBindingListener
(którym jest nasz SwiadomyAtrybut) przytrafiaj¹cych mu siê zdarzeñ HttpBindingEvent.<br>
Nasz serwlet testuj¹cy sprawdza który z przycisków w formularzu zosta³ wybrany
i odpowiednio do tego wykonuje dzia³ania (dodanie atrybutu, usuniêcie, zmiana).
Dzia³ania zapisuje na liœcie klasy Report, ale rownie¿ na te dzia³ania reaguj¹
odpowiedni s³uchacze (dopisuj¹c swoje informacje do listy). Obs³uga ka¿dego
zlecenia koñczy siê wyprowadzeniem &nbsp;listy z klasy Report (zawierajacej kumulaj¹ce
sie informacje o tym co do tej pory sie dzia³o).&nbsp; <br>
  <br>
Oto przyk³adowy wynik - czeœæ wygenerowanej strony HTML, znajduj¹ca siiê po formularzu.<br>
  <br>
<br>
  <u>Co siê dzia³o ?</u>
  <br><ol>
<li>Kontekst utworzony</li><li>Do kontekstu dodano atrybut Liczba = 1</li><li>Inicjacja serwletu</li><li><b><i>--- wybrano 'Normalny atrybut sesji (set)'</i></b></li><li>Do sesji dodany atrybut atr_ses1 = jestem zwyk³ym atrybutem sesji</li><li><b><i>--- wybrano 'Œwiadomy atrybut sesji (set)'</i></b></li><li>Jestem "œwiadomym" atrybutem atr_ses2 i wiem, ¿e w³asnie zosta³em dodany do sesji</li><li>Do sesji do
dany atrybut atr_ses2 = jestem atrybutem, co wie kiedy go dodaj¹ lub usuwaj¹</li><li><b><i>--- wybrano 'Usuñ normalny atrybut sesji'</i></b></li><li>Z sesji usuniêty atrybut atr_ses1 = jestem zwyk³ym atrybutem sesji</li><li><b><i>--- wybrano 'Usuñ œwiadomy atrybut sesji'</i></b></li><li>Jestem "œwiadomym" atrybutem atr_ses2 i wiem, ¿e w³asnie zosta³em usuniêty z sesji</li><li>Z sesji usuniêty atrybut atr_ses2 = jestem atrybutem, co wie kiedy go dodaj¹ lub usuwaj¹</li><li><b><i>--- wybrano 'Zmieñ atrybut kon
tekstu'</i></b></li><li>W kontekœcie zmieniono atrybut Liczba = 1</li><li><b><i>--- wybrano 'Zmieñ atrybut kontekstu'</i></b></li><li>W kontekœcie zmieniono atrybut Liczba = 2</li>
  </ol>
<br>Komunikaty 1 i 2 pochodz¹ od s³uchacza kontekstu i sluchacza atrybutów kontekstu (odpowiednio).<br>
Komunikat 3 zapisa³a metoda init() serwletu.<br>
Komunikat 5 i 10 wygenerowal s³uchacz atrybutów sesji na skutek naszych manipulacji "normalnym atrybutem" sesji.<br>
Komunikaty 7 i 12 pochodz¹ od naszego SwiadomegoAtrybutu, który tutaj zadzia³a³
jako s³uchacz HttpSessionBindingListener, obs³uguj¹cy zdarzenie ustalenia/usuniêcia
samego siebie jako atrybutu sesji.<br>
Komunikaty 8 i 13 powsta³y na skutek tych samych zdarzeñ co 7 i 12 odpowiednio.
W tym przypadku na ustalenie i usuniêcie atrybutu SwiadomyAtrybut sa zareagowaw³
HttpSessionAttributeListener.<br>
Wreszcie ostatnie komunikaty pokazuj¹ reakcje ServletContextAttributeListenera na zmiany wartoœci atrybutu "Liczba".<br>
  <br>
Zastosowania sewrletowych s³uchaczy mog¹ byæ bardzo ró¿norodne. Zapewne do
najczêstszych&nbsp; nale¿y wykonanie pewnych dzialañ inicjacyjnych (np. uzyskania
¿rod³a danych skojarzonego z baz¹ danych) na starcie ca³ej aplikacji (czyli
przy tworzeniu kontekstu) i uporz¹dkowanie œrodowiska (zwolnienie jakichœ
zasobow) na zakoñczenie jej&nbsp; pracyi. Zwrócmy uwagê, ¿e w œwiecie serwletów
bez s³uchaczy i w œrodowiskach dostêpnych poprzez wiele serwletów naraz takie
dzialania inicjacyjne musia³yby byæ duplikowane w czêœci inicajacyjnej&nbsp; ka¿dego
z serwletów (z dodatkow¹ logik¹ sprawdzaj¹c¹ czy nie zosta³y ju¿ wykonane
przez inny serwlet), a dla dzia³añ porz¹dkuj¹cych nie ma sensownej alternatywy
(bo nie wiadomo który z równolegle dzia³aj¹cych serwletów ostatni skoñczy
pracê).<br>
  <br>
Java Servlet API dostarcza jeszcze jednego mocnego narzêdzia uelastyczniania i upraszczania WEB-aplikacji - <b>filtrów</b>.<br>
  <br>
<div class="def"><b>Filtr</b> jest obiektem, który mo¿e modyfikowaæ zlecenia kierowane do
komponentów WEB, &nbsp;blokowaæ je lub przekierowywaæ, modyfikowaæ odpowiedzi
posy³ane prtzez kompoennty WEB do klientów. Stanowi dodatkow¹ fiunkcjonalnoœæ,
która mo¿e byæ przy³¹czona do dowolnego WEB-komponentu, ale jest od konkretnych
komponentów niezale¿na i mo¿e byæ konfigurowana dla wybranych lub wszystkich
komponentów aplikacji</div><br>
  <br>
Typowe zastosowania filtrów to: kompresje, szyfrowanie, kodowanie, konwersje obrazów, analiza sk³adniowa.<br>
  <br>
Filtry programujemy jako klasy implementuj¹ce interfejs <b>Filter</b>, dostarczaj¹c definicji trzech metod:<br>
  <ul>
    <li><b>doFilter</b> - w której wykonujemy dzia³ania zwi¹zane z analiz¹
zlecenia i ew. jego blokowaniem lub modyfikacj¹ (w szcególnoœci nag³ówków),&nbsp;
a tak¿e ew. modyfikacji odpowiedzi generowanych przez WEB-komponenty, do
których zlecenie jest kierowane,</li>
    <li><b>init</b> - która jest wolana zaraz po utworzeniu obiektu-filtra i m.in. pozwala pobraæ inicjalne parametry dla filtra</li>
    <li><b>destroy</b> - wo³ana przed usuniêciem filtra, pozwla na wykonanie prac porz¹dkowych (np. zwolnienie zasobów alokowanych przez filtr)</li>
  </ul>
  <br>
Metoda <b>doFilter</b> ma trzy parametry:<br>
  <ul>
    <li>obiekt-zlecenie (ServletRequest)</li>
    <li>obiekt-odpowied¿ (ServletResponse)</li>
    <li>³añcuch filtrów (FilterChain)</li>
  </ul>

Có¿ to jest ten ³añcuch filtrów? Otó¿ z komponentem-WEB mo¿e byæ skojarzone
wiele filtrów. Zlecenie do takiego komponentu przechodzi wtedy przez kolejne
filtry, stanowi¹ce w³aœnie ³añcuch filtrów. Na koñcu tego ³añcucha znajduje
siê komponent, do którego kierowano zlecenie.<br>

£añcuch filtrów jest obiektem klasy implementuj¹cej interfejs FilterChain.
Jego metoda doFilter() s³u¿y do wywo³ania kolejnego elementu ³añcucha.<br>
<br>
Pokazuje to poni¿szy rysunek<br>
  <img style="border: 1px solid ; width: 100%; height: 290px;" src="images/Filtrowanie.jpg" alt="r">
&nbsp;
  <br>
  <br><br>
  <br>

  <div class="syntax"><br>
  <br>
<div align="center">Typowa implementacja metody filtrowania w klasie filtra <br>
(kolejne kroki)</div><br>
  <br>
&nbsp;&nbsp;&nbsp; <b>doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)</b><br>
  <br>
  <ol>
    <li>Analiza zlecenie req.</li>
    <li>Opcjonalnie: opakowanie zlecenia we w³asn¹ implementacjê interfejsu
ServletRequest (zwykle klasê dziedzicz¹c¹ HttpServletRequestWrapper) i modyfikacja
jego nag³ówków i/lub treœci.</li>
    <li>Opcjonalnie: opakowanie odpowiedzi we w³asn¹ implementacjê interfejsu ServletResponse
(zwykle klasê dziedzicz¹c¹ HttpServletResponseWrapper) i modyfikacja jej
nag³ówków i/lub treœci.</li>
    <li>Albo wywo³anie nastêpnego elementu ³añcucha filtrów&nbsp; (chain.doFilter()), </li>
    <li>Albo zablokowanie/przekierowanie zlecenia (nie wywo³ujemy metody chain.doFilter()</li>
  </ol>
</div><br>
  <br>
Zbudujmy przyk³adowy filtr. Jego zadaniem bêdzie dodanie na pocz¹tku ka¿dej
odpowiedzi "paska reklamowego" - og³oszenia. Przy obs³udze ka¿dego zlecenia
og³oszenia maj¹ sie zmieniaæ. Zestaw og³oszeñ jest czytany z pliku. Równie¿
kodowania jest ustalane na podstawie "locale" zlecania, traktowanego jako
klucz w tablicy kodowañ, ³adowanych z pliku do obiektu klasy Properties.<br>
  <br>
  <pre>package filters;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

public class TestFilter implements Filter{

  private static int ind = 0;  // indeks og³oszenia

  // szablon og³oszenia
  private String szablon =
  "&lt;table cellpadding=\"2\" cellspacing=\"2\" border=\"1\" width=\"100%\"&gt;"+
  "&lt;tbody&gt;&lt;tr&gt;&lt;td valign=\"Top\" bgcolor=\"#000099\"&gt;" +
  "&lt;div align=\"Center\"&gt;&lt;font color=\"#ffffff\"&gt;@&lt;/font&gt;&lt;/div&gt;&lt;/td&gt;"+
  "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;";

  // Lista og³oszeñ
  private List oglosz = new  ArrayList();

  // Tablica kodowañ dla ró¿nych "locale"
  private Properties encodings = new Properties();

  public void init(FilterConfig fc) throws ServletException {

    ServletContext sc = fc.getServletContext();

    // Strumieñ dla tablicy kodowañ
    InputStream props = sc.getResourceAsStream("WEB-INF/encodings.properties");
    try {
      // za³adowanie tablicy kodowañ
      if (props != null) encodings.load(props);

      // Plik z og³oszeniami
      InputStream is = sc.getResourceAsStream("WEB-INF/ogloszenia.txt");
      BufferedReader br = new BufferedReader(
                          new InputStreamReader(is)
                          );
      String line;
      while ((line = br.readLine()) != null) oglosz.add(line);
      br.close();
    } catch (Exception exc) { oglosz.add("Witamy!"); }
  }


  public void doFilter(ServletRequest req, ServletResponse resp,
                       FilterChain chain)
                       throws IOException,ServletException
  {
    // Ustalenie kolejnego og³oszenia
    String msg;
    synchronized(this) {
      msg = szablon.replaceFirst("@", (String) oglosz.get(ind));
      if (ind &lt; oglosz.size() - 1) ind++;
      else ind = 0;
    }

    // Ustalenie kodowania
    Locale locale =  req.getLocale();
    String charset = (String) encodings.get(locale);
    if (charset == null) charset = "windows-1250";
    resp.setContentType("text/html; charset=" + charset);

    // Generacja pocz¹tku strony
    PrintWriter out = ((HttpServletResponse) resp).getWriter();
    out.println(msg);

    // Wywo³anie nastêpnego elementu FilterChain
    // zwykle ju¿ bezpoœrednio serwletu

    chain.doFilter(req, resp);
  }

  public void destroy() {

  }
}
</pre>
Uwagi:<br>
  <ul>
    <li>od FilterConfig (parametr metody init()) mo¿na pobraæ kontekst apliakacji
i za jego pomoc¹ uzyskaæ dostêp do zasobow (jak to robimy w powy¿szym programie)
lub np. ystaliæ jakieœ atrybuty kontekstu - do wykorzystania przez inne filtry
lub serwlety w ³añcuchu,</li>
    <li>programuj¹c filtry musimy pamiêtac o synchronizacji; tak samo jak
serwlety dostêp do obiektów-filtrów mo¿e mieæ równoczeœnie wiele w¹tków (w
naszym przyk³¹dzie synchronizujemy podstawienie og³oszenia do szablonu oraz
zmianê indeksu og³oszenia).</li>
  </ul>
  Skompiliwan¹ klasê umieœcimy w pakiecie filters (i w podkatalogu katalogu classes o tej samej nazwie).<br>
  <br>
Trzeba jeszcze zapewniæ by klasa filtru by³a ³adowana i zwi¹zaæ filtr z kompenentem
lub komponentami WEB. Do tego s³u¿¹ elementy filter i filter-mapping deskryptora
wdro¿enia aplikacji.<br>
Element <b>filter</b> dostarcza definicji klasy filtra, kojarzy tê klasê
z nazw¹ filtra. Ustalenie do jakich komponentów WEB odnosi siê dany filtr
uzyskujemy poprzez kojarzenie odwo³añ z nazw¹ filtra&nbsp; (praktycznmie takie
samo jak dla serwletów) w elemencie <b>filter-mapping</b>.<br>
  <br>
Nasz¹ klasê TestFilter zdefiniujemy jako filtr w nastêpuj¹cy sposób:<br>
  <br>
  <pre>    &lt;filter&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;filters.TestFilter&lt;/filter-class&gt;
    &lt;/filter&gt;

</pre>
Nastêpnie powinniœmy pwoiedzieæ jakich kompoentów dotyczy filtrowanie. Mo¿emy
specyfikowaæ konkretne odwo³ania do konkretnego serwletu lub strony JSP,
grup serwletów lub stron itp. Np. jeœli chcemy, by fiktowanie dotyczy³o serwletu,
który wywo³ujemy za pomoc¹ odniesienia go, napiszemy:<br>
  <br>
  <pre>    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/go&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</pre>
Mo¿emy dodaæ dowoln¹ liczbê mapowañ, np. oprócz serwletu go, równie¿ interakcja z serwletem run ma podlegaæ filtrowaniu:<br>
  <pre>    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/go&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/run&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</pre>
  <br>
Oczywiœcie, mo¿emy te¿ stosowaæ "widlcards" i np. w nazej testowej apliakcji
powiemy, ¿e nasz filtr ma byæ stosowany wobec wszystkicj jej komponentów
(czyli dowolnego do niej odwo³ania:<br>
  <br>
  <pre>    &lt;filter&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;filters.TestFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

</pre>
  <br>
Ogólnie, wiele filtrów mo¿e byæ stosowane wobec danego komponentu, i wiele
komponentów mo¿e byæ skojarzone z tym samym filtrem. Pokazuje to rysunek,
na którym literami F oznaczono filtry, a S - serwlety lub inne aktywne komponenty
WEB.<br>
  <br>
  <img style="border: 1px solid ; width: 403px; height: 300px;" src="images/filtry.gif" alt="r">
  <br>
  <br><br>
Wa¿ne jest te¿ umiejscowienie elementów zwi¹zanych z filtrami w deskryptorze wdro¿enia.<br>
  <br>
<div class="important">Elementy filter, a po nich elementy filter-mapping musz¹ wystêpowaæ po
elemantach context-param i przed elementami listener (które z kolei poprzedzaj¹
definicje serwletów)</div><br>
  <br>
Zatem, jeœli nasza aplikacja sk³ada siê ze znanychnam ju¿ serwletów Cookies
oraz ListenersTest (oraz s³uchaczy, o których mówiliœmy poprzednio), to dodaj¹c
do niej testowy filtr deskryptor wdro¿enia zapiszamy w nastêpuj¹cy sposób.<br>
  <br>
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-app_2_4.xsd"&gt;

    &lt;display-name&gt;Adds&lt;/display-name&gt;
    &lt;description&gt;Dodatkowe&lt;/description&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;filters.TestFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestContextListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestContextAttributeListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestSessionListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;listeners.TestSesAttrListener&lt;/listener-class&gt;
    &lt;/listener&gt;



    &lt;servlet&gt;
       &lt;servlet-name&gt;CookieAndSess&lt;/servlet-name&gt;
       &lt;description&gt;&lt;/description&gt;
       &lt;servlet-class&gt;CookieAndSess&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;CookieAndSess&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/cook&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
       &lt;servlet-name&gt;ListenersTest&lt;/servlet-name&gt;
       &lt;description&gt;&lt;/description&gt;
       &lt;servlet-class&gt;ListenersTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ListenersTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/listen&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre>
  <br>
I w tym momencie uzyskujemy efekt, który inaczej wynaga³by modyfikacji ka¿dego
z serwletów naszaj aplikacji. Dziêki za³o¿onemu filtrowi, odwo³anie do ka¿dego
z serwletów (bez zmiany jego kodu) bêdzie powodow¹³o dodanie na pocz¹tku
strony-odpowiedzi "paska og³oszenia",<br>
  <br>
Gdy zawo³amy znany nam ju¿, stary, niezmieniony test s³uchaczy w przegl¹darce
pojawi siê taki obrazek (kolejne odwo³ania bêd¹ zmieniaæ treœæ paska og³oszeñ).<br>
<br>
  <img style="width: 680px; height: 430px;" src="images/filtersRun1.jpg" alt="r">
  <br>
  <br>
  <br>
A kiedy wywo³amy testowanie cookies (kod taki sam jak by³), to równie¿ pojawi
siê pasek "reklamowy" (z kolejnym wybranym z zestawu og³oszeniem).<br>
  <br>
  <img style="width: 680px; height: 247px;" src="images/filtersRun2.jpg" alt="r">
  <br>
  <br>
<br>
Zauwa¿my, ¿e uda³o nam siê zmodyfikowaæ odpowiedŸ wysy³an¹ przez serwlety
tylko dlatego, ¿e nie zosta³a ona jeszcze zatwierdzona (committed). Innymi
s³owy mogliœmy coœ dodaæ na pocz¹tku odpowiedzi i nie zatwierdaj¹c jej (nie
zamykaj¹c strumienia wyjœciowego, nie wymiataj¹c buforów) przekazaæ zlecenie
do obs³ugi dalej umo¿liwiaj¹c serwletom dopisanie dalszego ci¹gu odpowiedzi.<br>
Je¿eli jednak chcemy w filtrze zmodyfikowac odpowiedŸ otrzyman¹ od serwletu,
to natrafimy na problem: odpowiedŸ (normalnie) jest ju¿ zatwierdzona, zatem
nie mo¿emy jej zmieniæ ani nic do niej dopisaæ. Co zrobiæ w takiej sytuyacji?<br>
  <br>
Rozwi¹zanie jest niezwykle prosta: nale¿y przekazaæ dalej (po ³añcuchu filtrów i w koñcu<br>
 do serwletu) nie oryginalny obiekt typu ServletResponse (w szczególnoœci,
gdy pos³ugujemy siê protoko³em HTTP - HttpServletResponse), ale obiekt w³asnej
klasy implementuj¹cej ten interfejs. W naszym obiekcie za strumienie wyjœciowe
podstawimy w³asne strumienie, które póŸniej bêdziemy mogli odczytac , zmodyfikiwac
ich zawartoœc i zwróciæ wo³aj¹cemu nas elementowi (innemu filtrowi czy te¿
kontenerowi serwletów) jako odpowiedŸ.<br>
  <br>
Implementacja interfejsu HttpServletResponse od podstaw by³aby uci¹¿liwa.
Dostarczona w pakiecie javax.servlet.http klasa HttpSevletResponseWrapper
implmentuje ten interfejs i bardzo u³atwia nam zadanie.<br>
  <br>
Zatem klasa naszej odpowiedzi powinna:<br>
  <ul>
    <li>odziedziczyæ HttpServletResponseWrapper,</li>
    <li>w konstruktorze z argumentem HttpServletResponse wyow³aæ konstruktor nadklasy przekazuj¹ ten argument (oryginaln¹ odpowiedŸ),</li>
    <li>przedefiniowaæ te metody klasy, dla których chcemy dostarczyæ w³asnej
funkcjonalnoœci, w szczeglnoœci np. podmiany strumienia do którego maj¹ pisaæ
swoj¹ odpowiedŸ serwlety na nasz w³asny strumieñ, który w filtrze bêdziemy
mogli odczytaæ i dzieki temu zmodyfikowaæ treœæ odpowiedzi przekazywanej
dalej, z powrotem po ³¹ñcuchu filtrów. </li>
  </ul>
Dla przyk³adu, stwórzmy filtr, który "za³o¿ony" na wszystkie komponenty aplikacji
dopisuje do ka¿dej ich odpowiedzi stopkê z jak¹œ informacj¹ (np. aktualn¹
dat¹ i czasem)&nbsp; <br>
  <br>
Jako obiekt w którym umieszczona ma byæ odowiedŸ (HttpServletResponse) bêdziemy
podsuwaæ serwletom obiekt naszej w³asnej klasy StringResponseWrapper.<br>
  <br>
Klasa ta wygl¹da w nastêpuj¹cy sposób:<br>
  <pre>package filters;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;


public class StringResponseWrapper extends HttpServletResponseWrapper {

  // Strumien do którego bêd¹ pisane odpowiedzi
  private StringWriter stringWriter = null;

  public StringResponseWrapper(HttpServletResponse response) {
    super(response);
  }

  // Przedefiniowanie metody getWriter()
  // ka¿dy kto ejj u¿yje - otrzyma nasz strumieñ StringWriter
  // i nic o tym nie wiedz¹c bêdzie pisa³ do niego
  // a nie do strumienia
  // zwi¹zanego z oryginalnym obiektem HttpServletResponse


  public PrintWriter getWriter() throws IOException {
    if (stringWriter == null) stringWriter = new StringWriter();
    return new PrintWriter(stringWriter);
  }

  // Nie jesteœmy przygotowani na obs³ugê strumieni binarnych
  // - wykluczamy ich zastosowanie (chocia¿ nie musimy tego robiæ)

  public ServletOutputStream getOutputStream() throws IOException {
    throw new IllegalStateException(
      "getOutputStream() not allowed for StringResponseWrapper"
      );
  }

  // Nasza w³asna metoda, pozwlaj¹ca uzyskaæ dostêp do strumioenia
  // i do jego zawartoœci

  public StringWriter getStringWriter() {
    return stringWriter;
  }

}
</pre>
Komentarze w kodzie szczehó³owo wyjaœniaj¹ jego dzia³anie. Zwróæmy jeszcze
tylko uwagê, ¿e tworzymy strumieñ wyjœciowy "w sposób leniew" - czyli tylko
wtedy, gdy naprawdê komuœ bêdzie potrzebny (gdy u¿yje metody getWriter()).<br>
  <br>
  <br>
Pokazan¹ klasê wykorzystamy w filtrze generuj¹cym "stopki". Przy przekazywaniu
zlecenia po ³añcuchu zleceñ podstawimy jej obiekt jako obiekt-odpowiedŸ (ServletResponse
w metodzie chain.doFilter()):<br>
  <br>
  <pre>import javax.servlet.*;
import javax.servlet.http.*;

public class FooterFilter implements Filter{

  public void init(FilterConfig p0) throws ServletException {
  }

  public void doFilter(ServletRequest req, ServletResponse resp,
                       FilterChain chain) throws IOException,ServletException {

    Locale locale = req.getLocale();
    StringResponseWrapper newResp = new StringResponseWrapper(
                                        (HttpServletResponse) resp
                                     );
    chain.doFilter(req, newResp);
    StringWriter sw = newResp.getStringWriter();

    // Uzyskujemy treœæ wygenrowanej odpowiedzi
    String cont = sw.toString();

    // Teraz mo¿emy zrobiæ cokolwiek z odpowiedzi¹
    // tu tylko dopiszemy do niej "stopkê"

    // Bierzemy strumieñ oryginalnej odpowiedzi
    PrintWriter out = resp.getWriter();

    // Przepisujemy otrzyman¹ odpowiedŸ
    out.println(cont);

    // Dopisujemy stopkê
    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG,
                                                   DateFormat.MEDIUM,
                                                   locale);

    out.println("&lt;hr&gt;&lt;i&gt;&lt;b&gt;" + df.format(new Date()) + "&lt;/i&gt;&lt;/b&gt;");
    out.close();
  }

  public void destroy() {
  }
}
</pre>
W tym fragmencie kodu (te¿ objaœnionym przez komentarze) nale¿y zwróciæ uwage
na koniecznoœæ wykonania konwersji: konstruktor klasy HttpResponseWrapper,
a w konsekwencji i naszej klasy StringResponseWrapper, ma parametr typu HttpServletResponse.
Tymczasem metoda doFilter otrzymuje argument ogólniejszego typu ServletResponse.
Dlatego musieliœmy napisaæ: <br>
  <br>
&nbsp;&nbsp;&nbsp; new StringResponseWrapper((HttpServletResponse) resp);<br>
  <br>
  <br>
Dodamy definicjê filtra do pliku deskryptora wdro¿enia.<br>
  <br>
  <pre>    &lt;filter&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;filters.TestFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HeaderFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;FooterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;filters.FooterFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;FooterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

</pre>
Po reinstalacji aplikacji wszystkie zlecenia-odpowiedzi do wszystkich jej komponentów bêd¹ filtrowane przez <b>oba</b> filtry: generuj¹cy nag³ówek i generuj¹cy stopkê.<br>
Przyk³adowo nasz serwlet testuj¹cy s³uchaczy pojawi siê teraz w nastepuj¹cej postaci:<br>
  <br>
  <img style="width: 680px; height: 572px;" src="images/filtersRun3.jpg" alt="r">
  <br>
  <br>
  <br>
Te proste przyk³ady powinny wystarczyæ do budowy w³asnych, ró¿norodnych filtrów.<br>
Pomóc w tym mog¹ jeszcze nastêpuj¹ce uwagi:<br>
  <ul>
    <li>tak samo jak odpowiedzi, równie¿ zlecenia (HttpServletRequest) mo¿emy
w filtrach modyfikowaæ, opakowuj¹c je obiektami w³asnych klas dziedizcz¹cych
HttpServletRequestWrapper,</li>
    <li>zablokowanie dostepu przez filtr jest bardzo proste - wystarczy nie
wyow³aæ metody doFilter ³añcucha filtrów, a zamiast tego dostarczyæ jako
odpowiedzi jakiejœ strony z wyjaœneiniem dlaczego dostep jest zabroniony;
zwykle bêdzie to zale¿eæ od jakichœ warunków, które mo¿emy sprawdziæ analizuj¹c
zlecenie (np. host sk¹d prztsz³o), od identyfikacji u¿ytkownika, jakichœ
parametrów czasowych,</li>
    <li>filtry mog¹ przekierowywac zlecenia (np. tymczasowo jakieœ komponenty
s¹ wy³¹czone z pracy, zlecenia do nich mog¹ przekierowane do stron informacyjnych
lub innych komponentów zastêpczych),</li>
    <li>filtry i opakowania zleceñ i odpowiedzi&nbsp; mo¿na budowaæ w ogólniejszy
ni¿ pokazano sposób, np. uzwglêdniaj¹c inne ni¿ HTPP protoko³y (dlatego parametry
metody doFilter maj¹ ogólniejsze typy: ServletRequest i ServletResponse)
czy te¿ - oprócz strumieni znakowych - równie¿ strumienie binarne (uzyskiwane
np. w serwletach przez getOutputStream()).</li>
  </ul>
  <br>

  <a name="WebApps.10"></a><h2>
  10. Rozszerzerzenia serwletów: Java Server Pages i Java Server Faces (syntetyczna informacja)</h2>
   

Na koniec rozdzialu w bardzo skrótowej formie przedstawione zostan¹ niektóre
informacje o technologich Java Server Pages i Java Server Faces.<br>
  <br>
Jak widzieliœmy, serwlety pozwalaj¹ na&nbsp; dynamiczne generowanie stron WWW poprzez<br>
u¿ycie metod "pisz¹cych" do strumieni odpowiedzi. Czyli tworzenie prezentacji
zapisane jest jako fragmenty programu w jêzyku Java. Stwarza to - znane nam
ju¿ - problemy separacji logiki i prezentacji, a ponadto:<br>
  <ul>
    <li>wymaga znajomoœci Javy do przygotowania prezentacyjnej czesci aplikacji
(a czêsto tak¹ prezentacj¹ zajmuj¹ sie ludzie nie znaj¹cy programowania),</li>
    <li>wymaga&nbsp; rekompilacji serwletu przy zmianie sposobu prezentacji treœci.</li>
  </ul>
Technologia Java Server Pages jest - w pewnym stopniu - odpowiedzi¹ na wymienione wy¿ej problemy. <br>
  <br>
Strona JSP jest plikiem tekstowym, &nbsp;w którym mo¿na zapisaæ wraz ze zwyk³¹
statyczn¹ treœci¹ HTML równie¿ dynamiczne fragmenty za pomoc¹ znaczników
JSP (które stanowi¹ swoisty uproszczony sposób programowania logiki i zale¿nej
od niej dynamicznej treœci aplikacji).<br>
  <br>
Strona JSP jest przy jej ³adowaniu, niejako w locie, t³umaczona przez serwer
na kod odpowiedniego serwletu, po czym serwlet jest kompilowany i obs³uguje
odwo³ania do tej strony JSP. Z punktu widzenia autora strony sama strona
JSP obs³uguje zlecenia, a tekst zapisany na tej stronie (elementy JSP) opisuje
sposób obs³ugi.<br>
  <br>
Podstawowe elementy "jêzyka" JSP to:
  <ul>
    <li>dyrektywy - zapisywane w znacznikach&nbsp;&nbsp; &lt; %@&nbsp; ....&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % &gt;&nbsp;
- dotycz¹ ca³ej strony opisuj¹ sposób jej translacji i wykonania przez serwer</li>
    <li>elementy skryptowe:</li>
    <ul>
      <li>deklaracje&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; %!&nbsp; ....&nbsp;&nbsp;&nbsp;&nbsp; %&nbsp; &gt;&nbsp;
deklaracje zmiennych,obiektów i metod</li>
      <li>wyra¿enia&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;%=&nbsp; ....&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %&gt;&nbsp;
wartoœci wyra¿eñ zwracane
przez serwer (zwykle dotycz¹ informacji uzyskiwanych od kontekstu
aplikacji,
zlecenia itp., &nbsp;niejako erplikuj¹ znane nam metody klas
ServletContext, HttpRequest,
HttpSession itp.)</li>
      <li>skryplety&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;%&nbsp;&nbsp; ....&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
%&gt;&nbsp; frgamenty kodu w&nbsp; Javie</li>
    </ul>
    <li>akcje - oznaczane tagami &nbsp; &lt; jsp: ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / &gt; m.in.</li>
    <ul>
      <li>&lt;jsp:useBean... /&gt; &nbsp; &nbsp; &nbsp;- tworzenie obiektu JavaBean</li>
      <li>&lt;jsp:setProperty... /&gt; &nbsp;- ustalenie w³aœciwosci JavaBean</li>
      <li>&lt;jsp:getProperty... /&gt; &nbsp;- pobranie w³aœciwoœci JavaBean</li>
      <li>&lt;jsp:include|forward..&gt; - u¿ycie RequestDispatchera do w³¹czenia
inengo kompoenetu WEB lub przekazania sterowania do innego kompoenntu WEB</li>
    </ul>
    <li>elementy jêzyka wyra¿eñ (EL) - wyra¿enia zapisane w znacznikach ${...}-&nbsp;
pozwalaj¹ m.in. wykonywaæ obliczenia i w latwy sposób odwo³ywaæ siê do w³aœciwoœci
JavaBeans</li>
    <li>definiowane znaczniki - w³asne znaczniki, niejako w³asne rozszerzenia
jêzyka JSP, dostarczane w bibliotekach znaczników (taglibs), które wi¹¿¹
elementy-znaczniki z obiektami, które definiuj¹ i implementuj¹ ich funkcjonalnoœæ.</li>
  </ul>
Bardzo mocnym narzêdziem jest standardowa bibliteka znaczników (JSTL), która
udostêpnia standardowe znaczniki, umo¿liwiaj¹ce wykonywanie wielu u¿ytecznych
zadañ.<br>
Sk³ada sie ona z ró¿nych funkcjonalnych obszarów, w ka¿dym z których znajdziemy
standardowe znaczniki wykonuj¹ce okreœlone funkcje. Poni¿sza tabela przedstawia
te obszary i funkcje oraz standardowe prefiksy jakimi nale¿y poprzedzaæ znaczniki
na stronie JSP.
  <p class="pBody"></p>
  <div align="left"><table summary="JSTL Tags" id="wp86475" border="1"><caption><div class="pTableTitle">&nbsp;</div></caption><tbody><tr align="center"><th><div class="pCellHeading">
Obszar
</div></th><th><div class="pCellHeading">
Funkcjonalnoœæ
</div></th><th><div class="pCellHeading">
Prefiks
</div></th></tr><tr align="left"><td colspan="1" rowspan="4"><div class="pCellHeading">
Core
</div></td><td><div class="pCellBody">Operacje na zmiennych
</div></td><td colspan="1" rowspan="4"><div class="pCellBody">c</div></td></tr><tr align="left"><td><div class="pCellBody">Instrukcje steruj¹ce
</div></td></tr><tr align="left"><td><div class="pCellBody">
Zarz¹dzanie URLami&nbsp;
</div></td></tr><tr align="left"><td><div class="pCellBody">Ró¿ne
</div></td></tr><tr align="left"><td colspan="1" rowspan="3"><div class="pCellHeading">
XML
</div></td><td><div class="pCellBody">
Podstawowe przetwarzanie
</div></td><td colspan="1" rowspan="3"><div class="pCellBody">x</div></td></tr><tr align="left"><td><div class="pCellBody">
Sterowanie
</div></td></tr><tr align="left"><td><div class="pCellBody">
Transformacje
</div></td></tr><tr align="left"><td colspan="1" rowspan="3"><div class="pCellHeading">
I18n
</div></td><td><div class="pCellBody">
Locale
</div></td><td colspan="1" rowspan="3"><div class="pCellBody">fmt</div></td></tr><tr align="left"><td><div class="pCellBody">
Formatowanie komunikatow
</div></td></tr><tr align="left"><td><div class="pCellBody">Formatowanie liczb i dat
</div></td></tr><tr align="left"><td><div class="pCellHeading">
Database
</div></td><td><div class="pCellBody">
SQL
</div></td><td><div class="pCellBody">sql</div></td></tr><tr align="left"><td colspan="1" rowspan="2"><div class="pCellHeading">
Functions
</div></td><td><div class="pCellBody">
D³ugoœæ kolekcji
</div></td><td colspan="1" rowspan="2"><div class="pCellBody">fn</div></td></tr><tr align="left"><td><div class="pCellBody">Manipulacje na Stringach
</div></td></tr></tbody></table></div>
  <div class="pSmartList1"><br>
Aby u¿ywaæ znaczników JSTL na stronach JSP trzeba podaæ odniesienie do odpowiedniej
czêœci tej biblioteki w znaczniku &lt;%@ taglib&nbsp; ...&nbsp; %&gt;<br>
Te odneisienia s¹ nastêpuj¹ce:<br>
  <br>
<li>Core: http://java.sun.com/jsp/jstl/core</li></div>
  <div class="pSmartList1"><li>XML: http://java.sun.com/jsp/jstl/xml</li></div>
  <div class="pSmartList1"><li>Internationalization: http://java.sun.com/jsp/jstl/fmt</li></div>
  <div class="pSmartList1"><li>SQL: http://java.sun.com/jsp/jstl/sql</li></div>
  <div class="pSmartList1"><li>Functions: http://java.sun.com/jsp/jstl/functions</li></div>
  <p class="pBody"><br>
Np. gdy chcemy u¿yæ bazowych znaczników (Core) piszemy:</p>
  <pre class="pPreformattedRelative">&lt;%@ taglib uri="<code class="cCode">http://java.sun.com/jsp/jstl/core</code>" <br>&nbsp;&nbsp;&nbsp;&nbsp;prefix="c" %&gt;</pre>
Rozwa¿my prosty przyk³ad, które pokazuj¹ stosunkowo nowe elementy JSP czyli&nbsp;
zarówno jêzyk wyra¿eñ EL (wprowadzony w wersji JSP 2.0), jak i zastosowanie
JSTL oraz wlasnej (niestandardowej) biblioteki znaczników.<br>
&nbsp;<br>
  Zbudujemy stronê JSP, która pobierze (z formularza) wprowadzony parametr
i wypisze go pod spodem. Do wypisywania informacji zastosujemy w³asny znacznik
msg.<br>
Ma on dwie w³aœciwosci: pre (napis przed w³aœciwym komnikatem) oraz info (komunikat), a jego definicja wygl¹da tak:<br>
  <pre>&lt;%--
 Znacznik wpisuj¹cy podany jako atrybut msg tekst
 poprzedzony jak¹œ (nieobowi¹zkow¹) informacj¹
--%&gt;
&lt;%@ attribute name="pre" required="false"%&gt;
&lt;%@ attribute name="info" required="true"%&gt;
&lt;h2&gt;${pre}&lt;br&gt;${info}&lt;/h2&gt;

</pre>
Jak widaæ znacznik ten po prostu wpisuje "w strone" tekst pobrany z atrybutów.<br>
Definicjê tego znacznika umieœcimy w pliku msg.tag w katalogu WEB-INF/tags.&nbsp; <br>
  <br>
Strona JSP &nbsp;wykorzysta standardowe znaczniki (ustalanie wartoœci zmiennych
oraz instrukcjê if, funkcjê, zwracaj¹c¹ d³ugoœæ napisu),&nbsp; a tak¿e i nasz
w³asny znacznik. Dlatego najpierw musimy powiedzieæ z jakich obszarów standardowych
tagów chcemy skorzystaæ i gdzie szukaæ naszych w³asnych znaczników ( a tak¿e
jakim prefiksem bêd¹ one poprzedzane).<br>
  <pre>&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %&gt;
&lt;%@ taglib tagdir="/WEB-INF/tags" prefix="m" %&gt;
</pre>
Dalsza czêœæ strony JSP tradycyjnie przeplata kod HTML z "dynamicznymi " znacznikami JSP (wszystko razem zapiszemy w pliku <b>dialog.jsp</b>).
  <pre>&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1250"&gt;
  &lt;title&gt;Test&lt;/title&gt;
&lt;/head&gt;
&lt;c:set var="fmsg" value="WprowadŸ informacjê" /&gt;
&lt;c:set var="preinfo" value="Wprowadzi³eœ:" /&gt;
&lt;h2&gt;Aplikacja testowa&lt;br&gt;${fmsg}&lt;/h2&gt;

&lt;form&gt;
&lt;input type="text" name="info" size="50"&gt;
&lt;p&gt;&lt;/p&gt;
&lt;input type="submit" value="Submit"&gt;
&lt;input type="reset" value="Reset"&gt;
&lt;/form&gt;

&lt;c:if test="${fn:length(param.info) &gt; 0}" &gt;
  &lt;m:msg pre="${preinfo}" info="${param.info}"/&gt;
&lt;/c:if&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
Komentarze:<br>
  <ul>
    <li>tagi s¹ poprzedzane prefiksami dla w³aœciwych bibliotek,</li>
    <li>set z Core JSTL ustala wartoœci zmiennych</li>
    <li>w jêzyku wyra¿eñ EL mo¿emy siê do nich odwo³ywaæ przez ${<i><b>nazwa_zmiennej</b></i>}</li>
    <li>do parametrów zlecenia odwo³ujemy siê przez <b>param.<i>nazwa_parametru</i></b>,</li>
  </ul>
Warto zwróciæ uwagê na to, ¿e ten kod JSP jest zdecydowanie krótszy od kodu
&nbsp;odpowiadaj¹cego mu serwletu. I dodatkowo nie wymaga od nas ¿adnego programowania
w Javie (trochê szkoda :-) - a w konsekwensji ¿adnych "rêcznie" przeprowadzanych
rekompilacji (nb mo¿na ³atwo siê przekonaæ o tym, ¿e serwer automatycznie
t³umaczy kody JSP na kody serwletów - wystarczy zajrzeæ do katalogo work).<br>
  <br>
Ha, to ju¿ jest ca³a nasz aplikacja WEB. Pozostaje tylko j¹ wdro¿yæ,<br>
Oczywiœcie musimy przygotowaæ deskryptor wdro¿enia. Tak naprawdê strona JSP
jest serwletem - zatem musimy zdefiniowaæ serwlet. Tym razem jednak zamiast
podelementu class-name podajemy podelement jsp-file.<br>
  <pre>  &lt;servlet&gt;
    &lt;display-name&gt;dialog&lt;/display-name&gt;
    &lt;servlet-name&gt;dialog&lt;/servlet-name&gt;
    &lt;jsp-file&gt;/dialog.jsp&lt;/jsp-file&gt;
  &lt;/servlet&gt;
</pre>
I dalej, mo¿emy dokonaæ dowolnego mapowania tej strony JSP na odwo³anie do niej.<br>
Na przyk³ad:<br>
  <pre>  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dialog&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/first&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</pre>

  Ale to nie wszystko.&nbsp; Musimy jeszcze zapewniæ odnalezienie bibliotek znaczników (jeœli ich u¿ywamy).<br>
Standardowe biblioteki znaczników (pliki jstl.jar i standard.jar) mo¿na
w Tomcacie odnaleŸæ w katalogu webapps/jsp-examples/lib. Mo¿na je
przekopiowaæ do naszego lib pod WEB-INF (bêd¹ dostêpne dla danej
aplikacji), albo umieœciæ w katalogu lib Tomcata (bêd¹ dostêpne dla
wszystkich aplikacji). <br>
A co z naszymi znacznikami? Powiedzieliœmy - u pocz¹tku strony JSP - ¿e znajd¹
siê w katalogu WEB-INF/tags. I tam powinniœmy umieœciæ plik z definicj¹ znacznika
msg.tag.<br>
  <br>
Te wszystkie czynnoœci wykona za nas Ant, jeœli tylko w zadaniu "build" dostarczymy
odpowiednich instrukcji kopiowania.&nbsp;<br>
  <br>
Jak zwykle trzeba pokazaæ efekty.<br>
Po wywo³aniu z przegl¹darki&nbsp; http://localhost:8080/jsp-test/first&nbsp;uzyskamy:<br>
  <br>
&nbsp;<img style="width: 680px; height: 430px;" src="images/Jsp1.jpg" alt="r">
  <br>
  <br>
  <br>
a po klikniêciu Submit (przy wprowadzonym napisie):<br>
  <br>
  <img style="width: 680px; height: 430px;" src="images/Jsp2.jpg" alt="r">
<br>
  <br>
  <br>
  Na koniec tego (pobie¿nego) wprowadzenia do JSP warto zwróciæ uwagê na dwa tagi z JSTL:<br>
  <ul>
    <li>c:forEach - pozwala na przebieganie tablic i &nbsp;- uwaga - dowolnych kolekcji</li>
    <li>sql:query - pozwala na posylanie kwerend do baz danych,</li>
  </ul>
(powy¿ej zastosowano standardowe prefiksy, mo¿na je zmieniæ, ale to raczej nie wskazane).<br>
  <br>
Jeœli dobrze siê przyjrzeæ, to JSP nie wnosi nic nadzwyczajnego w stosunku
do zwyk³ych serwletów (mo¿e jakieœ uproszczenia, ale kosztem opanowania zupe³nie
nowej, chcia³oby siê nawet powiedzieæ - nieco dzikiej - sk³adni).<br> Szczerze
mówi¹c, alternatywne wobec JSP, opracowane w ramach projektu Jakarta Velocity
(zob. http://jakarta.apache.org/velocity/) wydaje siê&nbsp; prostsze i bardziej
naturalne w u¿yciu.<br>
  <br>
A gdy chodzi o prostotê to na pewno mo¿emy siê z ni¹ po¿egnaæ w œrodowisku Java Server Faces. Ale tu nie chodzi o uproszczenia.<br>
Podstawow¹ koncepcj¹ jest dostarczenie uniwersalnych œrodków:<br>
  <ul>
    <li>reprezentacji komponemtów UI w sposób niezale¿ny od modeli danych</li>
    <li>obs³ugi zdarzeñ,</li>
    <li>walidacji danych po stronie serwera, </li>
    <li>konwersji danych</li>
    <li>nawigacji pomiêdzy stronami (html, jsp, serwletami),</li>
    <li>internacjoonalizacji treœci,</li>
    <li>oraz dowolnych rozszerzeñ tych funkcji,</li>
  </ul>
JSF jest bardzo mocn¹ technologi¹. Jej zalet nie dostrze¿emy na prostych przyk³adach,<br>
Wrêcz przeciwnie - najprostsze zastosowania wykazuj¹ istotne nadmiary (w
programowaniu, w definicjach deskryptorów wdro¿enia itp.).<br>
Ale - bez w¹tpienia - wiêksze, powa¿ne i (powiedzmy - prawdziwe) aplikacje WEB - skorzystaj¹ na tej technologii,<br>
Java Server Faces nie sposób omówiæ na kilku stronach. Do tego s¹ raczej ca³e ksi¹¿ki,<br>
 Zatem&nbsp; temat ten tylko sygnalizujemy - odsylaj¹c do literatury, np. ksi¹¿ki Caya Horstmanna "Core Java Faces".<br>
  <br>
  <a name="WebApps.11"></a><h2>
11. Zadania i æwiczenia</h2>
  <br>
  <ol>
    <li>Zainstalowaæ i przetestowac wszystkie apliakcje tego rozdzia³u.</li>
    <li>Napisaæ aplikacjê WEB, która po przedstawieniu tytu³ów ksi¹¿ek z
bazy ksi¹¿ek pozwala na wybór ksi¹¿ki i pokazanie szczegó³owej informacji
o niej (autor, isbn, cena). Przygotowaæ dwie wersje tej aplikacji: z wykorzystaniem
i bez wykorzystania JSP.</li>
    <li>Napisaæ apliakcjê WEB, która s³u¿y do przeprowadzania testów z jêzyka Java. U¿yæ narzêdzi bazodanowych.</li>
  </ol>

</body></html>