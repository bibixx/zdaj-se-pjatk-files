<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN"><html><head rel="stylesheet" type="text/css" href="../style/common.css">
 <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
 <meta name="GENERATOR" content="Mozilla/4.61 [en] (OS/2; I) [Netscape]"><title>Wyk³ad 2</title>
 <link rel="stylesheet" type="text/css" href="../style/common.css">
 <script type="text/javascript" language="JavaScript1.2" src="../js/dodatki.js">
  </script></head><body bgcolor="#efefef">
<div align="Center"><a name="W3"></a><a name="W2"></a><h1>2. Dynamiczna Java i programowanie komponentowe (JavaBeans)</h1></div>
<hr>
<a name="W2.1"></a><h2>2.1. Dynamiczne ³adowanie klas. </h2>
W klasie Object metoda getClass. Zastosowana wobec dowolnego obiektu
zwraca odnoœnik do jego klasy, do obiektu klasy java.lang.Class. <br><br>
Obiekty klasy Class s¹ klasami (to wa¿ne: tu same klasy s¹ obiektami) <br>
<br>
Mo¿emy wobec nich stosowaæ ró¿ne metody klasy Class z pakietu java.lang, np. <br>
<br>
getSuperClass(), <br>
getInterfaces(), <br>
newInstance(), <br>
<br>
Obiektów-klas nie mo¿emy tworzyæ za pomoc¹ konstrukcji new. <br>
Jedynie poprzez u¿ycie odpowiednich metod uzyskujemy odnoœniki do tych obiektów. <br>
<br>
Jedn¹ z takich metod jest statyczna metoda klasy Class: <br>
<br><b>
forName(String NazwaKlasy); </b><br>
<br>
Np. pisz¹c: <br>
<br>
Class c = Class.forName("javax.swing.JButton"); <br>
<br>
lub <br>
<br>
Class c = Class.forName(java.awt.Button.class); <br>
<br>
uzyskujemy deskryptor klasy przycisków i mo¿emy siê nim pos³u¿yæ przy tworzeniu obiektu: <br>
<br>
JButton b = c.newInstance(); <br>
   <br>
W statycznym przypadku, gdy wszystko jest ustalone "w Ÿródle" programu, sens
takich konstrukcji jest niewielki. Ale bardzo czêsto warto od³o¿yæ pewne
ustalenia do fazy wykonania programu, zwiêkszaj¹c jego elastycznoœæ i uniwersalnoœæ.
Wtedy dynamiczna reprezentacja obiektów-klas bardzo siê przydaje. <br>
<br>
Najprostszy przyk³ad: odroczenie ustalenia sposobu obs³ugi akcji na przycisku
do fazy wykonania programu pokazano na poni¿szym wydruku.  Jako argument
podajemy nazwê klasy, której obiekt obs³uguje akcjê. Mo¿emy mieæ wiele takich
(wariantowych) klas i bez ¿adnej rekompilacji zmieniaæ sposoby obs³ugi klikniêcia
w przycisk.<br>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

class Main extends JFrame {

static void exit(String s) { System.out.println(s); System.exit(1); }

public static void main(String args[]) {
   new Main(args[0]);
}

Main(String actionClassName) {
 Class actionClass = null;
 Action act = null;
 try {
       actionClass = Class.forName(actionClassName);
       act = (Action) actionClass.newInstance();
  } catch (Exception exc) {exit("Obiekt klasy akcji nie mo¿e byæ utworzony");}

 JButton b = new JButton();
 b.setAction(act);
 getContentPane().add(b);
 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 pack();
 show();
 }
}

</pre>
Uwaga:newInstance zwraca referencjê do obiektu klasy Object - st¹d potrzeba konwersji do typu Action.<br>
<br>
Jeœli teraz przygotujemy dwie klasy, opisuj¹ce ró¿ne akcje np.<br>
<pre>
import javax.swing.*;
import java.awt.event.*;

public class DialogAction extends AbstractAction {

  final static String ACTION_NAME = "Show msg";

   public DialogAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     JOptionPane.showMessageDialog(null, ACTION_NAME);
   }

}
</pre>
i<br>
<pre>
import javax.swing.*;
import java.awt.event.*;

public class PrintAction extends AbstractAction {

  final static String ACTION_NAME = "Print";

   public PrintAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     System.out.println("Wykonan akcja: " + ACTION_NAME);
   }

}
</pre>
to uruchomienie g³ównego programu z argumentem: DialogAction:<br>
<br>
java Main DialogAction<br>
<br>
spowoduje, ¿e przycisk w oknie uzysaka nazwê Show Msg, a jego klikniecie otworzy okienko komunikaty.<br>
<br>
Natomiast po uruchomieniu programu z argmentem PrintAction<br>
<br>
java Main PrintAction<br>
<br>
nada przyciskowi nazwê Print, a jego klikniêcie wyprowadzi komunikat na konsolê.<br>
<br>
<br>
Takie mo¿liwoœci istnia³y w Javie od zawsze. Ale samo dynamiczne ³adowanie
klas to zdecydowanie za ma³o, by mo¿na by³o tworzyæ naprawdê elastyczne programy.
Dopiero w wersji 1.1  Java zyska³a prawdziw¹ elastycznoœæ dziêki wprowadzeniu
mechanizmów refleksji<br>
<br>
<a name="W3.2"></a><a name="W2.2"></a><h2>2.2. Refleksja</h2>
Podstawowy programistyczny interfejs refleksji (<b>Core Reflection API</b>) realizowany jest przez klasy pakietu <b>java.lang.reflect</b>  oraz rozbudowan¹ klasê Class z pakietu java.lang.<br>
<br>
<div class="def"><b>Refleksja</b> oznacza mo¿liwoæ wykonywania W TRAKCIE WYKONANIA PROGRAMU nastêpuj¹cych dzia³añ:  <br>
<ul>
  <li>uzyskiwania pe³nej informacji o charakterystykach klasy (pola, metody, ich charakterystyki) </li>
  <li>dzia³añ na polach danego obiektu, poprzez ich nazwy,  </li>
  <li>aktywowanie metod na rzecz danego obiektu poprzez ich nazwy i z podaniem argumentów.</li>
</ul>
</div><br>
<br>
U¿ycie refleksji pozwala m.in. na: <br>
  <br>
<ul>
  <li>stwierdzenie jakie i z jakimi argumentami metody wystêpuj¹ w danej
klasie (np. podawanej dynamicznie w trakcie wykonania programu) </li>
  <li>dynamiczne wywo³ywanie metod (specyfikowanych w trakcie wykonania programu)
na rzecz jakiego obiektu (te¿ dynamicznie ustalanego), </li>
  <li>dynamiczne uzyskiwanie i modyfikacje wartoœci pól obiektu. </li>
</ul>
Uzywaj¹c mechanizmów refleksji do metod i pól odwo³ujemy siê poprzez ich nazwy, a nie identyfikatory. <br>
Na czym polega ró¿nica wobec statycznego przypadku? <br>
<br>
W statyce odwo³ania s¹ skonkretyzowane na etapie kompilacji. <br>
Piszemy np. b.geText(). I tak ju¿ zostanie na zawsze. <br><br>
W dynamice konstrukcja jest ca³kiem inna - w³aœnie pos³uguj¹ca siê nazw¹ metody. Piszemy raczej tak: b.wykonaj("getText"). <br><br>
<p align="Center"> Klasy pakietu java.lang.reflect</p>
<p></p>
<table border="1" cellspacing="1" width="623">
<tbody><tr><td width="14%" valign="Middle"><p align="Center">Klasa</p></td><td width="86%" valign="Middle"><p align="Center">Przeznaczenie</p></td></tr><tr><td width="14%" valign="Middle"><p>Array </p></td><td width="86%" valign="Middle"><p>Tworzenie tablic, uzyskiwa<font face="Times New Roman">nie i ustalanie wartoœci elementów</font></p></td></tr><tr><td width="14%" valign="Middle"><p>Constructor </p></td><td width="86%" valign="Middle"><p><font face="Times New Roman">Informacja i dostêp do danego konstru
ktora danej klasy. W szczególnoœci wykorzystanie dla tworzenia obiektu.</font></p></td></tr><tr><td width="14%" valign="Middle"><p>Field </p></td><td width="86%" valign="Middle"><p><font face="Times New Roman">Informacja i dostêp do pola obiektu. Pobranie i zmiana wartoœci pola.</font></p></td></tr><tr><td width="14%" valign="Middle"><p>Method </p></td><td width="86%" valign="Middle"><p>Informacja <font face="Times New Roman">o danej metodzie danej klasy. Dynamiczne wywo³anie metody na rzecz danego obiektu.
</font></p></td></tr><tr><td width="14%" valign="Middle"><p>Modifier </p></td><td width="86%" valign="Middle"><p><font face="Times New Roman">Uzyskiwanie informacji o modyfikatorach sk³adowej obiektu lub klasy.</font></p></td></tr></tbody>
</table>
<p align="Center"><br>
 <br>
U¿yteczne metody klasy java.lang.Class</p>
<p>  </p>
<table border="1" cellspacing="1" width="623">
<tbody><tr><td width="45%" valign="Middle"><p align="Center">Metoda</p></td><td width="55%" valign="Middle"><p align="Center">Przeznaczenie</p></td></tr><tr><td width="45%" valign="Middle"><p>getClasses()  </p><p>getDeclaredClasses() </p></td><td width="55%" valign="Middle"><p><font face="Times New Roman">Zwraca tablicê obiektów klasy Class, które s¹ sk³adowymi danej klasy.</font></p></td></tr><tr><td width="45%" valign="Middle"><p>getConstructors()  </p><p>getDeclaredConstructors()</p></td><td width="55%"
valign="Middle"><p><font face="Times New Roman">Zwraca tablicê obiektów klasy Constructor; s¹ to konstruktory danej klasy</font></p></td></tr><tr><td width="45%" valign="Middle"><p>getConstructor(Class[]) getDeclaredConstructor(Class[]) </p></td><td width="55%" valign="Middle"><p>Zwraca obiekt konstruktor (obiekt klasy konstruktor), który ma podane typy argumentów </p></td></tr><tr><td width="45%" valign="Middle"><p>getMethods()  </p><p>getDeclaredMethods() </p></td><td width="55%" valign="Middle"><p><font
face="Times New Roman">Zwraca tablicê, zawieraj¹c¹ odnoœniki do metod klasy. Metody s¹ obiektami klasy Method.</font></p></td></tr><tr><td width="45%" valign="Middle"><p>getMethod(String, Class[]) </p><p>getDeclaredMethod(String, Class[]) </p></td><td width="55%" valign="Middle"><p><font face="Times New Roman">Zwraca metodê o podanej nazwie i podanych argumentach jako obiekt klsy Method.</font></p></td></tr></tbody>
</table>
<font face="Times New Roman"><p>Uwaga : Rozró¿nienie pomiêdzy metodami maj¹cymi i nie maj¹cymi w nazwie tekstu "Declared" jest nastêpuj¹ce: </p></font>
<ul>
  <li><font face="Times New Roman">
    <p>
metody bez "Declared" zwracaj¹ sk³adowe tylko publiczne, ale jednoczeœnie równie¿ dziedziczone, </p>
    </font></li>
  <li><font face="Times New Roman">
    <p>
metody z "Declared" zwracaj¹ wszystkie sk³adowe (równie¿ prywatne i zabezpieczone), ale bez dziedziczonych</p>
    </font></li>
</ul>
<a name="W3.3"></a><a name="W2.3"></a><h2>2.3.  Przyk³ad wykorzystania refleksji </h2>
Napiszmy program, który daje u¿ytkownikowi wybór co do nastêpstw przyciœniêcia
jakiego przycisku. Co wiêcej, wyborów takich u¿ytkownik mo¿e dokonywaæ w
fazie wykonania programu. <br>
Zestaw mo¿liwych akcji (na przyciskach) bêdzie zawarty w klasie ActionsSet np. <br>
<br>
<pre>
class ActionsSet {
  public void Action1() { System.out.println("Action1"); }
  public void Action2() { System.out.println("Action2"); }
  public void Action3() { System.out.println("Action3"); }
  public void Action4() { System.out.println("Action4"); }
  public void Action5() { System.out.println("Action5"); }
}
</pre>
Opcje dla u¿ytkownika bêd¹ przedstawione w menu kontekstowym, otwieranym
na przycisku. Z tego menu mo¿e on wybraæ (wielokrotnie i ró¿nie w trakcie
dzia³ania programu) co konkretnie ma siê staæ, jeœli przyciœnie ten przycisk.<br>
<br>
Poni¿szy wydruk pokazuje konstrukcjê programu.<br>
<br>
<pre>
import java.lang.reflect.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class Main extends JFrame implements ActionListener, MouseListener {

  static void exit(String s) { System.out.println(s); System.exit(1); }

  Method currAction = null;   // bie¿¹ca metoda obs³ugi
  Class actionClass = null;   // klasa obs³ugi
  Object actionObject = null; // obiekt obs³ugi
  JPopupMenu popUp = null;    // menu kontekstowe z wyborem obs³ugi


Main() {
  super("Test refleksji");
  try {
    actionClass = Class.forName("ActionsSet");
    actionObject = actionClass.newInstance();
  }  catch(Exception exc) {
         exit("Wadliwa klasa obs³ugi");
  }

  JButton b = new JButton("Akcja");
  b.setFont(new Font("Dialog", Font.BOLD, 24));
  b.addActionListener(this);
  b.addMouseListener(this);
  getContentPane().setLayout(new FlowLayout());
  getContentPane().add(b);
  popUp = new JPopupMenu();
  createMenuItems();
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  pack();
  show();
}

void createMenuItems() {
  Method m[] = null;
   try {
       m = actionClass.getDeclaredMethods();
   } catch(Exception exc) {
        exit("Niedostêpna info o metodach klasy obs³ugi");
   }

  for (int i = 0; i &lt; m.length; i++) {
     String name = m[i].getName();
     JMenuItem mi = new JMenuItem(name);
     mi.addActionListener(this);
     popUp.add(mi);
  }
}


void setCurrentAction(String action) {
  Class args[] = {};
  try {
     currAction = actionClass.getMethod(action, args);
    } catch(Exception exc) { exit("Nieznana metoda obs³ugi"); }
}

public void actionPerformed(ActionEvent e) {
   Object src = e.getSource();
   if (src instanceof JMenuItem)
      setCurrentAction(((JMenuItem) src).getText());
   else {
     try {
       Object args[] = { };
       currAction.invoke(actionObject, args);  // wywo³anie metody obs³ugi
     }  catch(Exception exc) {
          JOptionPane.showMessageDialog(null, "Akcja na przycisku nieustalona!");
     }
   }
}

public void mousePressed(MouseEvent e) {
  showPopup(e);
}
public void mouseReleased(MouseEvent e) {
  showPopup(e);
}

public void mouseEntered(MouseEvent e) {}
public void mouseExited(MouseEvent e) {}
public void mouseClicked(MouseEvent e) {}

private void showPopup(MouseEvent e)  {
  if (e.isPopupTrigger()) popUp.show(e.getComponent(), e.getX(), e.getY());
}

public static void main(String args[]) { new Main(); }

}
</pre>
<br>
W programie korzystamy z klasy Method. Uzyskuj¹c odnoœnik do konkretnej metody,
mo¿emu ustaliæ j¹ jako obs³uguj¹c¹ zdarzenie (metoda setCurrentAction). Przy
zajœciu zdarzenia mo¿emy "poœrednio" (dynamicznie) wywo³aæ jego obs³ugê.
S³u¿y temu metoda invoke z klasy Method, u¿yta w actionPerformed. <br>
<br>
Dzia³anie programu ilustruje rysunek.<br>
<br>
<img src="images/Clipboard.jpg" alt="r" width="393" height="187" border="1">
<br>
<br>
Po wyborze opcji Action3 - klikniêcia w przycisk bêd¹ wyprowadzaæ na konsolê napisy "Akcja3".<br>
<br>
<br>
<u>Dwa  komentarze</u><br>
<br>
<b>Kwestia argumentów:</b> gdy okreœlaj¹ sygnaturê metody (w getMethod)  wystêpuj¹ jako typy danych, a wiêc obiekty klasy Class. <br>
Jako konkretne argumenty wywo³ania metody  s¹ konkretnymi obiektami, a wiêc
egzemplarzami klasy Object (obiekty klasy Object - w metodzie invoke). <br>
W tym programie metoda wywo³ywana poœrednio nie mia³a argumentów. <br>
<br>
<b>Sposób tworzenia menu kontekstowego</b>. prezentuje ono dostêpne akcje,
a te - ca³kowicie - s¹ opisywane poprzez klasê ActionsSet. St¹d u³atwienie
: dynamiczne pobranie akcji za pomoc¹ metody getDeclaredMethods z klasy Class.
Nawet wtedy, gdy wszystko jest umieszczone w jednym pliku i nie przewiduje
siê zmian w alternatywnych sposobach obs³ugi - to podejcie do programowania
zas³uguje na uwagê. <br>
<br>
<a name="W3.4"></a><a name="W2.4"></a><h2>2.4. Pojêcie JavaBean</h2>
<br>
<div class="def"><b>JavaBean</b> - (bean – ziarno) – to programowy komponent "wielokretnego
u¿ytku", którego w³aœciwoœci i funkcjonalnoœæ mog¹ byæ odczytywane i/lub
zmieniane uniwersalnymi œrodkami programistycznymi.</div><br>
<br>
Uwaga: JavaBean oznacza zarówno obiekt, jak i klasê tego obiektu. Rozró¿nienie
zawsze jasno wynika z kontekstu. O JavaBean bêdziemy mówiæ krócej "ziarno".<br>
<br>
Co oznacza powy¿sza definicja?<br>
Gdy wbudowujemy zewnêtrzny komponent-ziarno do naszego programu, mamy do
dyspozycji œrodki programistyczne, które pozwalaj¹ uzyskaæ o nim informacje:<br>
<br>
<ul>
  <li>jakie ma w³aœciwoœci? jakie metody s³u¿¹ do ich pobierania i ustalania? </li>
  <li>jakie obs³uguje zdarzenia? jakie zdarzenia mog¹ siê mu przytrafiaæ? </li>
  <li>jakie metody udostêpnia otoczeniu (eksportuje)? </li>
</ul>
Uniwersalnoœæ sposobów odczytywania i/lub zmieniana charakterystyk obiektu-ziarna opiera siê na:<br>
<ul>
  <li>uzgodnionym protokole. dotycz¹cym informacji o ziarnie (standardowe wzorce deklaracji metod i/lub klasy informacyjne) </li>
  <li>standardowych œrodkach pobierania informacji (introspekcja - realizowana przez klasê Introspector z pakietu java.beans) </li>
  <li>standardowych œrodkach dostosowania obiektu </li>
</ul>
<a name="W3.5"></a><a name="W2.5"></a><h2>2.5.  W³aœciwoœci i akcesory </h2>
Ziarna maj¹ w³aœciwoœci (atrybuty).<br>
<br>
<div class="def">Dostêp do w³asciwoœci zapewniaj¹ metody klasy-ziarna nazywane akcesorami..<br>
Akcesor pobieraj¹cy w³aœciwoœci nazywa siê getter, a ustalaj¹cy – setter.</div><br>
<br>
Wyró¿niamy w³asciwoœci <b>proste </b>(w tym binarne) oraz w³aœciwoœci <b>indeksowane</b>.<br>
W³aœciwoœci proste maj¹ jedn¹ wartoœæ, w³aœciwoœci indeksowane – wiele wartoœci, przedstawianych jako tablica.<br>
<br>
<div class="syntax">Standardowe wzorce deklaracji akcesorów s¹ nastêpuj¹ce<br>
<br>
Dla  prostej (niebinarnej) w³asciwoœci o nazwie NNN i typie Typ<br>
<br>
getter: Typ getNNN() <br>
setter: void  setNNN(Typ)<br>
<br>
np. dla ziarna javax.swing.JButton i w³asciwoœci background mamy <br>
getter: Color getBackground()<br>
 i setter: void setBackground(Color).<br>
<br>
Dla w³aœciwoœci binarnej o nazwie NNN:<br>
<br>
getter: boolean isNNN()<br>
setter: void setNNN(boolean)<br>
<br>
np. boolean isVisible(), setVisible(boolean)<br>
<br>
Dla w³aœciwoœci indeksowanej o nazwie NNN, której wartoœci reprezentowane s¹ jako tablice elementów typu Typ:<br>
 <br>
getter elementu:  Typ getNNN(int) // zwraca wartoœæ  podanego indeksu w³aœciwoœci<br>
setter elementu: vois setNNN(int, Typ) // ustala wartoœæ  podanego indeksu w³aœciwoœci<br>
<br>
getter tablicy: Typ[] getNNN()<br>
setter tablicy: void setNNN(Typ[])<br>
</div><br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>zwi¹zane (bounded)</b>. <br>
<br>
O zmianie zwi¹zanej w³aœciwoœci ziarna mog¹ byæ zawiadamiane inne komponenty i reagowaæ na tê zmianê. <br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>ograniczane (constrained)</b>.<br>
Ograniczana w³aœciwoœæ – to taka, o której zmianie powiadamiane s¹ zainteresowane
inne komponenty i s¹ pytane o zgodê na tê zmianê. Jeœli którykolwiek z komponentów
nie da takiej zgody (zawetuje zmianê)  – zmiana nie dochodzi do skutku.<br>
<br>
Setter zwi¹zanej i/lub ograniczanej w³aœciwoœci ma obowi¹zek wygenerowaæ zdarzenie klasy <b>PropertyChangeEvent</b>..<br>
<br>
Klasy-ziarna , maj¹ce zwi¹zane w³aœciwoœci mus¿¹ dostarczyæ metody przy³¹czania s³uchaczy zmian w³aœciwoœci: <b>addPropertyChangeListener(PropertyChangeListener)</b><br>
<br>
Klasy-ziarna, maj¹ce ograniczane w³aœciwoœci, musz¹ dostarczyæ  metody <b>addVetoableChangeListener(VetoableChangeListener)</b>.<br>
<br>
Ziarna mo¿emy wykorzystywaæ, mo¿emy te¿ je tworzyæ (w znaczeniu: definiowaæ klasê ziarna)<br>
<br>
Tworzenie ziarna (jako klasy) wymaga zdefiniowania klasy,  która:<br>
<ul>
  <li>stosuje ogólnie przyjête wzorce sygnatur metod  i/lub uzupe³niona jest
przez dodatkow¹ specjaln¹ klasê opisuj¹c¹ "niestandardowe" informacje o ziarnie
(implementacja interfejsu BeanInfo) </li>
  <li>zapewnia serializacjê obiektów</li>
  <li>zawiera konstruktor bezparametrowy </li>
  <li>uzwglêdnia dzia³ania w œrodowisku wielow¹tkowym (do obiektu klasy mo¿e równoczeœnie odwo³ywaæ siê kilka w¹tków) </li>
</ul>
<a name="W3.6"></a><a name="W2.6"></a><h2>2.6.  Nas³uch i wetowanie zmian w³aœciwosci</h2>
Zmiana w³aœciwoœci zwi¹zanej lub ograniczanej powinna generowaæ zdarzenie typu <b>PropertyChangeEvent</b>.<br>
<br>
Komponenty (obiekty) zainteresowane w œledzeniu zmian  tej w³asciwoœci  musz¹ implementowaæ interfejs <b>PropertyChangeListener</b>.  W ten sposób staj¹ siê s³uchaczami zmian w³aœciwoœci.. <br>
Komponenty, które mog¹ wetowaæ zmiany w³aœciwoœci musz¹ implementowaæ interfejs <b>VetoableChangeListener</b> (bêd¹ wiêc s³uchaczami zmian w³aœciwoœci ograniczonych i bêdê mia³y mo¿liwoœæ wetowania tych zmian).<br>
<br>
Zdarzenie typu PropertChangeEvent mo¿emy zapytaæ o:<br>
<ul>
  <li>nazwê w³aœciwoœci -  String getPropertyName()</li>
  <li>star¹ wartoœæ w³asciwoœci  (przed zmian¹) – Object getOldValue()</li>
  <li>now¹ wartoœæ w³asciwoœci – Object getNewValue() </li>
</ul>
Interfejs <b>PropertyChangeListener</b> ma jedn¹ metodê:<br>
<br>
<b>    public void propertyChange(PropertyChangeEvent)</b><br>
<br>
W implementacji tej metody, dowiaduj¹c siê o zmianach w³aœciwoœci, mo¿emy na nie odpowiednio reagowaæ.<br>
<br>
Równie¿ interfejs <b>VetoableChangeListener</b> ma jedn¹ metodê: <b>vetoableChange(...)</b>
 z argumentem–zdarzeniem typu PropertyChange. W jej implementacji , gdy dowiemy
siê ju¿ wszystkich niezbêdnych szczegó³ow o zmianie – mo¿emy j¹ zawetowaæ.<br>
<br>
<b>Wetowanie zmiany</b>  odbywa siê na zasadzie zg³oszenia wyj¹tku <b>PropertyVetoException</b>, zatem deklaracja metody vetoableChange wygl¹da nastêpuj¹co:<br>
<br>
<b>    public void vetoableChange(PropertyChangeEvent e)  <br>
                                                throws PropertyVetoException<br>
</b><br>
a w jej implementacji – gdy po sprawdzeniu waroœci w³aœciwoœci chcemy zg³osiæ veto – sygnalizujemy wyj¹tek: <b>throw new PropertyVetoException(...)</b>.<br>
<br>
<b>S³uchacze</b> zmian  w³aœciwoœci  zwi¹zanych (jak zawsze w Javie) mus¿¹
byæ przy³¹czeni do Ÿród³a zdarzenia., którym jest  w tym przypadku ziarno. 
<br><br>
Przy³¹czenie staje siê mo¿liwe, jesli w klasie-ziarnie zdefiniowano metodê <b>addPropertyChangeListener(...)</b><br>
Musi te¿ byæ zdefiniowana metoda <b>removePropertyChangeListener</b>, od³aczaj¹ca s³uchacza.<br>
<br>
To samo dotyczy nas³uchu zmian w³aœciwoœci ograniczanych: klasa zaiarno musi dostarczyæ  metody przy³¹czenia s³uchacza:  <b>addVetoableChangeListener</b> oraz metody od³¹czania s³uchacza:  <b>removeVetoableChangeListener</b>.<br>
<br><font color="#ff0000"><b>
Obowi¹zkiem klasy ziarna, która implementuje zwi¹zane i/lub ograniczane w³aœciwoœci
jest równie¿ dostarczenie odpowiednich definicji setterów dla tych w³aœciwoœci.
<br>


W setterach nale¿ey  generowaæ zdarzenie PropertyChangeEvent  i propagowaæ go poœród przy³¹czonych s³uchaczy.<br>
</b></font>
<br>
W pakiecie java.beans znajduj¹ siê dwie klasy narzêdziowe,  znacznie u³atwiaj¹ce
wykonanie tych zadañ: PropertyChangeSupport i VetoableChangeSupport.<br>
Klasy dostarczaj¹ metod  generowania zdarzeñ i propagacji zdarzeñ zmian:<br>
<ul>
  <li>w³aœciwoœci zwi¹zanych -  firePropertyChange </li>
  <li>w³aœciwoœci ograniczanych -  fireVetoableChange s³uchaczy.</li>
  <li>a tak¿e metod przy³¹czanai i od³¹czania s³uchaczy tych zmian (addNNNListener, removeNNListener).</li>
</ul>
Konstruktory tych klas maj¹ jako argument  referencjê do obiektu-ziarna.<br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci zwi¹zanej jest nastêpuj¹cy:</b></u><br>
<br>
<pre>
class Ziarno .... {

  //wsparcie
  private PropertyChangeSupport chg = new PropertyChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc zwi¹zana o nazwie "text"
  ...
// setter
synchronized void setText(String newTxt) { // pamiêtamy o wielow¹tkowoœci!

    String oldTxt =  text;   // stara wartoœæ
    text = newTxt;           // ustalenie nowej wartoœci
     // powiadomienie
    chg.firePropertyChange("text", oldTxt, newTxt);
}
....

// metody dodawania i usuwania s³uchaczy
public synchronized void addPropertyChangeListener(PropertyChangeListener l) {
 chg.addPropertyChangeListener(l);
 }

public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
 chg.removePropertyChangeListener(l);
 }
...
}

</pre>
<br>
Implementacja w³aœciwoœci ograniczanych musi uzwglêdniaæ mo¿liwoœæ zawetowania zmiany przez któregoœ ze s³uchaczy. <br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci ograniczanej jest nastêpuj¹cy:</b></u><br>
<br>
<pre>
class Ziarno .... {

  //wsparcie
  private VetoableChangeSupport veto = new VetoableChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc ograniczana o nazwie "tekst"
  ...
// setter

synchronized void setText(String newTxt)  throws PropertyVetoException
 {
    String oldTxt =  text;  // stara wartoœæ

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     //  przez metodê wywo³uj¹c¹ setText

     veto.fireVetoableChange("tekst", oldTxt, newTxt);

     // Tylko jeœli nikt nie zawetowa³ zmiany:

     text = newTxt;   // ustalenie nowej wartoœci
}
....
// metody dodawania i usuwania s³uchaczy

public synchronized void addVetoableChangeListener(PropertyChangeListener l) {
 veto.addVetoableChangeListener(l);
 }

public synchronized void removeVetoableChangeListener(PropertyChangeListener l) {
 veto.removeVetoableChangeListener(l);
 }
...
}

<b>// Uwaga: wsystkie klasy  zdarzeniowe i interfejsy nas³uchu
// dla w³aœciwoœci znajduj¹ siê w pakiecie java.beans.
</b>
</pre>
<br>
<a name="W3.7"></a><a name="W2.7"></a><h2>
2.7.  JavaBean - przyk³ad praktyczny</h2>

Bêdziemy budowaæ klasê-licznik jako JavaBean. Klasê nazwiemy <b>Counter</b>.<br>
Licznik bêdzie mia³ jedn¹ w³aœciwoœæ o nazwie <b>count</b> (stan licznika).<br>
W wersji pierwszej uczynimy tê w³aœciwoœæ zwi¹zan¹ (bounded), w  wersji drugiej – zwi¹zan¹ i ograniczon¹ (constrained).<br>
<br> Przy budowie aplikacji zastosujemy koncepcjê  "Model-View-Controller".
<br>
<br>
Sama klasa Counter odzwierciedla logikê dzia³ania licznika ("<b>model</b>
"). Obiekty tej klasy "s¹ niewidzialne", a zatem  ¿eby zobaczyæ licznik musimy
stworzyæ dodatkow¹ klasê, która zdefiniuje widok licznika  (<b>view</b>).<br>
Nazwiemy j¹ <b>CounterView</b>. Warto zwróciæ uwagê: separacja kodu jest
korzystna – widok uniezale¿niamy od modelu, a model od widoku, w ten sposób
mo¿emy mieæ np. wiele widoków licznika, lub zmieniaæ model nie zmieniaj¹c
widoku.<br>
<br>
Komunikacja miêdzy modelem i widokiem bêdzie siê odbywaæ na zasadzie nas³uchu
zmian w³aœciwoœci (zmian w³aœciwoœci count) czyli obiekt klasy CounterView
bêdzie te¿ s³uchaczem zmian w³aœciwoœci (PropertyChangeListener).<br>
<br>
Musimy te¿ mieæ jakieœ œrodki zmiany stanu licznika. Interakcjê u¿ytkownika z modelem/widokiem zapewnia tzw. kontroler.<br>
Widzieliœmy, ¿e w komponentach Swingu (w naturalny dla nich sposób) kontroler
po³¹czony jest z widokiem. Tu jednak odseparujemy jego kod od widoku, tworz¹c
klasê <b>CounterControlGui</b>, zapewniaj¹c¹ interfejs interakcji z licznikiem.. Widok zostanie dodany do tego GUI (ale kody obu klas bêd¹ odseparowane).<br>
<br>
W wersji drugiej – kiedy w³aœciwoœæ count bêdzie zwi¹zana i ograniczana musimy
dostarczyæ obiektu-nadzorcy, który bêdzie sprawdza³ czy zmiana w³aœciwoœci
jest dopuszczalna i jeœli stwierdzi, ¿e nie – bêdzie wetowa³ tê zmianê. Odpowiedni¹
klasê nazwiemy <b>CounterLimitator</b>.<br>
<br>
W metodzie main(...) klasy Main, w której nasza aplikacja zacznie ¿ycie stworzymy
wszystkie odpowiednie obiekty w/w klas i ustanowimy niezbêdne po³¹czenia
miêdzy nimi.<br>
<br>
W sumie logika dzia³ania aplikacji bêdzie wygl¹daæ tak:<br>
<br>
<br>
<img src="images/Counter1.jpg" alt="r" width="597" height="224" border="1">
<br>
<br>
Zaczynamy od wersji pierwszej, ubo¿szej, w której klasa Counter daje przyk³ad
typowego programowania JavaBean z wlaœciwoœci¹ zwi¹zan¹:<br>
<br>
<pre>
// Klasa Counter

import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class Counter implements Serializable {

  private int count = 0;    // w³aœciwoœæ count

  // Pomocniczy obiekt do prowadzenia listy s³uchaczy zmian w³aœciwoœci oraz
  // propagowania zmian  wœród zarejestrowanych z³uchaczy
   private PropertyChangeSupport propertyChange = new PropertyChangeSupport(this);


  // Konstruktory

  public Counter() {
    this(0);
  }

  public Counter(int aCount) {
    setCount( aCount );
  }


  // Metody przy³¹czania i od³¹czania s³uchaczy zmian w³aœciwoœci

  public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
    propertyChange.addPropertyChangeListener(listener);
  }

  public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
    propertyChange.removePropertyChangeListener(l);
  }

  // Proste metody zwiêkszania i zmniejszania licznika

  public void increment() {
    setCount(getCount()+1);
  }

  public void decrement() {
    setCount(getCount()-1);
  }


  // Getter w³aœciwoœci "count"
  public int getCount() {
    return count;
  }

  // Setter w³aœciowœci "count"
  public synchronized void setCount(int aCount) {
    int oldValue = count;
    count = aCount;

    // wywo³anie metody firePropertChange z klasy PropertyChangeSupport
    // powoduje wygenerowanie zdarzenia PropertyChangeEvent i rozpropagowanie
    // go wœród wszystkich przy³¹czonych s³uchaczy, ale tylko wtedy, gdy nowa
    // wartoœæ w³aœciwoœci ró¿ni siê od starej wartoœci

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                            new Integer(aCount));
  }

}
</pre>
Widok licznika przedstawimy jako etykietê - klasa ta jednoczeœnie bêdzie
nas³uchiowaæ zmian w³aœciwoœci count i odpowiednio do tego zmieniaæ tekst
na etykiecie (a tak¿e wyprowadzaæ informacje o zmianach w³aœciwoœci count
na konsolê).<br>
<br>
<pre>
//Klasa CounterView
//Widok licznika przedstawiamy w postaci etykiety

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;


public class CounterView extends JLabel implements PropertyChangeListener {


  // Konstruktor domyœlny: inicjalizuje etykietê tekstem "0"
  CounterView()  {
     this("0");
  }

  // Konstruktor inicjalizuj¹cy etykietê podanym tekstem
  CounterView(String lab) {
     super(lab);
     setOpaque(true);   // etykieta nie przezroczysta
       // ramka
     setBorder(BorderFactory.createLineBorder(Color.black));
       // rozmiary i wyrównanie tekstu
     setPreferredSize(new Dimension(75, 40));
     setHorizontalAlignment(CENTER);
  }

  // ob³uga zdarzenia PropertyChange
  public void propertyChange(PropertyChangeEvent e)  {
    Integer oldVal = (Integer) e.getOldValue(),
           newVal = (Integer) e.getNewValue();
    System.out.println("Value changed from " + oldVal + " to " + newVal);
    setText("" + newVal + "");  // pokazanie na etykiecie nowego stanu licznika
   }


}
</pre>
Klasa kontrolera - CounterControlGui dostarcza dwóch przycisków (zwiêksz,
zmniejsz licznik) oraz pole tekstowe, w którym mo¿na wpisaæ wartoœæ licznika
(ENTER)<br>
Zarówno klikniêcie w przyciski jak i ENTER na polu tekstowym powoduje powstanie
zdarzenia Action, które tu (w tej klasie) obs³ugujemy ustalaj¹c nowe wartoœci
licznika za pomoc¹ metod incremet() decrement() i setCount(...) z klasy  Counter.
<br>
<br>
<pre>
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class CounterControlGui extends JFrame implements ActionListener {

  Counter counter;
  JButton binc = new JButton("Increment");
  JButton bdec = new JButton("Decrement");
  JTextField txt = new JTextField(10);

  // Konstruktor otrzymuje jako argumenty obiekty typu Counter i CounterView
  // Pierwszy jest nam potrzebny do komunikacji z licznikiem, drugi - widok
  // wbudujemy w to GUI.

  CounterControlGui(Counter c, CounterView clab)  {
    counter = c;
    Container cp = getContentPane();
    cp.setLayout(new FlowLayout());
    binc.addActionListener(this);
    cp.add(binc);
    cp.add(clab);
    bdec.addActionListener(this);
    cp.add(bdec);
    txt.addActionListener(this);
    cp.add(txt);
    setDefaultCloseOperation(3);
    pack();
    show();
  }


  // Obs³uga akcji
  public void actionPerformed(ActionEvent e)  {
      if (e.getSource() == txt)  {
         int n = 0;
         try  {
            n = Integer.parseInt(txt.getText());
         } catch (NumberFormatException exc)  { return; }
         counter.setCount(n);
         return;
      }
      String cmd = e.getActionCommand();
      if (cmd.equals("Increment")) counter.increment();
      else if (cmd.equals("Decrement")) counter.decrement();
      else System.out.println("Unrecognized command");
  }

}
</pre>
I wreszcie lacz¹ca wszystko klasa Main, która inicjuje dzia³anie aplikacji.<br>
<br>
<pre>
public class Main {

 public static void main(String[] args)  {

   // Tworzymy obiekty: licznik i jego widok
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());

   // Rejestrujemy widok jako s³uchacza zmian licznika
   counter.addPropertyChangeListener(counterView);

   // Tworzymu GUI kontrolera i pokazujemy go
   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
<br>
Diza³anie aplikacji ilustruje rysunek oraz komunikaty na konsoli, powsta³e
po kolejnych klilniêciach w przyciski Incremenet i Decrement oraz wprowadzeniu
liczby 23 w polu tekstowym i naciœnieciu ENTER.<br>
<br>
<img src="images/Counter1-v1.jpg" alt="r" width="407" height="75" border="1">
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to 1<br>
Value changed from 1 to 0<br>
Value changed from 0 to 23<br>
</div><br>
<br>
<b>Wersja 2</b><br>
<br>
W wersji drugiej chcemy dodaæ obiekt – nadzorcê, który bêdzie sprawdza³ czy
zmiana licznika jest dopuszczalna, a jeœli nie to bêdzie wetowa³ tê zmianê.<br>
Mechanizm wetowania polega na sygnalizowaniu wyj¹tku PropertyVetoException.<br>
Wyj¹tek ten bêdzie sygnalizowany przez obiekt-nadzorcê, który jest jednoczesnie
s³uchaczem zmian wartoœci w³aœciwoœci ograniczonych (VetoableChangeListener).
<br>
<br>
Klasa definiuj¹ca obiekty nadzoruj¹ce nasz licznik wygl¹da tak.<br>
<br>
<pre>
import java.beans.*;

public class CounterLimitator implements VetoableChangeListener {

// minimalne i makszymalne dopuszczalne wartoœci licznika
private int min, max;

CounterLimitator(int minLim, int maxLim)  {
  min = minLim;
  max = maxLim;
}

// Obs³uga zdarzenia vetoableChange
// metoda mo¿e sygnalizowaæ PropertyVetoException
public void vetoableChange(PropertyChangeEvent e)
            throws PropertyVetoException {
   Integer newVal = (Integer) e.getNewValue();
   int val = newVal.intValue();
   // Sprawdzamy, czy zmiana  licznika jest dopuszczalna,
   // jeœli nie – sygnalizujemy wyjatek  PropertyVetoException
   if (val &lt; min || val &gt; max)
      throw new PropertyVetoException("Niedopuszczalna zmiana wartoœci", e);
   }

}

</pre>
W klasie Counter musimy poczyniæ zmiany, po to by w³aœciwoœæ count by³a zarazem zwi¹zana i ograniczana.<br>
Wykorzystamy podobn¹ do PropertyChangeSupport klasê pomocnicz¹ VetoableChangeSupport<br>
Obiekt tej klasy nazwiemy vetos, dostarczymy te¿ metod przy³¹czania i od³¹czania s³uchaczy zmian ograniczanych.<br>
<br>
<pre>
public class Counter {

//...

private VetoableChangeSupport vetos = new VetoableChangeSupport(this);

public synchronized void addVetoableChangeListener(VetoableChangeListener l) {
	vetos.addVetoableChangeListener(l);
}

public synchronized void removeVetoableChangeListener(VetoableChangeListener l) {
	vetos.removeVetoableChangeListener(l);
}

// ...
}
</pre>
<br>
Zmianie ulegnie te¿ metoda setCount.<br>
<br>
<pre>
public class Counter {

//...
public synchronized void setCount(int aCount)
                         throws PropertyVetoException {

     int oldValue = count;

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     // przez metodê wywo³uj¹c¹ setCount
     // (co zaznaczyliœmy w nag³ówku metody przez
     // throws PropertyVetoException)

    vetos.fireVetoableChange("count", new Integer(oldValue), new Integer(aCount));

    // tylko jeœli nikt nie zawetowa³

    count = aCount;  // ustalamy now¹ wartoœæ licznika

    // ... powiadamiamy nas³uchuj¹cych zmiany w³aœciwoœci count

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                       new Integer(aCount));
}

//...
}
</pre>
Poniewa¿ metody increment, decrement i konstruktory wywo³uj¹ metodê setCount,
to w sygnaturach tych metod i konstruktorów musimy dodaæ informacjê, ¿e wyj¹tek
PropertyVetoException ma byæ obs³ugiwany przez  wo³aj¹cego te metody.<br>
<br>
A wo³amy je z GUI kontrolera.<br>
Tam jest miejsce do obs³ugi tego wyj¹tku:<br>
<pre>
public class CounterControlGui .... {

....
public void actionPerformed(ActionEvent e)  {
  try  {
    if (e.getSource() == txt)  {
       int n = 0;
       try  {
          n = Integer.parseInt(txt.getText());
       } catch (NumberFormatException exc)  { return; }
       counter.setCount(n);
       return;
    }
    String cmd = e.getActionCommand();
    if (cmd.equals("Increment")) counter.increment();
    else if (cmd.equals("Decrement")) counter.decrement();
    else System.out.println("Unrecognized command");
  } catch (PropertyVetoException exc)  { // ob³uga wyjatku:
      System.out.println(""+ exc);       // podanie informacji
                                         //o niedopuszczalnej zmianie wartoœci
  }
}

//...
}
</pre>
W klasie Main dodajemy fragment dotycz¹cy tworzenia obiektu klasy CounterLimitator
(nadzorcy) i rejestrujemy go jako s³uchacza zmian w³aœciwoœci ograniczanej:<br>
<br>
<pre>
import java.beans.*;
public class Main {

 public static void main(String[] args) throws PropertyVetoException {
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());
   counter.addPropertyChangeListener(counterView);

   // licznik mo¿e siê zmieniaæ od –5 do 10
   // bo Limitator zawetuje ka¿d¹ inn¹ zmianê
   CounterLimitator clim = new CounterLimitator(-5, 10);
   counter.addVetoableChangeListener(clim);

   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
Dzialanie programu  (przy tym samym GUI kontrolera) zilustrujemy komunikatami
na konsoli po kolejneych klikniêciach w przycisk "Decrement".<br>
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to -1<br>
Value changed from -1 to -2<br>
Value changed from -2 to -3<br>
Value changed from -3 to -4<br>
Value changed from -4 to -5<br>
java.beans.PropertyVetoException: Niedopuszczalna zmiana wartoœci<br>
</div><br>
<br>
Jak widaæ, CounterLimitator nie dopuœci³ do zmiany wartoœci z -5 na -6.<br>
<br>
<br>
<a name="W3.8"></a><a name="W2.8"></a><h2>2.8. Introspekcja</h2>
<br>
Srodowisko programistyczne, które ma umo¿liwiaæ dynamiczne odczytywanie w³asnoœci
i funkcjonalnoœci dowolnych "podrzucanych" mu ziaren analizuje ziarna za
pomoc¹ uniwerslanych metod introspekcji. <br>
<br>
Introspekcja kojarzy dwa mechanizmy: <br>
<ul>
  <li>analizê komponentów za pomoc¹ metod refleksji przy za³o¿eniu, ¿e stosowane
s¹ pewne standardowe wzorce nazewnictwa, umo¿liwiaj¹ce okreœlenie  w³asnœciwoœci
i ich typu, metod pobierania i ustalania tych w³aœciwoœci,  rodzajóa zdarzeñ, 
metod rejestracji s³uchaczy i nnych metod udostêpnianych przez dane ziarno
"na zewn¹trz" </li>
  <li>okreœlanie uzewnêtrznianych w³aœciwoœci i funkcjonalnoœci ziarna na
podstawie dowolnie specyfikowanych przez twórcê ziarna elementów, zapisywanych
w odpowiedniej dla danego ziarna klasie BeanInfo. </li>
</ul>
Oba mechanizmy mog¹ byæ stosowane ³¹cznie. W prostych przypadkach (prostych
ziaren) nie ma potrzeby ¿mudnego tworzenia klasy BeanInfo, metody refleksji
s¹ ca³kiem wystarczaj¹ce. <br>
Introspekcja za pomoc¹ metod refleksji jest mo¿liwa dziêki kontraktowi dotycz¹cemu wzorców nazewnictwa. <br>
<br>
Dla w³aœciwoœci introspekcja okreœla pary metod <b>get... (is...)  -  set...</b>
 z tymi samymi nazwami w³aœciwoœci i z odpowiednimi sygnaturami. Mo¿e siê
okazaæ, ¿e niektóre w³aœciwoœci s¹ tylko do odczytu lub tylko do zapisu.
Uwzglêdnia siê te¿ indeksowane w³asciwoœci. <br>
<br>
Dla  okreœlenia, czy istniej¹ mo¿liwoœæ obs³ugi zdarzeñ i jakich u¿ywane s¹ wzorce: <b>addXXXListener i removeXXXListener. </b><br>
<br>
Sam¹ introspekcje realizuje klasa <b>Introspector</b>. <br>
<br>
Introspector analizuje klasê-zarna (i nadrzêdne wobec niej klasy oraz implementowane
interfejsy) zbieraj¹c informacje o w³aœciowoœciach, metodach, zdarzeniach.
<br>
Informacja ta jest umieszczana w obiekcie typu <b>BeanInfo</b> (BeanInfo jest nazw¹ interfejsu). Wobec tego obiektu mo¿emy nastêpnie zastosowaæ metody zwracaj¹ce iinformacje o ziarnie. <br>
<br>
Np. analizê klasy-ziarna javax.swing.JButton uzyskujemy przez nastêpuj¹ce odwo³anie: <br>
<br>
<b>BeanInfo info = Introspector.getBeanInfo(Class.forName("javax.swing.JButton")); </b><br>
lub<br>
<b>BeanInfo info = Introspector.getBeanInfo(javax.swing.JButton.class)); </b><br>
<br>
<br>
Nastêpnie wobec obiektu info mo¿emu zastosowaæ metody interfejsu BeanInfo: <br>
<br>
<ul>
  <li><b>EventSetDescriptor[]  getEventSetDescriptors()  - </b>zwraca tablicê deskryptorów zdarzeñ<b> </b></li>
  <li><b>PropertyDescriptor[]  getPropertyDescriptors()  - </b>zwraca tablicê deskryptorów w³asnoœci<b> </b></li>
  <li><b>MethodDescriptor[]   getMethodDescriptors()     - </b>zwraca tablicê deskryptorów metod</li>
  <li>dla ka¿dgo deskryptora metody <b>ParameterDescriptor[] getParameterDexriptors()</b> - zwraca tablicê deskryptorów parametrów tej metody<br>
  </li>
</ul>
Zwracane tablice s¹ tablicami obiektów odpowiednich klas. Wobec tych obiektów
stosujemy metody tych klas pozwalaj¹ce na uzyskiwanie ró¿nej konkretnej informacji.
<br>
Np. program na poini¿szym wydruku analizuje klasê podan¹ jako argument i wypisuje niektóre informacje o niej: <br>
<br>
<pre>
import java.lang.reflect.*;
import java.beans.*;

public class BeanAnalyze {

  static void say(String s) { System.out.println(s); }

  public static void main(String[] arg) throws Exception {

    BeanInfo beanInfo = Introspector.getBeanInfo(Class.forName(arg[0]));

    PropertyDescriptor[] pd = beanInfo.getPropertyDescriptors();
    MethodDescriptor[] md = beanInfo.getMethodDescriptors();
    EventSetDescriptor[] evd = beanInfo.getEventSetDescriptors();

    say("W³aœciwoœci:");
    for (int i = 0; i &lt; pd.length; i++) {
      say(pd[i].getShortDescription());
      // getReadMethod i getWriteMethod zwracaj¹ obiekty typu Method
      say(" getter: "+ pd[i].getReadMethod());
      say(" setter: "+ pd[i].getWriteMethod());
    }

    say("\nMetody:");
    for (int i=0; i&lt;md.length; i++) {
      say(" " + md[i].getMethod());
    }

    say("\nZdarzenia:");
    for (int i = 0; i &lt; evd.length; i++) {
      say("Zdarzenie : " + evd[i].getShortDescription());
      Method[] met = evd[i].getListenerMethods();
      say("Metody obs³ugi:");
      for (int j=0; j &lt; met.length; j++)  say(" " + met[j]);
    }
  }

}
</pre>
<br>
Fragmenty (du¿ego!) wydruku z programu uruchomionego z argumentem javax.swing.JButton:<br>
<br>
<div class="listing100"><br>
W³aœciwoœci:<br>
UI<br>
 getter: public javax.swing.plaf.ButtonUI javax.swing.AbstractButton.getUI()<br>
 setter: public void javax.swing.AbstractButton.setUI(javax.swing.plaf.ButtonUI)<br>
UIClassID<br>
 getter: public java.lang.String javax.swing.JButton.getUIClassID()<br>
 setter: null<br>
accessibleContext<br>
 getter: public javax.accessibility.AccessibleContext javax.swing.JButton.getAccessibleContext()<br>
 setter: null<br>
action<br>
 getter: public javax.swing.Action javax.swing.AbstractButton.getAction()<br>
 setter: public void javax.swing.AbstractButton.setAction(javax.swing.Action)<br>
actionCommand<br>
 getter: public java.lang.String javax.swing.AbstractButton.getActionCommand()<br>
 setter: public void javax.swing.AbstractButton.setActionCommand(java.lang.String)<br>
actionListeners<br>
 getter: public java.awt.event.ActionListener[] javax.swing.AbstractButton.getActionListeners()<br>
 setter: null<br>
actionMap<br>
 getter: public final javax.swing.ActionMap javax.swing.JComponent.getActionMap()<br>
 setter: public final void javax.swing.JComponent.setActionMap(javax.swing.ActionMap)<br>
...<br>
<br>
Metody:<br>
 public boolean java.awt.Component.action(java.awt.Event,java.lang.Object)<br>
 public synchronized void java.awt.Component.add(java.awt.PopupMenu)<br>
 public java.awt.Component java.awt.Container.add(java.awt.Component)<br>
 public java.awt.Component java.awt.Container.add(java.awt.Component,int)<br>
 public void java.awt.Container.add(java.awt.Component,java.lang.Object)<br>
 public void java.awt.Container.add(java.awt.Component,java.lang.Object,int)<br>
 public java.awt.Component java.awt.Container.add(java.lang.String,java.awt.Component)<br>
 public void javax.swing.AbstractButton.addActionListener(java.awt.event.ActionListener)<br>
...<br>
<br>
Zdarzenia:<br>
Zdarzenie : action<br>
Metody obs³ugi:<br>
 public abstract void java.awt.event.ActionListener.actionPerformed(java.awt.event.ActionEvent)<br>
Zdarzenie : ancestor<br>
Metody obs³ugi:<br>
 public abstract void javax.swing.event.AncestorListener.ancestorMoved(javax.swing.event.AncestorEvent)<br>
 public abstract void javax.swing.event.AncestorListener.ancestorAdded(javax.swing.event.AncestorEvent)<br>
 public abstract void javax.swing.event.AncestorListener.ancestorRemoved(javax.swing.event.AncestorEvent)<br>
Zdarzenie : change<br>
Metody obs³ugi:<br>
 public abstract void javax.swing.event.ChangeListener.stateChanged(javax.swing.event.ChangeEvent)<br>
...<br>
</div><br>
<br>
Szczerze mowi¹c, za pomoc¹ metod instrospekcji sporo mo¿na siê dowiedziec o dostêpnych w³aœciwoœciach i metodach danej klasy.<br>
<br>
Oczywiœcie, maj¹c obiekty-metody (uzyskane z deskryptorów metod) mozemy je
dynamicznie wyow³ywac œrodkami refleksji. Ale istnieje te¿ nieco prostsza,
specjalnie dla JavaBean przygotowana mo¿liwoœæ dynamicznego pobierania i
ustalania wlaœciwoœci oraz wo³ania innych metod.<br>
<br>
<a name="W3.9"></a><a name="W2.9"></a><h2>2.9. Dynamiczne pobieranie i ustalanie w³aœciwoœci</h2>
W pakiecie java.beans znajdziemy dwie ciekawe klasy  Statement i Expression<br>
<br>
<div class="syntax">Obiekt klasy Statement tworzymy za pomoc¹ konstuktora:<br>
<br>
<b>    Statement s =  Statement( Object target, <br>
                                           String methodName, <br>
                                           Object[] arguments );<br>
</b><br>
a wywo³anie na jego rzecz metody <b>void execute()</b> spowoduje wywo³anie na rzecz obiektu target metody o nazwie methodName z argumentami podanymi w tablicy arguments<br>
<br>
Zwykle stosujemy tê procedure do ustalania w³aœciowoœci JavaBean, ale mo¿e
ona byæ rownie¿ stosowana do wyo³ania dowolnych metod</div><br>
<br>
Klasa Expression dziedziczy klasê Statement. Czyli tu te¿ mo¿emy wo³aæ metodê
execute(). Jednak jej g³ówne zastosowanie polega na dynamicznym pobieraniu
w³aœciwoœci, lub - inaczej - dynamicznym wo³aniu metod, które zwracaj¹ wyniki
i uzyskiwaniu dostêpu do tych wyników. <br>
<br>
<div class="syntax">Obiekt klasy Expression tworzymy za pomoc¹ konstuktora:<br>
<br>
<b>
    Expression e =  Expression( Object target,<br>
                                                String methodName, <br>
                                                Object[] arguments );<br>
</b><br>
<ul>
  <li>
wywo³anie na jego rzecz metody <b>void execute()</b> spowoduje wywo³anie
na rzecz obiektu target metody o nazwie methodName z argumentami podanymi
w tablicy arguments oraz przechowanie wyniku wywo³anej metody w obiekcie
Expresion; wynik ten bêdzie dostêpny przez wywolanie metody Object getValue()
na rzecz obeiktu Expressiom</li>
  <li>samo wywo³anie metody <b>Object getValue()</b> spowoduje ten sam efekt o ile wynik dla danego obiektu-wyra¿enia nie zosta³ jeszcze ustalony.</li>
</ul>
</div><br>
<br>
Szczegó³owo komentowany program ilustruje zastosowanie tych klas.<br>
W poni¿szym przyk³adzie metody klas Statement i Expression bedziemy stosowac
wobec obiektów klasy JButton oraz naszej w³asnej klasy TestBean, która wygl¹da
tak:<br>
<pre>
public class TestBean {

  private String[] headers;
  private int count;


  public TestBean() {
  }

  public TestBean(int n) {
    count = n;
  }

  public String[] getHeaders() {
    return headers;
  }

  public void setHeaders(String[] value) {
    headers = value;
  }

  public int getCount() {
    return count;
  }

  public void setCount(int value) {
    count = value;
  }

}
</pre>
<br>
Szczegó³owo komentowany program ilustruje zastosowanie klas Statement i Expression,
daj¹c te¿ pewne dodatkowe na ich temat informacje.<br>
<pre>
import java.beans.*;
import java.awt.*;
import javax.swing.*;

public class DynamicExec {

  public static void main(String[] args) throws Exception {

    Statement stmt;
    Expression expr;

    JButton b = new JButton();

    // Na rzecz przycisku wo³amy dynamicznie metodê setText
    // z argumentem "Przycisk"
    stmt = new Statement(b, "setText", new Object[] { "Przycisk" });
    stmt.execute();

    // Jaki wynik? Najpierw statyczne odwo³anie
    System.out.println("Tekst na przycisku 1: " + b.getText());

    // Teraz dynamicznie: stwórzmy wyra¿enie, którego wynikiem
    // jest wynik podanej metody z podanymi argumentami wywolanej
    // na rzecz b
    // Uwaga: brak argumentów - czyli tablica Object o rozmiarze 0
    expr = new Expression(b, "getText", new Object[0]);

    // Je¿eli wyra¿enie expr nie ma jeszcze wyniku
    // metoda getValue() wywo³uje podan¹ w wyra¿eniu metodê
    // i zwraca jej wynik; w przeciwnym razie zwraca
    // ustalony wczesniej wynik

    String txt = (String) expr.getValue();
    System.out.println("Tekst na przycisku 2: " + txt);

    // Mo¿emy te¿ stosowaæ klasy Statement i Expression
    // wobec naszych w³asnych klas JavaBeans

    TestBean tbean = new TestBean();

    // Uwaga: przy przekazywaniu argumentów i zwrocie wynikow
    // nastêpuj¹ automatyczne przeksztalcenia pomiedzy
    // typami prostymi i odpowiadaj¹cymi im klasami opakowuj¹cymi
    // np. int - Integer  - setCount wymaga argumentu int,
    // my podajemy Integer

    stmt = new Statement(tbean, "setCount",
                               new Object[] { new Integer(22) });
    stmt.execute();

    // Jaka jest teraz wartoœæ w³aœciwoœci count
    // I znowu: getCount() zwraca int, my odbieramy Integer

    expr = new Expression( tbean, "getCount", new Object[0] );
    Integer val = (Integer) expr.getValue();

    System.out.println("Wartoœæ count: " + val);

    // Czy mo¿emy dzia³aæ na tabliach? Ale¿ tak!

    stmt = new Statement(tbean, "setHeaders",
                         new Object[] { new String[] { "a", "b" } }
                        );
    stmt.execute();

    expr = new Expression(tbean, "getHeaders", new Object[0]);
    String[] hdr = (String[]) expr.getValue();

    System.out.println("Ustalone nag³ówki");
    for (int i=0; i&lt;hdr.length; i++)
       System.out.println(hdr[i]);

    // Mo¿emy nawet stworzyæ nowy obiekt
    // u¿ywaj¹c specjalnej nazwy metody - new  (oczywiœcie)

    expr = new Expression(TestBean.class, "new",
                          new Object[] { new Integer(111) }
                         );
    TestBean tb2 = (TestBean) expr.getValue();

    expr = new Expression (tb2, "getCount", new Object[0]);
    val = (Integer) expr.getValue();

    System.out.println("W nowym obiecie count = " + val);

  }
}

</pre>
<br>
<br>
<a name="W3.10"></a><a name="W2.10"></a><h2>2.10. Serializacja JavaBeans</h2>
Oprócz zapisywania do strumieni obiektowych (ObjectOutputStream), obiekty
JavaBeans mo¿na serializowac w postaci tekstowej, w formacie XML (wersja
1.0, kodowanie UTF-8). Jest to nawet - w przypadku JavaBeans - bardziej "przenoœny"
sposób utrwalania obiektów.<br>
Zapisywaniem obiektów zajmuje siê klasa XMLEncoder, a ich odtwarzaniem -
klasa XMLDccoder. Przy tym  stan obiektu zapisywany jest w postaci  zdatnej
do wykorzystania przez klasy Statement i Expression przy odtwarzaniu tego
obiektu<br>
<br>
Najprostsze (przeznaczone wy³¹cznie dla JavaBeans) zastosowanie tych klas pokazuje poni¿szy program.<br>
<pre>
import java.beans.*;
import java.awt.*;
import javax.swing.*;
import java.io.*;

public class SerialBean {

  String fname = "test.xml";

  public SerialBean() {
    JButton b = new JButton("K¹œliwie wróbel æwierka³");
    b.setBackground(Color.red);
    b.setForeground(Color.yellow);

    try {
      XMLEncoder enc = new XMLEncoder(
                         new BufferedOutputStream(
                            new FileOutputStream(fname)
                            )
                      );
      enc.writeObject(b);
      enc.close();
    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    nowReadAndReport();
  }

  private void nowReadAndReport() {
    try {
      XMLDecoder dec = new XMLDecoder(
                          new BufferedInputStream(
                              new FileInputStream(fname)));
      Object obj = dec.readObject();
      JButton b = (JButton) obj;
      dec.close();
      System.out.println("Napis na przycisku: " + b.getText());
      System.out.println("Kolor t³a: " + b.getBackground());
      System.out.println("Kolor tekstu : " + b.getForeground());

    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }



  public static void main(String[] args) {
    SerialBean serialbean = new SerialBean();
  }


}
</pre>
Wyprowadzi on na konsolê w³aœciw¹  informacjê o stanie zapisanego a póŸniej odtworzonego obiektu:<br>
<div class="listing100"><br>
Napis na przycisku: K¹œliwie wróbel æwierka³<br>
Kolor t³a: java.awt.Color[r=255,g=0,b=0]<br>
Kolor tekstu : java.awt.Color[r=255,g=255,b=0]<br>
</div><br>
<br>
Z ciekawoœci mo¿na zajrzeæ do pliku test.xml.<br>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.4.1-rc" class="java.beans.XMLDecoder"&gt;
 &lt;object class="javax.swing.JButton"&gt;
  &lt;string&gt;KÄÅ&gt;liwie wrÃ³bel Ä+wierkaÅ'&lt;/string&gt;
  &lt;void property="background"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;void property="foreground"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
 &lt;/object&gt;
&lt;/java&gt;

</pre>
Faktycznie, jest do dok³adny szablon gotowy do zastosowania klas Expression
(dla metody-kostsruktora new z argumentem String) i Statement (dla setBackground
i setForeground). Wszystko opiera siê na zachowaniu protoko³u JavaBeans.<br>
<br>
Oczywiœcie, mo¿emy w ten sposób serializowaæ obiekty prawie wszystkich klas
Javy (bo prawie wszystkie s¹ JavaBeans) oraz  w³asnych klas, spe³niaj¹cych
protokó³ JavaBeans.<br> A nawet mo¿na uwzglêdniæ pewne odstêpstwa od tego
protoko³u (np. inicjacjê w³aœciwoœci JavaBeans w konstruktorz, bez u¿ycia
setterów) poprzez dostosowanie delegata "persystencji", do którego odwo³uje
siê XMLEncoder - klasy <b>DefaultPersistanceDelegate</b>. <br>O takim bardziej zaawansowanym zastosowaniu, jak równie¿ o u¿yciu nas³uchu wyj¹tków dekodowania za pomoc¹ interfejsu <b>ExceptionListener</b> mo¿na przeczytaæ w dokumentacji API Javy.<br>
<br>
<br>
<a name="W3.11"></a><a name="W2.11"></a><h2>2.11. Inne zagadnienia zwi¹zane z JavaBeans</h2>
<br>
To skrótowe wprowadzenie do JavaBeans nie wyczerpuje tematu.<br>
Warto wiêc na koniec zwróciæ uwagê na nieporuszone tu wa¿ne kwestie<br>
<ul>
  <li>przystosowanie ziaren: klasy-edytory w³aœciwoœci u¿ywane m.in. w œrodowiskach wizualnych </li>
  <li>tworzenie klas BeanInfo, opisuj¹cych informacje niedostêpn¹ metodami refleksji, </li>
  <li>koteksty (BeanContext) - swoiste kontenery, dostarczaj¹ce generalnych mechanizmów i serwisów dla JavaBeans.</li>
</ul>

Informacje na te teamaty mo¿na zanaleŸæ w dokumentacji.<br>
<a name="W3.12"></a><br>


</body></html>
